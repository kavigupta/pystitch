{"wtfpython-pypi/setup.py": "from setuptools import setup, find_packages\n\nif __name__ == \"__main__\":\n    setup(name='wtfpython',\n          version='0.2',\n          description='What the f*ck Python!',\n          author=\"Satwik Kansal\",\n          maintainer=\"Satwik Kansal\",\n          maintainer_email='satwikkansal@gmail.com',\n          url='https://github.com/satwikkansal/wtfpython',\n          platforms='any',\n          license=\"WTFPL 2.0\",\n          long_description=\"An interesting collection of subtle & tricky Python Snippets\"\n                           \" and features.\",\n          keywords=\"wtfpython gotchas snippets tricky\",\n          packages=find_packages(),\n          entry_points = {\n              'console_scripts': ['wtfpython = wtf_python.main:load_and_read']\n          },\n          classifiers=[\n              'Development Status :: 4 - Beta',\n\n              'Environment :: Console',\n              'Environment :: MacOS X',\n              'Environment :: Win32 (MS Windows)',\n\n              'Intended Audience :: Science/Research',\n              'Intended Audience :: Developers',\n              'Intended Audience :: Education',\n              'Intended Audience :: End Users/Desktop',\n\n              'Operating System :: OS Independent',\n\n              'Programming Language :: Python :: 3',\n              'Programming Language :: Python :: 2',\n\n              'Topic :: Documentation',\n              'Topic :: Education',\n              'Topic :: Scientific/Engineering',\n              'Topic :: Software Development'],\n            )\n", "wtfpython-pypi/wtf_python/main.py": "from os.path import dirname, join, realpath\n\nimport pydoc\ntry:\n    from urllib.request import urlretrieve\nexcept ImportError:\n    from urllib import urlretrieve\n\nurl = (\"http://raw.githubusercontent.com/satwikkansal/\"\n       \"wtfpython/master/README.md\")\n\nfile_path = join(dirname(dirname(realpath(__file__))), \"content.md\")\n\n\ndef fetch_updated_doc():\n    \"\"\"\n    Fetch the latest version of the file at `url` and save it to `file_path`.\n    If anything goes wrong, do nothing.\n    \"\"\"\n    try:\n        print(\"Fetching the latest version...\")\n        urlretrieve(url, file_path)\n        print(\"Done!\")\n    except Exception as e:\n        print(e)\n        print(\"Uh oh, failed to check for the latest version, \"\n              \"using the local version for now.\")\n\n\ndef render_doc():\n    with open(file_path, 'r', encoding=\"utf-8\") as f:\n        content = f.read()\n        pydoc.pager(content)\n\n\ndef load_and_read():\n    fetch_updated_doc()\n    render_doc()\n\n\nif __name__== \"__main__\":\n    load_and_read()\n", "wtfpython-pypi/wtf_python/__init__.py": "", "irrelevant/notebook_generator.py": "\"\"\"\nAn inefficient monolithic piece of code that'll generate jupyter notebook\nfrom the projects main README.\n\nPS: If you are a recruiter, please don't judge me by this piece of code. I wrote it\nin hurry. I know this is messy and can be simplified, but I don't want to change it\nmuch because it just works. \n\nSimplifictions and improvements through patches are more than welcome however :)\n\n\n#TODOs\n\n- CLI arguments for running this thing\n- Add it to prepush hook\n- Add support for skip comments, to skip examples that are not meant for notebook environment.\n- Use templates?\n\"\"\"\n\nimport json\nimport os\nimport pprint\n\nfpath = os.path.join(os.path.dirname( __file__ ), '..', 'README.md')\nexamples = []\n\n# The globals\ncurrent_example = 1\nsequence_num = 1\ncurrent_section_name = \"\"\n\n\nSTATEMENT_PREFIXES = [\"...\", \">>> \", \"$ \"]\n\nHOSTED_NOTEBOOK_INSTRUCTIONS = \"\"\"\n\n## Hosted notebook instructions\n\nThis is just an experimental attempt of browsing wtfpython through jupyter notebooks. Some examples are read-only because, \n- they either require a version of Python that's not supported in the hosted runtime.\n- or they can't be reproduced in the notebook envrinonment.\n\nThe expected outputs are already present in collapsed cells following the code cells. The Google colab provides Python2 (2.7) and Python3 (3.6, default) runtimes. You can switch among these for Python2 specific examples. For examples specific to other minor versions, you can simply refer to collapsed outputs (it's not possible to control the minor version in hosted notebooks as of now). You can check the active version using\n\n```py\n>>> import sys\n>>> sys.version\n# Prints out Python version here.\n```\n\nThat being said, most of the examples do work as expected. If you face any trouble, feel free to consult the original content on wtfpython and create an issue in the repo. Have fun!\n\n---\n\"\"\"\n\n\ndef generate_code_block(statements, output):\n    \"\"\"\n    Generates a code block that executes the given statements.\n\n    :param statements: The list of statements to execute.\n    :type statements: list(str)\n    \"\"\"\n    global sequence_num\n    result = {\n        \"type\": \"code\",\n        \"sequence_num\": sequence_num,\n        \"statements\": statements,\n        \"output\": output\n    }\n    sequence_num += 1\n    return result\n\n\ndef generate_markdown_block(lines):\n    \"\"\"\n    Generates a markdown block from a list of lines.\n    \"\"\"\n    global sequence_num\n    result = {\n        \"type\": \"markdown\",\n        \"sequence_num\": sequence_num,\n        \"value\": lines\n    }\n    sequence_num += 1\n    return result\n\n\ndef is_interactive_statement(line):\n    for prefix in STATEMENT_PREFIXES:\n        if line.lstrip().startswith(prefix):\n            return True\n    return False\n\n\ndef parse_example_parts(lines, title, current_line):\n    \"\"\"\n    Parse the given lines and return a dictionary with two keys:\n    build_up, which contains all the text before an H4 (explanation) is encountered,\n    and\n    explanation, which contains all the text after build_up until --- or another H3 is encountered.\n    \"\"\"\n    parts = {\n        \"build_up\": [],\n        \"explanation\": []\n    }\n    content = [title]\n    statements_so_far = []\n    output_so_far = []\n    next_line = current_line\n    # store build_up till an H4 (explanation) is encountered\n    while not (next_line.startswith(\"#### \")or next_line.startswith('---')):\n        # Watching out for the snippets\n        if next_line.startswith(\"```py\"):\n            # It's a snippet, whatever found until now is text\n            is_interactive = False\n            output_encountered = False\n            if content:\n                parts[\"build_up\"].append(generate_markdown_block(content))\n                content = []\n\n            next_line = next(lines)\n\n            while not next_line.startswith(\"```\"):\n                if is_interactive_statement(next_line):\n                    is_interactive = True\n                    if (output_so_far):\n                        parts[\"build_up\"].append(generate_code_block(statements_so_far, output_so_far))\n                        statements_so_far, output_so_far = [], []\n                    statements_so_far.append(next_line)\n                else:\n                    # can be either output or normal code\n                    if is_interactive:\n                        output_so_far.append(next_line)\n                    elif output_encountered:\n                        output_so_far.append(next_line)\n                    else:\n                        statements_so_far.append(next_line)\n                next_line = next(lines)\n\n            # Snippet is over\n            parts[\"build_up\"].append(generate_code_block(statements_so_far, output_so_far))\n            statements_so_far, output_so_far = [], []\n            next_line = next(lines)\n        else:\n            # It's a text, go on.\n            content.append(next_line)\n            next_line = next(lines)\n\n    # Explanation encountered, save any content till now (if any)\n    if content:\n        parts[\"build_up\"].append(generate_markdown_block(content))\n\n    # Reset stuff\n    content = []\n    statements_so_far, output_so_far = [], []\n\n    # store lines again until --- or another H3 is encountered\n    while not (next_line.startswith(\"---\") or\n               next_line.startswith(\"### \")):\n        if next_line.lstrip().startswith(\"```py\"):\n            # It's a snippet, whatever found until now is text\n            is_interactive = False\n            if content:\n                parts[\"explanation\"].append(generate_markdown_block(content))\n                content = []\n\n            next_line = next(lines)\n\n            while not next_line.lstrip().startswith(\"```\"):\n                if is_interactive_statement(next_line):\n                    is_interactive = True\n                    if (output_so_far):\n                        parts[\"explanation\"].append(generate_code_block(statements_so_far, output_so_far))\n                        statements_so_far, output_so_far = [], []\n                    statements_so_far.append(next_line)\n                else:\n                    # can be either output or normal code\n                    if is_interactive:\n                        output_so_far.append(next_line)\n                    else:\n                        statements_so_far.append(next_line)\n                next_line = next(lines)\n\n            # Snippet is over\n            parts[\"explanation\"].append(generate_code_block(statements_so_far, output_so_far))\n            statements_so_far, output_so_far = [], []\n            next_line = next(lines)\n        else:\n            # It's a text, go on.\n            content.append(next_line)\n            next_line = next(lines)\n\n    # All done\n    if content:\n        parts[\"explanation\"].append(generate_markdown_block(content))\n\n    return next_line, parts\n\n\ndef remove_from_beginning(tokens, line):\n    for token in tokens:\n        if line.lstrip().startswith(token):\n            line = line.replace(token, \"\")\n    return line\n\n\ndef inspect_and_sanitize_code_lines(lines):\n    \"\"\"\n    Remove lines from the beginning of a code block that are not statements.\n\n    :param lines: A list of strings, each representing a line in the code block.\n    :returns is_print_present, sanitized_lines: A boolean indicating whether print was present in the original code and a list of strings representing\n    sanitized lines.  The latter may be an empty list if all input lines were removed as comments or whitespace (and thus did not contain any statements).\n    This function does not remove blank lines at the end of `lines`.\n    \"\"\"\n    tokens_to_remove = STATEMENT_PREFIXES\n    result = []\n    is_print_present = False\n    for line in lines:\n        line = remove_from_beginning(tokens_to_remove, line)\n        if line.startswith(\"print \") or line.startswith(\"print(\"):\n            is_print_present = True\n        result.append(line)\n    return is_print_present, result\n\n\ndef convert_to_cells(cell_contents, read_only):\n    \"\"\"\n    Converts a list of dictionaries containing markdown and code cells into a Jupyter notebook.\n\n    :param cell_contents: A list of dictionaries, each\n    dictionary representing either a markdown or code cell. Each dictionary should have the following keys: \"type\", which is either \"markdown\" or \"code\",\n    and \"value\". The value for type = 'markdown' is the content as string, whereas the value for type = 'code' is another dictionary with two keys,\n    statements and output. The statements key contains all lines in between ```py\\n``` (including) until ```\\n```, while output contains all lines after\n    ```.output py\\n```. \n    :type cell_contents: List[Dict]\n\n        :param read_only (optional): If True then only print outputs are included in converted\n    cells. Default False\n        :type read_only (optional): bool\n\n        :returns A Jupyter notebook containing all cells from input parameter `cell_contents`.\n    Each converted cell has metadata attribute collapsed set to true if it's code-cell otherwise None if it's markdow-cell.\n    \"\"\"\n    cells = []\n    for stuff in cell_contents:\n        if stuff[\"type\"] == \"markdown\":\n            # todo add metadata later\n            cells.append(\n                {\n                    \"cell_type\": \"markdown\",\n                    \"metadata\": {},\n                    \"source\": stuff[\"value\"]\n                }\n            )\n        elif stuff[\"type\"] == \"code\":\n            if read_only:\n                # Skip read only\n                # TODO: Fix\n                cells.append(\n                {\n                    \"cell_type\": \"markdown\",\n                    \"metadata\": {},\n                    \"source\": [\"```py\\n\"] + stuff[\"statements\"] + [\"```\\n\"] + [\"```py\\n\"] + stuff['output'] + [\"```\\n\"]\n                    }\n                )\n                continue\n\n            is_print_present, sanitized_code = inspect_and_sanitize_code_lines(stuff[\"statements\"])\n            if is_print_present:\n                cells.append(\n                    {\n                        \"cell_type\": \"code\",\n                        \"metadata\": {\n                            \"collapsed\": True,\n\n                        },\n                        \"execution_count\": None,\n                        \"outputs\": [{\n                            \"name\": \"stdout\",\n                            \"output_type\": \"stream\",\n                            \"text\": stuff[\"output\"]\n                        }],\n                        \"source\": sanitized_code\n                    }\n                )\n            else:\n                cells.append(\n                    {\n                        \"cell_type\": \"code\",\n                        \"execution_count\": None,\n                        \"metadata\": {\n                            \"collapsed\": True\n                        },\n                        \"outputs\": [{\n                            \"data\": {\n                                \"text/plain\": stuff[\"output\"]\n                            },\n                            \"output_type\": \"execute_result\",\n                            \"metadata\": {},\n                            \"execution_count\": None\n                        }],\n                        \"source\": sanitized_code\n                    }\n                )\n\n    return cells\n\n\ndef convert_to_notebook(pre_examples_content, parsed_json, post_examples_content):\n    \"\"\"\n    Convert a JSON file containing the examples to a Jupyter Notebook.\n    \"\"\"\n    result = {\n        \"cells\": [],\n        \"metadata\": {},\n        \"nbformat\": 4,\n        \"nbformat_minor\": 2\n    }\n\n    notebook_path = \"wtf.ipynb\"\n\n    result[\"cells\"] += convert_to_cells([generate_markdown_block(pre_examples_content)], False)\n\n    for example in parsed_json:\n        parts = example[\"parts\"]\n        build_up = parts.get(\"build_up\")\n        explanation = parts.get(\"explanation\")\n        read_only = example.get(\"read_only\")\n\n        if build_up:\n            result[\"cells\"] += convert_to_cells(build_up, read_only)\n\n        if explanation:\n            result[\"cells\"] += convert_to_cells(explanation, read_only)\n\n    result[\"cells\"] += convert_to_cells([generate_markdown_block(post_examples_content)], False)\n\n    #pprint.pprint(result, indent=2)\n    with open(notebook_path, \"w\") as f:\n        json.dump(result, f, indent=2)\n\n\nwith open(fpath, 'r+', encoding=\"utf-8\") as f:\n    lines = iter(f.readlines())\n    line = next(lines)\n    result = []\n    pre_examples_phase = True\n    pre_stuff = []\n    post_stuff = []\n    try:\n        while True:\n            if line.startswith(\"## \"):\n                pre_examples_phase = False\n                # A section is encountered\n                current_section_name = line.replace(\"## \", \"\").strip()\n                section_text = []\n                line = next(lines)\n                # Until a new section is encountered\n                while not (line.startswith(\"## \") or line.startswith(\"# \")):\n                    # check if it's a H3\n                    if line.startswith(\"### \"):\n                        # An example is encountered\n                        title_line = line\n                        line = next(lines)\n                        read_only = False\n                        while line.strip() == \"\" or line.startswith('<!--'):\n                            #TODO: Capture example ID here using regex.\n                            if '<!-- read-only -->' in line:\n                                read_only = True\n                            line = next(lines)\n\n                        example_details = {\n                            \"id\": current_example,\n                            \"title\": title_line.replace(\"### \", \"\"),\n                            \"section\": current_section_name,\n                            \"read_only\": read_only\n                        }\n                        line, example_details[\"parts\"] = parse_example_parts(lines, title_line, line)\n                        result.append(example_details)\n                        current_example += 1\n                    else:\n                        section_text.append(line)\n                        line = next(lines)\n            else:\n                if pre_examples_phase:\n                    pre_stuff.append(line)\n                else:\n                    post_stuff.append(line)\n                line = next(lines)\n\n    except StopIteration as e:\n        #pprint.pprint(result, indent=2)\n        pre_stuff.append(HOSTED_NOTEBOOK_INSTRUCTIONS)\n        result.sort(key = lambda x: x[\"read_only\"])\n        convert_to_notebook(pre_stuff, result, post_stuff)\n", "irrelevant/insert_ids.py": "import uuid\n\nnew_file = []\noriginal_file = []\n\nfname = \"../README.md\"\n\n\ndef generate_random_id_comment():\n    random_id = uuid.uuid4()\n    return f\"<!-- Example ID: {random_id} --!>\"\n\n\nwith open(fname, \"r\") as f:\n    original_file = f.readlines()\n\n\nfor line in original_file:\n    new_file.append(line)\n    if line.strip().startswith(\"### \"):\n        new_file.append(generate_random_id_comment())\n\nwith open(fname, \"w\") as f:\n    f.write(\"\".join(new_file))\n", "irrelevant/obsolete/generate_contributions.py": "\"\"\"\nThis script parses the README.md and generates the table\n`CONTRIBUTORS.md`.\n\nNo longer works since we've moved on contributors to CONTRIBUTORS.md entirely.\n\"\"\"\n\nimport pprint\nimport re\nimport requests\n\nregex = (\"[sS]uggested by @(\\S+) in \\[this\\]\\(https:\\/\\/github\\.com\\/satwikkansal\"\n         \"\\/wtf[pP]ython\\/issues\\/(\\d+)\\) issue\")\n\n\nfname = \"README.md\"\ncontribs = {}\n\ntable_header = \"\"\"\n| Contributor | Github | Issues |\n|-------------|--------|--------|\n\"\"\"\n\ntable_row = '| {} | [{}](https://github.com/{}) | {} |'\nissue_format = '[#{}](https:/github.com/satwikkansal/wtfpython/issues/{})'\nrows_so_far = []\n\ngithub_rest_api = \"https://api.github.com/users/{}\"\n\n\nwith open(fname, 'r') as f:\n    file_content = f.read()\n    matches = re.findall(regex, file_content)\n    for match in matches:\n        if contribs.get(match[0]) and match[1] not in contribs[match[0]]:\n            contribs[match[0]].append(match[1])\n        else:\n            contribs[match[0]] = [match[1]]\n\nfor handle, issues in contribs.items():\n    issue_string = ', '.join([issue_format.format(i, i) for i in issues])\n    resp = requests.get(github_rest_api.format(handle))\n    name = handle\n    if resp.status_code == 200:\n        pprint.pprint(resp.json()['name'])\n    else:\n        print(handle, resp.content)\n    rows_so_far.append(table_row.format(name,\n                                        handle,\n                                        handle,\n                                        issue_string))\n\nprint(table_header + \"\\n\".join(rows_so_far))\n", "irrelevant/obsolete/parse_readme.py": "# -*- coding: utf-8 -*-\n\n\"\"\"\nThis inefficient module would parse the README.md in the initial version of\nWTFPython, and enable me to categorize and reorder a hell lot of examples with\nthe help of the file `add_categories` (part of which is automatically\ngenerated).\n\nAfter the refactor, this module would not work now with necessary updates in\nthe code.\n\"\"\"\n\ntry:\n    raw_input          # Python 2\nexcept NameError:\n    raw_input = input  # Python 3\n    \n\nfname = \"README.md\"\nsnippets = []\n\nwith open(fname, 'r') as f:\n    lines = iter(f.readlines())\n    line = lines.next()\n\n    try:\n        while True:\n            # check if it's a H3\n            if line.startswith(\"### \"):\n                title = line.replace(\"### \", \"\")\n                description = []\n                next_line = lines.next()\n\n                # store lines till an H4 (explanation) is encountered\n                while not next_line.startswith(\"#### \"):\n                    description.append(next_line)\n                    next_line = lines.next()\n\n                explanation = []\n                # store lines again until --- or another H3 is encountered\n                while not (next_line.startswith(\"---\") or\n                           next_line.startswith(\"### \")):\n                    explanation.append(next_line)\n                    next_line = lines.next()\n\n                # Store the results finally\n                snippets.append({\n                        \"title\": title,\n                        \"description\": '\\n'.join(description),\n                        \"explanation\": '\\n'.join(explanation)\n                })\n\n                line = next_line\n\n            else:\n                line = lines.next()\n\n    except StopIteration:\n        snippets.append({\n                        \"title\": title,\n                        \"description\": '\\n'.join(description),\n                        \"explanation\": '\\n'.join(explanation)\n        })\n\n'''\n# Create a file\nfile_content = \"\\n\\n\".join([snip[\"title\"] for snip in snippets])\n\nwith open(\"add_categories\", \"w\") as f:\n    f.write(file_content)\n'''\n\nsnips_by_title = {}\n\nwith open(\"add_categories\", \"r\") as f:\n    content = iter(f.readlines())\n    try:\n        while True:\n            title = content.next()\n            cat = content.next().strip()\n            is_new = True if cat[-1]==\"*\" else False\n            cat = cat.replace('*','')\n            snips_by_title[title] = {\n                \"category\": cat,\n                \"is_new\": is_new\n            }\n            content.next()\n    except StopIteration:\n        pass\n\nfor idx, snip in enumerate(snippets):\n    snippets[idx][\"category\"] = snips_by_title[snip[\"title\"]][\"category\"]\n    snippets[idx][\"is_new\"] = snips_by_title[snip[\"title\"]][\"is_new\"]\n\n\nsnips_by_cat = {}\nfor snip in snippets:\n    cat = snip[\"category\"]\n    if not snips_by_cat.get(cat):\n        snips_by_cat[cat] = []\n    snips_by_cat[cat].append(snip)\n\nsnippet_template = \"\"\"\n\n### \u25b6 {title}{is_new}\n\n{description}\n\n{explanation}\n\n---\n\"\"\"\n\ncategory_template = \"\"\"\n---\n\n## {category}\n\n{content}\n\"\"\"\n\nresult = \"\"\n\ncategory_names = {\n    \"a\": \"Appearances are Deceptive!\",\n    \"t\": \"The Hiddent treasures\",\n    \"f\": \"Strain your Brain\",\n    \"c\": \"Be careful of these\",\n    \"m\": \"Miscallaneous\"\n}\n\ncategories_in_order = [\"a\", \"t\", \"f\", \"c\", \"m\"]\n\nfor category in categories_in_order:\n    snips = snips_by_cat[category]\n    for i, snip in enumerate(snips):\n        print(i, \":\", snip[\"title\"])\n    content = \"\"\n    for _ in snips:\n        snip = snips[int(raw_input())]\n        is_new = \" *\" if snip[\"is_new\"] else \"\"\n        content += snippet_template.format(title=snip[\"title\"].strip(),\n                                           is_new=is_new,\n                                           description=snip[\"description\"].strip().replace(\"\\n\\n\", \"\\n\"),\n                                           explanation=snip[\"explanation\"].strip().replace(\"\\n\\n\", \"\\n\"))\n    result += category_template.format(category=category_names[category], content=content.replace(\"\\n\\n\\n\", \"\\n\\n\"))\n\nwith open(\"generated.md\", \"w\") as f:\n    f.write(result.replace(\"\\n\\n\\n\", \"\\n\\n\"))\n\nprint(\"Done!\")\n"}