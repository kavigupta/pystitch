{"tomlkit/exceptions.py": "from __future__ import annotations\n\nfrom typing import Collection\n\n\nclass TOMLKitError(Exception):\n    pass\n\n\nclass ParseError(ValueError, TOMLKitError):\n    \"\"\"\n    This error occurs when the parser encounters a syntax error\n    in the TOML being parsed. The error references the line and\n    location within the line where the error was encountered.\n    \"\"\"\n\n    def __init__(self, line: int, col: int, message: str | None = None) -> None:\n        self._line = line\n        self._col = col\n\n        if message is None:\n            message = \"TOML parse error\"\n\n        super().__init__(f\"{message} at line {self._line} col {self._col}\")\n\n    @property\n    def line(self):\n        return self._line\n\n    @property\n    def col(self):\n        return self._col\n\n\nclass MixedArrayTypesError(ParseError):\n    \"\"\"\n    An array was found that had two or more element types.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Mixed types found in array\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidNumberError(ParseError):\n    \"\"\"\n    A numeric field was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid number\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidDateTimeError(ParseError):\n    \"\"\"\n    A datetime field was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid datetime\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidDateError(ParseError):\n    \"\"\"\n    A date field was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid date\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidTimeError(ParseError):\n    \"\"\"\n    A date field was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid time\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidNumberOrDateError(ParseError):\n    \"\"\"\n    A numeric or date field was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid number or date format\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidUnicodeValueError(ParseError):\n    \"\"\"\n    A unicode code was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid unicode value\"\n\n        super().__init__(line, col, message=message)\n\n\nclass UnexpectedCharError(ParseError):\n    \"\"\"\n    An unexpected character was found during parsing.\n    \"\"\"\n\n    def __init__(self, line: int, col: int, char: str) -> None:\n        message = f\"Unexpected character: {char!r}\"\n\n        super().__init__(line, col, message=message)\n\n\nclass EmptyKeyError(ParseError):\n    \"\"\"\n    An empty key was found during parsing.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Empty key\"\n\n        super().__init__(line, col, message=message)\n\n\nclass EmptyTableNameError(ParseError):\n    \"\"\"\n    An empty table name was found during parsing.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Empty table name\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidCharInStringError(ParseError):\n    \"\"\"\n    The string being parsed contains an invalid character.\n    \"\"\"\n\n    def __init__(self, line: int, col: int, char: str) -> None:\n        message = f\"Invalid character {char!r} in string\"\n\n        super().__init__(line, col, message=message)\n\n\nclass UnexpectedEofError(ParseError):\n    \"\"\"\n    The TOML being parsed ended before the end of a statement.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Unexpected end of file\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InternalParserError(ParseError):\n    \"\"\"\n    An error that indicates a bug in the parser.\n    \"\"\"\n\n    def __init__(self, line: int, col: int, message: str | None = None) -> None:\n        msg = \"Internal parser error\"\n        if message:\n            msg += f\" ({message})\"\n\n        super().__init__(line, col, message=msg)\n\n\nclass NonExistentKey(KeyError, TOMLKitError):\n    \"\"\"\n    A non-existent key was used.\n    \"\"\"\n\n    def __init__(self, key):\n        message = f'Key \"{key}\" does not exist.'\n\n        super().__init__(message)\n\n\nclass KeyAlreadyPresent(TOMLKitError):\n    \"\"\"\n    An already present key was used.\n    \"\"\"\n\n    def __init__(self, key):\n        key = getattr(key, \"key\", key)\n        message = f'Key \"{key}\" already exists.'\n\n        super().__init__(message)\n\n\nclass InvalidControlChar(ParseError):\n    def __init__(self, line: int, col: int, char: int, type: str) -> None:\n        display_code = \"\\\\u00\"\n\n        if char < 16:\n            display_code += \"0\"\n\n        display_code += hex(char)[2:]\n\n        message = (\n            \"Control characters (codes less than 0x1f and 0x7f)\"\n            f\" are not allowed in {type}, \"\n            f\"use {display_code} instead\"\n        )\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidStringError(ValueError, TOMLKitError):\n    def __init__(self, value: str, invalid_sequences: Collection[str], delimiter: str):\n        repr_ = repr(value)[1:-1]\n        super().__init__(\n            f\"Invalid string: {delimiter}{repr_}{delimiter}. \"\n            f\"The character sequences {invalid_sequences} are invalid.\"\n        )\n\n\nclass ConvertError(TypeError, ValueError, TOMLKitError):\n    \"\"\"Raised when item() fails to convert a value.\n    It should be a TypeError, but due to historical reasons\n    it needs to subclass ValueError as well.\n    \"\"\"\n", "tomlkit/source.py": "from __future__ import annotations\n\nfrom copy import copy\nfrom typing import Any\n\nfrom tomlkit.exceptions import ParseError\nfrom tomlkit.exceptions import UnexpectedCharError\nfrom tomlkit.toml_char import TOMLChar\n\n\nclass _State:\n    def __init__(\n        self,\n        source: Source,\n        save_marker: bool | None = False,\n        restore: bool | None = False,\n    ) -> None:\n        self._source = source\n        self._save_marker = save_marker\n        self.restore = restore\n\n    def __enter__(self) -> _State:\n        # Entering this context manager - save the state\n        self._chars = copy(self._source._chars)\n        self._idx = self._source._idx\n        self._current = self._source._current\n        self._marker = self._source._marker\n\n        return self\n\n    def __exit__(self, exception_type, exception_val, trace):\n        # Exiting this context manager - restore the prior state\n        if self.restore or exception_type:\n            self._source._chars = self._chars\n            self._source._idx = self._idx\n            self._source._current = self._current\n            if self._save_marker:\n                self._source._marker = self._marker\n\n\nclass _StateHandler:\n    \"\"\"\n    State preserver for the Parser.\n    \"\"\"\n\n    def __init__(self, source: Source) -> None:\n        self._source = source\n        self._states = []\n\n    def __call__(self, *args, **kwargs):\n        return _State(self._source, *args, **kwargs)\n\n    def __enter__(self) -> _State:\n        state = self()\n        self._states.append(state)\n        return state.__enter__()\n\n    def __exit__(self, exception_type, exception_val, trace):\n        state = self._states.pop()\n        return state.__exit__(exception_type, exception_val, trace)\n\n\nclass Source(str):\n    EOF = TOMLChar(\"\\0\")\n\n    def __init__(self, _: str) -> None:\n        super().__init__()\n\n        # Collection of TOMLChars\n        self._chars = iter([(i, TOMLChar(c)) for i, c in enumerate(self)])\n\n        self._idx = 0\n        self._marker = 0\n        self._current = TOMLChar(\"\")\n\n        self._state = _StateHandler(self)\n\n        self.inc()\n\n    def reset(self):\n        # initialize both idx and current\n        self.inc()\n\n        # reset marker\n        self.mark()\n\n    @property\n    def state(self) -> _StateHandler:\n        return self._state\n\n    @property\n    def idx(self) -> int:\n        return self._idx\n\n    @property\n    def current(self) -> TOMLChar:\n        return self._current\n\n    @property\n    def marker(self) -> int:\n        return self._marker\n\n    def extract(self) -> str:\n        \"\"\"\n        Extracts the value between marker and index\n        \"\"\"\n        return self[self._marker : self._idx]\n\n    def inc(self, exception: type[ParseError] | None = None) -> bool:\n        \"\"\"\n        Increments the parser if the end of the input has not been reached.\n        Returns whether or not it was able to advance.\n        \"\"\"\n        try:\n            self._idx, self._current = next(self._chars)\n\n            return True\n        except StopIteration:\n            self._idx = len(self)\n            self._current = self.EOF\n            if exception:\n                raise self.parse_error(exception) from None\n\n            return False\n\n    def inc_n(self, n: int, exception: type[ParseError] | None = None) -> bool:\n        \"\"\"\n        Increments the parser by n characters\n        if the end of the input has not been reached.\n        \"\"\"\n        return all(self.inc(exception=exception) for _ in range(n))\n\n    def consume(self, chars, min=0, max=-1):\n        \"\"\"\n        Consume chars until min/max is satisfied is valid.\n        \"\"\"\n        while self.current in chars and max != 0:\n            min -= 1\n            max -= 1\n            if not self.inc():\n                break\n\n        # failed to consume minimum number of characters\n        if min > 0:\n            raise self.parse_error(UnexpectedCharError, self.current)\n\n    def end(self) -> bool:\n        \"\"\"\n        Returns True if the parser has reached the end of the input.\n        \"\"\"\n        return self._current is self.EOF\n\n    def mark(self) -> None:\n        \"\"\"\n        Sets the marker to the index's current position\n        \"\"\"\n        self._marker = self._idx\n\n    def parse_error(\n        self,\n        exception: type[ParseError] = ParseError,\n        *args: Any,\n        **kwargs: Any,\n    ) -> ParseError:\n        \"\"\"\n        Creates a generic \"parse error\" at the current position.\n        \"\"\"\n        line, col = self._to_linecol()\n\n        return exception(line, col, *args, **kwargs)\n\n    def _to_linecol(self) -> tuple[int, int]:\n        cur = 0\n        for i, line in enumerate(self.splitlines()):\n            if cur + len(line) + 1 > self.idx:\n                return (i + 1, self.idx - cur)\n\n            cur += len(line) + 1\n\n        return len(self.splitlines()), 0\n", "tomlkit/items.py": "from __future__ import annotations\n\nimport abc\nimport copy\nimport dataclasses\nimport math\nimport re\nimport string\nimport sys\n\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import tzinfo\nfrom enum import Enum\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Collection\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\n\nfrom tomlkit._compat import PY38\nfrom tomlkit._compat import decode\nfrom tomlkit._types import _CustomDict\nfrom tomlkit._types import _CustomFloat\nfrom tomlkit._types import _CustomInt\nfrom tomlkit._types import _CustomList\nfrom tomlkit._types import wrap_method\nfrom tomlkit._utils import CONTROL_CHARS\nfrom tomlkit._utils import escape_string\nfrom tomlkit.exceptions import ConvertError\nfrom tomlkit.exceptions import InvalidStringError\n\n\nif TYPE_CHECKING:\n    from tomlkit import container\n\n\nItemT = TypeVar(\"ItemT\", bound=\"Item\")\nEncoder = Callable[[Any], \"Item\"]\nCUSTOM_ENCODERS: list[Encoder] = []\nAT = TypeVar(\"AT\", bound=\"AbstractTable\")\n\n\n@overload\ndef item(value: bool, _parent: Item | None = ..., _sort_keys: bool = ...) -> Bool: ...\n\n\n@overload\ndef item(value: int, _parent: Item | None = ..., _sort_keys: bool = ...) -> Integer: ...\n\n\n@overload\ndef item(value: float, _parent: Item | None = ..., _sort_keys: bool = ...) -> Float: ...\n\n\n@overload\ndef item(value: str, _parent: Item | None = ..., _sort_keys: bool = ...) -> String: ...\n\n\n@overload\ndef item(\n    value: datetime, _parent: Item | None = ..., _sort_keys: bool = ...\n) -> DateTime: ...\n\n\n@overload\ndef item(value: date, _parent: Item | None = ..., _sort_keys: bool = ...) -> Date: ...\n\n\n@overload\ndef item(value: time, _parent: Item | None = ..., _sort_keys: bool = ...) -> Time: ...\n\n\n@overload\ndef item(\n    value: Sequence[dict], _parent: Item | None = ..., _sort_keys: bool = ...\n) -> AoT: ...\n\n\n@overload\ndef item(\n    value: Sequence, _parent: Item | None = ..., _sort_keys: bool = ...\n) -> Array: ...\n\n\n@overload\ndef item(value: dict, _parent: Array = ..., _sort_keys: bool = ...) -> InlineTable: ...\n\n\n@overload\ndef item(value: dict, _parent: Item | None = ..., _sort_keys: bool = ...) -> Table: ...\n\n\n@overload\ndef item(value: ItemT, _parent: Item | None = ..., _sort_keys: bool = ...) -> ItemT: ...\n\n\ndef item(value: Any, _parent: Item | None = None, _sort_keys: bool = False) -> Item:\n    \"\"\"Create a TOML item from a Python object.\n\n    :Example:\n\n    >>> item(42)\n    42\n    >>> item([1, 2, 3])\n    [1, 2, 3]\n    >>> item({'a': 1, 'b': 2})\n    a = 1\n    b = 2\n    \"\"\"\n\n    from tomlkit.container import Container\n\n    if isinstance(value, Item):\n        return value\n\n    if isinstance(value, bool):\n        return Bool(value, Trivia())\n    elif isinstance(value, int):\n        return Integer(value, Trivia(), str(value))\n    elif isinstance(value, float):\n        return Float(value, Trivia(), str(value))\n    elif isinstance(value, dict):\n        table_constructor = (\n            InlineTable if isinstance(_parent, (Array, InlineTable)) else Table\n        )\n        val = table_constructor(Container(), Trivia(), False)\n        for k, v in sorted(\n            value.items(),\n            key=lambda i: (isinstance(i[1], dict), i[0]) if _sort_keys else 1,\n        ):\n            val[k] = item(v, _parent=val, _sort_keys=_sort_keys)\n\n        return val\n    elif isinstance(value, (list, tuple)):\n        if (\n            value\n            and all(isinstance(v, dict) for v in value)\n            and (_parent is None or isinstance(_parent, Table))\n        ):\n            a = AoT([])\n            table_constructor = Table\n        else:\n            a = Array([], Trivia())\n            table_constructor = InlineTable\n\n        for v in value:\n            if isinstance(v, dict):\n                table = table_constructor(Container(), Trivia(), True)\n\n                for k, _v in sorted(\n                    v.items(),\n                    key=lambda i: (isinstance(i[1], dict), i[0] if _sort_keys else 1),\n                ):\n                    i = item(_v, _parent=table, _sort_keys=_sort_keys)\n                    if isinstance(table, InlineTable):\n                        i.trivia.trail = \"\"\n\n                    table[k] = i\n\n                v = table\n\n            a.append(v)\n\n        return a\n    elif isinstance(value, str):\n        return String.from_raw(value)\n    elif isinstance(value, datetime):\n        return DateTime(\n            value.year,\n            value.month,\n            value.day,\n            value.hour,\n            value.minute,\n            value.second,\n            value.microsecond,\n            value.tzinfo,\n            Trivia(),\n            value.isoformat().replace(\"+00:00\", \"Z\"),\n        )\n    elif isinstance(value, date):\n        return Date(value.year, value.month, value.day, Trivia(), value.isoformat())\n    elif isinstance(value, time):\n        return Time(\n            value.hour,\n            value.minute,\n            value.second,\n            value.microsecond,\n            value.tzinfo,\n            Trivia(),\n            value.isoformat(),\n        )\n    else:\n        for encoder in CUSTOM_ENCODERS:\n            try:\n                rv = encoder(value)\n            except ConvertError:\n                pass\n            else:\n                if not isinstance(rv, Item):\n                    raise ConvertError(\n                        f\"Custom encoder is expected to return an instance of Item, got {type(rv)}\"\n                    )\n                return rv\n\n    raise ConvertError(f\"Unable to convert an object of {type(value)} to a TOML item\")\n\n\nclass StringType(Enum):\n    # Single Line Basic\n    SLB = '\"'\n    # Multi Line Basic\n    MLB = '\"\"\"'\n    # Single Line Literal\n    SLL = \"'\"\n    # Multi Line Literal\n    MLL = \"'''\"\n\n    @classmethod\n    def select(cls, literal=False, multiline=False) -> StringType:\n        return {\n            (False, False): cls.SLB,\n            (False, True): cls.MLB,\n            (True, False): cls.SLL,\n            (True, True): cls.MLL,\n        }[(literal, multiline)]\n\n    @property\n    def escaped_sequences(self) -> Collection[str]:\n        # https://toml.io/en/v1.0.0#string\n        escaped_in_basic = CONTROL_CHARS | {\"\\\\\"}\n        allowed_in_multiline = {\"\\n\", \"\\r\"}\n        return {\n            StringType.SLB: escaped_in_basic | {'\"'},\n            StringType.MLB: (escaped_in_basic | {'\"\"\"'}) - allowed_in_multiline,\n            StringType.SLL: (),\n            StringType.MLL: (),\n        }[self]\n\n    @property\n    def invalid_sequences(self) -> Collection[str]:\n        # https://toml.io/en/v1.0.0#string\n        forbidden_in_literal = CONTROL_CHARS - {\"\\t\"}\n        allowed_in_multiline = {\"\\n\", \"\\r\"}\n        return {\n            StringType.SLB: (),\n            StringType.MLB: (),\n            StringType.SLL: forbidden_in_literal | {\"'\"},\n            StringType.MLL: (forbidden_in_literal | {\"'''\"}) - allowed_in_multiline,\n        }[self]\n\n    @property\n    def unit(self) -> str:\n        return self.value[0]\n\n    def is_basic(self) -> bool:\n        return self in {StringType.SLB, StringType.MLB}\n\n    def is_literal(self) -> bool:\n        return self in {StringType.SLL, StringType.MLL}\n\n    def is_singleline(self) -> bool:\n        return self in {StringType.SLB, StringType.SLL}\n\n    def is_multiline(self) -> bool:\n        return self in {StringType.MLB, StringType.MLL}\n\n    def toggle(self) -> StringType:\n        return {\n            StringType.SLB: StringType.MLB,\n            StringType.MLB: StringType.SLB,\n            StringType.SLL: StringType.MLL,\n            StringType.MLL: StringType.SLL,\n        }[self]\n\n\nclass BoolType(Enum):\n    TRUE = \"true\"\n    FALSE = \"false\"\n\n    def __bool__(self):\n        return {BoolType.TRUE: True, BoolType.FALSE: False}[self]\n\n    def __iter__(self):\n        return iter(self.value)\n\n    def __len__(self):\n        return len(self.value)\n\n\n@dataclasses.dataclass\nclass Trivia:\n    \"\"\"\n    Trivia information (aka metadata).\n    \"\"\"\n\n    # Whitespace before a value.\n    indent: str = \"\"\n    # Whitespace after a value, but before a comment.\n    comment_ws: str = \"\"\n    # Comment, starting with # character, or empty string if no comment.\n    comment: str = \"\"\n    # Trailing newline.\n    trail: str = \"\\n\"\n\n    def copy(self) -> Trivia:\n        return dataclasses.replace(self)\n\n\nclass KeyType(Enum):\n    \"\"\"\n    The type of a Key.\n\n    Keys can be bare (unquoted), or quoted using basic (\"), or literal (')\n    quotes following the same escaping rules as single-line StringType.\n    \"\"\"\n\n    Bare = \"\"\n    Basic = '\"'\n    Literal = \"'\"\n\n\nclass Key(abc.ABC):\n    \"\"\"Base class for a key\"\"\"\n\n    sep: str\n    _original: str\n    _keys: list[SingleKey]\n    _dotted: bool\n    key: str\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        pass\n\n    @abc.abstractmethod\n    def __eq__(self, __o: object) -> bool:\n        pass\n\n    def is_dotted(self) -> bool:\n        \"\"\"If the key is followed by other keys\"\"\"\n        return self._dotted\n\n    def __iter__(self) -> Iterator[SingleKey]:\n        return iter(self._keys)\n\n    def concat(self, other: Key) -> DottedKey:\n        \"\"\"Concatenate keys into a dotted key\"\"\"\n        keys = self._keys + other._keys\n        return DottedKey(keys, sep=self.sep)\n\n    def is_multi(self) -> bool:\n        \"\"\"Check if the key contains multiple keys\"\"\"\n        return len(self._keys) > 1\n\n    def as_string(self) -> str:\n        \"\"\"The TOML representation\"\"\"\n        return self._original\n\n    def __str__(self) -> str:\n        return self.as_string()\n\n    def __repr__(self) -> str:\n        return f\"<Key {self.as_string()}>\"\n\n\nclass SingleKey(Key):\n    \"\"\"A single key\"\"\"\n\n    def __init__(\n        self,\n        k: str,\n        t: KeyType | None = None,\n        sep: str | None = None,\n        original: str | None = None,\n    ) -> None:\n        if t is None:\n            if not k or any(\n                c not in string.ascii_letters + string.digits + \"-\" + \"_\" for c in k\n            ):\n                t = KeyType.Basic\n            else:\n                t = KeyType.Bare\n\n        self.t = t\n        if sep is None:\n            sep = \" = \"\n\n        self.sep = sep\n        self.key = k\n        if original is None:\n            key_str = escape_string(k) if t == KeyType.Basic else k\n            original = f\"{t.value}{key_str}{t.value}\"\n\n        self._original = original\n        self._keys = [self]\n        self._dotted = False\n\n    @property\n    def delimiter(self) -> str:\n        \"\"\"The delimiter: double quote/single quote/none\"\"\"\n        return self.t.value\n\n    def is_bare(self) -> bool:\n        \"\"\"Check if the key is bare\"\"\"\n        return self.t == KeyType.Bare\n\n    def __hash__(self) -> int:\n        return hash(self.key)\n\n    def __eq__(self, other: Any) -> bool:\n        if isinstance(other, Key):\n            return isinstance(other, SingleKey) and self.key == other.key\n\n        return self.key == other\n\n\nclass DottedKey(Key):\n    def __init__(\n        self,\n        keys: Iterable[SingleKey],\n        sep: str | None = None,\n        original: str | None = None,\n    ) -> None:\n        self._keys = list(keys)\n        if original is None:\n            original = \".\".join(k.as_string() for k in self._keys)\n\n        self.sep = \" = \" if sep is None else sep\n        self._original = original\n        self._dotted = False\n        self.key = \".\".join(k.key for k in self._keys)\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._keys))\n\n    def __eq__(self, __o: object) -> bool:\n        return isinstance(__o, DottedKey) and self._keys == __o._keys\n\n\nclass Item:\n    \"\"\"\n    An item within a TOML document.\n    \"\"\"\n\n    def __init__(self, trivia: Trivia) -> None:\n        self._trivia = trivia\n\n    @property\n    def trivia(self) -> Trivia:\n        \"\"\"The trivia element associated with this item\"\"\"\n        return self._trivia\n\n    @property\n    def discriminant(self) -> int:\n        raise NotImplementedError()\n\n    def as_string(self) -> str:\n        \"\"\"The TOML representation\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def value(self) -> Any:\n        return self\n\n    def unwrap(self) -> Any:\n        \"\"\"Returns as pure python object (ppo)\"\"\"\n        raise NotImplementedError()\n\n    # Helpers\n\n    def comment(self, comment: str) -> Item:\n        \"\"\"Attach a comment to this item\"\"\"\n        if not comment.strip().startswith(\"#\"):\n            comment = \"# \" + comment\n\n        self._trivia.comment_ws = \" \"\n        self._trivia.comment = comment\n\n        return self\n\n    def indent(self, indent: int) -> Item:\n        \"\"\"Indent this item with given number of spaces\"\"\"\n        if self._trivia.indent.startswith(\"\\n\"):\n            self._trivia.indent = \"\\n\" + \" \" * indent\n        else:\n            self._trivia.indent = \" \" * indent\n\n        return self\n\n    def is_boolean(self) -> bool:\n        return isinstance(self, Bool)\n\n    def is_table(self) -> bool:\n        return isinstance(self, Table)\n\n    def is_inline_table(self) -> bool:\n        return isinstance(self, InlineTable)\n\n    def is_aot(self) -> bool:\n        return isinstance(self, AoT)\n\n    def _getstate(self, protocol=3):\n        return (self._trivia,)\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)\n\n    def __reduce_ex__(self, protocol):\n        return self.__class__, self._getstate(protocol)\n\n\nclass Whitespace(Item):\n    \"\"\"\n    A whitespace literal.\n    \"\"\"\n\n    def __init__(self, s: str, fixed: bool = False) -> None:\n        self._s = s\n        self._fixed = fixed\n\n    @property\n    def s(self) -> str:\n        return self._s\n\n    @property\n    def value(self) -> str:\n        \"\"\"The wrapped string of the whitespace\"\"\"\n        return self._s\n\n    @property\n    def trivia(self) -> Trivia:\n        raise RuntimeError(\"Called trivia on a Whitespace variant.\")\n\n    @property\n    def discriminant(self) -> int:\n        return 0\n\n    def is_fixed(self) -> bool:\n        \"\"\"If the whitespace is fixed, it can't be merged or discarded from the output.\"\"\"\n        return self._fixed\n\n    def as_string(self) -> str:\n        return self._s\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__} {self._s!r}>\"\n\n    def _getstate(self, protocol=3):\n        return self._s, self._fixed\n\n\nclass Comment(Item):\n    \"\"\"\n    A comment literal.\n    \"\"\"\n\n    @property\n    def discriminant(self) -> int:\n        return 1\n\n    def as_string(self) -> str:\n        return (\n            f\"{self._trivia.indent}{decode(self._trivia.comment)}{self._trivia.trail}\"\n        )\n\n    def __str__(self) -> str:\n        return f\"{self._trivia.indent}{decode(self._trivia.comment)}\"\n\n\nclass Integer(Item, _CustomInt):\n    \"\"\"\n    An integer literal.\n    \"\"\"\n\n    def __new__(cls, value: int, trivia: Trivia, raw: str) -> Integer:\n        return int.__new__(cls, value)\n\n    def __init__(self, value: int, trivia: Trivia, raw: str) -> None:\n        super().__init__(trivia)\n        self._original = value\n        self._raw = raw\n        self._sign = False\n\n        if re.match(r\"^[+\\-]\\d+$\", raw):\n            self._sign = True\n\n    def unwrap(self) -> int:\n        return self._original\n\n    __int__ = unwrap\n\n    def __hash__(self) -> int:\n        return hash(self.unwrap())\n\n    @property\n    def discriminant(self) -> int:\n        return 2\n\n    @property\n    def value(self) -> int:\n        \"\"\"The wrapped integer value\"\"\"\n        return self\n\n    def as_string(self) -> str:\n        return self._raw\n\n    def _new(self, result):\n        raw = str(result)\n        if self._sign and result >= 0:\n            raw = f\"+{raw}\"\n\n        return Integer(result, self._trivia, raw)\n\n    def _getstate(self, protocol=3):\n        return int(self), self._trivia, self._raw\n\n    # int methods\n    __abs__ = wrap_method(int.__abs__)\n    __add__ = wrap_method(int.__add__)\n    __and__ = wrap_method(int.__and__)\n    __ceil__ = wrap_method(int.__ceil__)\n    __eq__ = int.__eq__\n    __floor__ = wrap_method(int.__floor__)\n    __floordiv__ = wrap_method(int.__floordiv__)\n    __invert__ = wrap_method(int.__invert__)\n    __le__ = int.__le__\n    __lshift__ = wrap_method(int.__lshift__)\n    __lt__ = int.__lt__\n    __mod__ = wrap_method(int.__mod__)\n    __mul__ = wrap_method(int.__mul__)\n    __neg__ = wrap_method(int.__neg__)\n    __or__ = wrap_method(int.__or__)\n    __pos__ = wrap_method(int.__pos__)\n    __pow__ = wrap_method(int.__pow__)\n    __radd__ = wrap_method(int.__radd__)\n    __rand__ = wrap_method(int.__rand__)\n    __rfloordiv__ = wrap_method(int.__rfloordiv__)\n    __rlshift__ = wrap_method(int.__rlshift__)\n    __rmod__ = wrap_method(int.__rmod__)\n    __rmul__ = wrap_method(int.__rmul__)\n    __ror__ = wrap_method(int.__ror__)\n    __round__ = wrap_method(int.__round__)\n    __rpow__ = wrap_method(int.__rpow__)\n    __rrshift__ = wrap_method(int.__rrshift__)\n    __rshift__ = wrap_method(int.__rshift__)\n    __rxor__ = wrap_method(int.__rxor__)\n    __trunc__ = wrap_method(int.__trunc__)\n    __xor__ = wrap_method(int.__xor__)\n\n    def __rtruediv__(self, other):\n        result = int.__rtruediv__(self, other)\n        if result is NotImplemented:\n            return result\n        return Float._new(self, result)\n\n    def __truediv__(self, other):\n        result = int.__truediv__(self, other)\n        if result is NotImplemented:\n            return result\n        return Float._new(self, result)\n\n\nclass Float(Item, _CustomFloat):\n    \"\"\"\n    A float literal.\n    \"\"\"\n\n    def __new__(cls, value: float, trivia: Trivia, raw: str) -> Float:\n        return float.__new__(cls, value)\n\n    def __init__(self, value: float, trivia: Trivia, raw: str) -> None:\n        super().__init__(trivia)\n        self._original = value\n        self._raw = raw\n        self._sign = False\n\n        if re.match(r\"^[+\\-].+$\", raw):\n            self._sign = True\n\n    def unwrap(self) -> float:\n        return self._original\n\n    __float__ = unwrap\n\n    def __hash__(self) -> int:\n        return hash(self.unwrap())\n\n    @property\n    def discriminant(self) -> int:\n        return 3\n\n    @property\n    def value(self) -> float:\n        \"\"\"The wrapped float value\"\"\"\n        return self\n\n    def as_string(self) -> str:\n        return self._raw\n\n    def _new(self, result):\n        raw = str(result)\n\n        if self._sign and result >= 0:\n            raw = f\"+{raw}\"\n\n        return Float(result, self._trivia, raw)\n\n    def _getstate(self, protocol=3):\n        return float(self), self._trivia, self._raw\n\n    # float methods\n    __abs__ = wrap_method(float.__abs__)\n    __add__ = wrap_method(float.__add__)\n    __eq__ = float.__eq__\n    __floordiv__ = wrap_method(float.__floordiv__)\n    __le__ = float.__le__\n    __lt__ = float.__lt__\n    __mod__ = wrap_method(float.__mod__)\n    __mul__ = wrap_method(float.__mul__)\n    __neg__ = wrap_method(float.__neg__)\n    __pos__ = wrap_method(float.__pos__)\n    __pow__ = wrap_method(float.__pow__)\n    __radd__ = wrap_method(float.__radd__)\n    __rfloordiv__ = wrap_method(float.__rfloordiv__)\n    __rmod__ = wrap_method(float.__rmod__)\n    __rmul__ = wrap_method(float.__rmul__)\n    __round__ = wrap_method(float.__round__)\n    __rpow__ = wrap_method(float.__rpow__)\n    __rtruediv__ = wrap_method(float.__rtruediv__)\n    __truediv__ = wrap_method(float.__truediv__)\n    __trunc__ = float.__trunc__\n\n    if sys.version_info >= (3, 9):\n        __ceil__ = float.__ceil__\n        __floor__ = float.__floor__\n    else:\n        __ceil__ = math.ceil\n        __floor__ = math.floor\n\n\nclass Bool(Item):\n    \"\"\"\n    A boolean literal.\n    \"\"\"\n\n    def __init__(self, t: int, trivia: Trivia) -> None:\n        super().__init__(trivia)\n\n        self._value = bool(t)\n\n    def unwrap(self) -> bool:\n        return bool(self)\n\n    @property\n    def discriminant(self) -> int:\n        return 4\n\n    @property\n    def value(self) -> bool:\n        \"\"\"The wrapped boolean value\"\"\"\n        return self._value\n\n    def as_string(self) -> str:\n        return str(self._value).lower()\n\n    def _getstate(self, protocol=3):\n        return self._value, self._trivia\n\n    def __bool__(self):\n        return self._value\n\n    __nonzero__ = __bool__\n\n    def __eq__(self, other):\n        if not isinstance(other, bool):\n            return NotImplemented\n\n        return other == self._value\n\n    def __hash__(self):\n        return hash(self._value)\n\n    def __repr__(self):\n        return repr(self._value)\n\n\nclass DateTime(Item, datetime):\n    \"\"\"\n    A datetime literal.\n    \"\"\"\n\n    def __new__(\n        cls,\n        year: int,\n        month: int,\n        day: int,\n        hour: int,\n        minute: int,\n        second: int,\n        microsecond: int,\n        tzinfo: tzinfo | None,\n        *_: Any,\n        **kwargs: Any,\n    ) -> datetime:\n        return datetime.__new__(\n            cls,\n            year,\n            month,\n            day,\n            hour,\n            minute,\n            second,\n            microsecond,\n            tzinfo=tzinfo,\n            **kwargs,\n        )\n\n    def __init__(\n        self,\n        year: int,\n        month: int,\n        day: int,\n        hour: int,\n        minute: int,\n        second: int,\n        microsecond: int,\n        tzinfo: tzinfo | None,\n        trivia: Trivia | None = None,\n        raw: str | None = None,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(trivia or Trivia())\n\n        self._raw = raw or self.isoformat()\n\n    def unwrap(self) -> datetime:\n        (\n            year,\n            month,\n            day,\n            hour,\n            minute,\n            second,\n            microsecond,\n            tzinfo,\n            _,\n            _,\n        ) = self._getstate()\n        return datetime(year, month, day, hour, minute, second, microsecond, tzinfo)\n\n    @property\n    def discriminant(self) -> int:\n        return 5\n\n    @property\n    def value(self) -> datetime:\n        return self\n\n    def as_string(self) -> str:\n        return self._raw\n\n    def __add__(self, other):\n        if PY38:\n            result = datetime(\n                self.year,\n                self.month,\n                self.day,\n                self.hour,\n                self.minute,\n                self.second,\n                self.microsecond,\n                self.tzinfo,\n            ).__add__(other)\n        else:\n            result = super().__add__(other)\n\n        return self._new(result)\n\n    def __sub__(self, other):\n        if PY38:\n            result = datetime(\n                self.year,\n                self.month,\n                self.day,\n                self.hour,\n                self.minute,\n                self.second,\n                self.microsecond,\n                self.tzinfo,\n            ).__sub__(other)\n        else:\n            result = super().__sub__(other)\n\n        if isinstance(result, datetime):\n            result = self._new(result)\n\n        return result\n\n    def replace(self, *args: Any, **kwargs: Any) -> datetime:\n        return self._new(super().replace(*args, **kwargs))\n\n    def astimezone(self, tz: tzinfo) -> datetime:\n        result = super().astimezone(tz)\n        if PY38:\n            return result\n        return self._new(result)\n\n    def _new(self, result) -> DateTime:\n        raw = result.isoformat()\n\n        return DateTime(\n            result.year,\n            result.month,\n            result.day,\n            result.hour,\n            result.minute,\n            result.second,\n            result.microsecond,\n            result.tzinfo,\n            self._trivia,\n            raw,\n        )\n\n    def _getstate(self, protocol=3):\n        return (\n            self.year,\n            self.month,\n            self.day,\n            self.hour,\n            self.minute,\n            self.second,\n            self.microsecond,\n            self.tzinfo,\n            self._trivia,\n            self._raw,\n        )\n\n\nclass Date(Item, date):\n    \"\"\"\n    A date literal.\n    \"\"\"\n\n    def __new__(cls, year: int, month: int, day: int, *_: Any) -> date:\n        return date.__new__(cls, year, month, day)\n\n    def __init__(\n        self,\n        year: int,\n        month: int,\n        day: int,\n        trivia: Trivia | None = None,\n        raw: str = \"\",\n    ) -> None:\n        super().__init__(trivia or Trivia())\n\n        self._raw = raw\n\n    def unwrap(self) -> date:\n        (year, month, day, _, _) = self._getstate()\n        return date(year, month, day)\n\n    @property\n    def discriminant(self) -> int:\n        return 6\n\n    @property\n    def value(self) -> date:\n        return self\n\n    def as_string(self) -> str:\n        return self._raw\n\n    def __add__(self, other):\n        if PY38:\n            result = date(self.year, self.month, self.day).__add__(other)\n        else:\n            result = super().__add__(other)\n\n        return self._new(result)\n\n    def __sub__(self, other):\n        if PY38:\n            result = date(self.year, self.month, self.day).__sub__(other)\n        else:\n            result = super().__sub__(other)\n\n        if isinstance(result, date):\n            result = self._new(result)\n\n        return result\n\n    def replace(self, *args: Any, **kwargs: Any) -> date:\n        return self._new(super().replace(*args, **kwargs))\n\n    def _new(self, result):\n        raw = result.isoformat()\n\n        return Date(result.year, result.month, result.day, self._trivia, raw)\n\n    def _getstate(self, protocol=3):\n        return (self.year, self.month, self.day, self._trivia, self._raw)\n\n\nclass Time(Item, time):\n    \"\"\"\n    A time literal.\n    \"\"\"\n\n    def __new__(\n        cls,\n        hour: int,\n        minute: int,\n        second: int,\n        microsecond: int,\n        tzinfo: tzinfo | None,\n        *_: Any,\n    ) -> time:\n        return time.__new__(cls, hour, minute, second, microsecond, tzinfo)\n\n    def __init__(\n        self,\n        hour: int,\n        minute: int,\n        second: int,\n        microsecond: int,\n        tzinfo: tzinfo | None,\n        trivia: Trivia | None = None,\n        raw: str = \"\",\n    ) -> None:\n        super().__init__(trivia or Trivia())\n\n        self._raw = raw\n\n    def unwrap(self) -> time:\n        (hour, minute, second, microsecond, tzinfo, _, _) = self._getstate()\n        return time(hour, minute, second, microsecond, tzinfo)\n\n    @property\n    def discriminant(self) -> int:\n        return 7\n\n    @property\n    def value(self) -> time:\n        return self\n\n    def as_string(self) -> str:\n        return self._raw\n\n    def replace(self, *args: Any, **kwargs: Any) -> time:\n        return self._new(super().replace(*args, **kwargs))\n\n    def _new(self, result):\n        raw = result.isoformat()\n\n        return Time(\n            result.hour,\n            result.minute,\n            result.second,\n            result.microsecond,\n            result.tzinfo,\n            self._trivia,\n            raw,\n        )\n\n    def _getstate(self, protocol: int = 3) -> tuple:\n        return (\n            self.hour,\n            self.minute,\n            self.second,\n            self.microsecond,\n            self.tzinfo,\n            self._trivia,\n            self._raw,\n        )\n\n\nclass _ArrayItemGroup:\n    __slots__ = (\"value\", \"indent\", \"comma\", \"comment\")\n\n    def __init__(\n        self,\n        value: Item | None = None,\n        indent: Whitespace | None = None,\n        comma: Whitespace | None = None,\n        comment: Comment | None = None,\n    ) -> None:\n        self.value = value\n        self.indent = indent\n        self.comma = comma\n        self.comment = comment\n\n    def __iter__(self) -> Iterator[Item]:\n        return filter(\n            lambda x: x is not None, (self.indent, self.value, self.comma, self.comment)\n        )\n\n    def __repr__(self) -> str:\n        return repr(tuple(self))\n\n    def is_whitespace(self) -> bool:\n        return self.value is None and self.comment is None\n\n    def __bool__(self) -> bool:\n        try:\n            next(iter(self))\n        except StopIteration:\n            return False\n        return True\n\n\nclass Array(Item, _CustomList):\n    \"\"\"\n    An array literal\n    \"\"\"\n\n    def __init__(\n        self, value: list[Item], trivia: Trivia, multiline: bool = False\n    ) -> None:\n        super().__init__(trivia)\n        list.__init__(\n            self,\n            [v for v in value if not isinstance(v, (Whitespace, Comment, Null))],\n        )\n        self._index_map: dict[int, int] = {}\n        self._value = self._group_values(value)\n        self._multiline = multiline\n        self._reindex()\n\n    def _group_values(self, value: list[Item]) -> list[_ArrayItemGroup]:\n        \"\"\"Group the values into (indent, value, comma, comment) tuples\"\"\"\n        groups = []\n        this_group = _ArrayItemGroup()\n        for item in value:\n            if isinstance(item, Whitespace):\n                if \",\" not in item.s:\n                    groups.append(this_group)\n                    this_group = _ArrayItemGroup(indent=item)\n                else:\n                    if this_group.value is None:\n                        # when comma is met and no value is provided, add a dummy Null\n                        this_group.value = Null()\n                    this_group.comma = item\n            elif isinstance(item, Comment):\n                if this_group.value is None:\n                    this_group.value = Null()\n                this_group.comment = item\n            elif this_group.value is None:\n                this_group.value = item\n            else:\n                groups.append(this_group)\n                this_group = _ArrayItemGroup(value=item)\n        groups.append(this_group)\n        return [group for group in groups if group]\n\n    def unwrap(self) -> list[Any]:\n        unwrapped = []\n        for v in self:\n            if hasattr(v, \"unwrap\"):\n                unwrapped.append(v.unwrap())\n            else:\n                unwrapped.append(v)\n        return unwrapped\n\n    @property\n    def discriminant(self) -> int:\n        return 8\n\n    @property\n    def value(self) -> list:\n        return self\n\n    def _iter_items(self) -> Iterator[Item]:\n        for v in self._value:\n            yield from v\n\n    def multiline(self, multiline: bool) -> Array:\n        \"\"\"Change the array to display in multiline or not.\n\n        :Example:\n\n        >>> a = item([1, 2, 3])\n        >>> print(a.as_string())\n        [1, 2, 3]\n        >>> print(a.multiline(True).as_string())\n        [\n            1,\n            2,\n            3,\n        ]\n        \"\"\"\n        self._multiline = multiline\n\n        return self\n\n    def as_string(self) -> str:\n        if not self._multiline or not self._value:\n            return f'[{\"\".join(v.as_string() for v in self._iter_items())}]'\n\n        s = \"[\\n\"\n        s += \"\".join(\n            self.trivia.indent\n            + \" \" * 4\n            + v.value.as_string()\n            + (\",\" if not isinstance(v.value, Null) else \"\")\n            + (v.comment.as_string() if v.comment is not None else \"\")\n            + \"\\n\"\n            for v in self._value\n            if v.value is not None\n        )\n        s += self.trivia.indent + \"]\"\n\n        return s\n\n    def _reindex(self) -> None:\n        self._index_map.clear()\n        index = 0\n        for i, v in enumerate(self._value):\n            if v.value is None or isinstance(v.value, Null):\n                continue\n            self._index_map[index] = i\n            index += 1\n\n    def add_line(\n        self,\n        *items: Any,\n        indent: str = \"    \",\n        comment: str | None = None,\n        add_comma: bool = True,\n        newline: bool = True,\n    ) -> None:\n        \"\"\"Add multiple items in a line to control the format precisely.\n        When add_comma is True, only accept actual values and\n        \", \" will be added between values automatically.\n\n        :Example:\n\n        >>> a = array()\n        >>> a.add_line(1, 2, 3)\n        >>> a.add_line(4, 5, 6)\n        >>> a.add_line(indent=\"\")\n        >>> print(a.as_string())\n        [\n            1, 2, 3,\n            4, 5, 6,\n        ]\n        \"\"\"\n        new_values: list[Item] = []\n        first_indent = f\"\\n{indent}\" if newline else indent\n        if first_indent:\n            new_values.append(Whitespace(first_indent))\n        whitespace = \"\"\n        data_values = []\n        for i, el in enumerate(items):\n            it = item(el, _parent=self)\n            if isinstance(it, Comment) or add_comma and isinstance(el, Whitespace):\n                raise ValueError(f\"item type {type(it)} is not allowed in add_line\")\n            if not isinstance(it, Whitespace):\n                if whitespace:\n                    new_values.append(Whitespace(whitespace))\n                    whitespace = \"\"\n                new_values.append(it)\n                data_values.append(it.value)\n                if add_comma:\n                    new_values.append(Whitespace(\",\"))\n                    if i != len(items) - 1:\n                        new_values.append(Whitespace(\" \"))\n            elif \",\" not in it.s:\n                whitespace += it.s\n            else:\n                new_values.append(it)\n        if whitespace:\n            new_values.append(Whitespace(whitespace))\n        if comment:\n            indent = \" \" if items else \"\"\n            new_values.append(\n                Comment(Trivia(indent=indent, comment=f\"# {comment}\", trail=\"\"))\n            )\n        list.extend(self, data_values)\n        if len(self._value) > 0:\n            last_item = self._value[-1]\n            last_value_item = next(\n                (\n                    v\n                    for v in self._value[::-1]\n                    if v.value is not None and not isinstance(v.value, Null)\n                ),\n                None,\n            )\n            if last_value_item is not None:\n                last_value_item.comma = Whitespace(\",\")\n            if last_item.is_whitespace():\n                self._value[-1:-1] = self._group_values(new_values)\n            else:\n                self._value.extend(self._group_values(new_values))\n        else:\n            self._value.extend(self._group_values(new_values))\n        self._reindex()\n\n    def clear(self) -> None:\n        \"\"\"Clear the array.\"\"\"\n        list.clear(self)\n        self._index_map.clear()\n        self._value.clear()\n\n    def __len__(self) -> int:\n        return list.__len__(self)\n\n    def __getitem__(self, key: int | slice) -> Any:\n        rv = cast(Item, list.__getitem__(self, key))\n        if rv.is_boolean():\n            return bool(rv)\n        return rv\n\n    def __setitem__(self, key: int | slice, value: Any) -> Any:\n        it = item(value, _parent=self)\n        list.__setitem__(self, key, it)\n        if isinstance(key, slice):\n            raise ValueError(\"slice assignment is not supported\")\n        if key < 0:\n            key += len(self)\n        self._value[self._index_map[key]].value = it\n\n    def insert(self, pos: int, value: Any) -> None:\n        it = item(value, _parent=self)\n        length = len(self)\n        if not isinstance(it, (Comment, Whitespace)):\n            list.insert(self, pos, it)\n        if pos < 0:\n            pos += length\n            if pos < 0:\n                pos = 0\n\n        idx = 0  # insert position of the self._value list\n        default_indent = \" \"\n        if pos < length:\n            try:\n                idx = self._index_map[pos]\n            except KeyError as e:\n                raise IndexError(\"list index out of range\") from e\n        else:\n            idx = len(self._value)\n            if idx >= 1 and self._value[idx - 1].is_whitespace():\n                # The last item is a pure whitespace(\\n ), insert before it\n                idx -= 1\n                if (\n                    self._value[idx].indent is not None\n                    and \"\\n\" in self._value[idx].indent.s\n                ):\n                    default_indent = \"\\n    \"\n        indent: Item | None = None\n        comma: Item | None = Whitespace(\",\") if pos < length else None\n        if idx < len(self._value) and not self._value[idx].is_whitespace():\n            # Prefer to copy the indentation from the item after\n            indent = self._value[idx].indent\n        if idx > 0:\n            last_item = self._value[idx - 1]\n            if indent is None:\n                indent = last_item.indent\n            if not isinstance(last_item.value, Null) and \"\\n\" in default_indent:\n                # Copy the comma from the last item if 1) it contains a value and\n                # 2) the array is multiline\n                comma = last_item.comma\n            if last_item.comma is None and not isinstance(last_item.value, Null):\n                # Add comma to the last item to separate it from the following items.\n                last_item.comma = Whitespace(\",\")\n        if indent is None and (idx > 0 or \"\\n\" in default_indent):\n            # apply default indent if it isn't the first item or the array is multiline.\n            indent = Whitespace(default_indent)\n        new_item = _ArrayItemGroup(value=it, indent=indent, comma=comma)\n        self._value.insert(idx, new_item)\n        self._reindex()\n\n    def __delitem__(self, key: int | slice):\n        length = len(self)\n        list.__delitem__(self, key)\n\n        if isinstance(key, slice):\n            indices_to_remove = list(\n                range(key.start or 0, key.stop or length, key.step or 1)\n            )\n        else:\n            indices_to_remove = [length + key if key < 0 else key]\n        for i in sorted(indices_to_remove, reverse=True):\n            try:\n                idx = self._index_map[i]\n            except KeyError as e:\n                if not isinstance(key, slice):\n                    raise IndexError(\"list index out of range\") from e\n            else:\n                del self._value[idx]\n                if (\n                    idx == 0\n                    and len(self._value) > 0\n                    and self._value[idx].indent\n                    and \"\\n\" not in self._value[idx].indent.s\n                ):\n                    # Remove the indentation of the first item if not newline\n                    self._value[idx].indent = None\n        if len(self._value) > 0:\n            v = self._value[-1]\n            if not v.is_whitespace():\n                # remove the comma of the last item\n                v.comma = None\n\n        self._reindex()\n\n    def _getstate(self, protocol=3):\n        return list(self._iter_items()), self._trivia, self._multiline\n\n\nclass AbstractTable(Item, _CustomDict):\n    \"\"\"Common behaviour of both :class:`Table` and :class:`InlineTable`\"\"\"\n\n    def __init__(self, value: container.Container, trivia: Trivia):\n        Item.__init__(self, trivia)\n\n        self._value = value\n\n        for k, v in self._value.body:\n            if k is not None:\n                dict.__setitem__(self, k.key, v)\n\n    def unwrap(self) -> dict[str, Any]:\n        unwrapped = {}\n        for k, v in self.items():\n            if isinstance(k, Key):\n                k = k.key\n            if hasattr(v, \"unwrap\"):\n                v = v.unwrap()\n            unwrapped[k] = v\n\n        return unwrapped\n\n    @property\n    def value(self) -> container.Container:\n        return self._value\n\n    @overload\n    def append(self: AT, key: None, value: Comment | Whitespace) -> AT: ...\n\n    @overload\n    def append(self: AT, key: Key | str, value: Any) -> AT: ...\n\n    def append(self, key, value):\n        raise NotImplementedError\n\n    @overload\n    def add(self: AT, key: Comment | Whitespace) -> AT: ...\n\n    @overload\n    def add(self: AT, key: Key | str, value: Any = ...) -> AT: ...\n\n    def add(self, key, value=None):\n        if value is None:\n            if not isinstance(key, (Comment, Whitespace)):\n                msg = \"Non comment/whitespace items must have an associated key\"\n                raise ValueError(msg)\n\n            key, value = None, key\n\n        return self.append(key, value)\n\n    def remove(self: AT, key: Key | str) -> AT:\n        self._value.remove(key)\n\n        if isinstance(key, Key):\n            key = key.key\n\n        if key is not None:\n            dict.__delitem__(self, key)\n\n        return self\n\n    def setdefault(self, key: Key | str, default: Any) -> Any:\n        super().setdefault(key, default)\n        return self[key]\n\n    def __str__(self):\n        return str(self.value)\n\n    def copy(self: AT) -> AT:\n        return copy.copy(self)\n\n    def __repr__(self) -> str:\n        return repr(self.value)\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(self._value)\n\n    def __len__(self) -> int:\n        return len(self._value)\n\n    def __delitem__(self, key: Key | str) -> None:\n        self.remove(key)\n\n    def __getitem__(self, key: Key | str) -> Item:\n        return cast(Item, self._value[key])\n\n    def __setitem__(self, key: Key | str, value: Any) -> None:\n        if not isinstance(value, Item):\n            value = item(value, _parent=self)\n\n        is_replace = key in self\n        self._value[key] = value\n\n        if key is not None:\n            dict.__setitem__(self, key, value)\n\n        if is_replace:\n            return\n        m = re.match(\"(?s)^[^ ]*([ ]+).*$\", self._trivia.indent)\n        if not m:\n            return\n\n        indent = m.group(1)\n\n        if not isinstance(value, Whitespace):\n            m = re.match(\"(?s)^([^ ]*)(.*)$\", value.trivia.indent)\n            if not m:\n                value.trivia.indent = indent\n            else:\n                value.trivia.indent = m.group(1) + indent + m.group(2)\n\n\nclass Table(AbstractTable):\n    \"\"\"\n    A table literal.\n    \"\"\"\n\n    def __init__(\n        self,\n        value: container.Container,\n        trivia: Trivia,\n        is_aot_element: bool,\n        is_super_table: bool | None = None,\n        name: str | None = None,\n        display_name: str | None = None,\n    ) -> None:\n        super().__init__(value, trivia)\n\n        self.name = name\n        self.display_name = display_name\n        self._is_aot_element = is_aot_element\n        self._is_super_table = is_super_table\n\n    @property\n    def discriminant(self) -> int:\n        return 9\n\n    def __copy__(self) -> Table:\n        return type(self)(\n            self._value.copy(),\n            self._trivia.copy(),\n            self._is_aot_element,\n            self._is_super_table,\n            self.name,\n            self.display_name,\n        )\n\n    def append(self, key: Key | str | None, _item: Any) -> Table:\n        \"\"\"\n        Appends a (key, item) to the table.\n        \"\"\"\n        if not isinstance(_item, Item):\n            _item = item(_item, _parent=self)\n\n        self._value.append(key, _item)\n\n        if isinstance(key, Key):\n            key = next(iter(key)).key\n            _item = self._value[key]\n\n        if key is not None:\n            dict.__setitem__(self, key, _item)\n\n        m = re.match(r\"(?s)^[^ ]*([ ]+).*$\", self._trivia.indent)\n        if not m:\n            return self\n\n        indent = m.group(1)\n\n        if not isinstance(_item, Whitespace):\n            m = re.match(\"(?s)^([^ ]*)(.*)$\", _item.trivia.indent)\n            if not m:\n                _item.trivia.indent = indent\n            else:\n                _item.trivia.indent = m.group(1) + indent + m.group(2)\n\n        return self\n\n    def raw_append(self, key: Key | str | None, _item: Any) -> Table:\n        \"\"\"Similar to :meth:`append` but does not copy indentation.\"\"\"\n        if not isinstance(_item, Item):\n            _item = item(_item)\n\n        self._value.append(key, _item, validate=False)\n\n        if isinstance(key, Key):\n            key = next(iter(key)).key\n            _item = self._value[key]\n\n        if key is not None:\n            dict.__setitem__(self, key, _item)\n\n        return self\n\n    def is_aot_element(self) -> bool:\n        \"\"\"True if the table is the direct child of an AOT element.\"\"\"\n        return self._is_aot_element\n\n    def is_super_table(self) -> bool:\n        \"\"\"A super table is the intermediate parent of a nested table as in [a.b.c].\n        If true, it won't appear in the TOML representation.\"\"\"\n        if self._is_super_table is not None:\n            return self._is_super_table\n        # If the table has only one child and that child is a table, then it is a super table.\n        if len(self) != 1:\n            return False\n        only_child = next(iter(self.values()))\n        return isinstance(only_child, (Table, AoT))\n\n    def as_string(self) -> str:\n        return self._value.as_string()\n\n    # Helpers\n\n    def indent(self, indent: int) -> Table:\n        \"\"\"Indent the table with given number of spaces.\"\"\"\n        super().indent(indent)\n\n        m = re.match(\"(?s)^[^ ]*([ ]+).*$\", self._trivia.indent)\n        if not m:\n            indent_str = \"\"\n        else:\n            indent_str = m.group(1)\n\n        for _, item in self._value.body:\n            if not isinstance(item, Whitespace):\n                item.trivia.indent = indent_str + item.trivia.indent\n\n        return self\n\n    def invalidate_display_name(self):\n        \"\"\"Call ``invalidate_display_name`` on the contained tables\"\"\"\n        self.display_name = None\n\n        for child in self.values():\n            if hasattr(child, \"invalidate_display_name\"):\n                child.invalidate_display_name()\n\n    def _getstate(self, protocol: int = 3) -> tuple:\n        return (\n            self._value,\n            self._trivia,\n            self._is_aot_element,\n            self._is_super_table,\n            self.name,\n            self.display_name,\n        )\n\n\nclass InlineTable(AbstractTable):\n    \"\"\"\n    An inline table literal.\n    \"\"\"\n\n    def __init__(\n        self, value: container.Container, trivia: Trivia, new: bool = False\n    ) -> None:\n        super().__init__(value, trivia)\n\n        self._new = new\n\n    @property\n    def discriminant(self) -> int:\n        return 10\n\n    def append(self, key: Key | str | None, _item: Any) -> InlineTable:\n        \"\"\"\n        Appends a (key, item) to the table.\n        \"\"\"\n        if not isinstance(_item, Item):\n            _item = item(_item, _parent=self)\n\n        if not isinstance(_item, (Whitespace, Comment)):\n            if not _item.trivia.indent and len(self._value) > 0 and not self._new:\n                _item.trivia.indent = \" \"\n            if _item.trivia.comment:\n                _item.trivia.comment = \"\"\n\n        self._value.append(key, _item)\n\n        if isinstance(key, Key):\n            key = key.key\n\n        if key is not None:\n            dict.__setitem__(self, key, _item)\n\n        return self\n\n    def as_string(self) -> str:\n        buf = \"{\"\n        last_item_idx = next(\n            (\n                i\n                for i in range(len(self._value.body) - 1, -1, -1)\n                if self._value.body[i][0] is not None\n            ),\n            None,\n        )\n        for i, (k, v) in enumerate(self._value.body):\n            if k is None:\n                if i == len(self._value.body) - 1:\n                    if self._new:\n                        buf = buf.rstrip(\", \")\n                    else:\n                        buf = buf.rstrip(\",\")\n\n                buf += v.as_string()\n\n                continue\n\n            v_trivia_trail = v.trivia.trail.replace(\"\\n\", \"\")\n            buf += (\n                f\"{v.trivia.indent}\"\n                f'{k.as_string() + (\".\" if k.is_dotted() else \"\")}'\n                f\"{k.sep}\"\n                f\"{v.as_string()}\"\n                f\"{v.trivia.comment}\"\n                f\"{v_trivia_trail}\"\n            )\n\n            if last_item_idx is not None and i < last_item_idx:\n                buf += \",\"\n                if self._new:\n                    buf += \" \"\n\n        buf += \"}\"\n\n        return buf\n\n    def __setitem__(self, key: Key | str, value: Any) -> None:\n        if hasattr(value, \"trivia\") and value.trivia.comment:\n            value.trivia.comment = \"\"\n        super().__setitem__(key, value)\n\n    def __copy__(self) -> InlineTable:\n        return type(self)(self._value.copy(), self._trivia.copy(), self._new)\n\n    def _getstate(self, protocol: int = 3) -> tuple:\n        return (self._value, self._trivia)\n\n\nclass String(str, Item):\n    \"\"\"\n    A string literal.\n    \"\"\"\n\n    def __new__(cls, t, value, original, trivia):\n        return super().__new__(cls, value)\n\n    def __init__(self, t: StringType, _: str, original: str, trivia: Trivia) -> None:\n        super().__init__(trivia)\n\n        self._t = t\n        self._original = original\n\n    def unwrap(self) -> str:\n        return str(self)\n\n    @property\n    def discriminant(self) -> int:\n        return 11\n\n    @property\n    def value(self) -> str:\n        return self\n\n    def as_string(self) -> str:\n        return f\"{self._t.value}{decode(self._original)}{self._t.value}\"\n\n    def __add__(self: ItemT, other: str) -> ItemT:\n        if not isinstance(other, str):\n            return NotImplemented\n        result = super().__add__(other)\n        original = self._original + getattr(other, \"_original\", other)\n\n        return self._new(result, original)\n\n    def _new(self, result: str, original: str) -> String:\n        return String(self._t, result, original, self._trivia)\n\n    def _getstate(self, protocol=3):\n        return self._t, str(self), self._original, self._trivia\n\n    @classmethod\n    def from_raw(cls, value: str, type_=StringType.SLB, escape=True) -> String:\n        value = decode(value)\n\n        invalid = type_.invalid_sequences\n        if any(c in value for c in invalid):\n            raise InvalidStringError(value, invalid, type_.value)\n\n        escaped = type_.escaped_sequences\n        string_value = escape_string(value, escaped) if escape and escaped else value\n\n        return cls(type_, decode(value), string_value, Trivia())\n\n\nclass AoT(Item, _CustomList):\n    \"\"\"\n    An array of table literal\n    \"\"\"\n\n    def __init__(\n        self, body: list[Table], name: str | None = None, parsed: bool = False\n    ) -> None:\n        self.name = name\n        self._body: list[Table] = []\n        self._parsed = parsed\n\n        super().__init__(Trivia(trail=\"\"))\n\n        for table in body:\n            self.append(table)\n\n    def unwrap(self) -> list[dict[str, Any]]:\n        unwrapped = []\n        for t in self._body:\n            if hasattr(t, \"unwrap\"):\n                unwrapped.append(t.unwrap())\n            else:\n                unwrapped.append(t)\n        return unwrapped\n\n    @property\n    def body(self) -> list[Table]:\n        return self._body\n\n    @property\n    def discriminant(self) -> int:\n        return 12\n\n    @property\n    def value(self) -> list[dict[Any, Any]]:\n        return [v.value for v in self._body]\n\n    def __len__(self) -> int:\n        return len(self._body)\n\n    @overload\n    def __getitem__(self, key: slice) -> list[Table]: ...\n\n    @overload\n    def __getitem__(self, key: int) -> Table: ...\n\n    def __getitem__(self, key):\n        return self._body[key]\n\n    def __setitem__(self, key: slice | int, value: Any) -> None:\n        raise NotImplementedError\n\n    def __delitem__(self, key: slice | int) -> None:\n        del self._body[key]\n        list.__delitem__(self, key)\n\n    def insert(self, index: int, value: dict) -> None:\n        value = item(value, _parent=self)\n        if not isinstance(value, Table):\n            raise ValueError(f\"Unsupported insert value type: {type(value)}\")\n        length = len(self)\n        if index < 0:\n            index += length\n        if index < 0:\n            index = 0\n        elif index >= length:\n            index = length\n        m = re.match(\"(?s)^[^ ]*([ ]+).*$\", self._trivia.indent)\n        if m:\n            indent = m.group(1)\n\n            m = re.match(\"(?s)^([^ ]*)(.*)$\", value.trivia.indent)\n            if not m:\n                value.trivia.indent = indent\n            else:\n                value.trivia.indent = m.group(1) + indent + m.group(2)\n        prev_table = self._body[index - 1] if 0 < index and length else None\n        next_table = self._body[index + 1] if index < length - 1 else None\n        if not self._parsed:\n            if prev_table and \"\\n\" not in value.trivia.indent:\n                value.trivia.indent = \"\\n\" + value.trivia.indent\n            if next_table and \"\\n\" not in next_table.trivia.indent:\n                next_table.trivia.indent = \"\\n\" + next_table.trivia.indent\n        self._body.insert(index, value)\n        list.insert(self, index, value)\n\n    def invalidate_display_name(self):\n        \"\"\"Call ``invalidate_display_name`` on the contained tables\"\"\"\n        for child in self:\n            if hasattr(child, \"invalidate_display_name\"):\n                child.invalidate_display_name()\n\n    def as_string(self) -> str:\n        b = \"\"\n        for table in self._body:\n            b += table.as_string()\n\n        return b\n\n    def __repr__(self) -> str:\n        return f\"<AoT {self.value}>\"\n\n    def _getstate(self, protocol=3):\n        return self._body, self.name, self._parsed\n\n\nclass Null(Item):\n    \"\"\"\n    A null item.\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(Trivia(trail=\"\"))\n\n    def unwrap(self) -> None:\n        return None\n\n    @property\n    def discriminant(self) -> int:\n        return -1\n\n    @property\n    def value(self) -> None:\n        return None\n\n    def as_string(self) -> str:\n        return \"\"\n\n    def _getstate(self, protocol=3) -> tuple:\n        return ()\n", "tomlkit/api.py": "from __future__ import annotations\n\nimport contextlib\nimport datetime as _datetime\n\nfrom collections.abc import Mapping\nfrom typing import IO\nfrom typing import Iterable\nfrom typing import TypeVar\n\nfrom tomlkit._utils import parse_rfc3339\nfrom tomlkit.container import Container\nfrom tomlkit.exceptions import UnexpectedCharError\nfrom tomlkit.items import CUSTOM_ENCODERS\nfrom tomlkit.items import AoT\nfrom tomlkit.items import Array\nfrom tomlkit.items import Bool\nfrom tomlkit.items import Comment\nfrom tomlkit.items import Date\nfrom tomlkit.items import DateTime\nfrom tomlkit.items import DottedKey\nfrom tomlkit.items import Encoder\nfrom tomlkit.items import Float\nfrom tomlkit.items import InlineTable\nfrom tomlkit.items import Integer\nfrom tomlkit.items import Item as _Item\nfrom tomlkit.items import Key\nfrom tomlkit.items import SingleKey\nfrom tomlkit.items import String\nfrom tomlkit.items import StringType as _StringType\nfrom tomlkit.items import Table\nfrom tomlkit.items import Time\nfrom tomlkit.items import Trivia\nfrom tomlkit.items import Whitespace\nfrom tomlkit.items import item\nfrom tomlkit.parser import Parser\nfrom tomlkit.toml_document import TOMLDocument\n\n\ndef loads(string: str | bytes) -> TOMLDocument:\n    \"\"\"\n    Parses a string into a TOMLDocument.\n\n    Alias for parse().\n    \"\"\"\n    return parse(string)\n\n\ndef dumps(data: Mapping, sort_keys: bool = False) -> str:\n    \"\"\"\n    Dumps a TOMLDocument into a string.\n    \"\"\"\n    if not isinstance(data, Container) and isinstance(data, Mapping):\n        data = item(dict(data), _sort_keys=sort_keys)\n\n    try:\n        # data should be a `Container` (and therefore implement `as_string`)\n        # for all type safe invocations of this function\n        return data.as_string()  # type: ignore[attr-defined]\n    except AttributeError as ex:\n        msg = f\"Expecting Mapping or TOML Container, {type(data)} given\"\n        raise TypeError(msg) from ex\n\n\ndef load(fp: IO[str] | IO[bytes]) -> TOMLDocument:\n    \"\"\"\n    Load toml document from a file-like object.\n    \"\"\"\n    return parse(fp.read())\n\n\ndef dump(data: Mapping, fp: IO[str], *, sort_keys: bool = False) -> None:\n    \"\"\"\n    Dump a TOMLDocument into a writable file stream.\n\n    :param data: a dict-like object to dump\n    :param sort_keys: if true, sort the keys in alphabetic order\n    \"\"\"\n    fp.write(dumps(data, sort_keys=sort_keys))\n\n\ndef parse(string: str | bytes) -> TOMLDocument:\n    \"\"\"\n    Parses a string or bytes into a TOMLDocument.\n    \"\"\"\n    return Parser(string).parse()\n\n\ndef document() -> TOMLDocument:\n    \"\"\"\n    Returns a new TOMLDocument instance.\n    \"\"\"\n    return TOMLDocument()\n\n\n# Items\ndef integer(raw: str | int) -> Integer:\n    \"\"\"Create an integer item from a number or string.\"\"\"\n    return item(int(raw))\n\n\ndef float_(raw: str | float) -> Float:\n    \"\"\"Create an float item from a number or string.\"\"\"\n    return item(float(raw))\n\n\ndef boolean(raw: str) -> Bool:\n    \"\"\"Turn `true` or `false` into a boolean item.\"\"\"\n    return item(raw == \"true\")\n\n\ndef string(\n    raw: str,\n    *,\n    literal: bool = False,\n    multiline: bool = False,\n    escape: bool = True,\n) -> String:\n    \"\"\"Create a string item.\n\n    By default, this function will create *single line basic* strings, but\n    boolean flags (e.g. ``literal=True`` and/or ``multiline=True``)\n    can be used for personalization.\n\n    For more information, please check the spec: `<https://toml.io/en/v1.0.0#string>`__.\n\n    Common escaping rules will be applied for basic strings.\n    This can be controlled by explicitly setting ``escape=False``.\n    Please note that, if you disable escaping, you will have to make sure that\n    the given strings don't contain any forbidden character or sequence.\n    \"\"\"\n    type_ = _StringType.select(literal, multiline)\n    return String.from_raw(raw, type_, escape)\n\n\ndef date(raw: str) -> Date:\n    \"\"\"Create a TOML date.\"\"\"\n    value = parse_rfc3339(raw)\n    if not isinstance(value, _datetime.date):\n        raise ValueError(\"date() only accepts date strings.\")\n\n    return item(value)\n\n\ndef time(raw: str) -> Time:\n    \"\"\"Create a TOML time.\"\"\"\n    value = parse_rfc3339(raw)\n    if not isinstance(value, _datetime.time):\n        raise ValueError(\"time() only accepts time strings.\")\n\n    return item(value)\n\n\ndef datetime(raw: str) -> DateTime:\n    \"\"\"Create a TOML datetime.\"\"\"\n    value = parse_rfc3339(raw)\n    if not isinstance(value, _datetime.datetime):\n        raise ValueError(\"datetime() only accepts datetime strings.\")\n\n    return item(value)\n\n\ndef array(raw: str = \"[]\") -> Array:\n    \"\"\"Create an array item for its string representation.\n\n    :Example:\n\n    >>> array(\"[1, 2, 3]\")  # Create from a string\n    [1, 2, 3]\n    >>> a = array()\n    >>> a.extend([1, 2, 3])  # Create from a list\n    >>> a\n    [1, 2, 3]\n    \"\"\"\n    return value(raw)\n\n\ndef table(is_super_table: bool | None = None) -> Table:\n    \"\"\"Create an empty table.\n\n    :param is_super_table: if true, the table is a super table\n\n    :Example:\n\n    >>> doc = document()\n    >>> foo = table(True)\n    >>> bar = table()\n    >>> bar.update({'x': 1})\n    >>> foo.append('bar', bar)\n    >>> doc.append('foo', foo)\n    >>> print(doc.as_string())\n    [foo.bar]\n    x = 1\n    \"\"\"\n    return Table(Container(), Trivia(), False, is_super_table)\n\n\ndef inline_table() -> InlineTable:\n    \"\"\"Create an inline table.\n\n    :Example:\n\n    >>> table = inline_table()\n    >>> table.update({'x': 1, 'y': 2})\n    >>> print(table.as_string())\n    {x = 1, y = 2}\n    \"\"\"\n    return InlineTable(Container(), Trivia(), new=True)\n\n\ndef aot() -> AoT:\n    \"\"\"Create an array of table.\n\n    :Example:\n\n    >>> doc = document()\n    >>> aot = aot()\n    >>> aot.append(item({'x': 1}))\n    >>> doc.append('foo', aot)\n    >>> print(doc.as_string())\n    [[foo]]\n    x = 1\n    \"\"\"\n    return AoT([])\n\n\ndef key(k: str | Iterable[str]) -> Key:\n    \"\"\"Create a key from a string. When a list of string is given,\n    it will create a dotted key.\n\n    :Example:\n\n    >>> doc = document()\n    >>> doc.append(key('foo'), 1)\n    >>> doc.append(key(['bar', 'baz']), 2)\n    >>> print(doc.as_string())\n    foo = 1\n    bar.baz = 2\n    \"\"\"\n    if isinstance(k, str):\n        return SingleKey(k)\n    return DottedKey([key(_k) for _k in k])\n\n\ndef value(raw: str) -> _Item:\n    \"\"\"Parse a simple value from a string.\n\n    :Example:\n\n    >>> value(\"1\")\n    1\n    >>> value(\"true\")\n    True\n    >>> value(\"[1, 2, 3]\")\n    [1, 2, 3]\n    \"\"\"\n    parser = Parser(raw)\n    v = parser._parse_value()\n    if not parser.end():\n        raise parser.parse_error(UnexpectedCharError, char=parser._current)\n    return v\n\n\ndef key_value(src: str) -> tuple[Key, _Item]:\n    \"\"\"Parse a key-value pair from a string.\n\n    :Example:\n\n    >>> key_value(\"foo = 1\")\n    (Key('foo'), 1)\n    \"\"\"\n    return Parser(src)._parse_key_value()\n\n\ndef ws(src: str) -> Whitespace:\n    \"\"\"Create a whitespace from a string.\"\"\"\n    return Whitespace(src, fixed=True)\n\n\ndef nl() -> Whitespace:\n    \"\"\"Create a newline item.\"\"\"\n    return ws(\"\\n\")\n\n\ndef comment(string: str) -> Comment:\n    \"\"\"Create a comment item.\"\"\"\n    return Comment(Trivia(comment_ws=\"  \", comment=\"# \" + string))\n\n\nE = TypeVar(\"E\", bound=Encoder)\n\n\ndef register_encoder(encoder: E) -> E:\n    \"\"\"Add a custom encoder, which should be a function that will be called\n    if the value can't otherwise be converted. It should takes a single value\n    and return a TOMLKit item or raise a ``TypeError``.\n    \"\"\"\n    CUSTOM_ENCODERS.append(encoder)\n    return encoder\n\n\ndef unregister_encoder(encoder: Encoder) -> None:\n    \"\"\"Unregister a custom encoder.\"\"\"\n    with contextlib.suppress(ValueError):\n        CUSTOM_ENCODERS.remove(encoder)\n", "tomlkit/container.py": "from __future__ import annotations\n\nimport copy\n\nfrom typing import Any\nfrom typing import Iterator\n\nfrom tomlkit._compat import decode\nfrom tomlkit._types import _CustomDict\nfrom tomlkit._utils import merge_dicts\nfrom tomlkit.exceptions import KeyAlreadyPresent\nfrom tomlkit.exceptions import NonExistentKey\nfrom tomlkit.exceptions import TOMLKitError\nfrom tomlkit.items import AoT\nfrom tomlkit.items import Comment\nfrom tomlkit.items import Item\nfrom tomlkit.items import Key\nfrom tomlkit.items import Null\nfrom tomlkit.items import SingleKey\nfrom tomlkit.items import Table\nfrom tomlkit.items import Trivia\nfrom tomlkit.items import Whitespace\nfrom tomlkit.items import item as _item\n\n\n_NOT_SET = object()\n\n\nclass Container(_CustomDict):\n    \"\"\"\n    A container for items within a TOMLDocument.\n\n    This class implements the `dict` interface with copy/deepcopy protocol.\n    \"\"\"\n\n    def __init__(self, parsed: bool = False) -> None:\n        self._map: dict[SingleKey, int | tuple[int, ...]] = {}\n        self._body: list[tuple[Key | None, Item]] = []\n        self._parsed = parsed\n        self._table_keys = []\n\n    @property\n    def body(self) -> list[tuple[Key | None, Item]]:\n        return self._body\n\n    def unwrap(self) -> dict[str, Any]:\n        \"\"\"Returns as pure python object (ppo)\"\"\"\n        unwrapped = {}\n        for k, v in self.items():\n            if k is None:\n                continue\n\n            if isinstance(k, Key):\n                k = k.key\n\n            if hasattr(v, \"unwrap\"):\n                v = v.unwrap()\n\n            if k in unwrapped:\n                merge_dicts(unwrapped[k], v)\n            else:\n                unwrapped[k] = v\n\n        return unwrapped\n\n    @property\n    def value(self) -> dict[str, Any]:\n        \"\"\"The wrapped dict value\"\"\"\n        d = {}\n        for k, v in self._body:\n            if k is None:\n                continue\n\n            k = k.key\n            v = v.value\n\n            if isinstance(v, Container):\n                v = v.value\n\n            if k in d:\n                merge_dicts(d[k], v)\n            else:\n                d[k] = v\n\n        return d\n\n    def parsing(self, parsing: bool) -> None:\n        self._parsed = parsing\n\n        for _, v in self._body:\n            if isinstance(v, Table):\n                v.value.parsing(parsing)\n            elif isinstance(v, AoT):\n                for t in v.body:\n                    t.value.parsing(parsing)\n\n    def add(self, key: Key | Item | str, item: Item | None = None) -> Container:\n        \"\"\"\n        Adds an item to the current Container.\n\n        :Example:\n\n        >>> # add a key-value pair\n        >>> doc.add('key', 'value')\n        >>> # add a comment or whitespace or newline\n        >>> doc.add(comment('# comment'))\n        \"\"\"\n        if item is None:\n            if not isinstance(key, (Comment, Whitespace)):\n                raise ValueError(\n                    \"Non comment/whitespace items must have an associated key\"\n                )\n\n            key, item = None, key\n\n        return self.append(key, item)\n\n    def _handle_dotted_key(self, key: Key, value: Item) -> None:\n        if isinstance(value, (Table, AoT)):\n            raise TOMLKitError(\"Can't add a table to a dotted key\")\n        name, *mid, last = key\n        name._dotted = True\n        table = current = Table(Container(True), Trivia(), False, is_super_table=True)\n        for _name in mid:\n            _name._dotted = True\n            new_table = Table(Container(True), Trivia(), False, is_super_table=True)\n            current.append(_name, new_table)\n            current = new_table\n\n        last.sep = key.sep\n        current.append(last, value)\n\n        self.append(name, table)\n        return\n\n    def _get_last_index_before_table(self) -> int:\n        last_index = -1\n        for i, (k, v) in enumerate(self._body):\n            if isinstance(v, Null):\n                continue  # Null elements are inserted after deletion\n\n            if isinstance(v, Whitespace) and not v.is_fixed():\n                continue\n\n            if isinstance(v, (Table, AoT)) and not k.is_dotted():\n                break\n            last_index = i\n        return last_index + 1\n\n    def _validate_out_of_order_table(self, key: SingleKey | None = None) -> None:\n        if key is None:\n            for k in self._map:\n                assert k is not None\n                self._validate_out_of_order_table(k)\n            return\n        if key not in self._map or not isinstance(self._map[key], tuple):\n            return\n        OutOfOrderTableProxy(self, self._map[key])\n\n    def append(\n        self, key: Key | str | None, item: Item, validate: bool = True\n    ) -> Container:\n        \"\"\"Similar to :meth:`add` but both key and value must be given.\"\"\"\n        if not isinstance(key, Key) and key is not None:\n            key = SingleKey(key)\n\n        if not isinstance(item, Item):\n            item = _item(item)\n\n        if key is not None and key.is_multi():\n            self._handle_dotted_key(key, item)\n            return self\n\n        if isinstance(item, (AoT, Table)) and item.name is None:\n            item.name = key.key\n\n        prev = self._previous_item()\n        prev_ws = isinstance(prev, Whitespace) or ends_with_whitespace(prev)\n        if isinstance(item, Table):\n            if not self._parsed:\n                item.invalidate_display_name()\n            if (\n                self._body\n                and not (self._parsed or item.trivia.indent or prev_ws)\n                and not key.is_dotted()\n            ):\n                item.trivia.indent = \"\\n\"\n\n        if isinstance(item, AoT) and self._body and not self._parsed:\n            item.invalidate_display_name()\n            if item and not (\"\\n\" in item[0].trivia.indent or prev_ws):\n                item[0].trivia.indent = \"\\n\" + item[0].trivia.indent\n\n        if key is not None and key in self:\n            current_idx = self._map[key]\n            if isinstance(current_idx, tuple):\n                current_body_element = self._body[current_idx[-1]]\n            else:\n                current_body_element = self._body[current_idx]\n\n            current = current_body_element[1]\n\n            if isinstance(item, Table):\n                if not isinstance(current, (Table, AoT)):\n                    raise KeyAlreadyPresent(key)\n\n                if item.is_aot_element():\n                    # New AoT element found later on\n                    # Adding it to the current AoT\n                    if not isinstance(current, AoT):\n                        current = AoT([current, item], parsed=self._parsed)\n\n                        self._replace(key, key, current)\n                    else:\n                        current.append(item)\n\n                    return self\n                elif current.is_aot():\n                    if not item.is_aot_element():\n                        # Tried to define a table after an AoT with the same name.\n                        raise KeyAlreadyPresent(key)\n\n                    current.append(item)\n\n                    return self\n                elif current.is_super_table():\n                    if item.is_super_table():\n                        # We need to merge both super tables\n                        if (\n                            key.is_dotted()\n                            or current_body_element[0].is_dotted()\n                            or self._table_keys[-1] != current_body_element[0]\n                        ):\n                            if key.is_dotted() and not self._parsed:\n                                idx = self._get_last_index_before_table()\n                            else:\n                                idx = len(self._body)\n\n                            if idx < len(self._body):\n                                self._insert_at(idx, key, item)\n                            else:\n                                self._raw_append(key, item)\n\n                            if validate:\n                                self._validate_out_of_order_table(key)\n\n                            return self\n\n                        # Create a new element to replace the old one\n                        current = copy.deepcopy(current)\n                        for k, v in item.value.body:\n                            current.append(k, v)\n                        self._body[\n                            (\n                                current_idx[-1]\n                                if isinstance(current_idx, tuple)\n                                else current_idx\n                            )\n                        ] = (current_body_element[0], current)\n\n                        return self\n                    elif current_body_element[0].is_dotted():\n                        raise TOMLKitError(\"Redefinition of an existing table\")\n                elif not item.is_super_table():\n                    raise KeyAlreadyPresent(key)\n            elif isinstance(item, AoT):\n                if not isinstance(current, AoT):\n                    # Tried to define an AoT after a table with the same name.\n                    raise KeyAlreadyPresent(key)\n\n                for table in item.body:\n                    current.append(table)\n\n                return self\n            else:\n                raise KeyAlreadyPresent(key)\n\n        is_table = isinstance(item, (Table, AoT))\n        if (\n            key is not None\n            and self._body\n            and not self._parsed\n            and (not is_table or key.is_dotted())\n        ):\n            # If there is already at least one table in the current container\n            # and the given item is not a table, we need to find the last\n            # item that is not a table and insert after it\n            # If no such item exists, insert at the top of the table\n            last_index = self._get_last_index_before_table()\n\n            if last_index < len(self._body):\n                return self._insert_at(last_index, key, item)\n            else:\n                previous_item = self._body[-1][1]\n                if not (\n                    isinstance(previous_item, Whitespace)\n                    or ends_with_whitespace(previous_item)\n                    or \"\\n\" in previous_item.trivia.trail\n                ):\n                    previous_item.trivia.trail += \"\\n\"\n\n        self._raw_append(key, item)\n        return self\n\n    def _raw_append(self, key: Key | None, item: Item) -> None:\n        if key in self._map:\n            current_idx = self._map[key]\n            if not isinstance(current_idx, tuple):\n                current_idx = (current_idx,)\n\n            current = self._body[current_idx[-1]][1]\n            if key is not None and not isinstance(current, Table):\n                raise KeyAlreadyPresent(key)\n\n            self._map[key] = (*current_idx, len(self._body))\n        elif key is not None:\n            self._map[key] = len(self._body)\n\n        self._body.append((key, item))\n        if item.is_table():\n            self._table_keys.append(key)\n\n        if key is not None:\n            dict.__setitem__(self, key.key, item.value)\n\n    def _remove_at(self, idx: int) -> None:\n        key = self._body[idx][0]\n        index = self._map.get(key)\n        if index is None:\n            raise NonExistentKey(key)\n        self._body[idx] = (None, Null())\n\n        if isinstance(index, tuple):\n            index = list(index)\n            index.remove(idx)\n            if len(index) == 1:\n                index = index.pop()\n            else:\n                index = tuple(index)\n            self._map[key] = index\n        else:\n            dict.__delitem__(self, key.key)\n            self._map.pop(key)\n\n    def remove(self, key: Key | str) -> Container:\n        \"\"\"Remove a key from the container.\"\"\"\n        if not isinstance(key, Key):\n            key = SingleKey(key)\n\n        idx = self._map.pop(key, None)\n        if idx is None:\n            raise NonExistentKey(key)\n\n        if isinstance(idx, tuple):\n            for i in idx:\n                self._body[i] = (None, Null())\n        else:\n            self._body[idx] = (None, Null())\n\n        dict.__delitem__(self, key.key)\n\n        return self\n\n    def _insert_after(\n        self, key: Key | str, other_key: Key | str, item: Any\n    ) -> Container:\n        if key is None:\n            raise ValueError(\"Key cannot be null in insert_after()\")\n\n        if key not in self:\n            raise NonExistentKey(key)\n\n        if not isinstance(key, Key):\n            key = SingleKey(key)\n\n        if not isinstance(other_key, Key):\n            other_key = SingleKey(other_key)\n\n        item = _item(item)\n\n        idx = self._map[key]\n        # Insert after the max index if there are many.\n        if isinstance(idx, tuple):\n            idx = max(idx)\n        current_item = self._body[idx][1]\n        if \"\\n\" not in current_item.trivia.trail:\n            current_item.trivia.trail += \"\\n\"\n\n        # Increment indices after the current index\n        for k, v in self._map.items():\n            if isinstance(v, tuple):\n                new_indices = []\n                for v_ in v:\n                    if v_ > idx:\n                        v_ = v_ + 1\n\n                    new_indices.append(v_)\n\n                self._map[k] = tuple(new_indices)\n            elif v > idx:\n                self._map[k] = v + 1\n\n        self._map[other_key] = idx + 1\n        self._body.insert(idx + 1, (other_key, item))\n\n        if key is not None:\n            dict.__setitem__(self, other_key.key, item.value)\n\n        return self\n\n    def _insert_at(self, idx: int, key: Key | str, item: Any) -> Container:\n        if idx > len(self._body) - 1:\n            raise ValueError(f\"Unable to insert at position {idx}\")\n\n        if not isinstance(key, Key):\n            key = SingleKey(key)\n\n        item = _item(item)\n\n        if idx > 0:\n            previous_item = self._body[idx - 1][1]\n            if not (\n                isinstance(previous_item, Whitespace)\n                or ends_with_whitespace(previous_item)\n                or isinstance(item, (AoT, Table))\n                or \"\\n\" in previous_item.trivia.trail\n            ):\n                previous_item.trivia.trail += \"\\n\"\n\n        # Increment indices after the current index\n        for k, v in self._map.items():\n            if isinstance(v, tuple):\n                new_indices = []\n                for v_ in v:\n                    if v_ >= idx:\n                        v_ = v_ + 1\n\n                    new_indices.append(v_)\n\n                self._map[k] = tuple(new_indices)\n            elif v >= idx:\n                self._map[k] = v + 1\n\n        if key in self._map:\n            current_idx = self._map[key]\n            if not isinstance(current_idx, tuple):\n                current_idx = (current_idx,)\n            self._map[key] = (*current_idx, idx)\n        else:\n            self._map[key] = idx\n        self._body.insert(idx, (key, item))\n\n        dict.__setitem__(self, key.key, item.value)\n\n        return self\n\n    def item(self, key: Key | str) -> Item:\n        \"\"\"Get an item for the given key.\"\"\"\n        if not isinstance(key, Key):\n            key = SingleKey(key)\n\n        idx = self._map.get(key)\n        if idx is None:\n            raise NonExistentKey(key)\n\n        if isinstance(idx, tuple):\n            # The item we are getting is an out of order table\n            # so we need a proxy to retrieve the proper objects\n            # from the parent container\n            return OutOfOrderTableProxy(self, idx)\n\n        return self._body[idx][1]\n\n    def last_item(self) -> Item | None:\n        \"\"\"Get the last item.\"\"\"\n        if self._body:\n            return self._body[-1][1]\n\n    def as_string(self) -> str:\n        \"\"\"Render as TOML string.\"\"\"\n        s = \"\"\n        for k, v in self._body:\n            if k is not None:\n                if isinstance(v, Table):\n                    s += self._render_table(k, v)\n                elif isinstance(v, AoT):\n                    s += self._render_aot(k, v)\n                else:\n                    s += self._render_simple_item(k, v)\n            else:\n                s += self._render_simple_item(k, v)\n\n        return s\n\n    def _render_table(self, key: Key, table: Table, prefix: str | None = None) -> str:\n        cur = \"\"\n\n        if table.display_name is not None:\n            _key = table.display_name\n        else:\n            _key = key.as_string()\n\n            if prefix is not None:\n                _key = prefix + \".\" + _key\n\n        if not table.is_super_table() or (\n            any(\n                not isinstance(v, (Table, AoT, Whitespace, Null))\n                for _, v in table.value.body\n            )\n            and not key.is_dotted()\n        ):\n            open_, close = \"[\", \"]\"\n            if table.is_aot_element():\n                open_, close = \"[[\", \"]]\"\n\n            newline_in_table_trivia = (\n                \"\\n\" if \"\\n\" not in table.trivia.trail and len(table.value) > 0 else \"\"\n            )\n            cur += (\n                f\"{table.trivia.indent}\"\n                f\"{open_}\"\n                f\"{decode(_key)}\"\n                f\"{close}\"\n                f\"{table.trivia.comment_ws}\"\n                f\"{decode(table.trivia.comment)}\"\n                f\"{table.trivia.trail}\"\n                f\"{newline_in_table_trivia}\"\n            )\n        elif table.trivia.indent == \"\\n\":\n            cur += table.trivia.indent\n\n        for k, v in table.value.body:\n            if isinstance(v, Table):\n                if v.is_super_table():\n                    if k.is_dotted() and not key.is_dotted():\n                        # Dotted key inside table\n                        cur += self._render_table(k, v)\n                    else:\n                        cur += self._render_table(k, v, prefix=_key)\n                else:\n                    cur += self._render_table(k, v, prefix=_key)\n            elif isinstance(v, AoT):\n                cur += self._render_aot(k, v, prefix=_key)\n            else:\n                cur += self._render_simple_item(\n                    k, v, prefix=_key if key.is_dotted() else None\n                )\n\n        return cur\n\n    def _render_aot(self, key, aot, prefix=None):\n        _key = key.as_string()\n        if prefix is not None:\n            _key = prefix + \".\" + _key\n\n        cur = \"\"\n        _key = decode(_key)\n        for table in aot.body:\n            cur += self._render_aot_table(table, prefix=_key)\n\n        return cur\n\n    def _render_aot_table(self, table: Table, prefix: str | None = None) -> str:\n        cur = \"\"\n        _key = prefix or \"\"\n        open_, close = \"[[\", \"]]\"\n\n        cur += (\n            f\"{table.trivia.indent}\"\n            f\"{open_}\"\n            f\"{decode(_key)}\"\n            f\"{close}\"\n            f\"{table.trivia.comment_ws}\"\n            f\"{decode(table.trivia.comment)}\"\n            f\"{table.trivia.trail}\"\n        )\n\n        for k, v in table.value.body:\n            if isinstance(v, Table):\n                if v.is_super_table():\n                    if k.is_dotted():\n                        # Dotted key inside table\n                        cur += self._render_table(k, v)\n                    else:\n                        cur += self._render_table(k, v, prefix=_key)\n                else:\n                    cur += self._render_table(k, v, prefix=_key)\n            elif isinstance(v, AoT):\n                cur += self._render_aot(k, v, prefix=_key)\n            else:\n                cur += self._render_simple_item(k, v)\n\n        return cur\n\n    def _render_simple_item(self, key, item, prefix=None):\n        if key is None:\n            return item.as_string()\n\n        _key = key.as_string()\n        if prefix is not None:\n            _key = prefix + \".\" + _key\n\n        return (\n            f\"{item.trivia.indent}\"\n            f\"{decode(_key)}\"\n            f\"{key.sep}\"\n            f\"{decode(item.as_string())}\"\n            f\"{item.trivia.comment_ws}\"\n            f\"{decode(item.trivia.comment)}\"\n            f\"{item.trivia.trail}\"\n        )\n\n    def __len__(self) -> int:\n        return dict.__len__(self)\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(dict.keys(self))\n\n    # Dictionary methods\n    def __getitem__(self, key: Key | str) -> Item | Container:\n        item = self.item(key)\n        if isinstance(item, Item) and item.is_boolean():\n            return item.value\n\n        return item\n\n    def __setitem__(self, key: Key | str, value: Any) -> None:\n        if key is not None and key in self:\n            old_key = next(filter(lambda k: k == key, self._map))\n            self._replace(old_key, key, value)\n        else:\n            self.append(key, value)\n\n    def __delitem__(self, key: Key | str) -> None:\n        self.remove(key)\n\n    def setdefault(self, key: Key | str, default: Any) -> Any:\n        super().setdefault(key, default=default)\n        return self[key]\n\n    def _replace(self, key: Key | str, new_key: Key | str, value: Item) -> None:\n        if not isinstance(key, Key):\n            key = SingleKey(key)\n\n        idx = self._map.get(key)\n        if idx is None:\n            raise NonExistentKey(key)\n\n        self._replace_at(idx, new_key, value)\n\n    def _replace_at(\n        self, idx: int | tuple[int], new_key: Key | str, value: Item\n    ) -> None:\n        value = _item(value)\n\n        if isinstance(idx, tuple):\n            for i in idx[1:]:\n                self._body[i] = (None, Null())\n\n            idx = idx[0]\n\n        k, v = self._body[idx]\n        if not isinstance(new_key, Key):\n            if (\n                isinstance(value, (AoT, Table)) != isinstance(v, (AoT, Table))\n                or new_key != k.key\n            ):\n                new_key = SingleKey(new_key)\n            else:  # Inherit the sep of the old key\n                new_key = k\n\n        del self._map[k]\n        self._map[new_key] = idx\n        if new_key != k:\n            dict.__delitem__(self, k)\n\n        if isinstance(value, (AoT, Table)) != isinstance(v, (AoT, Table)):\n            # new tables should appear after all non-table values\n            self.remove(k)\n            for i in range(idx, len(self._body)):\n                if isinstance(self._body[i][1], (AoT, Table)):\n                    self._insert_at(i, new_key, value)\n                    idx = i\n                    break\n            else:\n                idx = -1\n                self.append(new_key, value)\n        else:\n            # Copying trivia\n            if not isinstance(value, (Whitespace, AoT)):\n                value.trivia.indent = v.trivia.indent\n                value.trivia.comment_ws = value.trivia.comment_ws or v.trivia.comment_ws\n                value.trivia.comment = value.trivia.comment or v.trivia.comment\n                value.trivia.trail = v.trivia.trail\n            self._body[idx] = (new_key, value)\n\n        if hasattr(value, \"invalidate_display_name\"):\n            value.invalidate_display_name()  # type: ignore[attr-defined]\n\n        if isinstance(value, Table):\n            # Insert a cosmetic new line for tables if:\n            # - it does not have it yet OR is not followed by one\n            # - it is not the last item, or\n            # - The table being replaced has a newline\n            last, _ = self._previous_item_with_index()\n            idx = last if idx < 0 else idx\n            has_ws = ends_with_whitespace(value)\n            replace_has_ws = (\n                isinstance(v, Table)\n                and v.value.body\n                and isinstance(v.value.body[-1][1], Whitespace)\n            )\n            next_ws = idx < last and isinstance(self._body[idx + 1][1], Whitespace)\n            if (idx < last or replace_has_ws) and not (next_ws or has_ws):\n                value.append(None, Whitespace(\"\\n\"))\n\n            dict.__setitem__(self, new_key.key, value.value)\n\n    def __str__(self) -> str:\n        return str(self.value)\n\n    def __repr__(self) -> str:\n        return repr(self.value)\n\n    def __eq__(self, other: dict) -> bool:\n        if not isinstance(other, dict):\n            return NotImplemented\n\n        return self.value == other\n\n    def _getstate(self, protocol):\n        return (self._parsed,)\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)\n\n    def __reduce_ex__(self, protocol):\n        return (\n            self.__class__,\n            self._getstate(protocol),\n            (self._map, self._body, self._parsed, self._table_keys),\n        )\n\n    def __setstate__(self, state):\n        self._map = state[0]\n        self._body = state[1]\n        self._parsed = state[2]\n        self._table_keys = state[3]\n\n        for key, item in self._body:\n            if key is not None:\n                dict.__setitem__(self, key.key, item.value)\n\n    def copy(self) -> Container:\n        return copy.copy(self)\n\n    def __copy__(self) -> Container:\n        c = self.__class__(self._parsed)\n        for k, v in dict.items(self):\n            dict.__setitem__(c, k, v)\n\n        c._body += self.body\n        c._map.update(self._map)\n\n        return c\n\n    def _previous_item_with_index(\n        self, idx: int | None = None, ignore=(Null,)\n    ) -> tuple[int, Item] | None:\n        \"\"\"Find the immediate previous item before index ``idx``\"\"\"\n        if idx is None or idx > len(self._body):\n            idx = len(self._body)\n        for i in range(idx - 1, -1, -1):\n            v = self._body[i][-1]\n            if not isinstance(v, ignore):\n                return i, v\n        return None\n\n    def _previous_item(self, idx: int | None = None, ignore=(Null,)) -> Item | None:\n        \"\"\"Find the immediate previous item before index ``idx``.\n        If ``idx`` is not given, the last item is returned.\n        \"\"\"\n        prev = self._previous_item_with_index(idx, ignore)\n        return prev[-1] if prev else None\n\n\nclass OutOfOrderTableProxy(_CustomDict):\n    def __init__(self, container: Container, indices: tuple[int]) -> None:\n        self._container = container\n        self._internal_container = Container(True)\n        self._tables = []\n        self._tables_map = {}\n\n        for i in indices:\n            _, item = self._container._body[i]\n\n            if isinstance(item, Table):\n                self._tables.append(item)\n                table_idx = len(self._tables) - 1\n                for k, v in item.value.body:\n                    self._internal_container.append(k, v, validate=False)\n                    self._tables_map[k] = table_idx\n                    if k is not None:\n                        dict.__setitem__(self, k.key, v)\n\n        self._internal_container._validate_out_of_order_table()\n\n    def unwrap(self) -> str:\n        return self._internal_container.unwrap()\n\n    @property\n    def value(self):\n        return self._internal_container.value\n\n    def __getitem__(self, key: Key | str) -> Any:\n        if key not in self._internal_container:\n            raise NonExistentKey(key)\n\n        return self._internal_container[key]\n\n    def __setitem__(self, key: Key | str, item: Any) -> None:\n        if key in self._tables_map:\n            table = self._tables[self._tables_map[key]]\n            table[key] = item\n        elif self._tables:\n            table = self._tables[0]\n            table[key] = item\n        else:\n            self._container[key] = item\n\n        self._internal_container[key] = item\n        if key is not None:\n            dict.__setitem__(self, key, item)\n\n    def _remove_table(self, table: Table) -> None:\n        \"\"\"Remove table from the parent container\"\"\"\n        self._tables.remove(table)\n        for idx, item in enumerate(self._container._body):\n            if item[1] is table:\n                self._container._remove_at(idx)\n                break\n\n    def __delitem__(self, key: Key | str) -> None:\n        if key in self._tables_map:\n            table = self._tables[self._tables_map[key]]\n            del table[key]\n            if not table and len(self._tables) > 1:\n                self._remove_table(table)\n            del self._tables_map[key]\n        else:\n            raise NonExistentKey(key)\n\n        del self._internal_container[key]\n        if key is not None:\n            dict.__delitem__(self, key)\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(dict.keys(self))\n\n    def __len__(self) -> int:\n        return dict.__len__(self)\n\n    def setdefault(self, key: Key | str, default: Any) -> Any:\n        super().setdefault(key, default=default)\n        return self[key]\n\n\ndef ends_with_whitespace(it: Any) -> bool:\n    \"\"\"Returns ``True`` if the given item ``it`` is a ``Table`` or ``AoT`` object\n    ending with a ``Whitespace``.\n    \"\"\"\n    return (\n        isinstance(it, Table) and isinstance(it.value._previous_item(), Whitespace)\n    ) or (isinstance(it, AoT) and len(it) > 0 and isinstance(it[-1], Whitespace))\n", "tomlkit/toml_char.py": "import string\n\n\nclass TOMLChar(str):\n    def __init__(self, c):\n        super().__init__()\n\n        if len(self) > 1:\n            raise ValueError(\"A TOML character must be of length 1\")\n\n    BARE = string.ascii_letters + string.digits + \"-_\"\n    KV = \"= \\t\"\n    NUMBER = string.digits + \"+-_.e\"\n    SPACES = \" \\t\"\n    NL = \"\\n\\r\"\n    WS = SPACES + NL\n\n    def is_bare_key_char(self) -> bool:\n        \"\"\"\n        Whether the character is a valid bare key name or not.\n        \"\"\"\n        return self in self.BARE\n\n    def is_kv_sep(self) -> bool:\n        \"\"\"\n        Whether the character is a valid key/value separator or not.\n        \"\"\"\n        return self in self.KV\n\n    def is_int_float_char(self) -> bool:\n        \"\"\"\n        Whether the character if a valid integer or float value character or not.\n        \"\"\"\n        return self in self.NUMBER\n\n    def is_ws(self) -> bool:\n        \"\"\"\n        Whether the character is a whitespace character or not.\n        \"\"\"\n        return self in self.WS\n\n    def is_nl(self) -> bool:\n        \"\"\"\n        Whether the character is a new line character or not.\n        \"\"\"\n        return self in self.NL\n\n    def is_spaces(self) -> bool:\n        \"\"\"\n        Whether the character is a space or not\n        \"\"\"\n        return self in self.SPACES\n", "tomlkit/toml_file.py": "import os\nimport re\n\nfrom typing import TYPE_CHECKING\n\nfrom tomlkit.api import loads\nfrom tomlkit.toml_document import TOMLDocument\n\n\nif TYPE_CHECKING:\n    from _typeshed import StrPath as _StrPath\nelse:\n    from typing import Union\n\n    _StrPath = Union[str, os.PathLike]\n\n\nclass TOMLFile:\n    \"\"\"\n    Represents a TOML file.\n\n    :param path: path to the TOML file\n    \"\"\"\n\n    def __init__(self, path: _StrPath) -> None:\n        self._path = path\n        self._linesep = os.linesep\n\n    def read(self) -> TOMLDocument:\n        \"\"\"Read the file content as a :class:`tomlkit.toml_document.TOMLDocument`.\"\"\"\n        with open(self._path, encoding=\"utf-8\", newline=\"\") as f:\n            content = f.read()\n\n            # check if consistent line endings\n            num_newline = content.count(\"\\n\")\n            if num_newline > 0:\n                num_win_eol = content.count(\"\\r\\n\")\n                if num_win_eol == num_newline:\n                    self._linesep = \"\\r\\n\"\n                elif num_win_eol == 0:\n                    self._linesep = \"\\n\"\n                else:\n                    self._linesep = \"mixed\"\n\n            return loads(content)\n\n    def write(self, data: TOMLDocument) -> None:\n        \"\"\"Write the TOMLDocument to the file.\"\"\"\n        content = data.as_string()\n\n        # apply linesep\n        if self._linesep == \"\\n\":\n            content = content.replace(\"\\r\\n\", \"\\n\")\n        elif self._linesep == \"\\r\\n\":\n            content = re.sub(r\"(?<!\\r)\\n\", \"\\r\\n\", content)\n\n        with open(self._path, \"w\", encoding=\"utf-8\", newline=\"\") as f:\n            f.write(content)\n", "tomlkit/_utils.py": "from __future__ import annotations\n\nimport re\n\nfrom collections.abc import Mapping\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom typing import Collection\n\nfrom tomlkit._compat import decode\n\n\nRFC_3339_LOOSE = re.compile(\n    \"^\"\n    r\"(([0-9]+)-(\\d{2})-(\\d{2}))?\"  # Date\n    \"(\"\n    \"([Tt ])?\"  # Separator\n    r\"(\\d{2}):(\\d{2}):(\\d{2})(\\.([0-9]+))?\"  # Time\n    r\"(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):([0-5][0-9])))?\"  # Timezone\n    \")?\"\n    \"$\"\n)\n\nRFC_3339_DATETIME = re.compile(\n    \"^\"\n    \"([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])\"  # Date\n    \"[Tt ]\"  # Separator\n    r\"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.([0-9]+))?\"  # Time\n    r\"(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):([0-5][0-9])))?\"  # Timezone\n    \"$\"\n)\n\nRFC_3339_DATE = re.compile(\"^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$\")\n\nRFC_3339_TIME = re.compile(\n    r\"^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.([0-9]+))?$\"\n)\n\n_utc = timezone(timedelta(), \"UTC\")\n\n\ndef parse_rfc3339(string: str) -> datetime | date | time:\n    m = RFC_3339_DATETIME.match(string)\n    if m:\n        year = int(m.group(1))\n        month = int(m.group(2))\n        day = int(m.group(3))\n        hour = int(m.group(4))\n        minute = int(m.group(5))\n        second = int(m.group(6))\n        microsecond = 0\n\n        if m.group(7):\n            microsecond = int((f\"{m.group(8):<06s}\")[:6])\n\n        if m.group(9):\n            # Timezone\n            tz = m.group(9)\n            if tz.upper() == \"Z\":\n                tzinfo = _utc\n            else:\n                sign = m.group(11)[0]\n                hour_offset, minute_offset = int(m.group(12)), int(m.group(13))\n                offset = timedelta(seconds=hour_offset * 3600 + minute_offset * 60)\n                if sign == \"-\":\n                    offset = -offset\n\n                tzinfo = timezone(offset, f\"{sign}{m.group(12)}:{m.group(13)}\")\n\n            return datetime(\n                year, month, day, hour, minute, second, microsecond, tzinfo=tzinfo\n            )\n        else:\n            return datetime(year, month, day, hour, minute, second, microsecond)\n\n    m = RFC_3339_DATE.match(string)\n    if m:\n        year = int(m.group(1))\n        month = int(m.group(2))\n        day = int(m.group(3))\n\n        return date(year, month, day)\n\n    m = RFC_3339_TIME.match(string)\n    if m:\n        hour = int(m.group(1))\n        minute = int(m.group(2))\n        second = int(m.group(3))\n        microsecond = 0\n\n        if m.group(4):\n            microsecond = int((f\"{m.group(5):<06s}\")[:6])\n\n        return time(hour, minute, second, microsecond)\n\n    raise ValueError(\"Invalid RFC 339 string\")\n\n\n# https://toml.io/en/v1.0.0#string\nCONTROL_CHARS = frozenset(chr(c) for c in range(0x20)) | {chr(0x7F)}\n_escaped = {\n    \"b\": \"\\b\",\n    \"t\": \"\\t\",\n    \"n\": \"\\n\",\n    \"f\": \"\\f\",\n    \"r\": \"\\r\",\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n}\n_compact_escapes = {\n    **{v: f\"\\\\{k}\" for k, v in _escaped.items()},\n    '\"\"\"': '\"\"\\\\\"',\n}\n_basic_escapes = CONTROL_CHARS | {'\"', \"\\\\\"}\n\n\ndef _unicode_escape(seq: str) -> str:\n    return \"\".join(f\"\\\\u{ord(c):04x}\" for c in seq)\n\n\ndef escape_string(s: str, escape_sequences: Collection[str] = _basic_escapes) -> str:\n    s = decode(s)\n\n    res = []\n    start = 0\n\n    def flush(inc=1):\n        if start != i:\n            res.append(s[start:i])\n\n        return i + inc\n\n    found_sequences = {seq for seq in escape_sequences if seq in s}\n\n    i = 0\n    while i < len(s):\n        for seq in found_sequences:\n            seq_len = len(seq)\n            if s[i:].startswith(seq):\n                start = flush(seq_len)\n                res.append(_compact_escapes.get(seq) or _unicode_escape(seq))\n                i += seq_len - 1  # fast-forward escape sequence\n        i += 1\n\n    flush()\n\n    return \"\".join(res)\n\n\ndef merge_dicts(d1: dict, d2: dict) -> dict:\n    for k, v in d2.items():\n        if k in d1 and isinstance(d1[k], dict) and isinstance(v, Mapping):\n            merge_dicts(d1[k], v)\n        else:\n            d1[k] = d2[k]\n", "tomlkit/_types.py": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import TypeVar\n\n\nWT = TypeVar(\"WT\", bound=\"WrapperType\")\n\nif TYPE_CHECKING:  # pragma: no cover\n    # Define _CustomList and _CustomDict as a workaround for:\n    # https://github.com/python/mypy/issues/11427\n    #\n    # According to this issue, the typeshed contains a \"lie\"\n    # (it adds MutableSequence to the ancestry of list and MutableMapping to\n    # the ancestry of dict) which completely messes with the type inference for\n    # Table, InlineTable, Array and Container.\n    #\n    # Importing from builtins is preferred over simple assignment, see issues:\n    # https://github.com/python/mypy/issues/8715\n    # https://github.com/python/mypy/issues/10068\n    from builtins import dict as _CustomDict\n    from builtins import float as _CustomFloat\n    from builtins import int as _CustomInt\n    from builtins import list as _CustomList\n    from typing import Callable\n    from typing import Concatenate\n    from typing import ParamSpec\n    from typing import Protocol\n\n    P = ParamSpec(\"P\")\n\n    class WrapperType(Protocol):\n        def _new(self: WT, value: Any) -> WT: ...\n\nelse:\n    from collections.abc import MutableMapping\n    from collections.abc import MutableSequence\n    from numbers import Integral\n    from numbers import Real\n\n    class _CustomList(MutableSequence, list):\n        \"\"\"Adds MutableSequence mixin while pretending to be a builtin list\"\"\"\n\n        def __add__(self, other):\n            new_list = self.copy()\n            new_list.extend(other)\n            return new_list\n\n        def __iadd__(self, other):\n            self.extend(other)\n            return self\n\n    class _CustomDict(MutableMapping, dict):\n        \"\"\"Adds MutableMapping mixin while pretending to be a builtin dict\"\"\"\n\n        def __or__(self, other):\n            new_dict = self.copy()\n            new_dict.update(other)\n            return new_dict\n\n        def __ior__(self, other):\n            self.update(other)\n            return self\n\n    class _CustomInt(Integral, int):\n        \"\"\"Adds Integral mixin while pretending to be a builtin int\"\"\"\n\n    class _CustomFloat(Real, float):\n        \"\"\"Adds Real mixin while pretending to be a builtin float\"\"\"\n\n\ndef wrap_method(\n    original_method: Callable[Concatenate[WT, P], Any],\n) -> Callable[Concatenate[WT, P], Any]:\n    def wrapper(self: WT, *args: P.args, **kwargs: P.kwargs) -> Any:\n        result = original_method(self, *args, **kwargs)\n        if result is NotImplemented:\n            return result\n        return self._new(result)\n\n    return wrapper\n", "tomlkit/_compat.py": "from __future__ import annotations\n\nimport contextlib\nimport sys\n\nfrom typing import Any\n\n\nPY38 = sys.version_info >= (3, 8)\n\n\ndef decode(string: Any, encodings: list[str] | None = None):\n    if not isinstance(string, bytes):\n        return string\n\n    encodings = encodings or [\"utf-8\", \"latin1\", \"ascii\"]\n\n    for encoding in encodings:\n        with contextlib.suppress(UnicodeEncodeError, UnicodeDecodeError):\n            return string.decode(encoding)\n\n    return string.decode(encodings[0], errors=\"ignore\")\n", "tomlkit/__init__.py": "from tomlkit.api import TOMLDocument\nfrom tomlkit.api import aot\nfrom tomlkit.api import array\nfrom tomlkit.api import boolean\nfrom tomlkit.api import comment\nfrom tomlkit.api import date\nfrom tomlkit.api import datetime\nfrom tomlkit.api import document\nfrom tomlkit.api import dump\nfrom tomlkit.api import dumps\nfrom tomlkit.api import float_\nfrom tomlkit.api import inline_table\nfrom tomlkit.api import integer\nfrom tomlkit.api import item\nfrom tomlkit.api import key\nfrom tomlkit.api import key_value\nfrom tomlkit.api import load\nfrom tomlkit.api import loads\nfrom tomlkit.api import nl\nfrom tomlkit.api import parse\nfrom tomlkit.api import register_encoder\nfrom tomlkit.api import string\nfrom tomlkit.api import table\nfrom tomlkit.api import time\nfrom tomlkit.api import unregister_encoder\nfrom tomlkit.api import value\nfrom tomlkit.api import ws\n\n\n__version__ = \"0.12.5\"\n__all__ = [\n    \"aot\",\n    \"array\",\n    \"boolean\",\n    \"comment\",\n    \"date\",\n    \"datetime\",\n    \"document\",\n    \"dump\",\n    \"dumps\",\n    \"float_\",\n    \"inline_table\",\n    \"integer\",\n    \"item\",\n    \"key\",\n    \"key_value\",\n    \"load\",\n    \"loads\",\n    \"nl\",\n    \"parse\",\n    \"string\",\n    \"table\",\n    \"time\",\n    \"TOMLDocument\",\n    \"value\",\n    \"ws\",\n    \"register_encoder\",\n    \"unregister_encoder\",\n]\n", "tomlkit/parser.py": "from __future__ import annotations\n\nimport datetime\nimport re\nimport string\n\nfrom tomlkit._compat import decode\nfrom tomlkit._utils import RFC_3339_LOOSE\nfrom tomlkit._utils import _escaped\nfrom tomlkit._utils import parse_rfc3339\nfrom tomlkit.container import Container\nfrom tomlkit.exceptions import EmptyKeyError\nfrom tomlkit.exceptions import EmptyTableNameError\nfrom tomlkit.exceptions import InternalParserError\nfrom tomlkit.exceptions import InvalidCharInStringError\nfrom tomlkit.exceptions import InvalidControlChar\nfrom tomlkit.exceptions import InvalidDateError\nfrom tomlkit.exceptions import InvalidDateTimeError\nfrom tomlkit.exceptions import InvalidNumberError\nfrom tomlkit.exceptions import InvalidTimeError\nfrom tomlkit.exceptions import InvalidUnicodeValueError\nfrom tomlkit.exceptions import ParseError\nfrom tomlkit.exceptions import UnexpectedCharError\nfrom tomlkit.exceptions import UnexpectedEofError\nfrom tomlkit.items import AoT\nfrom tomlkit.items import Array\nfrom tomlkit.items import Bool\nfrom tomlkit.items import BoolType\nfrom tomlkit.items import Comment\nfrom tomlkit.items import Date\nfrom tomlkit.items import DateTime\nfrom tomlkit.items import Float\nfrom tomlkit.items import InlineTable\nfrom tomlkit.items import Integer\nfrom tomlkit.items import Item\nfrom tomlkit.items import Key\nfrom tomlkit.items import KeyType\nfrom tomlkit.items import Null\nfrom tomlkit.items import SingleKey\nfrom tomlkit.items import String\nfrom tomlkit.items import StringType\nfrom tomlkit.items import Table\nfrom tomlkit.items import Time\nfrom tomlkit.items import Trivia\nfrom tomlkit.items import Whitespace\nfrom tomlkit.source import Source\nfrom tomlkit.toml_char import TOMLChar\nfrom tomlkit.toml_document import TOMLDocument\n\n\nCTRL_I = 0x09  # Tab\nCTRL_J = 0x0A  # Line feed\nCTRL_M = 0x0D  # Carriage return\nCTRL_CHAR_LIMIT = 0x1F\nCHR_DEL = 0x7F\n\n\nclass Parser:\n    \"\"\"\n    Parser for TOML documents.\n    \"\"\"\n\n    def __init__(self, string: str | bytes) -> None:\n        # Input to parse\n        self._src = Source(decode(string))\n\n        self._aot_stack: list[Key] = []\n\n    @property\n    def _state(self):\n        return self._src.state\n\n    @property\n    def _idx(self):\n        return self._src.idx\n\n    @property\n    def _current(self):\n        return self._src.current\n\n    @property\n    def _marker(self):\n        return self._src.marker\n\n    def extract(self) -> str:\n        \"\"\"\n        Extracts the value between marker and index\n        \"\"\"\n        return self._src.extract()\n\n    def inc(self, exception: type[ParseError] | None = None) -> bool:\n        \"\"\"\n        Increments the parser if the end of the input has not been reached.\n        Returns whether or not it was able to advance.\n        \"\"\"\n        return self._src.inc(exception=exception)\n\n    def inc_n(self, n: int, exception: type[ParseError] | None = None) -> bool:\n        \"\"\"\n        Increments the parser by n characters\n        if the end of the input has not been reached.\n        \"\"\"\n        return self._src.inc_n(n=n, exception=exception)\n\n    def consume(self, chars, min=0, max=-1):\n        \"\"\"\n        Consume chars until min/max is satisfied is valid.\n        \"\"\"\n        return self._src.consume(chars=chars, min=min, max=max)\n\n    def end(self) -> bool:\n        \"\"\"\n        Returns True if the parser has reached the end of the input.\n        \"\"\"\n        return self._src.end()\n\n    def mark(self) -> None:\n        \"\"\"\n        Sets the marker to the index's current position\n        \"\"\"\n        self._src.mark()\n\n    def parse_error(self, exception=ParseError, *args, **kwargs):\n        \"\"\"\n        Creates a generic \"parse error\" at the current position.\n        \"\"\"\n        return self._src.parse_error(exception, *args, **kwargs)\n\n    def parse(self) -> TOMLDocument:\n        body = TOMLDocument(True)\n\n        # Take all keyvals outside of tables/AoT's.\n        while not self.end():\n            # Break out if a table is found\n            if self._current == \"[\":\n                break\n\n            # Otherwise, take and append one KV\n            item = self._parse_item()\n            if not item:\n                break\n\n            key, value = item\n            if (key is not None and key.is_multi()) or not self._merge_ws(value, body):\n                # We actually have a table\n                try:\n                    body.append(key, value)\n                except Exception as e:\n                    raise self.parse_error(ParseError, str(e)) from e\n\n            self.mark()\n\n        while not self.end():\n            key, value = self._parse_table()\n            if isinstance(value, Table) and value.is_aot_element():\n                # This is just the first table in an AoT. Parse the rest of the array\n                # along with it.\n                value = self._parse_aot(value, key)\n\n            try:\n                body.append(key, value)\n            except Exception as e:\n                raise self.parse_error(ParseError, str(e)) from e\n\n        body.parsing(False)\n\n        return body\n\n    def _merge_ws(self, item: Item, container: Container) -> bool:\n        \"\"\"\n        Merges the given Item with the last one currently in the given Container if\n        both are whitespace items.\n\n        Returns True if the items were merged.\n        \"\"\"\n        last = container.last_item()\n        if not last:\n            return False\n\n        if not isinstance(item, Whitespace) or not isinstance(last, Whitespace):\n            return False\n\n        start = self._idx - (len(last.s) + len(item.s))\n        container.body[-1] = (\n            container.body[-1][0],\n            Whitespace(self._src[start : self._idx]),\n        )\n\n        return True\n\n    def _is_child(self, parent: Key, child: Key) -> bool:\n        \"\"\"\n        Returns whether a key is strictly a child of another key.\n        AoT siblings are not considered children of one another.\n        \"\"\"\n        parent_parts = tuple(parent)\n        child_parts = tuple(child)\n\n        if parent_parts == child_parts:\n            return False\n\n        return parent_parts == child_parts[: len(parent_parts)]\n\n    def _parse_item(self) -> tuple[Key | None, Item] | None:\n        \"\"\"\n        Attempts to parse the next item and returns it, along with its key\n        if the item is value-like.\n        \"\"\"\n        self.mark()\n        with self._state as state:\n            while True:\n                c = self._current\n                if c == \"\\n\":\n                    # Found a newline; Return all whitespace found up to this point.\n                    self.inc()\n\n                    return None, Whitespace(self.extract())\n                elif c in \" \\t\\r\":\n                    # Skip whitespace.\n                    if not self.inc():\n                        return None, Whitespace(self.extract())\n                elif c == \"#\":\n                    # Found a comment, parse it\n                    indent = self.extract()\n                    cws, comment, trail = self._parse_comment_trail()\n\n                    return None, Comment(Trivia(indent, cws, comment, trail))\n                elif c == \"[\":\n                    # Found a table, delegate to the calling function.\n                    return\n                else:\n                    # Beginning of a KV pair.\n                    # Return to beginning of whitespace so it gets included\n                    # as indentation for the KV about to be parsed.\n                    state.restore = True\n                    break\n\n        return self._parse_key_value(True)\n\n    def _parse_comment_trail(self, parse_trail: bool = True) -> tuple[str, str, str]:\n        \"\"\"\n        Returns (comment_ws, comment, trail)\n        If there is no comment, comment_ws and comment will\n        simply be empty.\n        \"\"\"\n        if self.end():\n            return \"\", \"\", \"\"\n\n        comment = \"\"\n        comment_ws = \"\"\n        self.mark()\n\n        while True:\n            c = self._current\n\n            if c == \"\\n\":\n                break\n            elif c == \"#\":\n                comment_ws = self.extract()\n\n                self.mark()\n                self.inc()  # Skip #\n\n                # The comment itself\n                while not self.end() and not self._current.is_nl():\n                    code = ord(self._current)\n                    if code == CHR_DEL or code <= CTRL_CHAR_LIMIT and code != CTRL_I:\n                        raise self.parse_error(InvalidControlChar, code, \"comments\")\n\n                    if not self.inc():\n                        break\n\n                comment = self.extract()\n                self.mark()\n\n                break\n            elif c in \" \\t\\r\":\n                self.inc()\n            else:\n                raise self.parse_error(UnexpectedCharError, c)\n\n            if self.end():\n                break\n\n        trail = \"\"\n        if parse_trail:\n            while self._current.is_spaces() and self.inc():\n                pass\n\n            if self._current == \"\\r\":\n                self.inc()\n\n            if self._current == \"\\n\":\n                self.inc()\n\n            if self._idx != self._marker or self._current.is_ws():\n                trail = self.extract()\n\n        return comment_ws, comment, trail\n\n    def _parse_key_value(self, parse_comment: bool = False) -> tuple[Key, Item]:\n        # Leading indent\n        self.mark()\n\n        while self._current.is_spaces() and self.inc():\n            pass\n\n        indent = self.extract()\n\n        # Key\n        key = self._parse_key()\n\n        self.mark()\n\n        found_equals = self._current == \"=\"\n        while self._current.is_kv_sep() and self.inc():\n            if self._current == \"=\":\n                if found_equals:\n                    raise self.parse_error(UnexpectedCharError, \"=\")\n                else:\n                    found_equals = True\n        if not found_equals:\n            raise self.parse_error(UnexpectedCharError, self._current)\n\n        if not key.sep:\n            key.sep = self.extract()\n        else:\n            key.sep += self.extract()\n\n        # Value\n        val = self._parse_value()\n        # Comment\n        if parse_comment:\n            cws, comment, trail = self._parse_comment_trail()\n            meta = val.trivia\n            if not meta.comment_ws:\n                meta.comment_ws = cws\n\n            meta.comment = comment\n            meta.trail = trail\n        else:\n            val.trivia.trail = \"\"\n\n        val.trivia.indent = indent\n\n        return key, val\n\n    def _parse_key(self) -> Key:\n        \"\"\"\n        Parses a Key at the current position;\n        WS before the key must be exhausted first at the callsite.\n        \"\"\"\n        self.mark()\n        while self._current.is_spaces() and self.inc():\n            # Skip any leading whitespace\n            pass\n        if self._current in \"\\\"'\":\n            return self._parse_quoted_key()\n        else:\n            return self._parse_bare_key()\n\n    def _parse_quoted_key(self) -> Key:\n        \"\"\"\n        Parses a key enclosed in either single or double quotes.\n        \"\"\"\n        # Extract the leading whitespace\n        original = self.extract()\n        quote_style = self._current\n        key_type = next((t for t in KeyType if t.value == quote_style), None)\n\n        if key_type is None:\n            raise RuntimeError(\"Should not have entered _parse_quoted_key()\")\n\n        key_str = self._parse_string(\n            StringType.SLB if key_type == KeyType.Basic else StringType.SLL\n        )\n        if key_str._t.is_multiline():\n            raise self.parse_error(UnexpectedCharError, key_str._t.value)\n        original += key_str.as_string()\n        self.mark()\n        while self._current.is_spaces() and self.inc():\n            pass\n        original += self.extract()\n        key = SingleKey(str(key_str), t=key_type, sep=\"\", original=original)\n        if self._current == \".\":\n            self.inc()\n            key = key.concat(self._parse_key())\n\n        return key\n\n    def _parse_bare_key(self) -> Key:\n        \"\"\"\n        Parses a bare key.\n        \"\"\"\n        while (\n            self._current.is_bare_key_char() or self._current.is_spaces()\n        ) and self.inc():\n            pass\n\n        original = self.extract()\n        key = original.strip()\n        if not key:\n            # Empty key\n            raise self.parse_error(EmptyKeyError)\n\n        if \" \" in key:\n            # Bare key with spaces in it\n            raise self.parse_error(ParseError, f'Invalid key \"{key}\"')\n\n        key = SingleKey(key, KeyType.Bare, \"\", original)\n\n        if self._current == \".\":\n            self.inc()\n            key = key.concat(self._parse_key())\n\n        return key\n\n    def _parse_value(self) -> Item:\n        \"\"\"\n        Attempts to parse a value at the current position.\n        \"\"\"\n        self.mark()\n        c = self._current\n        trivia = Trivia()\n\n        if c == StringType.SLB.value:\n            return self._parse_basic_string()\n        elif c == StringType.SLL.value:\n            return self._parse_literal_string()\n        elif c == BoolType.TRUE.value[0]:\n            return self._parse_true()\n        elif c == BoolType.FALSE.value[0]:\n            return self._parse_false()\n        elif c == \"[\":\n            return self._parse_array()\n        elif c == \"{\":\n            return self._parse_inline_table()\n        elif c in \"+-\" or self._peek(4) in {\n            \"+inf\",\n            \"-inf\",\n            \"inf\",\n            \"+nan\",\n            \"-nan\",\n            \"nan\",\n        }:\n            # Number\n            while self._current not in \" \\t\\n\\r#,]}\" and self.inc():\n                pass\n\n            raw = self.extract()\n\n            item = self._parse_number(raw, trivia)\n            if item is not None:\n                return item\n\n            raise self.parse_error(InvalidNumberError)\n        elif c in string.digits:\n            # Integer, Float, Date, Time or DateTime\n            while self._current not in \" \\t\\n\\r#,]}\" and self.inc():\n                pass\n\n            raw = self.extract()\n\n            m = RFC_3339_LOOSE.match(raw)\n            if m:\n                if m.group(1) and m.group(5):\n                    # datetime\n                    try:\n                        dt = parse_rfc3339(raw)\n                        assert isinstance(dt, datetime.datetime)\n                        return DateTime(\n                            dt.year,\n                            dt.month,\n                            dt.day,\n                            dt.hour,\n                            dt.minute,\n                            dt.second,\n                            dt.microsecond,\n                            dt.tzinfo,\n                            trivia,\n                            raw,\n                        )\n                    except ValueError:\n                        raise self.parse_error(InvalidDateTimeError) from None\n\n                if m.group(1):\n                    try:\n                        dt = parse_rfc3339(raw)\n                        assert isinstance(dt, datetime.date)\n                        date = Date(dt.year, dt.month, dt.day, trivia, raw)\n                        self.mark()\n                        while self._current not in \"\\t\\n\\r#,]}\" and self.inc():\n                            pass\n\n                        time_raw = self.extract()\n                        time_part = time_raw.rstrip()\n                        trivia.comment_ws = time_raw[len(time_part) :]\n                        if not time_part:\n                            return date\n\n                        dt = parse_rfc3339(raw + time_part)\n                        assert isinstance(dt, datetime.datetime)\n                        return DateTime(\n                            dt.year,\n                            dt.month,\n                            dt.day,\n                            dt.hour,\n                            dt.minute,\n                            dt.second,\n                            dt.microsecond,\n                            dt.tzinfo,\n                            trivia,\n                            raw + time_part,\n                        )\n                    except ValueError:\n                        raise self.parse_error(InvalidDateError) from None\n\n                if m.group(5):\n                    try:\n                        t = parse_rfc3339(raw)\n                        assert isinstance(t, datetime.time)\n                        return Time(\n                            t.hour,\n                            t.minute,\n                            t.second,\n                            t.microsecond,\n                            t.tzinfo,\n                            trivia,\n                            raw,\n                        )\n                    except ValueError:\n                        raise self.parse_error(InvalidTimeError) from None\n\n            item = self._parse_number(raw, trivia)\n            if item is not None:\n                return item\n\n            raise self.parse_error(InvalidNumberError)\n        else:\n            raise self.parse_error(UnexpectedCharError, c)\n\n    def _parse_true(self):\n        return self._parse_bool(BoolType.TRUE)\n\n    def _parse_false(self):\n        return self._parse_bool(BoolType.FALSE)\n\n    def _parse_bool(self, style: BoolType) -> Bool:\n        with self._state:\n            style = BoolType(style)\n\n            # only keep parsing for bool if the characters match the style\n            # try consuming rest of chars in style\n            for c in style:\n                self.consume(c, min=1, max=1)\n\n            return Bool(style, Trivia())\n\n    def _parse_array(self) -> Array:\n        # Consume opening bracket, EOF here is an issue (middle of array)\n        self.inc(exception=UnexpectedEofError)\n\n        elems: list[Item] = []\n        prev_value = None\n        while True:\n            # consume whitespace\n            mark = self._idx\n            self.consume(TOMLChar.SPACES + TOMLChar.NL)\n            indent = self._src[mark : self._idx]\n            newline = set(TOMLChar.NL) & set(indent)\n            if newline:\n                elems.append(Whitespace(indent))\n                continue\n\n            # consume comment\n            if self._current == \"#\":\n                cws, comment, trail = self._parse_comment_trail(parse_trail=False)\n                elems.append(Comment(Trivia(indent, cws, comment, trail)))\n                continue\n\n            # consume indent\n            if indent:\n                elems.append(Whitespace(indent))\n                continue\n\n            # consume value\n            if not prev_value:\n                try:\n                    elems.append(self._parse_value())\n                    prev_value = True\n                    continue\n                except UnexpectedCharError:\n                    pass\n\n            # consume comma\n            if prev_value and self._current == \",\":\n                self.inc(exception=UnexpectedEofError)\n                elems.append(Whitespace(\",\"))\n                prev_value = False\n                continue\n\n            # consume closing bracket\n            if self._current == \"]\":\n                # consume closing bracket, EOF here doesn't matter\n                self.inc()\n                break\n\n            raise self.parse_error(UnexpectedCharError, self._current)\n\n        try:\n            res = Array(elems, Trivia())\n        except ValueError:\n            pass\n        else:\n            return res\n\n    def _parse_inline_table(self) -> InlineTable:\n        # consume opening bracket, EOF here is an issue (middle of array)\n        self.inc(exception=UnexpectedEofError)\n\n        elems = Container(True)\n        trailing_comma = None\n        while True:\n            # consume leading whitespace\n            mark = self._idx\n            self.consume(TOMLChar.SPACES)\n            raw = self._src[mark : self._idx]\n            if raw:\n                elems.add(Whitespace(raw))\n\n            if not trailing_comma:\n                # None: empty inline table\n                # False: previous key-value pair was not followed by a comma\n                if self._current == \"}\":\n                    # consume closing bracket, EOF here doesn't matter\n                    self.inc()\n                    break\n\n                if (\n                    trailing_comma is False\n                    or trailing_comma is None\n                    and self._current == \",\"\n                ):\n                    # Either the previous key-value pair was not followed by a comma\n                    # or the table has an unexpected leading comma.\n                    raise self.parse_error(UnexpectedCharError, self._current)\n            else:\n                # True: previous key-value pair was followed by a comma\n                if self._current == \"}\" or self._current == \",\":\n                    raise self.parse_error(UnexpectedCharError, self._current)\n\n            key, val = self._parse_key_value(False)\n            elems.add(key, val)\n\n            # consume trailing whitespace\n            mark = self._idx\n            self.consume(TOMLChar.SPACES)\n            raw = self._src[mark : self._idx]\n            if raw:\n                elems.add(Whitespace(raw))\n\n            # consume trailing comma\n            trailing_comma = self._current == \",\"\n            if trailing_comma:\n                # consume closing bracket, EOF here is an issue (middle of inline table)\n                self.inc(exception=UnexpectedEofError)\n\n        return InlineTable(elems, Trivia())\n\n    def _parse_number(self, raw: str, trivia: Trivia) -> Item | None:\n        # Leading zeros are not allowed\n        sign = \"\"\n        if raw.startswith((\"+\", \"-\")):\n            sign = raw[0]\n            raw = raw[1:]\n\n        if len(raw) > 1 and (\n            raw.startswith(\"0\")\n            and not raw.startswith((\"0.\", \"0o\", \"0x\", \"0b\", \"0e\"))\n            or sign\n            and raw.startswith(\".\")\n        ):\n            return None\n\n        if raw.startswith((\"0o\", \"0x\", \"0b\")) and sign:\n            return None\n\n        digits = \"[0-9]\"\n        base = 10\n        if raw.startswith(\"0b\"):\n            digits = \"[01]\"\n            base = 2\n        elif raw.startswith(\"0o\"):\n            digits = \"[0-7]\"\n            base = 8\n        elif raw.startswith(\"0x\"):\n            digits = \"[0-9a-f]\"\n            base = 16\n\n        # Underscores should be surrounded by digits\n        clean = re.sub(f\"(?i)(?<={digits})_(?={digits})\", \"\", raw).lower()\n\n        if \"_\" in clean:\n            return None\n\n        if (\n            clean.endswith(\".\")\n            or not clean.startswith(\"0x\")\n            and clean.split(\"e\", 1)[0].endswith(\".\")\n        ):\n            return None\n\n        try:\n            return Integer(int(sign + clean, base), trivia, sign + raw)\n        except ValueError:\n            try:\n                return Float(float(sign + clean), trivia, sign + raw)\n            except ValueError:\n                return None\n\n    def _parse_literal_string(self) -> String:\n        with self._state:\n            return self._parse_string(StringType.SLL)\n\n    def _parse_basic_string(self) -> String:\n        with self._state:\n            return self._parse_string(StringType.SLB)\n\n    def _parse_escaped_char(self, multiline):\n        if multiline and self._current.is_ws():\n            # When the last non-whitespace character on a line is\n            # a \\, it will be trimmed along with all whitespace\n            # (including newlines) up to the next non-whitespace\n            # character or closing delimiter.\n            # \"\"\"\\\n            #     hello \\\n            #     world\"\"\"\n            tmp = \"\"\n            while self._current.is_ws():\n                tmp += self._current\n                # consume the whitespace, EOF here is an issue\n                # (middle of string)\n                self.inc(exception=UnexpectedEofError)\n                continue\n\n            # the escape followed by whitespace must have a newline\n            # before any other chars\n            if \"\\n\" not in tmp:\n                raise self.parse_error(InvalidCharInStringError, self._current)\n\n            return \"\"\n\n        if self._current in _escaped:\n            c = _escaped[self._current]\n\n            # consume this char, EOF here is an issue (middle of string)\n            self.inc(exception=UnexpectedEofError)\n\n            return c\n\n        if self._current in {\"u\", \"U\"}:\n            # this needs to be a unicode\n            u, ue = self._peek_unicode(self._current == \"U\")\n            if u is not None:\n                # consume the U char and the unicode value\n                self.inc_n(len(ue) + 1)\n\n                return u\n\n            raise self.parse_error(InvalidUnicodeValueError)\n\n        raise self.parse_error(InvalidCharInStringError, self._current)\n\n    def _parse_string(self, delim: StringType) -> String:\n        # only keep parsing for string if the current character matches the delim\n        if self._current != delim.unit:\n            raise self.parse_error(\n                InternalParserError,\n                f\"Invalid character for string type {delim}\",\n            )\n\n        # consume the opening/first delim, EOF here is an issue\n        # (middle of string or middle of delim)\n        self.inc(exception=UnexpectedEofError)\n\n        if self._current == delim.unit:\n            # consume the closing/second delim, we do not care if EOF occurs as\n            # that would simply imply an empty single line string\n            if not self.inc() or self._current != delim.unit:\n                # Empty string\n                return String(delim, \"\", \"\", Trivia())\n\n            # consume the third delim, EOF here is an issue (middle of string)\n            self.inc(exception=UnexpectedEofError)\n\n            delim = delim.toggle()  # convert delim to multi delim\n\n        self.mark()  # to extract the original string with whitespace and all\n        value = \"\"\n\n        # A newline immediately following the opening delimiter will be trimmed.\n        if delim.is_multiline():\n            if self._current == \"\\n\":\n                # consume the newline, EOF here is an issue (middle of string)\n                self.inc(exception=UnexpectedEofError)\n            else:\n                cur = self._current\n                with self._state(restore=True):\n                    if self.inc():\n                        cur += self._current\n                if cur == \"\\r\\n\":\n                    self.inc_n(2, exception=UnexpectedEofError)\n\n        escaped = False  # whether the previous key was ESCAPE\n        while True:\n            code = ord(self._current)\n            if (\n                delim.is_singleline()\n                and not escaped\n                and (code == CHR_DEL or code <= CTRL_CHAR_LIMIT and code != CTRL_I)\n            ) or (\n                delim.is_multiline()\n                and not escaped\n                and (\n                    code == CHR_DEL\n                    or code <= CTRL_CHAR_LIMIT\n                    and code not in [CTRL_I, CTRL_J, CTRL_M]\n                )\n            ):\n                raise self.parse_error(InvalidControlChar, code, \"strings\")\n            elif not escaped and self._current == delim.unit:\n                # try to process current as a closing delim\n                original = self.extract()\n\n                close = \"\"\n                if delim.is_multiline():\n                    # Consume the delimiters to see if we are at the end of the string\n                    close = \"\"\n                    while self._current == delim.unit:\n                        close += self._current\n                        self.inc()\n\n                    if len(close) < 3:\n                        # Not a triple quote, leave in result as-is.\n                        # Adding back the characters we already consumed\n                        value += close\n                        continue\n\n                    if len(close) == 3:\n                        # We are at the end of the string\n                        return String(delim, value, original, Trivia())\n\n                    if len(close) >= 6:\n                        raise self.parse_error(InvalidCharInStringError, self._current)\n\n                    value += close[:-3]\n                    original += close[:-3]\n\n                    return String(delim, value, original, Trivia())\n                else:\n                    # consume the closing delim, we do not care if EOF occurs as\n                    # that would simply imply the end of self._src\n                    self.inc()\n\n                return String(delim, value, original, Trivia())\n            elif delim.is_basic() and escaped:\n                # attempt to parse the current char as an escaped value, an exception\n                # is raised if this fails\n                value += self._parse_escaped_char(delim.is_multiline())\n\n                # no longer escaped\n                escaped = False\n            elif delim.is_basic() and self._current == \"\\\\\":\n                # the next char is being escaped\n                escaped = True\n\n                # consume this char, EOF here is an issue (middle of string)\n                self.inc(exception=UnexpectedEofError)\n            else:\n                # this is either a literal string where we keep everything as is,\n                # or this is not a special escaped char in a basic string\n                value += self._current\n\n                # consume this char, EOF here is an issue (middle of string)\n                self.inc(exception=UnexpectedEofError)\n\n    def _parse_table(\n        self, parent_name: Key | None = None, parent: Table | None = None\n    ) -> tuple[Key, Table | AoT]:\n        \"\"\"\n        Parses a table element.\n        \"\"\"\n        if self._current != \"[\":\n            raise self.parse_error(\n                InternalParserError, \"_parse_table() called on non-bracket character.\"\n            )\n\n        indent = self.extract()\n        self.inc()  # Skip opening bracket\n\n        if self.end():\n            raise self.parse_error(UnexpectedEofError)\n\n        is_aot = False\n        if self._current == \"[\":\n            if not self.inc():\n                raise self.parse_error(UnexpectedEofError)\n\n            is_aot = True\n        try:\n            key = self._parse_key()\n        except EmptyKeyError:\n            raise self.parse_error(EmptyTableNameError) from None\n        if self.end():\n            raise self.parse_error(UnexpectedEofError)\n        elif self._current != \"]\":\n            raise self.parse_error(UnexpectedCharError, self._current)\n\n        key.sep = \"\"\n        full_key = key\n        name_parts = tuple(key)\n        if any(\" \" in part.key.strip() and part.is_bare() for part in name_parts):\n            raise self.parse_error(\n                ParseError, f'Invalid table name \"{full_key.as_string()}\"'\n            )\n\n        missing_table = False\n        if parent_name:\n            parent_name_parts = tuple(parent_name)\n        else:\n            parent_name_parts = ()\n\n        if len(name_parts) > len(parent_name_parts) + 1:\n            missing_table = True\n\n        name_parts = name_parts[len(parent_name_parts) :]\n\n        values = Container(True)\n\n        self.inc()  # Skip closing bracket\n        if is_aot:\n            # TODO: Verify close bracket\n            self.inc()\n\n        cws, comment, trail = self._parse_comment_trail()\n\n        result = Null()\n        table = Table(\n            values,\n            Trivia(indent, cws, comment, trail),\n            is_aot,\n            name=name_parts[0].key if name_parts else key.key,\n            display_name=full_key.as_string(),\n            is_super_table=False,\n        )\n\n        if len(name_parts) > 1:\n            if missing_table:\n                # Missing super table\n                # i.e. a table initialized like this: [foo.bar]\n                # without initializing [foo]\n                #\n                # So we have to create the parent tables\n                table = Table(\n                    Container(True),\n                    Trivia(\"\", cws, comment, trail),\n                    is_aot and name_parts[0] in self._aot_stack,\n                    is_super_table=True,\n                    name=name_parts[0].key,\n                )\n\n            result = table\n            key = name_parts[0]\n\n            for i, _name in enumerate(name_parts[1:]):\n                child = table.get(\n                    _name,\n                    Table(\n                        Container(True),\n                        Trivia(indent, cws, comment, trail),\n                        is_aot and i == len(name_parts) - 2,\n                        is_super_table=i < len(name_parts) - 2,\n                        name=_name.key,\n                        display_name=(\n                            full_key.as_string() if i == len(name_parts) - 2 else None\n                        ),\n                    ),\n                )\n\n                if is_aot and i == len(name_parts) - 2:\n                    table.raw_append(_name, AoT([child], name=table.name, parsed=True))\n                else:\n                    table.raw_append(_name, child)\n\n                table = child\n                values = table.value\n        else:\n            if name_parts:\n                key = name_parts[0]\n\n        while not self.end():\n            item = self._parse_item()\n            if item:\n                _key, item = item\n                if not self._merge_ws(item, values):\n                    table.raw_append(_key, item)\n            else:\n                if self._current == \"[\":\n                    _, key_next = self._peek_table()\n\n                    if self._is_child(full_key, key_next):\n                        key_next, table_next = self._parse_table(full_key, table)\n\n                        table.raw_append(key_next, table_next)\n\n                        # Picking up any sibling\n                        while not self.end():\n                            _, key_next = self._peek_table()\n\n                            if not self._is_child(full_key, key_next):\n                                break\n\n                            key_next, table_next = self._parse_table(full_key, table)\n\n                            table.raw_append(key_next, table_next)\n\n                    break\n                else:\n                    raise self.parse_error(\n                        InternalParserError,\n                        \"_parse_item() returned None on a non-bracket character.\",\n                    )\n        table.value._validate_out_of_order_table()\n        if isinstance(result, Null):\n            result = table\n\n            if is_aot and (not self._aot_stack or full_key != self._aot_stack[-1]):\n                result = self._parse_aot(result, full_key)\n\n        return key, result\n\n    def _peek_table(self) -> tuple[bool, Key]:\n        \"\"\"\n        Peeks ahead non-intrusively by cloning then restoring the\n        initial state of the parser.\n\n        Returns the name of the table about to be parsed,\n        as well as whether it is part of an AoT.\n        \"\"\"\n        # we always want to restore after exiting this scope\n        with self._state(save_marker=True, restore=True):\n            if self._current != \"[\":\n                raise self.parse_error(\n                    InternalParserError,\n                    \"_peek_table() entered on non-bracket character\",\n                )\n\n            # AoT\n            self.inc()\n            is_aot = False\n            if self._current == \"[\":\n                self.inc()\n                is_aot = True\n            try:\n                return is_aot, self._parse_key()\n            except EmptyKeyError:\n                raise self.parse_error(EmptyTableNameError) from None\n\n    def _parse_aot(self, first: Table, name_first: Key) -> AoT:\n        \"\"\"\n        Parses all siblings of the provided table first and bundles them into\n        an AoT.\n        \"\"\"\n        payload = [first]\n        self._aot_stack.append(name_first)\n        while not self.end():\n            is_aot_next, name_next = self._peek_table()\n            if is_aot_next and name_next == name_first:\n                _, table = self._parse_table(name_first)\n                payload.append(table)\n            else:\n                break\n\n        self._aot_stack.pop()\n\n        return AoT(payload, parsed=True)\n\n    def _peek(self, n: int) -> str:\n        \"\"\"\n        Peeks ahead n characters.\n\n        n is the max number of characters that will be peeked.\n        \"\"\"\n        # we always want to restore after exiting this scope\n        with self._state(restore=True):\n            buf = \"\"\n            for _ in range(n):\n                if self._current not in \" \\t\\n\\r#,]}\" + self._src.EOF:\n                    buf += self._current\n                    self.inc()\n                    continue\n\n                break\n            return buf\n\n    def _peek_unicode(self, is_long: bool) -> tuple[str | None, str | None]:\n        \"\"\"\n        Peeks ahead non-intrusively by cloning then restoring the\n        initial state of the parser.\n\n        Returns the unicode value is it's a valid one else None.\n        \"\"\"\n        # we always want to restore after exiting this scope\n        with self._state(save_marker=True, restore=True):\n            if self._current not in {\"u\", \"U\"}:\n                raise self.parse_error(\n                    InternalParserError, \"_peek_unicode() entered on non-unicode value\"\n                )\n\n            self.inc()  # Dropping prefix\n            self.mark()\n\n            if is_long:\n                chars = 8\n            else:\n                chars = 4\n\n            if not self.inc_n(chars):\n                value, extracted = None, None\n            else:\n                extracted = self.extract()\n\n                if extracted[0].lower() == \"d\" and extracted[1].strip(\"01234567\"):\n                    return None, None\n\n                try:\n                    value = chr(int(extracted, 16))\n                except (ValueError, OverflowError):\n                    value = None\n\n            return value, extracted\n"}