{"exercises.py": "def measure_startup_perf():\n    # run by pytest_perf\n    import subprocess\n    import sys  # end warmup\n\n    subprocess.check_call([sys.executable, '-c', 'pass'])\n", "setup.py": "#!/usr/bin/env python\n\nimport os\nimport sys\nimport textwrap\n\nimport setuptools\nfrom setuptools.command.install import install\n\nhere = os.path.dirname(__file__)\n\n\npackage_data = dict(\n    setuptools=['script (dev).tmpl', 'script.tmpl', 'site-patch.py'],\n)\n\nforce_windows_specific_files = os.environ.get(\n    \"SETUPTOOLS_INSTALL_WINDOWS_SPECIFIC_FILES\", \"1\"\n).lower() not in (\"\", \"0\", \"false\", \"no\")\n\ninclude_windows_files = sys.platform == 'win32' or force_windows_specific_files\n\nif include_windows_files:\n    package_data.setdefault('setuptools', []).extend(['*.exe'])\n    package_data.setdefault('setuptools.command', []).extend(['*.xml'])\n\n\ndef pypi_link(pkg_filename):\n    \"\"\"\n    Given the filename, including md5 fragment, construct the\n    dependency link for PyPI.\n    \"\"\"\n    root = 'https://files.pythonhosted.org/packages/source'\n    name, sep, rest = pkg_filename.partition('-')\n    parts = root, name[0], name, pkg_filename\n    return '/'.join(parts)\n\n\nclass install_with_pth(install):\n    \"\"\"\n    Custom install command to install a .pth file for distutils patching.\n\n    This hack is necessary because there's no standard way to install behavior\n    on startup (and it's debatable if there should be one). This hack (ab)uses\n    the `extra_path` behavior in Setuptools to install a `.pth` file with\n    implicit behavior on startup to give higher precedence to the local version\n    of `distutils` over the version from the standard library.\n\n    Please do not replicate this behavior.\n    \"\"\"\n\n    _pth_name = 'distutils-precedence'\n    _pth_contents = (\n        textwrap.dedent(\n            \"\"\"\n        import os\n        var = 'SETUPTOOLS_USE_DISTUTILS'\n        enabled = os.environ.get(var, 'local') == 'local'\n        enabled and __import__('_distutils_hack').add_shim()\n        \"\"\"\n        )\n        .lstrip()\n        .replace('\\n', '; ')\n    )\n\n    def initialize_options(self):\n        install.initialize_options(self)\n        self.extra_path = self._pth_name, self._pth_contents\n\n    def finalize_options(self):\n        install.finalize_options(self)\n        self._restore_install_lib()\n\n    def _restore_install_lib(self):\n        \"\"\"\n        Undo secondary effect of `extra_path` adding to `install_lib`\n        \"\"\"\n        suffix = os.path.relpath(self.install_lib, self.install_libbase)\n\n        if suffix.strip() == self._pth_contents.strip():\n            self.install_lib = self.install_libbase\n\n\nsetup_params = dict(\n    cmdclass={'install': install_with_pth},\n    package_data=package_data,\n)\n\nif __name__ == '__main__':\n    # allow setup.py to run from another directory\n    # TODO: Use a proper conditional statement here\n    here and os.chdir(here)  # type: ignore[func-returns-value]\n    dist = setuptools.setup(**setup_params)\n", "tools/finalize.py": "\"\"\"\nFinalize the repo for a release. Invokes towncrier and bumpversion.\n\"\"\"\n\n__requires__ = ['bump2version', 'towncrier', 'jaraco.develop>=7.21']\n\n\nimport subprocess\nimport pathlib\nimport re\nimport sys\n\nfrom jaraco.develop import towncrier\n\n\nbump_version_command = [\n    sys.executable,\n    '-m',\n    'bumpversion',\n    towncrier.release_kind(),\n]\n\n\ndef get_version():\n    cmd = bump_version_command + ['--dry-run', '--verbose']\n    out = subprocess.check_output(cmd, text=True, encoding='utf-8')\n    return re.search('^new_version=(.*)', out, re.MULTILINE).group(1)\n\n\ndef update_changelog():\n    towncrier.run('build', '--yes')\n    _repair_changelog()\n\n\ndef _repair_changelog():\n    \"\"\"\n    Workaround for #2666\n    \"\"\"\n    changelog_fn = pathlib.Path('NEWS.rst')\n    changelog = changelog_fn.read_text(encoding='utf-8')\n    fixed = re.sub(r'^(v[0-9.]+)v[0-9.]+$', r'\\1', changelog, flags=re.M)\n    changelog_fn.write_text(fixed, encoding='utf-8')\n    subprocess.check_output(['git', 'add', changelog_fn])\n\n\ndef bump_version():\n    cmd = bump_version_command + ['--allow-dirty']\n    subprocess.check_call(cmd)\n\n\ndef ensure_config():\n    \"\"\"\n    Double-check that Git has an e-mail configured.\n    \"\"\"\n    subprocess.check_output(['git', 'config', 'user.email'])\n\n\nif __name__ == '__main__':\n    print(\"Cutting release at\", get_version())\n    ensure_config()\n    towncrier.check_changes()\n    update_changelog()\n    bump_version()\n", "tools/vendored.py": "import re\nimport shutil\nimport sys\nimport subprocess\nfrom textwrap import dedent\n\nfrom path import Path\n\n\ndef remove_all(paths):\n    for path in paths:\n        path.rmtree() if path.is_dir() else path.remove()\n\n\ndef update_vendored():\n    update_pkg_resources()\n    update_setuptools()\n\n\ndef rewrite_packaging(pkg_files, new_root):\n    \"\"\"\n    Rewrite imports in packaging to redirect to vendored copies.\n    \"\"\"\n    for file in pkg_files.glob('*.py'):\n        text = file.text()\n        text = re.sub(r' (pyparsing)', rf' {new_root}.\\1', text)\n        text = text.replace(\n            'from six.moves.urllib import parse',\n            'from urllib import parse',\n        )\n        file.write_text(text)\n\n\ndef rewrite_jaraco_text(pkg_files, new_root):\n    \"\"\"\n    Rewrite imports in jaraco.text to redirect to vendored copies.\n    \"\"\"\n    for file in pkg_files.glob('*.py'):\n        text = file.read_text()\n        text = re.sub(r' (jaraco\\.)', rf' {new_root}.\\1', text)\n        text = re.sub(r' (importlib_resources)', rf' {new_root}.\\1', text)\n        # suppress loading of lorem_ipsum; ref #3072\n        text = re.sub(r'^lorem_ipsum.*\\n$', '', text, flags=re.M)\n        file.write_text(text)\n\n\ndef repair_namespace(pkg_files):\n    # required for zip-packaged setuptools #3084\n    pkg_files.joinpath('__init__.py').write_text('')\n\n\ndef rewrite_jaraco_functools(pkg_files, new_root):\n    \"\"\"\n    Rewrite imports in jaraco.functools to redirect to vendored copies.\n    \"\"\"\n    for file in pkg_files.glob('*.py'):\n        text = file.read_text()\n        text = re.sub(r' (more_itertools)', rf' {new_root}.\\1', text)\n        file.write_text(text)\n\n\ndef rewrite_jaraco_context(pkg_files, new_root):\n    \"\"\"\n    Rewrite imports in jaraco.context to redirect to vendored copies.\n    \"\"\"\n    for file in pkg_files.glob('context.py'):\n        text = file.read_text()\n        text = re.sub(r' (backports)', rf' {new_root}.\\1', text)\n        file.write_text(text)\n\n\ndef rewrite_importlib_resources(pkg_files, new_root):\n    \"\"\"\n    Rewrite imports in importlib_resources to redirect to vendored copies.\n    \"\"\"\n    for file in pkg_files.glob('*.py'):\n        text = file.read_text().replace('importlib_resources.abc', '.abc')\n        text = text.replace('zipp', '..zipp')\n        file.write_text(text)\n\n\ndef rewrite_importlib_metadata(pkg_files, new_root):\n    \"\"\"\n    Rewrite imports in importlib_metadata to redirect to vendored copies.\n    \"\"\"\n    for file in pkg_files.glob('*.py'):\n        text = file.read_text()\n        text = text.replace('import zipp', 'from .. import zipp')\n        file.write_text(text)\n\n\ndef rewrite_more_itertools(pkg_files: Path):\n    \"\"\"\n    Defer import of concurrent.futures. Workaround for #3090.\n    \"\"\"\n    more_file = pkg_files.joinpath('more.py')\n    text = more_file.read_text()\n    text = re.sub(r'^.*concurrent.futures.*?\\n', '', text, flags=re.MULTILINE)\n    text = re.sub(\n        'ThreadPoolExecutor',\n        '__import__(\"concurrent.futures\").futures.ThreadPoolExecutor',\n        text,\n    )\n    more_file.write_text(text)\n\n\ndef rewrite_wheel(pkg_files: Path):\n    \"\"\"\n    Remove parts of wheel not needed by bdist_wheel, and rewrite imports to use\n    setuptools's own code or vendored dependencies.\n    \"\"\"\n    shutil.rmtree(pkg_files / 'cli')\n    shutil.rmtree(pkg_files / 'vendored')\n    pkg_files.joinpath('_setuptools_logging.py').unlink()\n    pkg_files.joinpath('__main__.py').unlink()\n    pkg_files.joinpath('bdist_wheel.py').unlink()\n\n    # Rewrite vendored imports to use setuptools's own vendored libraries\n    for path in pkg_files.iterdir():\n        if path.suffix == '.py':  # type: ignore[attr-defined]\n            code = path.read_text()\n            if path.name == 'wheelfile.py':\n                code = re.sub(\n                    r\"^from wheel.util import \",\n                    r\"from .util import \",\n                    code,\n                    flags=re.MULTILINE,\n                )\n\n                # No need to keep the wheel.cli package just for this trivial exception\n                code = re.sub(\n                    r\"^from wheel.cli import WheelError\\n\",\n                    r\"\",\n                    code,\n                    flags=re.MULTILINE,\n                )\n                code += dedent(\n                    \"\"\"\n\n                    class WheelError(Exception):\n                        pass\n                    \"\"\"\n                )\n            else:\n                code = re.sub(\n                    r\"^from \\.vendored\\.([\\w.]+) import \",\n                    r\"from ..\\1 import \",\n                    code,\n                    flags=re.MULTILINE,\n                )\n                code = re.sub(\n                    r\"^from \\.util import log$\",\n                    r\"from distutils import log$\",\n                    code,\n                    flags=re.MULTILINE,\n                )\n\n            path.write_text(code)  # type: ignore[attr-defined]\n\n\ndef rewrite_platformdirs(pkg_files: Path):\n    \"\"\"\n    Replace some absolute imports with relative ones.\n    \"\"\"\n    init = pkg_files.joinpath('__init__.py')\n    text = init.read_text()\n    text = text.replace('from platformdirs.', 'from .')\n    init.write_text(text)\n\n\ndef clean(vendor):\n    \"\"\"\n    Remove all files out of the vendor directory except the meta\n    data (as pip uninstall doesn't support -t).\n    \"\"\"\n    ignored = ['vendored.txt', 'ruff.toml']\n    remove_all(path for path in vendor.glob('*') if path.basename() not in ignored)\n\n\ndef install(vendor):\n    clean(vendor)\n    install_args = [\n        sys.executable,\n        '-m',\n        'pip',\n        'install',\n        '-r',\n        str(vendor / 'vendored.txt'),\n        '-t',\n        str(vendor),\n    ]\n    subprocess.check_call(install_args)\n    (vendor / '__init__.py').write_text('')\n\n\ndef update_pkg_resources():\n    vendor = Path('pkg_resources/_vendor')\n    install(vendor)\n    rewrite_packaging(vendor / 'packaging', 'pkg_resources.extern')\n    repair_namespace(vendor / 'jaraco')\n    repair_namespace(vendor / 'backports')\n    rewrite_jaraco_text(vendor / 'jaraco/text', 'pkg_resources.extern')\n    rewrite_jaraco_functools(vendor / 'jaraco/functools', 'pkg_resources.extern')\n    rewrite_jaraco_context(vendor / 'jaraco', 'pkg_resources.extern')\n    rewrite_importlib_resources(vendor / 'importlib_resources', 'pkg_resources.extern')\n    rewrite_more_itertools(vendor / \"more_itertools\")\n    rewrite_platformdirs(vendor / \"platformdirs\")\n\n\ndef update_setuptools():\n    vendor = Path('setuptools/_vendor')\n    install(vendor)\n    rewrite_packaging(vendor / 'packaging', 'setuptools.extern')\n    repair_namespace(vendor / 'jaraco')\n    repair_namespace(vendor / 'backports')\n    rewrite_jaraco_text(vendor / 'jaraco/text', 'setuptools.extern')\n    rewrite_jaraco_functools(vendor / 'jaraco/functools', 'setuptools.extern')\n    rewrite_jaraco_context(vendor / 'jaraco', 'setuptools.extern')\n    rewrite_importlib_resources(vendor / 'importlib_resources', 'setuptools.extern')\n    rewrite_importlib_metadata(vendor / 'importlib_metadata', 'setuptools.extern')\n    rewrite_more_itertools(vendor / \"more_itertools\")\n    rewrite_wheel(vendor / \"wheel\")\n\n\ndef yield_top_level(name):\n    \"\"\"Iterate over all modules and (top level) packages vendored\n    >>> roots = set(yield_top_level(\"setuptools\"))\n    >>> examples = roots & {\"jaraco\", \"backports\", \"zipp\"}\n    >>> list(sorted(examples))\n    ['backports', 'jaraco', 'zipp']\n    >>> 'bin' in examples\n    False\n    \"\"\"\n    vendor = Path(f\"{name}/_vendor\")\n    ignore = {\"__pycache__\", \"__init__.py\", \".ruff_cache\", \"bin\"}\n\n    for item in sorted(vendor.iterdir()):\n        if item.name in ignore:\n            continue\n        if item.is_dir() and item.suffix != \".dist-info\":\n            yield str(item.name)\n        if item.is_file() and item.suffix == \".py\":\n            yield str(item.stem)\n\n\n__name__ == '__main__' and update_vendored()\n", "tools/generate_validation_code.py": "from __future__ import annotations\n\nfrom os import PathLike\nimport subprocess\nimport sys\n\nfrom pathlib import Path\n\n\ndef generate_pyproject_validation(dest: str | PathLike[str]):\n    \"\"\"\n    Generates validation code for ``pyproject.toml`` based on JSON schemas and the\n    ``validate-pyproject`` library.\n    \"\"\"\n    cmd = [\n        sys.executable,\n        \"-m\",\n        \"validate_pyproject.pre_compile\",\n        f\"--output-dir={dest}\",\n        \"--enable-plugins\",\n        \"setuptools\",\n        \"distutils\",\n        \"--very-verbose\",\n    ]\n    subprocess.check_call(cmd)\n    print(f\"Validation code generated at: {dest}\")\n\n\ndef main():\n    generate_pyproject_validation(Path(\"setuptools/config/_validate_pyproject\"))\n\n\n__name__ == '__main__' and main()\n", "tools/ppc64le-patch.py": "\"\"\"\nExcept on bionic, Travis Linux base image for PPC64LE\nplatform lacks the proper\npermissions to the directory ~/.cache/pip/wheels that allow\nthe user running travis build to install pip packages.\nTODO: is someone tracking this issue? Maybe just move to bionic?\n\"\"\"\n\nimport subprocess\nimport collections\nimport os\n\n\ndef patch():\n    env = collections.defaultdict(str, os.environ)\n    if env['TRAVIS_CPU_ARCH'] != 'ppc64le':\n        return\n    cmd = [\n        'sudo',\n        'chown',\n        '-Rfv',\n        '{USER}:{GROUP}'.format_map(env),\n        os.path.expanduser('~/.cache/pip/wheels'),\n    ]\n    subprocess.Popen(cmd)\n\n\n__name__ == '__main__' and patch()\n", "tools/build_launchers.py": "\"\"\"\nBuild executable launchers for Windows.\n\nBuild module requires installation of\n`CMake <https://cmake.org/download/>`_ and Visual Studio.\n\nPlease ensure that buildtools v143 or later are installed for Visual\nStudio. Ensure that you install ARM build tools.\n\nFrom Visual Studio Installer:\nVisual Studio -> Modify -> Individual Components\n\nList of components needed to install to compile on ARM:\n- C++ Universal Windows Platform Support for v143 build Tools (ARM64)\n- MSVC v143 - VS 2022 C++ ARM64 build tools (latest)\n- MSVC v143 - VS 2022 C++ ARM64 Spectre-mitigated libs (latest)\n- C++ ATL for latest v143 build tools (ARM64)\n\"\"\"\n\nimport os\nimport functools\nimport itertools\nimport pathlib\nimport shutil\nimport subprocess\nimport tempfile\n\n\nBUILD_TARGETS = [\"cli\", \"gui\"]\nGUI = {\"cli\": 0, \"gui\": 1}\nBUILD_PLATFORMS = [\"Win32\", \"x64\", \"arm64\"]\nREPO_ROOT = pathlib.Path(__file__).parent.parent.resolve()\nLAUNCHER_CMAKE_PROJECT = REPO_ROOT / \"launcher\"\nMSBUILD_OUT_DIR = REPO_ROOT / \"setuptools\"\nVISUAL_STUDIO_VERSION = \"Visual Studio 17 2022\"\n\"\"\"\nVersion of Visual Studio that is currently installed on the machine.\nNot tested with the older visual studios less then 16 version.\nGenerators\n* Visual Studio 17 2022        = Generates Visual Studio 2022 project files.\n                                 Use -A option to specify architecture.\n  Visual Studio 16 2019        = Generates Visual Studio 2019 project files.\n                                 Use -A option to specify architecture.\n  Visual Studio 15 2017 [arch] = Generates Visual Studio 2017 project files.\n                                 Optional [arch] can be \"Win64\" or \"ARM\".\n  Visual Studio 14 2015 [arch] = Generates Visual Studio 2015 project files.\n                                 Optional [arch] can be \"Win64\" or \"ARM\".\n  Visual Studio 12 2013 [arch] = Generates Visual Studio 2013 project files.\n                                 Optional [arch] can be \"Win64\" or \"ARM\".\n  Visual Studio 11 2012 [arch] = Deprecated.  Generates Visual Studio 2012\n                                 project files.  Optional [arch] can be\n                                 \"Win64\" or \"ARM\".\n  Visual Studio 9 2008 [arch]  = Generates Visual Studio 2008 project files.\n                                 Optional [arch] can be \"Win64\" or \"IA64\".\n\"\"\"\n\n\ndef resolve_platform(platform: str):\n    if platform in [\"Win32\", \"x64\"]:\n        return platform[-2:]\n    return platform\n\n\ndef get_executable_name(name, platform: str):\n    return f\"{name}-{resolve_platform(platform)}\"\n\n\ndef generate_cmake_project(build_arena, cmake_project_path, platform, is_gui):\n    cmd = [\n        get_cmake(),\n        '-G',\n        VISUAL_STUDIO_VERSION,\n        '-A',\n        platform,\n        cmake_project_path,\n        f'-DGUI={is_gui}',\n    ]\n    subprocess.check_call(cmd, cwd=build_arena)\n\n\ndef build_cmake_project_with_msbuild(build_arena, msbuild_parameters):\n    cmd = [\n        get_msbuild(),\n        'launcher.vcxproj',\n    ] + msbuild_parameters\n    subprocess.check_call(cmd, cwd=build_arena)\n\n\n@functools.lru_cache\ndef get_cmake():\n    \"\"\"Find CMake using registry.\"\"\"\n    import winreg\n\n    with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r\"SOFTWARE\\Kitware\\CMake\") as key:\n        root = pathlib.Path(winreg.QueryValueEx(key, \"InstallDir\")[0])\n    return root / 'bin\\\\CMake.exe'\n\n\n@functools.lru_cache\ndef get_msbuild():\n    \"\"\"Use VSWhere to find MSBuild.\"\"\"\n    vswhere = pathlib.Path(\n        os.environ['ProgramFiles(x86)'],\n        'Microsoft Visual Studio',\n        'Installer',\n        'vswhere.exe',\n    )\n    cmd = [\n        vswhere,\n        '-latest',\n        '-prerelease',\n        '-products',\n        '*',\n        '-requires',\n        'Microsoft.Component.MSBuild',\n        '-find',\n        r'MSBuild\\**\\Bin\\MSBuild.exe',\n    ]\n    try:\n        return subprocess.check_output(cmd, encoding='utf-8', text=True).strip()\n    except subprocess.CalledProcessError as e:\n        raise SystemExit(\"Unable to find MSBuild; check Visual Studio install\") from e\n\n\ndef do_build(arena, platform, target):\n    print(f\"Building {target} for {platform}\")\n\n    generate_cmake_project(arena, LAUNCHER_CMAKE_PROJECT, platform, GUI[target])\n\n    build_params = [\n        '/t:build',\n        '/property:Configuration=Release',\n        f'/property:Platform={platform}',\n        f'/p:OutDir={MSBUILD_OUT_DIR.resolve()}',\n        f'/p:TargetName={get_executable_name(target, platform)}',\n    ]\n    build_cmake_project_with_msbuild(arena, build_params)\n\n\ndef main():\n    # check for executables early\n    get_cmake()\n    get_msbuild()\n\n    for platform, target in itertools.product(BUILD_PLATFORMS, BUILD_TARGETS):\n        with tempfile.TemporaryDirectory(dir=REPO_ROOT) as arena:\n            do_build(arena, platform, target)\n\n    # copy win32 as default executables\n    for target in BUILD_TARGETS:\n        executable = MSBUILD_OUT_DIR / f\"{get_executable_name(target, 'Win32')}.exe\"\n        destination_executable = MSBUILD_OUT_DIR / f\"{target}.exe\"\n        shutil.copy(executable, destination_executable)\n\n\nif __name__ == \"__main__\":\n    main()\n", "setuptools/logging.py": "import sys\nimport inspect\nimport logging\nimport distutils.log\nfrom . import monkey\n\n\ndef _not_warning(record):\n    return record.levelno < logging.WARNING\n\n\ndef configure():\n    \"\"\"\n    Configure logging to emit warning and above to stderr\n    and everything else to stdout. This behavior is provided\n    for compatibility with distutils.log but may change in\n    the future.\n    \"\"\"\n    err_handler = logging.StreamHandler()\n    err_handler.setLevel(logging.WARNING)\n    out_handler = logging.StreamHandler(sys.stdout)\n    out_handler.addFilter(_not_warning)\n    handlers = err_handler, out_handler\n    logging.basicConfig(\n        format=\"{message}\", style='{', handlers=handlers, level=logging.DEBUG\n    )\n    if inspect.ismodule(distutils.dist.log):\n        monkey.patch_func(set_threshold, distutils.log, 'set_threshold')\n        # For some reason `distutils.log` module is getting cached in `distutils.dist`\n        # and then loaded again when patched,\n        # implying: id(distutils.log) != id(distutils.dist.log).\n        # Make sure the same module object is used everywhere:\n        distutils.dist.log = distutils.log\n\n\ndef set_threshold(level):\n    logging.root.setLevel(level * 10)\n    return set_threshold.unpatched(level)\n", "setuptools/discovery.py": "\"\"\"Automatic discovery of Python modules and packages (for inclusion in the\ndistribution) and other config values.\n\nFor the purposes of this module, the following nomenclature is used:\n\n- \"src-layout\": a directory representing a Python project that contains a \"src\"\n  folder. Everything under the \"src\" folder is meant to be included in the\n  distribution when packaging the project. Example::\n\n    .\n    \u251c\u2500\u2500 tox.ini\n    \u251c\u2500\u2500 pyproject.toml\n    \u2514\u2500\u2500 src/\n        \u2514\u2500\u2500 mypkg/\n            \u251c\u2500\u2500 __init__.py\n            \u251c\u2500\u2500 mymodule.py\n            \u2514\u2500\u2500 my_data_file.txt\n\n- \"flat-layout\": a Python project that does not use \"src-layout\" but instead\n  have a directory under the project root for each package::\n\n    .\n    \u251c\u2500\u2500 tox.ini\n    \u251c\u2500\u2500 pyproject.toml\n    \u2514\u2500\u2500 mypkg/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 mymodule.py\n        \u2514\u2500\u2500 my_data_file.txt\n\n- \"single-module\": a project that contains a single Python script direct under\n  the project root (no directory used)::\n\n    .\n    \u251c\u2500\u2500 tox.ini\n    \u251c\u2500\u2500 pyproject.toml\n    \u2514\u2500\u2500 mymodule.py\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport itertools\nimport os\nfrom fnmatch import fnmatchcase\nfrom glob import glob\nfrom pathlib import Path\nfrom typing import (\n    TYPE_CHECKING,\n    Iterable,\n    Iterator,\n    Mapping,\n)\n\nimport _distutils_hack.override  # noqa: F401\n\nfrom ._path import StrPath\nfrom distutils import log\nfrom distutils.util import convert_path\n\nStrIter = Iterator[str]\n\nchain_iter = itertools.chain.from_iterable\n\nif TYPE_CHECKING:\n    from setuptools import Distribution  # noqa\n\n\ndef _valid_name(path: StrPath) -> bool:\n    # Ignore invalid names that cannot be imported directly\n    return os.path.basename(path).isidentifier()\n\n\nclass _Filter:\n    \"\"\"\n    Given a list of patterns, create a callable that will be true only if\n    the input matches at least one of the patterns.\n    \"\"\"\n\n    def __init__(self, *patterns: str):\n        self._patterns = dict.fromkeys(patterns)\n\n    def __call__(self, item: str) -> bool:\n        return any(fnmatchcase(item, pat) for pat in self._patterns)\n\n    def __contains__(self, item: str) -> bool:\n        return item in self._patterns\n\n\nclass _Finder:\n    \"\"\"Base class that exposes functionality for module/package finders\"\"\"\n\n    ALWAYS_EXCLUDE: tuple[str, ...] = ()\n    DEFAULT_EXCLUDE: tuple[str, ...] = ()\n\n    @classmethod\n    def find(\n        cls,\n        where: StrPath = '.',\n        exclude: Iterable[str] = (),\n        include: Iterable[str] = ('*',),\n    ) -> list[str]:\n        \"\"\"Return a list of all Python items (packages or modules, depending on\n        the finder implementation) found within directory 'where'.\n\n        'where' is the root directory which will be searched.\n        It should be supplied as a \"cross-platform\" (i.e. URL-style) path;\n        it will be converted to the appropriate local path syntax.\n\n        'exclude' is a sequence of names to exclude; '*' can be used\n        as a wildcard in the names.\n        When finding packages, 'foo.*' will exclude all subpackages of 'foo'\n        (but not 'foo' itself).\n\n        'include' is a sequence of names to include.\n        If it's specified, only the named items will be included.\n        If it's not specified, all found items will be included.\n        'include' can contain shell style wildcard patterns just like\n        'exclude'.\n        \"\"\"\n\n        exclude = exclude or cls.DEFAULT_EXCLUDE\n        return list(\n            cls._find_iter(\n                convert_path(str(where)),\n                _Filter(*cls.ALWAYS_EXCLUDE, *exclude),\n                _Filter(*include),\n            )\n        )\n\n    @classmethod\n    def _find_iter(cls, where: StrPath, exclude: _Filter, include: _Filter) -> StrIter:\n        raise NotImplementedError\n\n\nclass PackageFinder(_Finder):\n    \"\"\"\n    Generate a list of all Python packages found within a directory\n    \"\"\"\n\n    ALWAYS_EXCLUDE = (\"ez_setup\", \"*__pycache__\")\n\n    @classmethod\n    def _find_iter(cls, where: StrPath, exclude: _Filter, include: _Filter) -> StrIter:\n        \"\"\"\n        All the packages found in 'where' that pass the 'include' filter, but\n        not the 'exclude' filter.\n        \"\"\"\n        for root, dirs, files in os.walk(str(where), followlinks=True):\n            # Copy dirs to iterate over it, then empty dirs.\n            all_dirs = dirs[:]\n            dirs[:] = []\n\n            for dir in all_dirs:\n                full_path = os.path.join(root, dir)\n                rel_path = os.path.relpath(full_path, where)\n                package = rel_path.replace(os.path.sep, '.')\n\n                # Skip directory trees that are not valid packages\n                if '.' in dir or not cls._looks_like_package(full_path, package):\n                    continue\n\n                # Should this package be included?\n                if include(package) and not exclude(package):\n                    yield package\n\n                # Early pruning if there is nothing else to be scanned\n                if f\"{package}*\" in exclude or f\"{package}.*\" in exclude:\n                    continue\n\n                # Keep searching subdirectories, as there may be more packages\n                # down there, even if the parent was excluded.\n                dirs.append(dir)\n\n    @staticmethod\n    def _looks_like_package(path: StrPath, _package_name: str) -> bool:\n        \"\"\"Does a directory look like a package?\"\"\"\n        return os.path.isfile(os.path.join(path, '__init__.py'))\n\n\nclass PEP420PackageFinder(PackageFinder):\n    @staticmethod\n    def _looks_like_package(_path: StrPath, _package_name: str) -> bool:\n        return True\n\n\nclass ModuleFinder(_Finder):\n    \"\"\"Find isolated Python modules.\n    This function will **not** recurse subdirectories.\n    \"\"\"\n\n    @classmethod\n    def _find_iter(cls, where: StrPath, exclude: _Filter, include: _Filter) -> StrIter:\n        for file in glob(os.path.join(where, \"*.py\")):\n            module, _ext = os.path.splitext(os.path.basename(file))\n\n            if not cls._looks_like_module(module):\n                continue\n\n            if include(module) and not exclude(module):\n                yield module\n\n    _looks_like_module = staticmethod(_valid_name)\n\n\n# We have to be extra careful in the case of flat layout to not include files\n# and directories not meant for distribution (e.g. tool-related)\n\n\nclass FlatLayoutPackageFinder(PEP420PackageFinder):\n    _EXCLUDE = (\n        \"ci\",\n        \"bin\",\n        \"debian\",\n        \"doc\",\n        \"docs\",\n        \"documentation\",\n        \"manpages\",\n        \"news\",\n        \"newsfragments\",\n        \"changelog\",\n        \"test\",\n        \"tests\",\n        \"unit_test\",\n        \"unit_tests\",\n        \"example\",\n        \"examples\",\n        \"scripts\",\n        \"tools\",\n        \"util\",\n        \"utils\",\n        \"python\",\n        \"build\",\n        \"dist\",\n        \"venv\",\n        \"env\",\n        \"requirements\",\n        # ---- Task runners / Build tools ----\n        \"tasks\",  # invoke\n        \"fabfile\",  # fabric\n        \"site_scons\",  # SCons\n        # ---- Other tools ----\n        \"benchmark\",\n        \"benchmarks\",\n        \"exercise\",\n        \"exercises\",\n        \"htmlcov\",  # Coverage.py\n        # ---- Hidden directories/Private packages ----\n        \"[._]*\",\n    )\n\n    DEFAULT_EXCLUDE = tuple(chain_iter((p, f\"{p}.*\") for p in _EXCLUDE))\n    \"\"\"Reserved package names\"\"\"\n\n    @staticmethod\n    def _looks_like_package(_path: StrPath, package_name: str) -> bool:\n        names = package_name.split('.')\n        # Consider PEP 561\n        root_pkg_is_valid = names[0].isidentifier() or names[0].endswith(\"-stubs\")\n        return root_pkg_is_valid and all(name.isidentifier() for name in names[1:])\n\n\nclass FlatLayoutModuleFinder(ModuleFinder):\n    DEFAULT_EXCLUDE = (\n        \"setup\",\n        \"conftest\",\n        \"test\",\n        \"tests\",\n        \"example\",\n        \"examples\",\n        \"build\",\n        # ---- Task runners ----\n        \"toxfile\",\n        \"noxfile\",\n        \"pavement\",\n        \"dodo\",\n        \"tasks\",\n        \"fabfile\",\n        # ---- Other tools ----\n        \"[Ss][Cc]onstruct\",  # SCons\n        \"conanfile\",  # Connan: C/C++ build tool\n        \"manage\",  # Django\n        \"benchmark\",\n        \"benchmarks\",\n        \"exercise\",\n        \"exercises\",\n        # ---- Hidden files/Private modules ----\n        \"[._]*\",\n    )\n    \"\"\"Reserved top-level module names\"\"\"\n\n\ndef _find_packages_within(root_pkg: str, pkg_dir: StrPath) -> list[str]:\n    nested = PEP420PackageFinder.find(pkg_dir)\n    return [root_pkg] + [\".\".join((root_pkg, n)) for n in nested]\n\n\nclass ConfigDiscovery:\n    \"\"\"Fill-in metadata and options that can be automatically derived\n    (from other metadata/options, the file system or conventions)\n    \"\"\"\n\n    def __init__(self, distribution: Distribution):\n        self.dist = distribution\n        self._called = False\n        self._disabled = False\n        self._skip_ext_modules = False\n\n    def _disable(self):\n        \"\"\"Internal API to disable automatic discovery\"\"\"\n        self._disabled = True\n\n    def _ignore_ext_modules(self):\n        \"\"\"Internal API to disregard ext_modules.\n\n        Normally auto-discovery would not be triggered if ``ext_modules`` are set\n        (this is done for backward compatibility with existing packages relying on\n        ``setup.py`` or ``setup.cfg``). However, ``setuptools`` can call this function\n        to ignore given ``ext_modules`` and proceed with the auto-discovery if\n        ``packages`` and ``py_modules`` are not given (e.g. when using pyproject.toml\n        metadata).\n        \"\"\"\n        self._skip_ext_modules = True\n\n    @property\n    def _root_dir(self) -> StrPath:\n        # The best is to wait until `src_root` is set in dist, before using _root_dir.\n        return self.dist.src_root or os.curdir\n\n    @property\n    def _package_dir(self) -> dict[str, str]:\n        if self.dist.package_dir is None:\n            return {}\n        return self.dist.package_dir\n\n    def __call__(self, force=False, name=True, ignore_ext_modules=False):\n        \"\"\"Automatically discover missing configuration fields\n        and modifies the given ``distribution`` object in-place.\n\n        Note that by default this will only have an effect the first time the\n        ``ConfigDiscovery`` object is called.\n\n        To repeatedly invoke automatic discovery (e.g. when the project\n        directory changes), please use ``force=True`` (or create a new\n        ``ConfigDiscovery`` instance).\n        \"\"\"\n        if force is False and (self._called or self._disabled):\n            # Avoid overhead of multiple calls\n            return\n\n        self._analyse_package_layout(ignore_ext_modules)\n        if name:\n            self.analyse_name()  # depends on ``packages`` and ``py_modules``\n\n        self._called = True\n\n    def _explicitly_specified(self, ignore_ext_modules: bool) -> bool:\n        \"\"\"``True`` if the user has specified some form of package/module listing\"\"\"\n        ignore_ext_modules = ignore_ext_modules or self._skip_ext_modules\n        ext_modules = not (self.dist.ext_modules is None or ignore_ext_modules)\n        return (\n            self.dist.packages is not None\n            or self.dist.py_modules is not None\n            or ext_modules\n            or hasattr(self.dist, \"configuration\")\n            and self.dist.configuration\n            # ^ Some projects use numpy.distutils.misc_util.Configuration\n        )\n\n    def _analyse_package_layout(self, ignore_ext_modules: bool) -> bool:\n        if self._explicitly_specified(ignore_ext_modules):\n            # For backward compatibility, just try to find modules/packages\n            # when nothing is given\n            return True\n\n        log.debug(\n            \"No `packages` or `py_modules` configuration, performing \"\n            \"automatic discovery.\"\n        )\n\n        return (\n            self._analyse_explicit_layout()\n            or self._analyse_src_layout()\n            # flat-layout is the trickiest for discovery so it should be last\n            or self._analyse_flat_layout()\n        )\n\n    def _analyse_explicit_layout(self) -> bool:\n        \"\"\"The user can explicitly give a package layout via ``package_dir``\"\"\"\n        package_dir = self._package_dir.copy()  # don't modify directly\n        package_dir.pop(\"\", None)  # This falls under the \"src-layout\" umbrella\n        root_dir = self._root_dir\n\n        if not package_dir:\n            return False\n\n        log.debug(f\"`explicit-layout` detected -- analysing {package_dir}\")\n        pkgs = chain_iter(\n            _find_packages_within(pkg, os.path.join(root_dir, parent_dir))\n            for pkg, parent_dir in package_dir.items()\n        )\n        self.dist.packages = list(pkgs)\n        log.debug(f\"discovered packages -- {self.dist.packages}\")\n        return True\n\n    def _analyse_src_layout(self) -> bool:\n        \"\"\"Try to find all packages or modules under the ``src`` directory\n        (or anything pointed by ``package_dir[\"\"]``).\n\n        The \"src-layout\" is relatively safe for automatic discovery.\n        We assume that everything within is meant to be included in the\n        distribution.\n\n        If ``package_dir[\"\"]`` is not given, but the ``src`` directory exists,\n        this function will set ``package_dir[\"\"] = \"src\"``.\n        \"\"\"\n        package_dir = self._package_dir\n        src_dir = os.path.join(self._root_dir, package_dir.get(\"\", \"src\"))\n        if not os.path.isdir(src_dir):\n            return False\n\n        log.debug(f\"`src-layout` detected -- analysing {src_dir}\")\n        package_dir.setdefault(\"\", os.path.basename(src_dir))\n        self.dist.package_dir = package_dir  # persist eventual modifications\n        self.dist.packages = PEP420PackageFinder.find(src_dir)\n        self.dist.py_modules = ModuleFinder.find(src_dir)\n        log.debug(f\"discovered packages -- {self.dist.packages}\")\n        log.debug(f\"discovered py_modules -- {self.dist.py_modules}\")\n        return True\n\n    def _analyse_flat_layout(self) -> bool:\n        \"\"\"Try to find all packages and modules under the project root.\n\n        Since the ``flat-layout`` is more dangerous in terms of accidentally including\n        extra files/directories, this function is more conservative and will raise an\n        error if multiple packages or modules are found.\n\n        This assumes that multi-package dists are uncommon and refuse to support that\n        use case in order to be able to prevent unintended errors.\n        \"\"\"\n        log.debug(f\"`flat-layout` detected -- analysing {self._root_dir}\")\n        return self._analyse_flat_packages() or self._analyse_flat_modules()\n\n    def _analyse_flat_packages(self) -> bool:\n        self.dist.packages = FlatLayoutPackageFinder.find(self._root_dir)\n        top_level = remove_nested_packages(remove_stubs(self.dist.packages))\n        log.debug(f\"discovered packages -- {self.dist.packages}\")\n        self._ensure_no_accidental_inclusion(top_level, \"packages\")\n        return bool(top_level)\n\n    def _analyse_flat_modules(self) -> bool:\n        self.dist.py_modules = FlatLayoutModuleFinder.find(self._root_dir)\n        log.debug(f\"discovered py_modules -- {self.dist.py_modules}\")\n        self._ensure_no_accidental_inclusion(self.dist.py_modules, \"modules\")\n        return bool(self.dist.py_modules)\n\n    def _ensure_no_accidental_inclusion(self, detected: list[str], kind: str):\n        if len(detected) > 1:\n            from inspect import cleandoc\n\n            from setuptools.errors import PackageDiscoveryError\n\n            msg = f\"\"\"Multiple top-level {kind} discovered in a flat-layout: {detected}.\n\n            To avoid accidental inclusion of unwanted files or directories,\n            setuptools will not proceed with this build.\n\n            If you are trying to create a single distribution with multiple {kind}\n            on purpose, you should not rely on automatic discovery.\n            Instead, consider the following options:\n\n            1. set up custom discovery (`find` directive with `include` or `exclude`)\n            2. use a `src-layout`\n            3. explicitly set `py_modules` or `packages` with a list of names\n\n            To find more information, look for \"package discovery\" on setuptools docs.\n            \"\"\"\n            raise PackageDiscoveryError(cleandoc(msg))\n\n    def analyse_name(self):\n        \"\"\"The packages/modules are the essential contribution of the author.\n        Therefore the name of the distribution can be derived from them.\n        \"\"\"\n        if self.dist.metadata.name or self.dist.name:\n            # get_name() is not reliable (can return \"UNKNOWN\")\n            return\n\n        log.debug(\"No `name` configuration, performing automatic discovery\")\n\n        name = (\n            self._find_name_single_package_or_module()\n            or self._find_name_from_packages()\n        )\n        if name:\n            self.dist.metadata.name = name\n\n    def _find_name_single_package_or_module(self) -> str | None:\n        \"\"\"Exactly one module or package\"\"\"\n        for field in ('packages', 'py_modules'):\n            items = getattr(self.dist, field, None) or []\n            if items and len(items) == 1:\n                log.debug(f\"Single module/package detected, name: {items[0]}\")\n                return items[0]\n\n        return None\n\n    def _find_name_from_packages(self) -> str | None:\n        \"\"\"Try to find the root package that is not a PEP 420 namespace\"\"\"\n        if not self.dist.packages:\n            return None\n\n        packages = remove_stubs(sorted(self.dist.packages, key=len))\n        package_dir = self.dist.package_dir or {}\n\n        parent_pkg = find_parent_package(packages, package_dir, self._root_dir)\n        if parent_pkg:\n            log.debug(f\"Common parent package detected, name: {parent_pkg}\")\n            return parent_pkg\n\n        log.warn(\"No parent package detected, impossible to derive `name`\")\n        return None\n\n\ndef remove_nested_packages(packages: list[str]) -> list[str]:\n    \"\"\"Remove nested packages from a list of packages.\n\n    >>> remove_nested_packages([\"a\", \"a.b1\", \"a.b2\", \"a.b1.c1\"])\n    ['a']\n    >>> remove_nested_packages([\"a\", \"b\", \"c.d\", \"c.d.e.f\", \"g.h\", \"a.a1\"])\n    ['a', 'b', 'c.d', 'g.h']\n    \"\"\"\n    pkgs = sorted(packages, key=len)\n    top_level = pkgs[:]\n    size = len(pkgs)\n    for i, name in enumerate(reversed(pkgs)):\n        if any(name.startswith(f\"{other}.\") for other in top_level):\n            top_level.pop(size - i - 1)\n\n    return top_level\n\n\ndef remove_stubs(packages: list[str]) -> list[str]:\n    \"\"\"Remove type stubs (:pep:`561`) from a list of packages.\n\n    >>> remove_stubs([\"a\", \"a.b\", \"a-stubs\", \"a-stubs.b.c\", \"b\", \"c-stubs\"])\n    ['a', 'a.b', 'b']\n    \"\"\"\n    return [pkg for pkg in packages if not pkg.split(\".\")[0].endswith(\"-stubs\")]\n\n\ndef find_parent_package(\n    packages: list[str], package_dir: Mapping[str, str], root_dir: StrPath\n) -> str | None:\n    \"\"\"Find the parent package that is not a namespace.\"\"\"\n    packages = sorted(packages, key=len)\n    common_ancestors = []\n    for i, name in enumerate(packages):\n        if not all(n.startswith(f\"{name}.\") for n in packages[i + 1 :]):\n            # Since packages are sorted by length, this condition is able\n            # to find a list of all common ancestors.\n            # When there is divergence (e.g. multiple root packages)\n            # the list will be empty\n            break\n        common_ancestors.append(name)\n\n    for name in common_ancestors:\n        pkg_path = find_package_path(name, package_dir, root_dir)\n        init = os.path.join(pkg_path, \"__init__.py\")\n        if os.path.isfile(init):\n            return name\n\n    return None\n\n\ndef find_package_path(\n    name: str, package_dir: Mapping[str, str], root_dir: StrPath\n) -> str:\n    \"\"\"Given a package name, return the path where it should be found on\n    disk, considering the ``package_dir`` option.\n\n    >>> path = find_package_path(\"my.pkg\", {\"\": \"root/is/nested\"}, \".\")\n    >>> path.replace(os.sep, \"/\")\n    './root/is/nested/my/pkg'\n\n    >>> path = find_package_path(\"my.pkg\", {\"my\": \"root/is/nested\"}, \".\")\n    >>> path.replace(os.sep, \"/\")\n    './root/is/nested/pkg'\n\n    >>> path = find_package_path(\"my.pkg\", {\"my.pkg\": \"root/is/nested\"}, \".\")\n    >>> path.replace(os.sep, \"/\")\n    './root/is/nested'\n\n    >>> path = find_package_path(\"other.pkg\", {\"my.pkg\": \"root/is/nested\"}, \".\")\n    >>> path.replace(os.sep, \"/\")\n    './other/pkg'\n    \"\"\"\n    parts = name.split(\".\")\n    for i in range(len(parts), 0, -1):\n        # Look backwards, the most specific package_dir first\n        partial_name = \".\".join(parts[:i])\n        if partial_name in package_dir:\n            parent = package_dir[partial_name]\n            return os.path.join(root_dir, parent, *parts[i:])\n\n    parent = package_dir.get(\"\") or \"\"\n    return os.path.join(root_dir, *parent.split(\"/\"), *parts)\n\n\ndef construct_package_dir(packages: list[str], package_path: StrPath) -> dict[str, str]:\n    parent_pkgs = remove_nested_packages(packages)\n    prefix = Path(package_path).parts\n    return {pkg: \"/\".join([*prefix, *pkg.split(\".\")]) for pkg in parent_pkgs}\n", "setuptools/_imp.py": "\"\"\"\nRe-implementation of find_module and get_frozen_object\nfrom the deprecated imp module.\n\"\"\"\n\nimport os\nimport importlib.util\nimport importlib.machinery\nimport tokenize\n\nfrom importlib.util import module_from_spec\n\n\nPY_SOURCE = 1\nPY_COMPILED = 2\nC_EXTENSION = 3\nC_BUILTIN = 6\nPY_FROZEN = 7\n\n\ndef find_spec(module, paths):\n    finder = (\n        importlib.machinery.PathFinder().find_spec\n        if isinstance(paths, list)\n        else importlib.util.find_spec\n    )\n    return finder(module, paths)\n\n\ndef find_module(module, paths=None):\n    \"\"\"Just like 'imp.find_module()', but with package support\"\"\"\n    spec = find_spec(module, paths)\n    if spec is None:\n        raise ImportError(\"Can't find %s\" % module)\n    if not spec.has_location and hasattr(spec, 'submodule_search_locations'):\n        spec = importlib.util.spec_from_loader('__init__.py', spec.loader)\n\n    kind = -1\n    file = None\n    static = isinstance(spec.loader, type)\n    if (\n        spec.origin == 'frozen'\n        or static\n        and issubclass(spec.loader, importlib.machinery.FrozenImporter)\n    ):\n        kind = PY_FROZEN\n        path = None  # imp compabilty\n        suffix = mode = ''  # imp compatibility\n    elif (\n        spec.origin == 'built-in'\n        or static\n        and issubclass(spec.loader, importlib.machinery.BuiltinImporter)\n    ):\n        kind = C_BUILTIN\n        path = None  # imp compabilty\n        suffix = mode = ''  # imp compatibility\n    elif spec.has_location:\n        path = spec.origin\n        suffix = os.path.splitext(path)[1]\n        mode = 'r' if suffix in importlib.machinery.SOURCE_SUFFIXES else 'rb'\n\n        if suffix in importlib.machinery.SOURCE_SUFFIXES:\n            kind = PY_SOURCE\n            file = tokenize.open(path)\n        elif suffix in importlib.machinery.BYTECODE_SUFFIXES:\n            kind = PY_COMPILED\n            file = open(path, 'rb')\n        elif suffix in importlib.machinery.EXTENSION_SUFFIXES:\n            kind = C_EXTENSION\n\n    else:\n        path = None\n        suffix = mode = ''\n\n    return file, path, (suffix, mode, kind)\n\n\ndef get_frozen_object(module, paths=None):\n    spec = find_spec(module, paths)\n    if not spec:\n        raise ImportError(\"Can't find %s\" % module)\n    return spec.loader.get_code(module)\n\n\ndef get_module(module, paths, info):\n    spec = find_spec(module, paths)\n    if not spec:\n        raise ImportError(\"Can't find %s\" % module)\n    return module_from_spec(spec)\n", "setuptools/_itertools.py": "from setuptools.extern.more_itertools import consume  # noqa: F401\n\n\n# copied from jaraco.itertools 6.1\ndef ensure_unique(iterable, key=lambda x: x):\n    \"\"\"\n    Wrap an iterable to raise a ValueError if non-unique values are encountered.\n\n    >>> list(ensure_unique('abc'))\n    ['a', 'b', 'c']\n    >>> consume(ensure_unique('abca'))\n    Traceback (most recent call last):\n    ...\n    ValueError: Duplicate element 'a' encountered.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    for element in iterable:\n        k = key(element)\n        if k in seen:\n            raise ValueError(f\"Duplicate element {element!r} encountered.\")\n        seen_add(k)\n        yield element\n", "setuptools/installer.py": "import glob\nimport os\nimport subprocess\nimport sys\nimport tempfile\nfrom distutils import log\nfrom distutils.errors import DistutilsError\nfrom functools import partial\n\nfrom . import _reqs\nfrom .wheel import Wheel\nfrom .warnings import SetuptoolsDeprecationWarning\n\n\ndef _fixup_find_links(find_links):\n    \"\"\"Ensure find-links option end-up being a list of strings.\"\"\"\n    if isinstance(find_links, str):\n        return find_links.split()\n    assert isinstance(find_links, (tuple, list))\n    return find_links\n\n\ndef fetch_build_egg(dist, req):\n    \"\"\"Fetch an egg needed for building.\n\n    Use pip/wheel to fetch/build a wheel.\"\"\"\n    _DeprecatedInstaller.emit()\n    _warn_wheel_not_available(dist)\n    return _fetch_build_egg_no_warn(dist, req)\n\n\ndef _fetch_build_eggs(dist, requires):\n    import pkg_resources  # Delay import to avoid unnecessary side-effects\n\n    _DeprecatedInstaller.emit(stacklevel=3)\n    _warn_wheel_not_available(dist)\n\n    resolved_dists = pkg_resources.working_set.resolve(\n        _reqs.parse(requires, pkg_resources.Requirement),  # required for compatibility\n        installer=partial(_fetch_build_egg_no_warn, dist),  # avoid warning twice\n        replace_conflicting=True,\n    )\n    for dist in resolved_dists:\n        pkg_resources.working_set.add(dist, replace=True)\n    return resolved_dists\n\n\ndef _fetch_build_egg_no_warn(dist, req):  # noqa: C901  # is too complex (16)  # FIXME\n    import pkg_resources  # Delay import to avoid unnecessary side-effects\n\n    # Ignore environment markers; if supplied, it is required.\n    req = strip_marker(req)\n    # Take easy_install options into account, but do not override relevant\n    # pip environment variables (like PIP_INDEX_URL or PIP_QUIET); they'll\n    # take precedence.\n    opts = dist.get_option_dict('easy_install')\n    if 'allow_hosts' in opts:\n        raise DistutilsError(\n            'the `allow-hosts` option is not supported '\n            'when using pip to install requirements.'\n        )\n    quiet = 'PIP_QUIET' not in os.environ and 'PIP_VERBOSE' not in os.environ\n    if 'PIP_INDEX_URL' in os.environ:\n        index_url = None\n    elif 'index_url' in opts:\n        index_url = opts['index_url'][1]\n    else:\n        index_url = None\n    find_links = (\n        _fixup_find_links(opts['find_links'][1])[:] if 'find_links' in opts else []\n    )\n    if dist.dependency_links:\n        find_links.extend(dist.dependency_links)\n    eggs_dir = os.path.realpath(dist.get_egg_cache_dir())\n    environment = pkg_resources.Environment()\n    for egg_dist in pkg_resources.find_distributions(eggs_dir):\n        if egg_dist in req and environment.can_add(egg_dist):\n            return egg_dist\n    with tempfile.TemporaryDirectory() as tmpdir:\n        cmd = [\n            sys.executable,\n            '-m',\n            'pip',\n            '--disable-pip-version-check',\n            'wheel',\n            '--no-deps',\n            '-w',\n            tmpdir,\n        ]\n        if quiet:\n            cmd.append('--quiet')\n        if index_url is not None:\n            cmd.extend(('--index-url', index_url))\n        for link in find_links or []:\n            cmd.extend(('--find-links', link))\n        # If requirement is a PEP 508 direct URL, directly pass\n        # the URL to pip, as `req @ url` does not work on the\n        # command line.\n        cmd.append(req.url or str(req))\n        try:\n            subprocess.check_call(cmd)\n        except subprocess.CalledProcessError as e:\n            raise DistutilsError(str(e)) from e\n        wheel = Wheel(glob.glob(os.path.join(tmpdir, '*.whl'))[0])\n        dist_location = os.path.join(eggs_dir, wheel.egg_name())\n        wheel.install_as_egg(dist_location)\n        dist_metadata = pkg_resources.PathMetadata(\n            dist_location, os.path.join(dist_location, 'EGG-INFO')\n        )\n        return pkg_resources.Distribution.from_filename(\n            dist_location, metadata=dist_metadata\n        )\n\n\ndef strip_marker(req):\n    \"\"\"\n    Return a new requirement without the environment marker to avoid\n    calling pip with something like `babel; extra == \"i18n\"`, which\n    would always be ignored.\n    \"\"\"\n    import pkg_resources  # Delay import to avoid unnecessary side-effects\n\n    # create a copy to avoid mutating the input\n    req = pkg_resources.Requirement.parse(str(req))\n    req.marker = None\n    return req\n\n\ndef _warn_wheel_not_available(dist):\n    import pkg_resources  # Delay import to avoid unnecessary side-effects\n\n    try:\n        pkg_resources.get_distribution('wheel')\n    except pkg_resources.DistributionNotFound:\n        dist.announce('WARNING: The wheel package is not available.', log.WARN)\n\n\nclass _DeprecatedInstaller(SetuptoolsDeprecationWarning):\n    _SUMMARY = \"setuptools.installer and fetch_build_eggs are deprecated.\"\n    _DETAILS = \"\"\"\n    Requirements should be satisfied by a PEP 517 installer.\n    If you are using pip, you can try `pip install --use-pep517`.\n    \"\"\"\n    # _DUE_DATE not decided yet\n", "setuptools/sandbox.py": "from __future__ import annotations\n\nimport os\nimport sys\nimport tempfile\nimport operator\nimport functools\nimport itertools\nimport re\nimport contextlib\nimport pickle\nimport textwrap\nimport builtins\n\nimport pkg_resources\nfrom distutils.errors import DistutilsError\nfrom pkg_resources import working_set\n\nif sys.platform.startswith('java'):\n    import org.python.modules.posix.PosixModule as _os\nelse:\n    _os = sys.modules[os.name]\ntry:\n    _file = file  # type: ignore[name-defined] # Check for global variable\nexcept NameError:\n    _file = None\n_open = open\n\n\n__all__ = [\n    \"AbstractSandbox\",\n    \"DirectorySandbox\",\n    \"SandboxViolation\",\n    \"run_setup\",\n]\n\n\ndef _execfile(filename, globals, locals=None):\n    \"\"\"\n    Python 3 implementation of execfile.\n    \"\"\"\n    mode = 'rb'\n    with open(filename, mode) as stream:\n        script = stream.read()\n    if locals is None:\n        locals = globals\n    code = compile(script, filename, 'exec')\n    exec(code, globals, locals)\n\n\n@contextlib.contextmanager\ndef save_argv(repl=None):\n    saved = sys.argv[:]\n    if repl is not None:\n        sys.argv[:] = repl\n    try:\n        yield saved\n    finally:\n        sys.argv[:] = saved\n\n\n@contextlib.contextmanager\ndef save_path():\n    saved = sys.path[:]\n    try:\n        yield saved\n    finally:\n        sys.path[:] = saved\n\n\n@contextlib.contextmanager\ndef override_temp(replacement):\n    \"\"\"\n    Monkey-patch tempfile.tempdir with replacement, ensuring it exists\n    \"\"\"\n    os.makedirs(replacement, exist_ok=True)\n\n    saved = tempfile.tempdir\n\n    tempfile.tempdir = replacement\n\n    try:\n        yield\n    finally:\n        tempfile.tempdir = saved\n\n\n@contextlib.contextmanager\ndef pushd(target):\n    saved = os.getcwd()\n    os.chdir(target)\n    try:\n        yield saved\n    finally:\n        os.chdir(saved)\n\n\nclass UnpickleableException(Exception):\n    \"\"\"\n    An exception representing another Exception that could not be pickled.\n    \"\"\"\n\n    @staticmethod\n    def dump(type, exc):\n        \"\"\"\n        Always return a dumped (pickled) type and exc. If exc can't be pickled,\n        wrap it in UnpickleableException first.\n        \"\"\"\n        try:\n            return pickle.dumps(type), pickle.dumps(exc)\n        except Exception:\n            # get UnpickleableException inside the sandbox\n            from setuptools.sandbox import UnpickleableException as cls\n\n            return cls.dump(cls, cls(repr(exc)))\n\n\nclass ExceptionSaver:\n    \"\"\"\n    A Context Manager that will save an exception, serialize, and restore it\n    later.\n    \"\"\"\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, type, exc, tb):\n        if not exc:\n            return False\n\n        # dump the exception\n        self._saved = UnpickleableException.dump(type, exc)\n        self._tb = tb\n\n        # suppress the exception\n        return True\n\n    def resume(self):\n        \"restore and re-raise any exception\"\n\n        if '_saved' not in vars(self):\n            return\n\n        type, exc = map(pickle.loads, self._saved)\n        raise exc.with_traceback(self._tb)\n\n\n@contextlib.contextmanager\ndef save_modules():\n    \"\"\"\n    Context in which imported modules are saved.\n\n    Translates exceptions internal to the context into the equivalent exception\n    outside the context.\n    \"\"\"\n    saved = sys.modules.copy()\n    with ExceptionSaver() as saved_exc:\n        yield saved\n\n    sys.modules.update(saved)\n    # remove any modules imported since\n    del_modules = (\n        mod_name\n        for mod_name in sys.modules\n        if mod_name not in saved\n        # exclude any encodings modules. See #285\n        and not mod_name.startswith('encodings.')\n    )\n    _clear_modules(del_modules)\n\n    saved_exc.resume()\n\n\ndef _clear_modules(module_names):\n    for mod_name in list(module_names):\n        del sys.modules[mod_name]\n\n\n@contextlib.contextmanager\ndef save_pkg_resources_state():\n    saved = pkg_resources.__getstate__()\n    try:\n        yield saved\n    finally:\n        pkg_resources.__setstate__(saved)\n\n\n@contextlib.contextmanager\ndef setup_context(setup_dir):\n    temp_dir = os.path.join(setup_dir, 'temp')\n    with save_pkg_resources_state():\n        with save_modules():\n            with save_path():\n                hide_setuptools()\n                with save_argv():\n                    with override_temp(temp_dir):\n                        with pushd(setup_dir):\n                            # ensure setuptools commands are available\n                            __import__('setuptools')\n                            yield\n\n\n_MODULES_TO_HIDE = {\n    'setuptools',\n    'distutils',\n    'pkg_resources',\n    'Cython',\n    '_distutils_hack',\n}\n\n\ndef _needs_hiding(mod_name):\n    \"\"\"\n    >>> _needs_hiding('setuptools')\n    True\n    >>> _needs_hiding('pkg_resources')\n    True\n    >>> _needs_hiding('setuptools_plugin')\n    False\n    >>> _needs_hiding('setuptools.__init__')\n    True\n    >>> _needs_hiding('distutils')\n    True\n    >>> _needs_hiding('os')\n    False\n    >>> _needs_hiding('Cython')\n    True\n    \"\"\"\n    base_module = mod_name.split('.', 1)[0]\n    return base_module in _MODULES_TO_HIDE\n\n\ndef hide_setuptools():\n    \"\"\"\n    Remove references to setuptools' modules from sys.modules to allow the\n    invocation to import the most appropriate setuptools. This technique is\n    necessary to avoid issues such as #315 where setuptools upgrading itself\n    would fail to find a function declared in the metadata.\n    \"\"\"\n    _distutils_hack = sys.modules.get('_distutils_hack', None)\n    if _distutils_hack is not None:\n        _distutils_hack._remove_shim()\n\n    modules = filter(_needs_hiding, sys.modules)\n    _clear_modules(modules)\n\n\ndef run_setup(setup_script, args):\n    \"\"\"Run a distutils setup script, sandboxed in its directory\"\"\"\n    setup_dir = os.path.abspath(os.path.dirname(setup_script))\n    with setup_context(setup_dir):\n        try:\n            sys.argv[:] = [setup_script] + list(args)\n            sys.path.insert(0, setup_dir)\n            # reset to include setup dir, w/clean callback list\n            working_set.__init__()\n            working_set.callbacks.append(lambda dist: dist.activate())\n\n            with DirectorySandbox(setup_dir):\n                ns = dict(__file__=setup_script, __name__='__main__')\n                _execfile(setup_script, ns)\n        except SystemExit as v:\n            if v.args and v.args[0]:\n                raise\n            # Normal exit, just return\n\n\nclass AbstractSandbox:\n    \"\"\"Wrap 'os' module and 'open()' builtin for virtualizing setup scripts\"\"\"\n\n    _active = False\n\n    def __init__(self):\n        self._attrs = [\n            name\n            for name in dir(_os)\n            if not name.startswith('_') and hasattr(self, name)\n        ]\n\n    def _copy(self, source):\n        for name in self._attrs:\n            setattr(os, name, getattr(source, name))\n\n    def __enter__(self):\n        self._copy(self)\n        if _file:\n            builtins.file = self._file\n        builtins.open = self._open\n        self._active = True\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self._active = False\n        if _file:\n            builtins.file = _file\n        builtins.open = _open\n        self._copy(_os)\n\n    def run(self, func):\n        \"\"\"Run 'func' under os sandboxing\"\"\"\n        with self:\n            return func()\n\n    def _mk_dual_path_wrapper(name: str):  # type: ignore[misc] # https://github.com/pypa/setuptools/pull/4099\n        original = getattr(_os, name)\n\n        def wrap(self, src, dst, *args, **kw):\n            if self._active:\n                src, dst = self._remap_pair(name, src, dst, *args, **kw)\n            return original(src, dst, *args, **kw)\n\n        return wrap\n\n    for __name in [\"rename\", \"link\", \"symlink\"]:\n        if hasattr(_os, __name):\n            locals()[__name] = _mk_dual_path_wrapper(__name)\n\n    def _mk_single_path_wrapper(name: str, original=None):  # type: ignore[misc] # https://github.com/pypa/setuptools/pull/4099\n        original = original or getattr(_os, name)\n\n        def wrap(self, path, *args, **kw):\n            if self._active:\n                path = self._remap_input(name, path, *args, **kw)\n            return original(path, *args, **kw)\n\n        return wrap\n\n    if _file:\n        _file = _mk_single_path_wrapper('file', _file)\n    _open = _mk_single_path_wrapper('open', _open)\n    for __name in [\n        \"stat\",\n        \"listdir\",\n        \"chdir\",\n        \"open\",\n        \"chmod\",\n        \"chown\",\n        \"mkdir\",\n        \"remove\",\n        \"unlink\",\n        \"rmdir\",\n        \"utime\",\n        \"lchown\",\n        \"chroot\",\n        \"lstat\",\n        \"startfile\",\n        \"mkfifo\",\n        \"mknod\",\n        \"pathconf\",\n        \"access\",\n    ]:\n        if hasattr(_os, __name):\n            locals()[__name] = _mk_single_path_wrapper(__name)\n\n    def _mk_single_with_return(name: str):  # type: ignore[misc] # https://github.com/pypa/setuptools/pull/4099\n        original = getattr(_os, name)\n\n        def wrap(self, path, *args, **kw):\n            if self._active:\n                path = self._remap_input(name, path, *args, **kw)\n                return self._remap_output(name, original(path, *args, **kw))\n            return original(path, *args, **kw)\n\n        return wrap\n\n    for __name in ['readlink', 'tempnam']:\n        if hasattr(_os, __name):\n            locals()[__name] = _mk_single_with_return(__name)\n\n    def _mk_query(name: str):  # type: ignore[misc] # https://github.com/pypa/setuptools/pull/4099\n        original = getattr(_os, name)\n\n        def wrap(self, *args, **kw):\n            retval = original(*args, **kw)\n            if self._active:\n                return self._remap_output(name, retval)\n            return retval\n\n        return wrap\n\n    for __name in ['getcwd', 'tmpnam']:\n        if hasattr(_os, __name):\n            locals()[__name] = _mk_query(__name)\n\n    def _validate_path(self, path):\n        \"\"\"Called to remap or validate any path, whether input or output\"\"\"\n        return path\n\n    def _remap_input(self, operation, path, *args, **kw):\n        \"\"\"Called for path inputs\"\"\"\n        return self._validate_path(path)\n\n    def _remap_output(self, operation, path):\n        \"\"\"Called for path outputs\"\"\"\n        return self._validate_path(path)\n\n    def _remap_pair(self, operation, src, dst, *args, **kw):\n        \"\"\"Called for path pairs like rename, link, and symlink operations\"\"\"\n        return (\n            self._remap_input(operation + '-from', src, *args, **kw),\n            self._remap_input(operation + '-to', dst, *args, **kw),\n        )\n\n\nif hasattr(os, 'devnull'):\n    _EXCEPTIONS = [os.devnull]\nelse:\n    _EXCEPTIONS = []\n\n\nclass DirectorySandbox(AbstractSandbox):\n    \"\"\"Restrict operations to a single subdirectory - pseudo-chroot\"\"\"\n\n    write_ops = dict.fromkeys([\n        \"open\",\n        \"chmod\",\n        \"chown\",\n        \"mkdir\",\n        \"remove\",\n        \"unlink\",\n        \"rmdir\",\n        \"utime\",\n        \"lchown\",\n        \"chroot\",\n        \"mkfifo\",\n        \"mknod\",\n        \"tempnam\",\n    ])\n\n    _exception_patterns: list[str | re.Pattern] = []\n    \"exempt writing to paths that match the pattern\"\n\n    def __init__(self, sandbox, exceptions=_EXCEPTIONS):\n        self._sandbox = os.path.normcase(os.path.realpath(sandbox))\n        self._prefix = os.path.join(self._sandbox, '')\n        self._exceptions = [\n            os.path.normcase(os.path.realpath(path)) for path in exceptions\n        ]\n        AbstractSandbox.__init__(self)\n\n    def _violation(self, operation, *args, **kw):\n        from setuptools.sandbox import SandboxViolation\n\n        raise SandboxViolation(operation, args, kw)\n\n    if _file:\n\n        def _file(self, path, mode='r', *args, **kw):\n            if mode not in ('r', 'rt', 'rb', 'rU', 'U') and not self._ok(path):\n                self._violation(\"file\", path, mode, *args, **kw)\n            return _file(path, mode, *args, **kw)\n\n    def _open(self, path, mode='r', *args, **kw):\n        if mode not in ('r', 'rt', 'rb', 'rU', 'U') and not self._ok(path):\n            self._violation(\"open\", path, mode, *args, **kw)\n        return _open(path, mode, *args, **kw)\n\n    def tmpnam(self):\n        self._violation(\"tmpnam\")\n\n    def _ok(self, path):\n        active = self._active\n        try:\n            self._active = False\n            realpath = os.path.normcase(os.path.realpath(path))\n            return (\n                self._exempted(realpath)\n                or realpath == self._sandbox\n                or realpath.startswith(self._prefix)\n            )\n        finally:\n            self._active = active\n\n    def _exempted(self, filepath):\n        start_matches = (\n            filepath.startswith(exception) for exception in self._exceptions\n        )\n        pattern_matches = (\n            re.match(pattern, filepath) for pattern in self._exception_patterns\n        )\n        candidates = itertools.chain(start_matches, pattern_matches)\n        return any(candidates)\n\n    def _remap_input(self, operation, path, *args, **kw):\n        \"\"\"Called for path inputs\"\"\"\n        if operation in self.write_ops and not self._ok(path):\n            self._violation(operation, os.path.realpath(path), *args, **kw)\n        return path\n\n    def _remap_pair(self, operation, src, dst, *args, **kw):\n        \"\"\"Called for path pairs like rename, link, and symlink operations\"\"\"\n        if not self._ok(src) or not self._ok(dst):\n            self._violation(operation, src, dst, *args, **kw)\n        return (src, dst)\n\n    def open(self, file, flags, mode=0o777, *args, **kw):\n        \"\"\"Called for low-level os.open()\"\"\"\n        if flags & WRITE_FLAGS and not self._ok(file):\n            self._violation(\"os.open\", file, flags, mode, *args, **kw)\n        return _os.open(file, flags, mode, *args, **kw)\n\n\nWRITE_FLAGS = functools.reduce(\n    operator.or_,\n    [\n        getattr(_os, a, 0)\n        for a in \"O_WRONLY O_RDWR O_APPEND O_CREAT O_TRUNC O_TEMPORARY\".split()\n    ],\n)\n\n\nclass SandboxViolation(DistutilsError):\n    \"\"\"A setup script attempted to modify the filesystem outside the sandbox\"\"\"\n\n    tmpl = textwrap.dedent(\n        \"\"\"\n        SandboxViolation: {cmd}{args!r} {kwargs}\n\n        The package setup script has attempted to modify files on your system\n        that are not within the EasyInstall build area, and has been aborted.\n\n        This package cannot be safely installed by EasyInstall, and may not\n        support alternate installation locations even if you run its setup\n        script by hand.  Please inform the package's author and the EasyInstall\n        maintainers to find out if a fix or workaround is available.\n        \"\"\"\n    ).lstrip()\n\n    def __str__(self):\n        cmd, args, kwargs = self.args\n        return self.tmpl.format(**locals())\n", "setuptools/launch.py": "\"\"\"\nLaunch the Python script on the command line after\nsetuptools is bootstrapped via import.\n\"\"\"\n\n# Note that setuptools gets imported implicitly by the\n# invocation of this script using python -m setuptools.launch\n\nimport tokenize\nimport sys\n\n\ndef run():\n    \"\"\"\n    Run the script in sys.argv[1] as if it had\n    been invoked naturally.\n    \"\"\"\n    __builtins__\n    script_name = sys.argv[1]\n    namespace = dict(\n        __file__=script_name,\n        __name__='__main__',\n        __doc__=None,\n    )\n    sys.argv[:] = sys.argv[1:]\n\n    open_ = getattr(tokenize, 'open', open)\n    with open_(script_name) as fid:\n        script = fid.read()\n    norm_script = script.replace('\\\\r\\\\n', '\\\\n')\n    code = compile(norm_script, script_name, 'exec')\n    exec(code, namespace)\n\n\nif __name__ == '__main__':\n    run()\n", "setuptools/glob.py": "\"\"\"\nFilename globbing utility. Mostly a copy of `glob` from Python 3.5.\n\nChanges include:\n * `yield from` and PEP3102 `*` removed.\n * Hidden files are not ignored.\n\"\"\"\n\nimport os\nimport re\nimport fnmatch\n\n__all__ = [\"glob\", \"iglob\", \"escape\"]\n\n\ndef glob(pathname, recursive=False):\n    \"\"\"Return a list of paths matching a pathname pattern.\n\n    The pattern may contain simple shell-style wildcards a la\n    fnmatch. However, unlike fnmatch, filenames starting with a\n    dot are special cases that are not matched by '*' and '?'\n    patterns.\n\n    If recursive is true, the pattern '**' will match any files and\n    zero or more directories and subdirectories.\n    \"\"\"\n    return list(iglob(pathname, recursive=recursive))\n\n\ndef iglob(pathname, recursive=False):\n    \"\"\"Return an iterator which yields the paths matching a pathname pattern.\n\n    The pattern may contain simple shell-style wildcards a la\n    fnmatch. However, unlike fnmatch, filenames starting with a\n    dot are special cases that are not matched by '*' and '?'\n    patterns.\n\n    If recursive is true, the pattern '**' will match any files and\n    zero or more directories and subdirectories.\n    \"\"\"\n    it = _iglob(pathname, recursive)\n    if recursive and _isrecursive(pathname):\n        s = next(it)  # skip empty string\n        assert not s\n    return it\n\n\ndef _iglob(pathname, recursive):\n    dirname, basename = os.path.split(pathname)\n    glob_in_dir = glob2 if recursive and _isrecursive(basename) else glob1\n\n    if not has_magic(pathname):\n        if basename:\n            if os.path.lexists(pathname):\n                yield pathname\n        else:\n            # Patterns ending with a slash should match only directories\n            if os.path.isdir(dirname):\n                yield pathname\n        return\n\n    if not dirname:\n        yield from glob_in_dir(dirname, basename)\n        return\n    # `os.path.split()` returns the argument itself as a dirname if it is a\n    # drive or UNC path.  Prevent an infinite recursion if a drive or UNC path\n    # contains magic characters (i.e. r'\\\\?\\C:').\n    if dirname != pathname and has_magic(dirname):\n        dirs = _iglob(dirname, recursive)\n    else:\n        dirs = [dirname]\n    if not has_magic(basename):\n        glob_in_dir = glob0\n    for dirname in dirs:\n        for name in glob_in_dir(dirname, basename):\n            yield os.path.join(dirname, name)\n\n\n# These 2 helper functions non-recursively glob inside a literal directory.\n# They return a list of basenames. `glob1` accepts a pattern while `glob0`\n# takes a literal basename (so it only has to check for its existence).\n\n\ndef glob1(dirname, pattern):\n    if not dirname:\n        if isinstance(pattern, bytes):\n            dirname = os.curdir.encode('ASCII')\n        else:\n            dirname = os.curdir\n    try:\n        names = os.listdir(dirname)\n    except OSError:\n        return []\n    return fnmatch.filter(names, pattern)\n\n\ndef glob0(dirname, basename):\n    if not basename:\n        # `os.path.split()` returns an empty basename for paths ending with a\n        # directory separator.  'q*x/' should match only directories.\n        if os.path.isdir(dirname):\n            return [basename]\n    else:\n        if os.path.lexists(os.path.join(dirname, basename)):\n            return [basename]\n    return []\n\n\n# This helper function recursively yields relative pathnames inside a literal\n# directory.\n\n\ndef glob2(dirname, pattern):\n    assert _isrecursive(pattern)\n    yield pattern[:0]\n    yield from _rlistdir(dirname)\n\n\n# Recursively yields relative pathnames inside a literal directory.\ndef _rlistdir(dirname):\n    if not dirname:\n        if isinstance(dirname, bytes):\n            dirname = os.curdir.encode('ASCII')\n        else:\n            dirname = os.curdir\n    try:\n        names = os.listdir(dirname)\n    except OSError:\n        return\n    for x in names:\n        yield x\n        path = os.path.join(dirname, x) if dirname else x\n        for y in _rlistdir(path):\n            yield os.path.join(x, y)\n\n\nmagic_check = re.compile('([*?[])')\nmagic_check_bytes = re.compile(b'([*?[])')\n\n\ndef has_magic(s):\n    if isinstance(s, bytes):\n        match = magic_check_bytes.search(s)\n    else:\n        match = magic_check.search(s)\n    return match is not None\n\n\ndef _isrecursive(pattern):\n    if isinstance(pattern, bytes):\n        return pattern == b'**'\n    else:\n        return pattern == '**'\n\n\ndef escape(pathname):\n    \"\"\"Escape all special characters.\"\"\"\n    # Escaping is done by wrapping any of \"*?[\" between square brackets.\n    # Metacharacters do not work in the drive part and shouldn't be escaped.\n    drive, pathname = os.path.splitdrive(pathname)\n    if isinstance(pathname, bytes):\n        pathname = magic_check_bytes.sub(rb'[\\1]', pathname)\n    else:\n        pathname = magic_check.sub(r'[\\1]', pathname)\n    return drive + pathname\n", "setuptools/dist.py": "from __future__ import annotations\n\nimport io\nimport itertools\nimport numbers\nimport os\nimport re\nimport sys\nfrom contextlib import suppress\nfrom glob import iglob\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, MutableMapping\n\nimport distutils.cmd\nimport distutils.command\nimport distutils.core\nimport distutils.dist\nimport distutils.log\nfrom distutils.debug import DEBUG\nfrom distutils.errors import DistutilsOptionError, DistutilsSetupError\nfrom distutils.fancy_getopt import translate_longopt\nfrom distutils.util import strtobool\n\nfrom .extern.more_itertools import partition, unique_everseen\nfrom .extern.ordered_set import OrderedSet\nfrom .extern.packaging.markers import InvalidMarker, Marker\nfrom .extern.packaging.specifiers import InvalidSpecifier, SpecifierSet\nfrom .extern.packaging.version import Version\n\nfrom . import _entry_points\nfrom . import _normalization\nfrom . import _reqs\nfrom . import command as _  # noqa  -- imported for side-effects\nfrom ._importlib import metadata\nfrom .config import setupcfg, pyprojecttoml\nfrom .discovery import ConfigDiscovery\nfrom .monkey import get_unpatched\nfrom .warnings import InformationOnly, SetuptoolsDeprecationWarning\n\n__all__ = ['Distribution']\n\nsequence = tuple, list\n\n\ndef check_importable(dist, attr, value):\n    try:\n        ep = metadata.EntryPoint(value=value, name=None, group=None)\n        assert not ep.extras\n    except (TypeError, ValueError, AttributeError, AssertionError) as e:\n        raise DistutilsSetupError(\n            \"%r must be importable 'module:attrs' string (got %r)\" % (attr, value)\n        ) from e\n\n\ndef assert_string_list(dist, attr, value):\n    \"\"\"Verify that value is a string list\"\"\"\n    try:\n        # verify that value is a list or tuple to exclude unordered\n        # or single-use iterables\n        assert isinstance(value, (list, tuple))\n        # verify that elements of value are strings\n        assert ''.join(value) != value\n    except (TypeError, ValueError, AttributeError, AssertionError) as e:\n        raise DistutilsSetupError(\n            \"%r must be a list of strings (got %r)\" % (attr, value)\n        ) from e\n\n\ndef check_nsp(dist, attr, value):\n    \"\"\"Verify that namespace packages are valid\"\"\"\n    ns_packages = value\n    assert_string_list(dist, attr, ns_packages)\n    for nsp in ns_packages:\n        if not dist.has_contents_for(nsp):\n            raise DistutilsSetupError(\n                \"Distribution contains no modules or packages for \"\n                + \"namespace package %r\" % nsp\n            )\n        parent, sep, child = nsp.rpartition('.')\n        if parent and parent not in ns_packages:\n            distutils.log.warn(\n                \"WARNING: %r is declared as a package namespace, but %r\"\n                \" is not: please correct this in setup.py\",\n                nsp,\n                parent,\n            )\n        SetuptoolsDeprecationWarning.emit(\n            \"The namespace_packages parameter is deprecated.\",\n            \"Please replace its usage with implicit namespaces (PEP 420).\",\n            see_docs=\"references/keywords.html#keyword-namespace-packages\",\n            # TODO: define due_date, it may break old packages that are no longer\n            # maintained (e.g. sphinxcontrib extensions) when installed from source.\n            # Warning officially introduced in May 2022, however the deprecation\n            # was mentioned much earlier in the docs (May 2020, see #2149).\n        )\n\n\ndef check_extras(dist, attr, value):\n    \"\"\"Verify that extras_require mapping is valid\"\"\"\n    try:\n        list(itertools.starmap(_check_extra, value.items()))\n    except (TypeError, ValueError, AttributeError) as e:\n        raise DistutilsSetupError(\n            \"'extras_require' must be a dictionary whose values are \"\n            \"strings or lists of strings containing valid project/version \"\n            \"requirement specifiers.\"\n        ) from e\n\n\ndef _check_extra(extra, reqs):\n    name, sep, marker = extra.partition(':')\n    try:\n        _check_marker(marker)\n    except InvalidMarker:\n        msg = f\"Invalid environment marker: {marker} ({extra!r})\"\n        raise DistutilsSetupError(msg) from None\n    list(_reqs.parse(reqs))\n\n\ndef _check_marker(marker):\n    if not marker:\n        return\n    m = Marker(marker)\n    m.evaluate()\n\n\ndef assert_bool(dist, attr, value):\n    \"\"\"Verify that value is True, False, 0, or 1\"\"\"\n    if bool(value) != value:\n        tmpl = \"{attr!r} must be a boolean value (got {value!r})\"\n        raise DistutilsSetupError(tmpl.format(attr=attr, value=value))\n\n\ndef invalid_unless_false(dist, attr, value):\n    if not value:\n        DistDeprecationWarning.emit(f\"{attr} is ignored.\")\n        # TODO: should there be a `due_date` here?\n        return\n    raise DistutilsSetupError(f\"{attr} is invalid.\")\n\n\ndef check_requirements(dist, attr, value):\n    \"\"\"Verify that install_requires is a valid requirements list\"\"\"\n    try:\n        list(_reqs.parse(value))\n        if isinstance(value, (dict, set)):\n            raise TypeError(\"Unordered types are not allowed\")\n    except (TypeError, ValueError) as error:\n        tmpl = (\n            \"{attr!r} must be a string or list of strings \"\n            \"containing valid project/version requirement specifiers; {error}\"\n        )\n        raise DistutilsSetupError(tmpl.format(attr=attr, error=error)) from error\n\n\ndef check_specifier(dist, attr, value):\n    \"\"\"Verify that value is a valid version specifier\"\"\"\n    try:\n        SpecifierSet(value)\n    except (InvalidSpecifier, AttributeError) as error:\n        tmpl = (\n            \"{attr!r} must be a string \" \"containing valid version specifiers; {error}\"\n        )\n        raise DistutilsSetupError(tmpl.format(attr=attr, error=error)) from error\n\n\ndef check_entry_points(dist, attr, value):\n    \"\"\"Verify that entry_points map is parseable\"\"\"\n    try:\n        _entry_points.load(value)\n    except Exception as e:\n        raise DistutilsSetupError(e) from e\n\n\ndef check_test_suite(dist, attr, value):\n    if not isinstance(value, str):\n        raise DistutilsSetupError(\"test_suite must be a string\")\n\n\ndef check_package_data(dist, attr, value):\n    \"\"\"Verify that value is a dictionary of package names to glob lists\"\"\"\n    if not isinstance(value, dict):\n        raise DistutilsSetupError(\n            \"{!r} must be a dictionary mapping package names to lists of \"\n            \"string wildcard patterns\".format(attr)\n        )\n    for k, v in value.items():\n        if not isinstance(k, str):\n            raise DistutilsSetupError(\n                \"keys of {!r} dict must be strings (got {!r})\".format(attr, k)\n            )\n        assert_string_list(dist, 'values of {!r} dict'.format(attr), v)\n\n\ndef check_packages(dist, attr, value):\n    for pkgname in value:\n        if not re.match(r'\\w+(\\.\\w+)*', pkgname):\n            distutils.log.warn(\n                \"WARNING: %r not a valid package name; please use only \"\n                \".-separated package names in setup.py\",\n                pkgname,\n            )\n\n\nif TYPE_CHECKING:\n    # Work around a mypy issue where type[T] can't be used as a base: https://github.com/python/mypy/issues/10962\n    _Distribution = distutils.core.Distribution\nelse:\n    _Distribution = get_unpatched(distutils.core.Distribution)\n\n\nclass Distribution(_Distribution):\n    \"\"\"Distribution with support for tests and package data\n\n    This is an enhanced version of 'distutils.dist.Distribution' that\n    effectively adds the following new optional keyword arguments to 'setup()':\n\n     'install_requires' -- a string or sequence of strings specifying project\n        versions that the distribution requires when installed, in the format\n        used by 'pkg_resources.require()'.  They will be installed\n        automatically when the package is installed.  If you wish to use\n        packages that are not available in PyPI, or want to give your users an\n        alternate download location, you can add a 'find_links' option to the\n        '[easy_install]' section of your project's 'setup.cfg' file, and then\n        setuptools will scan the listed web pages for links that satisfy the\n        requirements.\n\n     'extras_require' -- a dictionary mapping names of optional \"extras\" to the\n        additional requirement(s) that using those extras incurs. For example,\n        this::\n\n            extras_require = dict(reST = [\"docutils>=0.3\", \"reSTedit\"])\n\n        indicates that the distribution can optionally provide an extra\n        capability called \"reST\", but it can only be used if docutils and\n        reSTedit are installed.  If the user installs your package using\n        EasyInstall and requests one of your extras, the corresponding\n        additional requirements will be installed if needed.\n\n     'test_suite' -- the name of a test suite to run for the 'test' command.\n        If the user runs 'python setup.py test', the package will be installed,\n        and the named test suite will be run.  The format is the same as\n        would be used on a 'unittest.py' command line.  That is, it is the\n        dotted name of an object to import and call to generate a test suite.\n\n     'package_data' -- a dictionary mapping package names to lists of filenames\n        or globs to use to find data files contained in the named packages.\n        If the dictionary has filenames or globs listed under '\"\"' (the empty\n        string), those names will be searched for in every package, in addition\n        to any names for the specific package.  Data files found using these\n        names/globs will be installed along with the package, in the same\n        location as the package.  Note that globs are allowed to reference\n        the contents of non-package subdirectories, as long as you use '/' as\n        a path separator.  (Globs are automatically converted to\n        platform-specific paths at runtime.)\n\n    In addition to these new keywords, this class also has several new methods\n    for manipulating the distribution's contents.  For example, the 'include()'\n    and 'exclude()' methods can be thought of as in-place add and subtract\n    commands that add or remove packages, modules, extensions, and so on from\n    the distribution.\n    \"\"\"\n\n    _DISTUTILS_UNSUPPORTED_METADATA = {\n        'long_description_content_type': lambda: None,\n        'project_urls': dict,\n        'provides_extras': OrderedSet,\n        'license_file': lambda: None,\n        'license_files': lambda: None,\n        'install_requires': list,\n        'extras_require': dict,\n    }\n\n    _patched_dist = None\n    # Used by build_py, editable_wheel and install_lib commands for legacy namespaces\n    namespace_packages: list[str]  #: :meta private: DEPRECATED\n\n    def patch_missing_pkg_info(self, attrs):\n        # Fake up a replacement for the data that would normally come from\n        # PKG-INFO, but which might not yet be built if this is a fresh\n        # checkout.\n        #\n        if not attrs or 'name' not in attrs or 'version' not in attrs:\n            return\n        name = _normalization.safe_name(str(attrs['name'])).lower()\n        with suppress(metadata.PackageNotFoundError):\n            dist = metadata.distribution(name)\n            if dist is not None and not dist.read_text('PKG-INFO'):\n                dist._version = _normalization.safe_version(str(attrs['version']))\n                self._patched_dist = dist\n\n    def __init__(self, attrs: MutableMapping | None = None) -> None:\n        have_package_data = hasattr(self, \"package_data\")\n        if not have_package_data:\n            self.package_data: dict[str, list[str]] = {}\n        attrs = attrs or {}\n        self.dist_files: list[tuple[str, str, str]] = []\n        # Filter-out setuptools' specific options.\n        self.src_root = attrs.pop(\"src_root\", None)\n        self.patch_missing_pkg_info(attrs)\n        self.dependency_links = attrs.pop('dependency_links', [])\n        self.setup_requires = attrs.pop('setup_requires', [])\n        for ep in metadata.entry_points(group='distutils.setup_keywords'):\n            vars(self).setdefault(ep.name, None)\n\n        metadata_only = set(self._DISTUTILS_UNSUPPORTED_METADATA)\n        metadata_only -= {\"install_requires\", \"extras_require\"}\n        dist_attrs = {k: v for k, v in attrs.items() if k not in metadata_only}\n        _Distribution.__init__(self, dist_attrs)\n\n        # Private API (setuptools-use only, not restricted to Distribution)\n        # Stores files that are referenced by the configuration and need to be in the\n        # sdist (e.g. `version = file: VERSION.txt`)\n        self._referenced_files: set[str] = set()\n\n        self.set_defaults = ConfigDiscovery(self)\n\n        self._set_metadata_defaults(attrs)\n\n        self.metadata.version = self._normalize_version(self.metadata.version)\n        self._finalize_requires()\n\n    def _validate_metadata(self):\n        required = {\"name\"}\n        provided = {\n            key\n            for key in vars(self.metadata)\n            if getattr(self.metadata, key, None) is not None\n        }\n        missing = required - provided\n\n        if missing:\n            msg = f\"Required package metadata is missing: {missing}\"\n            raise DistutilsSetupError(msg)\n\n    def _set_metadata_defaults(self, attrs):\n        \"\"\"\n        Fill-in missing metadata fields not supported by distutils.\n        Some fields may have been set by other tools (e.g. pbr).\n        Those fields (vars(self.metadata)) take precedence to\n        supplied attrs.\n        \"\"\"\n        for option, default in self._DISTUTILS_UNSUPPORTED_METADATA.items():\n            vars(self.metadata).setdefault(option, attrs.get(option, default()))\n\n    @staticmethod\n    def _normalize_version(version):\n        from . import sic\n\n        if isinstance(version, numbers.Number):\n            # Some people apparently take \"version number\" too literally :)\n            version = str(version)\n        elif isinstance(version, sic) or version is None:\n            return version\n\n        normalized = str(Version(version))\n        if version != normalized:\n            InformationOnly.emit(f\"Normalizing '{version}' to '{normalized}'\")\n            return normalized\n        return version\n\n    def _finalize_requires(self):\n        \"\"\"\n        Set `metadata.python_requires` and fix environment markers\n        in `install_requires` and `extras_require`.\n        \"\"\"\n        if getattr(self, 'python_requires', None):\n            self.metadata.python_requires = self.python_requires\n\n        self._normalize_requires()\n        self.metadata.install_requires = self.install_requires\n        self.metadata.extras_require = self.extras_require\n\n        if self.extras_require:\n            for extra in self.extras_require.keys():\n                # Setuptools allows a weird \"<name>:<env markers> syntax for extras\n                extra = extra.split(':')[0]\n                if extra:\n                    self.metadata.provides_extras.add(extra)\n\n    def _normalize_requires(self):\n        \"\"\"Make sure requirement-related attributes exist and are normalized\"\"\"\n        install_requires = getattr(self, \"install_requires\", None) or []\n        extras_require = getattr(self, \"extras_require\", None) or {}\n        self.install_requires = list(map(str, _reqs.parse(install_requires)))\n        self.extras_require = {\n            k: list(map(str, _reqs.parse(v or []))) for k, v in extras_require.items()\n        }\n\n    def _finalize_license_files(self) -> None:\n        \"\"\"Compute names of all license files which should be included.\"\"\"\n        license_files: list[str] | None = self.metadata.license_files\n        patterns: list[str] = license_files if license_files else []\n\n        license_file: str | None = self.metadata.license_file\n        if license_file and license_file not in patterns:\n            patterns.append(license_file)\n\n        if license_files is None and license_file is None:\n            # Default patterns match the ones wheel uses\n            # See https://wheel.readthedocs.io/en/stable/user_guide.html\n            # -> 'Including license files in the generated wheel file'\n            patterns = ['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']\n\n        self.metadata.license_files = list(\n            unique_everseen(self._expand_patterns(patterns))\n        )\n\n    @staticmethod\n    def _expand_patterns(patterns):\n        \"\"\"\n        >>> list(Distribution._expand_patterns(['LICENSE']))\n        ['LICENSE']\n        >>> list(Distribution._expand_patterns(['pyproject.toml', 'LIC*']))\n        ['pyproject.toml', 'LICENSE']\n        \"\"\"\n        return (\n            path\n            for pattern in patterns\n            for path in sorted(iglob(pattern))\n            if not path.endswith('~') and os.path.isfile(path)\n        )\n\n    # FIXME: 'Distribution._parse_config_files' is too complex (14)\n    def _parse_config_files(self, filenames=None):  # noqa: C901\n        \"\"\"\n        Adapted from distutils.dist.Distribution.parse_config_files,\n        this method provides the same functionality in subtly-improved\n        ways.\n        \"\"\"\n        from configparser import ConfigParser\n\n        # Ignore install directory options if we have a venv\n        ignore_options = (\n            []\n            if sys.prefix == sys.base_prefix\n            else [\n                'install-base',\n                'install-platbase',\n                'install-lib',\n                'install-platlib',\n                'install-purelib',\n                'install-headers',\n                'install-scripts',\n                'install-data',\n                'prefix',\n                'exec-prefix',\n                'home',\n                'user',\n                'root',\n            ]\n        )\n\n        ignore_options = frozenset(ignore_options)\n\n        if filenames is None:\n            filenames = self.find_config_files()\n\n        if DEBUG:\n            self.announce(\"Distribution.parse_config_files():\")\n\n        parser = ConfigParser()\n        parser.optionxform = str\n        for filename in filenames:\n            with open(filename, encoding='utf-8') as reader:\n                if DEBUG:\n                    self.announce(\"  reading {filename}\".format(**locals()))\n                parser.read_file(reader)\n            for section in parser.sections():\n                options = parser.options(section)\n                opt_dict = self.get_option_dict(section)\n\n                for opt in options:\n                    if opt == '__name__' or opt in ignore_options:\n                        continue\n\n                    val = parser.get(section, opt)\n                    opt = self.warn_dash_deprecation(opt, section)\n                    opt = self.make_option_lowercase(opt, section)\n                    opt_dict[opt] = (filename, val)\n\n            # Make the ConfigParser forget everything (so we retain\n            # the original filenames that options come from)\n            parser.__init__()\n\n        if 'global' not in self.command_options:\n            return\n\n        # If there was a \"global\" section in the config file, use it\n        # to set Distribution options.\n\n        for opt, (src, val) in self.command_options['global'].items():\n            alias = self.negative_opt.get(opt)\n            if alias:\n                val = not strtobool(val)\n            elif opt in ('verbose', 'dry_run'):  # ugh!\n                val = strtobool(val)\n\n            try:\n                setattr(self, alias or opt, val)\n            except ValueError as e:\n                raise DistutilsOptionError(e) from e\n\n    def warn_dash_deprecation(self, opt, section):\n        if section in (\n            'options.extras_require',\n            'options.data_files',\n        ):\n            return opt\n\n        underscore_opt = opt.replace('-', '_')\n        commands = list(\n            itertools.chain(\n                distutils.command.__all__,\n                self._setuptools_commands(),\n            )\n        )\n        if (\n            not section.startswith('options')\n            and section != 'metadata'\n            and section not in commands\n        ):\n            return underscore_opt\n\n        if '-' in opt:\n            SetuptoolsDeprecationWarning.emit(\n                \"Invalid dash-separated options\",\n                f\"\"\"\n                Usage of dash-separated {opt!r} will not be supported in future\n                versions. Please use the underscore name {underscore_opt!r} instead.\n                \"\"\",\n                see_docs=\"userguide/declarative_config.html\",\n                due_date=(2024, 9, 26),\n                # Warning initially introduced in 3 Mar 2021\n            )\n        return underscore_opt\n\n    def _setuptools_commands(self):\n        try:\n            entry_points = metadata.distribution('setuptools').entry_points\n            return {ep.name for ep in entry_points}  # Avoid newer API for compatibility\n        except metadata.PackageNotFoundError:\n            # during bootstrapping, distribution doesn't exist\n            return []\n\n    def make_option_lowercase(self, opt, section):\n        if section != 'metadata' or opt.islower():\n            return opt\n\n        lowercase_opt = opt.lower()\n        SetuptoolsDeprecationWarning.emit(\n            \"Invalid uppercase configuration\",\n            f\"\"\"\n            Usage of uppercase key {opt!r} in {section!r} will not be supported in\n            future versions. Please use lowercase {lowercase_opt!r} instead.\n            \"\"\",\n            see_docs=\"userguide/declarative_config.html\",\n            due_date=(2024, 9, 26),\n            # Warning initially introduced in 6 Mar 2021\n        )\n        return lowercase_opt\n\n    # FIXME: 'Distribution._set_command_options' is too complex (14)\n    def _set_command_options(self, command_obj, option_dict=None):  # noqa: C901\n        \"\"\"\n        Set the options for 'command_obj' from 'option_dict'.  Basically\n        this means copying elements of a dictionary ('option_dict') to\n        attributes of an instance ('command').\n\n        'command_obj' must be a Command instance.  If 'option_dict' is not\n        supplied, uses the standard option dictionary for this command\n        (from 'self.command_options').\n\n        (Adopted from distutils.dist.Distribution._set_command_options)\n        \"\"\"\n        command_name = command_obj.get_command_name()\n        if option_dict is None:\n            option_dict = self.get_option_dict(command_name)\n\n        if DEBUG:\n            self.announce(\"  setting options for '%s' command:\" % command_name)\n        for option, (source, value) in option_dict.items():\n            if DEBUG:\n                self.announce(\"    %s = %s (from %s)\" % (option, value, source))\n            try:\n                bool_opts = [translate_longopt(o) for o in command_obj.boolean_options]\n            except AttributeError:\n                bool_opts = []\n            try:\n                neg_opt = command_obj.negative_opt\n            except AttributeError:\n                neg_opt = {}\n\n            try:\n                is_string = isinstance(value, str)\n                if option in neg_opt and is_string:\n                    setattr(command_obj, neg_opt[option], not strtobool(value))\n                elif option in bool_opts and is_string:\n                    setattr(command_obj, option, strtobool(value))\n                elif hasattr(command_obj, option):\n                    setattr(command_obj, option, value)\n                else:\n                    raise DistutilsOptionError(\n                        \"error in %s: command '%s' has no such option '%s'\"\n                        % (source, command_name, option)\n                    )\n            except ValueError as e:\n                raise DistutilsOptionError(e) from e\n\n    def _get_project_config_files(self, filenames):\n        \"\"\"Add default file and split between INI and TOML\"\"\"\n        tomlfiles = []\n        standard_project_metadata = Path(self.src_root or os.curdir, \"pyproject.toml\")\n        if filenames is not None:\n            parts = partition(lambda f: Path(f).suffix == \".toml\", filenames)\n            filenames = list(parts[0])  # 1st element => predicate is False\n            tomlfiles = list(parts[1])  # 2nd element => predicate is True\n        elif standard_project_metadata.exists():\n            tomlfiles = [standard_project_metadata]\n        return filenames, tomlfiles\n\n    def parse_config_files(self, filenames=None, ignore_option_errors=False):\n        \"\"\"Parses configuration files from various levels\n        and loads configuration.\n        \"\"\"\n        inifiles, tomlfiles = self._get_project_config_files(filenames)\n\n        self._parse_config_files(filenames=inifiles)\n\n        setupcfg.parse_configuration(\n            self, self.command_options, ignore_option_errors=ignore_option_errors\n        )\n        for filename in tomlfiles:\n            pyprojecttoml.apply_configuration(self, filename, ignore_option_errors)\n\n        self._finalize_requires()\n        self._finalize_license_files()\n\n    def fetch_build_eggs(self, requires):\n        \"\"\"Resolve pre-setup requirements\"\"\"\n        from .installer import _fetch_build_eggs\n\n        return _fetch_build_eggs(self, requires)\n\n    def finalize_options(self):\n        \"\"\"\n        Allow plugins to apply arbitrary operations to the\n        distribution. Each hook may optionally define a 'order'\n        to influence the order of execution. Smaller numbers\n        go first and the default is 0.\n        \"\"\"\n        group = 'setuptools.finalize_distribution_options'\n\n        def by_order(hook):\n            return getattr(hook, 'order', 0)\n\n        defined = metadata.entry_points(group=group)\n        filtered = itertools.filterfalse(self._removed, defined)\n        loaded = map(lambda e: e.load(), filtered)\n        for ep in sorted(loaded, key=by_order):\n            ep(self)\n\n    @staticmethod\n    def _removed(ep):\n        \"\"\"\n        When removing an entry point, if metadata is loaded\n        from an older version of Setuptools, that removed\n        entry point will attempt to be loaded and will fail.\n        See #2765 for more details.\n        \"\"\"\n        removed = {\n            # removed 2021-09-05\n            '2to3_doctests',\n        }\n        return ep.name in removed\n\n    def _finalize_setup_keywords(self):\n        for ep in metadata.entry_points(group='distutils.setup_keywords'):\n            value = getattr(self, ep.name, None)\n            if value is not None:\n                ep.load()(self, ep.name, value)\n\n    def get_egg_cache_dir(self):\n        from . import windows_support\n\n        egg_cache_dir = os.path.join(os.curdir, '.eggs')\n        if not os.path.exists(egg_cache_dir):\n            os.mkdir(egg_cache_dir)\n            windows_support.hide_file(egg_cache_dir)\n            readme_txt_filename = os.path.join(egg_cache_dir, 'README.txt')\n            with open(readme_txt_filename, 'w', encoding=\"utf-8\") as f:\n                f.write(\n                    'This directory contains eggs that were downloaded '\n                    'by setuptools to build, test, and run plug-ins.\\n\\n'\n                )\n                f.write(\n                    'This directory caches those eggs to prevent '\n                    'repeated downloads.\\n\\n'\n                )\n                f.write('However, it is safe to delete this directory.\\n\\n')\n\n        return egg_cache_dir\n\n    def fetch_build_egg(self, req):\n        \"\"\"Fetch an egg needed for building\"\"\"\n        from .installer import fetch_build_egg\n\n        return fetch_build_egg(self, req)\n\n    def get_command_class(self, command):\n        \"\"\"Pluggable version of get_command_class()\"\"\"\n        if command in self.cmdclass:\n            return self.cmdclass[command]\n\n        # Special case bdist_wheel so it's never loaded from \"wheel\"\n        if command == 'bdist_wheel':\n            from .command.bdist_wheel import bdist_wheel\n\n            return bdist_wheel\n\n        eps = metadata.entry_points(group='distutils.commands', name=command)\n        for ep in eps:\n            self.cmdclass[command] = cmdclass = ep.load()\n            return cmdclass\n        else:\n            return _Distribution.get_command_class(self, command)\n\n    def print_commands(self):\n        for ep in metadata.entry_points(group='distutils.commands'):\n            if ep.name not in self.cmdclass:\n                cmdclass = ep.load()\n                self.cmdclass[ep.name] = cmdclass\n        return _Distribution.print_commands(self)\n\n    def get_command_list(self):\n        for ep in metadata.entry_points(group='distutils.commands'):\n            if ep.name not in self.cmdclass:\n                cmdclass = ep.load()\n                self.cmdclass[ep.name] = cmdclass\n        return _Distribution.get_command_list(self)\n\n    def include(self, **attrs):\n        \"\"\"Add items to distribution that are named in keyword arguments\n\n        For example, 'dist.include(py_modules=[\"x\"])' would add 'x' to\n        the distribution's 'py_modules' attribute, if it was not already\n        there.\n\n        Currently, this method only supports inclusion for attributes that are\n        lists or tuples.  If you need to add support for adding to other\n        attributes in this or a subclass, you can add an '_include_X' method,\n        where 'X' is the name of the attribute.  The method will be called with\n        the value passed to 'include()'.  So, 'dist.include(foo={\"bar\":\"baz\"})'\n        will try to call 'dist._include_foo({\"bar\":\"baz\"})', which can then\n        handle whatever special inclusion logic is needed.\n        \"\"\"\n        for k, v in attrs.items():\n            include = getattr(self, '_include_' + k, None)\n            if include:\n                include(v)\n            else:\n                self._include_misc(k, v)\n\n    def exclude_package(self, package):\n        \"\"\"Remove packages, modules, and extensions in named package\"\"\"\n\n        pfx = package + '.'\n        if self.packages:\n            self.packages = [\n                p for p in self.packages if p != package and not p.startswith(pfx)\n            ]\n\n        if self.py_modules:\n            self.py_modules = [\n                p for p in self.py_modules if p != package and not p.startswith(pfx)\n            ]\n\n        if self.ext_modules:\n            self.ext_modules = [\n                p\n                for p in self.ext_modules\n                if p.name != package and not p.name.startswith(pfx)\n            ]\n\n    def has_contents_for(self, package):\n        \"\"\"Return true if 'exclude_package(package)' would do something\"\"\"\n\n        pfx = package + '.'\n\n        for p in self.iter_distribution_names():\n            if p == package or p.startswith(pfx):\n                return True\n\n        return False\n\n    def _exclude_misc(self, name, value):\n        \"\"\"Handle 'exclude()' for list/tuple attrs without a special handler\"\"\"\n        if not isinstance(value, sequence):\n            raise DistutilsSetupError(\n                \"%s: setting must be a list or tuple (%r)\" % (name, value)\n            )\n        try:\n            old = getattr(self, name)\n        except AttributeError as e:\n            raise DistutilsSetupError(\"%s: No such distribution setting\" % name) from e\n        if old is not None and not isinstance(old, sequence):\n            raise DistutilsSetupError(\n                name + \": this setting cannot be changed via include/exclude\"\n            )\n        elif old:\n            setattr(self, name, [item for item in old if item not in value])\n\n    def _include_misc(self, name, value):\n        \"\"\"Handle 'include()' for list/tuple attrs without a special handler\"\"\"\n\n        if not isinstance(value, sequence):\n            raise DistutilsSetupError(\"%s: setting must be a list (%r)\" % (name, value))\n        try:\n            old = getattr(self, name)\n        except AttributeError as e:\n            raise DistutilsSetupError(\"%s: No such distribution setting\" % name) from e\n        if old is None:\n            setattr(self, name, value)\n        elif not isinstance(old, sequence):\n            raise DistutilsSetupError(\n                name + \": this setting cannot be changed via include/exclude\"\n            )\n        else:\n            new = [item for item in value if item not in old]\n            setattr(self, name, old + new)\n\n    def exclude(self, **attrs):\n        \"\"\"Remove items from distribution that are named in keyword arguments\n\n        For example, 'dist.exclude(py_modules=[\"x\"])' would remove 'x' from\n        the distribution's 'py_modules' attribute.  Excluding packages uses\n        the 'exclude_package()' method, so all of the package's contained\n        packages, modules, and extensions are also excluded.\n\n        Currently, this method only supports exclusion from attributes that are\n        lists or tuples.  If you need to add support for excluding from other\n        attributes in this or a subclass, you can add an '_exclude_X' method,\n        where 'X' is the name of the attribute.  The method will be called with\n        the value passed to 'exclude()'.  So, 'dist.exclude(foo={\"bar\":\"baz\"})'\n        will try to call 'dist._exclude_foo({\"bar\":\"baz\"})', which can then\n        handle whatever special exclusion logic is needed.\n        \"\"\"\n        for k, v in attrs.items():\n            exclude = getattr(self, '_exclude_' + k, None)\n            if exclude:\n                exclude(v)\n            else:\n                self._exclude_misc(k, v)\n\n    def _exclude_packages(self, packages):\n        if not isinstance(packages, sequence):\n            raise DistutilsSetupError(\n                \"packages: setting must be a list or tuple (%r)\" % (packages,)\n            )\n        list(map(self.exclude_package, packages))\n\n    def _parse_command_opts(self, parser, args):\n        # Remove --with-X/--without-X options when processing command args\n        self.global_options = self.__class__.global_options\n        self.negative_opt = self.__class__.negative_opt\n\n        # First, expand any aliases\n        command = args[0]\n        aliases = self.get_option_dict('aliases')\n        while command in aliases:\n            src, alias = aliases[command]\n            del aliases[command]  # ensure each alias can expand only once!\n            import shlex\n\n            args[:1] = shlex.split(alias, True)\n            command = args[0]\n\n        nargs = _Distribution._parse_command_opts(self, parser, args)\n\n        # Handle commands that want to consume all remaining arguments\n        cmd_class = self.get_command_class(command)\n        if getattr(cmd_class, 'command_consumes_arguments', None):\n            self.get_option_dict(command)['args'] = (\"command line\", nargs)\n            if nargs is not None:\n                return []\n\n        return nargs\n\n    def get_cmdline_options(self):\n        \"\"\"Return a '{cmd: {opt:val}}' map of all command-line options\n\n        Option names are all long, but do not include the leading '--', and\n        contain dashes rather than underscores.  If the option doesn't take\n        an argument (e.g. '--quiet'), the 'val' is 'None'.\n\n        Note that options provided by config files are intentionally excluded.\n        \"\"\"\n\n        d = {}\n\n        for cmd, opts in self.command_options.items():\n            for opt, (src, val) in opts.items():\n                if src != \"command line\":\n                    continue\n\n                opt = opt.replace('_', '-')\n\n                if val == 0:\n                    cmdobj = self.get_command_obj(cmd)\n                    neg_opt = self.negative_opt.copy()\n                    neg_opt.update(getattr(cmdobj, 'negative_opt', {}))\n                    for neg, pos in neg_opt.items():\n                        if pos == opt:\n                            opt = neg\n                            val = None\n                            break\n                    else:\n                        raise AssertionError(\"Shouldn't be able to get here\")\n\n                elif val == 1:\n                    val = None\n\n                d.setdefault(cmd, {})[opt] = val\n\n        return d\n\n    def iter_distribution_names(self):\n        \"\"\"Yield all packages, modules, and extension names in distribution\"\"\"\n\n        yield from self.packages or ()\n\n        yield from self.py_modules or ()\n\n        for ext in self.ext_modules or ():\n            if isinstance(ext, tuple):\n                name, buildinfo = ext\n            else:\n                name = ext.name\n            if name.endswith('module'):\n                name = name[:-6]\n            yield name\n\n    def handle_display_options(self, option_order):\n        \"\"\"If there were any non-global \"display-only\" options\n        (--help-commands or the metadata display options) on the command\n        line, display the requested info and return true; else return\n        false.\n        \"\"\"\n        import sys\n\n        if self.help_commands:\n            return _Distribution.handle_display_options(self, option_order)\n\n        # Stdout may be StringIO (e.g. in tests)\n        if not isinstance(sys.stdout, io.TextIOWrapper):\n            return _Distribution.handle_display_options(self, option_order)\n\n        # Don't wrap stdout if utf-8 is already the encoding. Provides\n        #  workaround for #334.\n        if sys.stdout.encoding.lower() in ('utf-8', 'utf8'):\n            return _Distribution.handle_display_options(self, option_order)\n\n        # Print metadata in UTF-8 no matter the platform\n        encoding = sys.stdout.encoding\n        sys.stdout.reconfigure(encoding='utf-8')\n        try:\n            return _Distribution.handle_display_options(self, option_order)\n        finally:\n            sys.stdout.reconfigure(encoding=encoding)\n\n    def run_command(self, command):\n        self.set_defaults()\n        # Postpone defaults until all explicit configuration is considered\n        # (setup() args, config files, command line and plugins)\n\n        super().run_command(command)\n\n\nclass DistDeprecationWarning(SetuptoolsDeprecationWarning):\n    \"\"\"Class for warning about deprecations in dist in\n    setuptools. Not ignored by default, unlike DeprecationWarning.\"\"\"\n", "setuptools/depends.py": "import sys\nimport marshal\nimport contextlib\nimport dis\n\n\nfrom . import _imp\nfrom ._imp import find_module, PY_COMPILED, PY_FROZEN, PY_SOURCE\nfrom .extern.packaging.version import Version\n\n\n__all__ = ['Require', 'find_module']\n\n\nclass Require:\n    \"\"\"A prerequisite to building or installing a distribution\"\"\"\n\n    def __init__(\n        self, name, requested_version, module, homepage='', attribute=None, format=None\n    ):\n        if format is None and requested_version is not None:\n            format = Version\n\n        if format is not None:\n            requested_version = format(requested_version)\n            if attribute is None:\n                attribute = '__version__'\n\n        self.__dict__.update(locals())\n        del self.self\n\n    def full_name(self):\n        \"\"\"Return full package/distribution name, w/version\"\"\"\n        if self.requested_version is not None:\n            return '%s-%s' % (self.name, self.requested_version)\n        return self.name\n\n    def version_ok(self, version):\n        \"\"\"Is 'version' sufficiently up-to-date?\"\"\"\n        return (\n            self.attribute is None\n            or self.format is None\n            or str(version) != \"unknown\"\n            and self.format(version) >= self.requested_version\n        )\n\n    def get_version(self, paths=None, default=\"unknown\"):\n        \"\"\"Get version number of installed module, 'None', or 'default'\n\n        Search 'paths' for module.  If not found, return 'None'.  If found,\n        return the extracted version attribute, or 'default' if no version\n        attribute was specified, or the value cannot be determined without\n        importing the module.  The version is formatted according to the\n        requirement's version format (if any), unless it is 'None' or the\n        supplied 'default'.\n        \"\"\"\n\n        if self.attribute is None:\n            try:\n                f, p, i = find_module(self.module, paths)\n                if f:\n                    f.close()\n                return default\n            except ImportError:\n                return None\n\n        v = get_module_constant(self.module, self.attribute, default, paths)\n\n        if v is not None and v is not default and self.format is not None:\n            return self.format(v)\n\n        return v\n\n    def is_present(self, paths=None):\n        \"\"\"Return true if dependency is present on 'paths'\"\"\"\n        return self.get_version(paths) is not None\n\n    def is_current(self, paths=None):\n        \"\"\"Return true if dependency is present and up-to-date on 'paths'\"\"\"\n        version = self.get_version(paths)\n        if version is None:\n            return False\n        return self.version_ok(str(version))\n\n\ndef maybe_close(f):\n    @contextlib.contextmanager\n    def empty():\n        yield\n        return\n\n    if not f:\n        return empty()\n\n    return contextlib.closing(f)\n\n\n# Some objects are not available on some platforms.\n# XXX it'd be better to test assertions about bytecode instead.\nif not sys.platform.startswith('java') and sys.platform != 'cli':\n\n    def get_module_constant(module, symbol, default=-1, paths=None):\n        \"\"\"Find 'module' by searching 'paths', and extract 'symbol'\n\n        Return 'None' if 'module' does not exist on 'paths', or it does not define\n        'symbol'.  If the module defines 'symbol' as a constant, return the\n        constant.  Otherwise, return 'default'.\"\"\"\n\n        try:\n            f, path, (suffix, mode, kind) = info = find_module(module, paths)\n        except ImportError:\n            # Module doesn't exist\n            return None\n\n        with maybe_close(f):\n            if kind == PY_COMPILED:\n                f.read(8)  # skip magic & date\n                code = marshal.load(f)\n            elif kind == PY_FROZEN:\n                code = _imp.get_frozen_object(module, paths)\n            elif kind == PY_SOURCE:\n                code = compile(f.read(), path, 'exec')\n            else:\n                # Not something we can parse; we'll have to import it.  :(\n                imported = _imp.get_module(module, paths, info)\n                return getattr(imported, symbol, None)\n\n        return extract_constant(code, symbol, default)\n\n    def extract_constant(code, symbol, default=-1):\n        \"\"\"Extract the constant value of 'symbol' from 'code'\n\n        If the name 'symbol' is bound to a constant value by the Python code\n        object 'code', return that value.  If 'symbol' is bound to an expression,\n        return 'default'.  Otherwise, return 'None'.\n\n        Return value is based on the first assignment to 'symbol'.  'symbol' must\n        be a global, or at least a non-\"fast\" local in the code block.  That is,\n        only 'STORE_NAME' and 'STORE_GLOBAL' opcodes are checked, and 'symbol'\n        must be present in 'code.co_names'.\n        \"\"\"\n        if symbol not in code.co_names:\n            # name's not there, can't possibly be an assignment\n            return None\n\n        name_idx = list(code.co_names).index(symbol)\n\n        STORE_NAME = dis.opmap['STORE_NAME']\n        STORE_GLOBAL = dis.opmap['STORE_GLOBAL']\n        LOAD_CONST = dis.opmap['LOAD_CONST']\n\n        const = default\n\n        for byte_code in dis.Bytecode(code):\n            op = byte_code.opcode\n            arg = byte_code.arg\n\n            if op == LOAD_CONST:\n                const = code.co_consts[arg]\n            elif arg == name_idx and (op == STORE_NAME or op == STORE_GLOBAL):\n                return const\n            else:\n                const = default\n\n        return None\n\n    __all__ += ['get_module_constant', 'extract_constant']\n", "setuptools/extension.py": "import re\nimport functools\nimport distutils.core\nimport distutils.errors\nimport distutils.extension\nfrom typing import TYPE_CHECKING\n\nfrom .monkey import get_unpatched\n\n\ndef _have_cython():\n    \"\"\"\n    Return True if Cython can be imported.\n    \"\"\"\n    cython_impl = 'Cython.Distutils.build_ext'\n    try:\n        # from (cython_impl) import build_ext\n        __import__(cython_impl, fromlist=['build_ext']).build_ext\n        return True\n    except Exception:\n        pass\n    return False\n\n\n# for compatibility\nhave_pyrex = _have_cython\nif TYPE_CHECKING:\n    # Work around a mypy issue where type[T] can't be used as a base: https://github.com/python/mypy/issues/10962\n    _Extension = distutils.core.Extension\nelse:\n    _Extension = get_unpatched(distutils.core.Extension)\n\n\nclass Extension(_Extension):\n    \"\"\"\n    Describes a single extension module.\n\n    This means that all source files will be compiled into a single binary file\n    ``<module path>.<suffix>`` (with ``<module path>`` derived from ``name`` and\n    ``<suffix>`` defined by one of the values in\n    ``importlib.machinery.EXTENSION_SUFFIXES``).\n\n    In the case ``.pyx`` files are passed as ``sources and`` ``Cython`` is **not**\n    installed in the build environment, ``setuptools`` may also try to look for the\n    equivalent ``.cpp`` or ``.c`` files.\n\n    :arg str name:\n      the full name of the extension, including any packages -- ie.\n      *not* a filename or pathname, but Python dotted name\n\n    :arg list[str] sources:\n      list of source filenames, relative to the distribution root\n      (where the setup script lives), in Unix form (slash-separated)\n      for portability.  Source files may be C, C++, SWIG (.i),\n      platform-specific resource files, or whatever else is recognized\n      by the \"build_ext\" command as source for a Python extension.\n\n    :keyword list[str] include_dirs:\n      list of directories to search for C/C++ header files (in Unix\n      form for portability)\n\n    :keyword list[tuple[str, str|None]] define_macros:\n      list of macros to define; each macro is defined using a 2-tuple:\n      the first item corresponding to the name of the macro and the second\n      item either a string with its value or None to\n      define it without a particular value (equivalent of \"#define\n      FOO\" in source or -DFOO on Unix C compiler command line)\n\n    :keyword list[str] undef_macros:\n      list of macros to undefine explicitly\n\n    :keyword list[str] library_dirs:\n      list of directories to search for C/C++ libraries at link time\n\n    :keyword list[str] libraries:\n      list of library names (not filenames or paths) to link against\n\n    :keyword list[str] runtime_library_dirs:\n      list of directories to search for C/C++ libraries at run time\n      (for shared extensions, this is when the extension is loaded).\n      Setting this will cause an exception during build on Windows\n      platforms.\n\n    :keyword list[str] extra_objects:\n      list of extra files to link with (eg. object files not implied\n      by 'sources', static library that must be explicitly specified,\n      binary resource files, etc.)\n\n    :keyword list[str] extra_compile_args:\n      any extra platform- and compiler-specific information to use\n      when compiling the source files in 'sources'.  For platforms and\n      compilers where \"command line\" makes sense, this is typically a\n      list of command-line arguments, but for other platforms it could\n      be anything.\n\n    :keyword list[str] extra_link_args:\n      any extra platform- and compiler-specific information to use\n      when linking object files together to create the extension (or\n      to create a new static Python interpreter).  Similar\n      interpretation as for 'extra_compile_args'.\n\n    :keyword list[str] export_symbols:\n      list of symbols to be exported from a shared extension.  Not\n      used on all platforms, and not generally necessary for Python\n      extensions, which typically export exactly one symbol: \"init\" +\n      extension_name.\n\n    :keyword list[str] swig_opts:\n      any extra options to pass to SWIG if a source file has the .i\n      extension.\n\n    :keyword list[str] depends:\n      list of files that the extension depends on\n\n    :keyword str language:\n      extension language (i.e. \"c\", \"c++\", \"objc\"). Will be detected\n      from the source extensions if not provided.\n\n    :keyword bool optional:\n      specifies that a build failure in the extension should not abort the\n      build process, but simply not install the failing extension.\n\n    :keyword bool py_limited_api:\n      opt-in flag for the usage of :doc:`Python's limited API <python:c-api/stable>`.\n\n    :raises setuptools.errors.PlatformError: if 'runtime_library_dirs' is\n      specified on Windows. (since v63)\n    \"\"\"\n\n    def __init__(self, name, sources, *args, **kw):\n        # The *args is needed for compatibility as calls may use positional\n        # arguments. py_limited_api may be set only via keyword.\n        self.py_limited_api = kw.pop(\"py_limited_api\", False)\n        super().__init__(name, sources, *args, **kw)\n\n    def _convert_pyx_sources_to_lang(self):\n        \"\"\"\n        Replace sources with .pyx extensions to sources with the target\n        language extension. This mechanism allows language authors to supply\n        pre-converted sources but to prefer the .pyx sources.\n        \"\"\"\n        if _have_cython():\n            # the build has Cython, so allow it to compile the .pyx files\n            return\n        lang = self.language or ''\n        target_ext = '.cpp' if lang.lower() == 'c++' else '.c'\n        sub = functools.partial(re.sub, '.pyx$', target_ext)\n        self.sources = list(map(sub, self.sources))\n\n\nclass Library(Extension):\n    \"\"\"Just like a regular Extension, but built as a library instead\"\"\"\n", "setuptools/version.py": "from ._importlib import metadata\n\ntry:\n    __version__ = metadata.version('setuptools') or '0.dev0+unknown'\nexcept Exception:\n    __version__ = '0.dev0+unknown'\n", "setuptools/wheel.py": "\"\"\"Wheels support.\"\"\"\n\nimport email\nimport itertools\nimport functools\nimport os\nimport posixpath\nimport re\nimport zipfile\nimport contextlib\n\nfrom distutils.util import get_platform\n\nimport setuptools\nfrom setuptools.extern.packaging.version import Version as parse_version\nfrom setuptools.extern.packaging.tags import sys_tags\nfrom setuptools.extern.packaging.utils import canonicalize_name\nfrom setuptools.command.egg_info import write_requirements, _egg_basename\nfrom setuptools.archive_util import _unpack_zipfile_obj\n\nfrom .unicode_utils import _read_utf8_with_fallback\n\n\nWHEEL_NAME = re.compile(\n    r\"\"\"^(?P<project_name>.+?)-(?P<version>\\d.*?)\n    ((-(?P<build>\\d.*?))?-(?P<py_version>.+?)-(?P<abi>.+?)-(?P<platform>.+?)\n    )\\.whl$\"\"\",\n    re.VERBOSE,\n).match\n\nNAMESPACE_PACKAGE_INIT = \"__import__('pkg_resources').declare_namespace(__name__)\\n\"\n\n\n@functools.lru_cache(maxsize=None)\ndef _get_supported_tags():\n    # We calculate the supported tags only once, otherwise calling\n    # this method on thousands of wheels takes seconds instead of\n    # milliseconds.\n    return {(t.interpreter, t.abi, t.platform) for t in sys_tags()}\n\n\ndef unpack(src_dir, dst_dir):\n    \"\"\"Move everything under `src_dir` to `dst_dir`, and delete the former.\"\"\"\n    for dirpath, dirnames, filenames in os.walk(src_dir):\n        subdir = os.path.relpath(dirpath, src_dir)\n        for f in filenames:\n            src = os.path.join(dirpath, f)\n            dst = os.path.join(dst_dir, subdir, f)\n            os.renames(src, dst)\n        for n, d in reversed(list(enumerate(dirnames))):\n            src = os.path.join(dirpath, d)\n            dst = os.path.join(dst_dir, subdir, d)\n            if not os.path.exists(dst):\n                # Directory does not exist in destination,\n                # rename it and prune it from os.walk list.\n                os.renames(src, dst)\n                del dirnames[n]\n    # Cleanup.\n    for dirpath, dirnames, filenames in os.walk(src_dir, topdown=True):\n        assert not filenames\n        os.rmdir(dirpath)\n\n\n@contextlib.contextmanager\ndef disable_info_traces():\n    \"\"\"\n    Temporarily disable info traces.\n    \"\"\"\n    from distutils import log\n\n    saved = log.set_threshold(log.WARN)\n    try:\n        yield\n    finally:\n        log.set_threshold(saved)\n\n\nclass Wheel:\n    def __init__(self, filename):\n        match = WHEEL_NAME(os.path.basename(filename))\n        if match is None:\n            raise ValueError('invalid wheel name: %r' % filename)\n        self.filename = filename\n        for k, v in match.groupdict().items():\n            setattr(self, k, v)\n\n    def tags(self):\n        \"\"\"List tags (py_version, abi, platform) supported by this wheel.\"\"\"\n        return itertools.product(\n            self.py_version.split('.'),\n            self.abi.split('.'),\n            self.platform.split('.'),\n        )\n\n    def is_compatible(self):\n        \"\"\"Is the wheel compatible with the current platform?\"\"\"\n        return next((True for t in self.tags() if t in _get_supported_tags()), False)\n\n    def egg_name(self):\n        return (\n            _egg_basename(\n                self.project_name,\n                self.version,\n                platform=(None if self.platform == 'any' else get_platform()),\n            )\n            + \".egg\"\n        )\n\n    def get_dist_info(self, zf):\n        # find the correct name of the .dist-info dir in the wheel file\n        for member in zf.namelist():\n            dirname = posixpath.dirname(member)\n            if dirname.endswith('.dist-info') and canonicalize_name(dirname).startswith(\n                canonicalize_name(self.project_name)\n            ):\n                return dirname\n        raise ValueError(\"unsupported wheel format. .dist-info not found\")\n\n    def install_as_egg(self, destination_eggdir):\n        \"\"\"Install wheel as an egg directory.\"\"\"\n        with zipfile.ZipFile(self.filename) as zf:\n            self._install_as_egg(destination_eggdir, zf)\n\n    def _install_as_egg(self, destination_eggdir, zf):\n        dist_basename = '%s-%s' % (self.project_name, self.version)\n        dist_info = self.get_dist_info(zf)\n        dist_data = '%s.data' % dist_basename\n        egg_info = os.path.join(destination_eggdir, 'EGG-INFO')\n\n        self._convert_metadata(zf, destination_eggdir, dist_info, egg_info)\n        self._move_data_entries(destination_eggdir, dist_data)\n        self._fix_namespace_packages(egg_info, destination_eggdir)\n\n    @staticmethod\n    def _convert_metadata(zf, destination_eggdir, dist_info, egg_info):\n        import pkg_resources\n\n        def get_metadata(name):\n            with zf.open(posixpath.join(dist_info, name)) as fp:\n                value = fp.read().decode('utf-8')\n                return email.parser.Parser().parsestr(value)\n\n        wheel_metadata = get_metadata('WHEEL')\n        # Check wheel format version is supported.\n        wheel_version = parse_version(wheel_metadata.get('Wheel-Version'))\n        wheel_v1 = parse_version('1.0') <= wheel_version < parse_version('2.0dev0')\n        if not wheel_v1:\n            raise ValueError('unsupported wheel format version: %s' % wheel_version)\n        # Extract to target directory.\n        _unpack_zipfile_obj(zf, destination_eggdir)\n        # Convert metadata.\n        dist_info = os.path.join(destination_eggdir, dist_info)\n        dist = pkg_resources.Distribution.from_location(\n            destination_eggdir,\n            dist_info,\n            metadata=pkg_resources.PathMetadata(destination_eggdir, dist_info),\n        )\n\n        # Note: Evaluate and strip markers now,\n        # as it's difficult to convert back from the syntax:\n        # foobar; \"linux\" in sys_platform and extra == 'test'\n        def raw_req(req):\n            req.marker = None\n            return str(req)\n\n        install_requires = list(map(raw_req, dist.requires()))\n        extras_require = {\n            extra: [\n                req\n                for req in map(raw_req, dist.requires((extra,)))\n                if req not in install_requires\n            ]\n            for extra in dist.extras\n        }\n        os.rename(dist_info, egg_info)\n        os.rename(\n            os.path.join(egg_info, 'METADATA'),\n            os.path.join(egg_info, 'PKG-INFO'),\n        )\n        setup_dist = setuptools.Distribution(\n            attrs=dict(\n                install_requires=install_requires,\n                extras_require=extras_require,\n            ),\n        )\n        with disable_info_traces():\n            write_requirements(\n                setup_dist.get_command_obj('egg_info'),\n                None,\n                os.path.join(egg_info, 'requires.txt'),\n            )\n\n    @staticmethod\n    def _move_data_entries(destination_eggdir, dist_data):\n        \"\"\"Move data entries to their correct location.\"\"\"\n        dist_data = os.path.join(destination_eggdir, dist_data)\n        dist_data_scripts = os.path.join(dist_data, 'scripts')\n        if os.path.exists(dist_data_scripts):\n            egg_info_scripts = os.path.join(destination_eggdir, 'EGG-INFO', 'scripts')\n            os.mkdir(egg_info_scripts)\n            for entry in os.listdir(dist_data_scripts):\n                # Remove bytecode, as it's not properly handled\n                # during easy_install scripts install phase.\n                if entry.endswith('.pyc'):\n                    os.unlink(os.path.join(dist_data_scripts, entry))\n                else:\n                    os.rename(\n                        os.path.join(dist_data_scripts, entry),\n                        os.path.join(egg_info_scripts, entry),\n                    )\n            os.rmdir(dist_data_scripts)\n        for subdir in filter(\n            os.path.exists,\n            (\n                os.path.join(dist_data, d)\n                for d in ('data', 'headers', 'purelib', 'platlib')\n            ),\n        ):\n            unpack(subdir, destination_eggdir)\n        if os.path.exists(dist_data):\n            os.rmdir(dist_data)\n\n    @staticmethod\n    def _fix_namespace_packages(egg_info, destination_eggdir):\n        namespace_packages = os.path.join(egg_info, 'namespace_packages.txt')\n        if os.path.exists(namespace_packages):\n            namespace_packages = _read_utf8_with_fallback(namespace_packages).split()\n\n            for mod in namespace_packages:\n                mod_dir = os.path.join(destination_eggdir, *mod.split('.'))\n                mod_init = os.path.join(mod_dir, '__init__.py')\n                if not os.path.exists(mod_dir):\n                    os.mkdir(mod_dir)\n                if not os.path.exists(mod_init):\n                    with open(mod_init, 'w', encoding=\"utf-8\") as fp:\n                        fp.write(NAMESPACE_PACKAGE_INIT)\n", "setuptools/warnings.py": "\"\"\"Provide basic warnings used by setuptools modules.\n\nUsing custom classes (other than ``UserWarning``) allow users to set\n``PYTHONWARNINGS`` filters to run tests and prepare for upcoming changes in\nsetuptools.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport warnings\nfrom datetime import date\nfrom inspect import cleandoc\nfrom textwrap import indent\nfrom typing import Tuple\n\n_DueDate = Tuple[int, int, int]  # time tuple\n_INDENT = 8 * \" \"\n_TEMPLATE = f\"\"\"{80 * '*'}\\n{{details}}\\n{80 * '*'}\"\"\"\n\n\nclass SetuptoolsWarning(UserWarning):\n    \"\"\"Base class in ``setuptools`` warning hierarchy.\"\"\"\n\n    @classmethod\n    def emit(\n        cls,\n        summary: str | None = None,\n        details: str | None = None,\n        due_date: _DueDate | None = None,\n        see_docs: str | None = None,\n        see_url: str | None = None,\n        stacklevel: int = 2,\n        **kwargs,\n    ):\n        \"\"\"Private: reserved for ``setuptools`` internal use only\"\"\"\n        # Default values:\n        summary_ = summary or getattr(cls, \"_SUMMARY\", None) or \"\"\n        details_ = details or getattr(cls, \"_DETAILS\", None) or \"\"\n        due_date = due_date or getattr(cls, \"_DUE_DATE\", None)\n        docs_ref = see_docs or getattr(cls, \"_SEE_DOCS\", None)\n        docs_url = docs_ref and f\"https://setuptools.pypa.io/en/latest/{docs_ref}\"\n        see_url = see_url or getattr(cls, \"_SEE_URL\", None)\n        due = date(*due_date) if due_date else None\n\n        text = cls._format(summary_, details_, due, see_url or docs_url, kwargs)\n        if due and due < date.today() and _should_enforce():\n            raise cls(text)\n        warnings.warn(text, cls, stacklevel=stacklevel + 1)\n\n    @classmethod\n    def _format(\n        cls,\n        summary: str,\n        details: str,\n        due_date: date | None = None,\n        see_url: str | None = None,\n        format_args: dict | None = None,\n    ):\n        \"\"\"Private: reserved for ``setuptools`` internal use only\"\"\"\n        today = date.today()\n        summary = cleandoc(summary).format_map(format_args or {})\n        possible_parts = [\n            cleandoc(details).format_map(format_args or {}),\n            (\n                f\"\\nBy {due_date:%Y-%b-%d}, you need to update your project and remove \"\n                \"deprecated calls\\nor your builds will no longer be supported.\"\n                if due_date and due_date > today\n                else None\n            ),\n            (\n                \"\\nThis deprecation is overdue, please update your project and remove \"\n                \"deprecated\\ncalls to avoid build errors in the future.\"\n                if due_date and due_date < today\n                else None\n            ),\n            (f\"\\nSee {see_url} for details.\" if see_url else None),\n        ]\n        parts = [x for x in possible_parts if x]\n        if parts:\n            body = indent(_TEMPLATE.format(details=\"\\n\".join(parts)), _INDENT)\n            return \"\\n\".join([summary, \"!!\\n\", body, \"\\n!!\"])\n        return summary\n\n\nclass InformationOnly(SetuptoolsWarning):\n    \"\"\"Currently there is no clear way of displaying messages to the users\n    that use the setuptools backend directly via ``pip``.\n    The only thing that might work is a warning, although it is not the\n    most appropriate tool for the job...\n\n    See pypa/packaging-problems#558.\n    \"\"\"\n\n\nclass SetuptoolsDeprecationWarning(SetuptoolsWarning):\n    \"\"\"\n    Base class for warning deprecations in ``setuptools``\n\n    This class is not derived from ``DeprecationWarning``, and as such is\n    visible by default.\n    \"\"\"\n\n\ndef _should_enforce():\n    enforce = os.getenv(\"SETUPTOOLS_ENFORCE_DEPRECATION\", \"false\").lower()\n    return enforce in (\"true\", \"on\", \"ok\", \"1\")\n", "setuptools/_normalization.py": "\"\"\"\nHelpers for normalization as expected in wheel/sdist/module file names\nand core metadata\n\"\"\"\n\nimport re\n\nfrom .extern import packaging\n\n# https://packaging.python.org/en/latest/specifications/core-metadata/#name\n_VALID_NAME = re.compile(r\"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$\", re.I)\n_UNSAFE_NAME_CHARS = re.compile(r\"[^A-Z0-9._-]+\", re.I)\n_NON_ALPHANUMERIC = re.compile(r\"[^A-Z0-9]+\", re.I)\n_PEP440_FALLBACK = re.compile(r\"^v?(?P<safe>(?:[0-9]+!)?[0-9]+(?:\\.[0-9]+)*)\", re.I)\n\n\ndef safe_identifier(name: str) -> str:\n    \"\"\"Make a string safe to be used as Python identifier.\n    >>> safe_identifier(\"12abc\")\n    '_12abc'\n    >>> safe_identifier(\"__editable__.myns.pkg-78.9.3_local\")\n    '__editable___myns_pkg_78_9_3_local'\n    \"\"\"\n    safe = re.sub(r'\\W|^(?=\\d)', '_', name)\n    assert safe.isidentifier()\n    return safe\n\n\ndef safe_name(component: str) -> str:\n    \"\"\"Escape a component used as a project name according to Core Metadata.\n    >>> safe_name(\"hello world\")\n    'hello-world'\n    >>> safe_name(\"hello?world\")\n    'hello-world'\n    >>> safe_name(\"hello_world\")\n    'hello_world'\n    \"\"\"\n    # See pkg_resources.safe_name\n    return _UNSAFE_NAME_CHARS.sub(\"-\", component)\n\n\ndef safe_version(version: str) -> str:\n    \"\"\"Convert an arbitrary string into a valid version string.\n    Can still raise an ``InvalidVersion`` exception.\n    To avoid exceptions use ``best_effort_version``.\n    >>> safe_version(\"1988 12 25\")\n    '1988.12.25'\n    >>> safe_version(\"v0.2.1\")\n    '0.2.1'\n    >>> safe_version(\"v0.2?beta\")\n    '0.2b0'\n    >>> safe_version(\"v0.2 beta\")\n    '0.2b0'\n    >>> safe_version(\"ubuntu lts\")\n    Traceback (most recent call last):\n    ...\n    setuptools.extern.packaging.version.InvalidVersion: Invalid version: 'ubuntu.lts'\n    \"\"\"\n    v = version.replace(' ', '.')\n    try:\n        return str(packaging.version.Version(v))\n    except packaging.version.InvalidVersion:\n        attempt = _UNSAFE_NAME_CHARS.sub(\"-\", v)\n        return str(packaging.version.Version(attempt))\n\n\ndef best_effort_version(version: str) -> str:\n    \"\"\"Convert an arbitrary string into a version-like string.\n    Fallback when ``safe_version`` is not safe enough.\n    >>> best_effort_version(\"v0.2 beta\")\n    '0.2b0'\n    >>> best_effort_version(\"ubuntu lts\")\n    '0.dev0+sanitized.ubuntu.lts'\n    >>> best_effort_version(\"0.23ubuntu1\")\n    '0.23.dev0+sanitized.ubuntu1'\n    >>> best_effort_version(\"0.23-\")\n    '0.23.dev0+sanitized'\n    >>> best_effort_version(\"0.-_\")\n    '0.dev0+sanitized'\n    >>> best_effort_version(\"42.+?1\")\n    '42.dev0+sanitized.1'\n    \"\"\"\n    # See pkg_resources._forgiving_version\n    try:\n        return safe_version(version)\n    except packaging.version.InvalidVersion:\n        v = version.replace(' ', '.')\n        match = _PEP440_FALLBACK.search(v)\n        if match:\n            safe = match[\"safe\"]\n            rest = v[len(safe) :]\n        else:\n            safe = \"0\"\n            rest = version\n        safe_rest = _NON_ALPHANUMERIC.sub(\".\", rest).strip(\".\")\n        local = f\"sanitized.{safe_rest}\".strip(\".\")\n        return safe_version(f\"{safe}.dev0+{local}\")\n\n\ndef safe_extra(extra: str) -> str:\n    \"\"\"Normalize extra name according to PEP 685\n    >>> safe_extra(\"_FrIeNdLy-._.-bArD\")\n    'friendly-bard'\n    >>> safe_extra(\"FrIeNdLy-._.-bArD__._-\")\n    'friendly-bard'\n    \"\"\"\n    return _NON_ALPHANUMERIC.sub(\"-\", extra).strip(\"-\").lower()\n\n\ndef filename_component(value: str) -> str:\n    \"\"\"Normalize each component of a filename (e.g. distribution/version part of wheel)\n    Note: ``value`` needs to be already normalized.\n    >>> filename_component(\"my-pkg\")\n    'my_pkg'\n    \"\"\"\n    return value.replace(\"-\", \"_\").strip(\"_\")\n\n\ndef filename_component_broken(value: str) -> str:\n    \"\"\"\n    Produce the incorrect filename component for compatibility.\n\n    See pypa/setuptools#4167 for detailed analysis.\n\n    TODO: replace this with filename_component after pip 24 is\n    nearly-ubiquitous.\n\n    >>> filename_component_broken('foo_bar-baz')\n    'foo-bar-baz'\n    \"\"\"\n    return value.replace('_', '-')\n\n\ndef safer_name(value: str) -> str:\n    \"\"\"Like ``safe_name`` but can be used as filename component for wheel\"\"\"\n    # See bdist_wheel.safer_name\n    return filename_component(safe_name(value))\n\n\ndef safer_best_effort_version(value: str) -> str:\n    \"\"\"Like ``best_effort_version`` but can be used as filename component for wheel\"\"\"\n    # See bdist_wheel.safer_verion\n    # TODO: Replace with only safe_version in the future (no need for best effort)\n    return filename_component(best_effort_version(value))\n", "setuptools/errors.py": "\"\"\"setuptools.errors\n\nProvides exceptions used by setuptools modules.\n\"\"\"\n\nfrom distutils import errors as _distutils_errors\n\n\n# Re-export errors from distutils to facilitate the migration to PEP632\n\nByteCompileError = _distutils_errors.DistutilsByteCompileError\nCCompilerError = _distutils_errors.CCompilerError\nClassError = _distutils_errors.DistutilsClassError\nCompileError = _distutils_errors.CompileError\nExecError = _distutils_errors.DistutilsExecError\nFileError = _distutils_errors.DistutilsFileError\nInternalError = _distutils_errors.DistutilsInternalError\nLibError = _distutils_errors.LibError\nLinkError = _distutils_errors.LinkError\nModuleError = _distutils_errors.DistutilsModuleError\nOptionError = _distutils_errors.DistutilsOptionError\nPlatformError = _distutils_errors.DistutilsPlatformError\nPreprocessError = _distutils_errors.PreprocessError\nSetupError = _distutils_errors.DistutilsSetupError\nTemplateError = _distutils_errors.DistutilsTemplateError\nUnknownFileError = _distutils_errors.UnknownFileError\n\n# The root error class in the hierarchy\nBaseError = _distutils_errors.DistutilsError\n\n\nclass InvalidConfigError(OptionError):\n    \"\"\"Error used for invalid configurations.\"\"\"\n\n\nclass RemovedConfigError(OptionError):\n    \"\"\"Error used for configurations that were deprecated and removed.\"\"\"\n\n\nclass RemovedCommandError(BaseError, RuntimeError):\n    \"\"\"Error used for commands that have been removed in setuptools.\n\n    Since ``setuptools`` is built on ``distutils``, simply removing a command\n    from ``setuptools`` will make the behavior fall back to ``distutils``; this\n    error is raised if a command exists in ``distutils`` but has been actively\n    removed in ``setuptools``.\n    \"\"\"\n\n\nclass PackageDiscoveryError(BaseError, RuntimeError):\n    \"\"\"Impossible to perform automatic discovery of packages and/or modules.\n\n    The current project layout or given discovery options can lead to problems when\n    scanning the project directory.\n\n    Setuptools might also refuse to complete auto-discovery if an error prone condition\n    is detected (e.g. when a project is organised as a flat-layout but contains\n    multiple directories that can be taken as top-level packages inside a single\n    distribution [*]_). In these situations the users are encouraged to be explicit\n    about which packages to include or to make the discovery parameters more specific.\n\n    .. [*] Since multi-package distributions are uncommon it is very likely that the\n       developers did not intend for all the directories to be packaged, and are just\n       leaving auxiliary code in the repository top-level, such as maintenance-related\n       scripts.\n    \"\"\"\n", "setuptools/msvc.py": "\"\"\"\nImproved support for Microsoft Visual C++ compilers.\n\nKnown supported compilers:\n--------------------------\nMicrosoft Visual C++ 14.X:\n    Microsoft Visual C++ Build Tools 2015 (x86, x64, arm)\n    Microsoft Visual Studio Build Tools 2017 (x86, x64, arm, arm64)\n    Microsoft Visual Studio Build Tools 2019 (x86, x64, arm, arm64)\n\nThis may also support compilers shipped with compatible Visual Studio versions.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nfrom os import listdir, pathsep\nfrom os.path import join, isfile, isdir, dirname\nfrom subprocess import CalledProcessError\nimport contextlib\nimport platform\nimport itertools\nimport subprocess\nimport distutils.errors\nfrom typing import TYPE_CHECKING\nfrom setuptools.extern.more_itertools import unique_everseen\n\n# https://github.com/python/mypy/issues/8166\nif not TYPE_CHECKING and platform.system() == 'Windows':\n    import winreg\n    from os import environ\nelse:\n    # Mock winreg and environ so the module can be imported on this platform.\n\n    class winreg:\n        HKEY_USERS = None\n        HKEY_CURRENT_USER = None\n        HKEY_LOCAL_MACHINE = None\n        HKEY_CLASSES_ROOT = None\n\n    environ: dict[str, str] = dict()\n\n\ndef _msvc14_find_vc2015():\n    \"\"\"Python 3.8 \"distutils/_msvccompiler.py\" backport\"\"\"\n    try:\n        key = winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE,\n            r\"Software\\Microsoft\\VisualStudio\\SxS\\VC7\",\n            0,\n            winreg.KEY_READ | winreg.KEY_WOW64_32KEY,\n        )\n    except OSError:\n        return None, None\n\n    best_version = 0\n    best_dir = None\n    with key:\n        for i in itertools.count():\n            try:\n                v, vc_dir, vt = winreg.EnumValue(key, i)\n            except OSError:\n                break\n            if v and vt == winreg.REG_SZ and isdir(vc_dir):\n                try:\n                    version = int(float(v))\n                except (ValueError, TypeError):\n                    continue\n                if version >= 14 and version > best_version:\n                    best_version, best_dir = version, vc_dir\n    return best_version, best_dir\n\n\ndef _msvc14_find_vc2017():\n    \"\"\"Python 3.8 \"distutils/_msvccompiler.py\" backport\n\n    Returns \"15, path\" based on the result of invoking vswhere.exe\n    If no install is found, returns \"None, None\"\n\n    The version is returned to avoid unnecessarily changing the function\n    result. It may be ignored when the path is not None.\n\n    If vswhere.exe is not available, by definition, VS 2017 is not\n    installed.\n    \"\"\"\n    root = environ.get(\"ProgramFiles(x86)\") or environ.get(\"ProgramFiles\")\n    if not root:\n        return None, None\n\n    suitable_components = (\n        \"Microsoft.VisualStudio.Component.VC.Tools.x86.x64\",\n        \"Microsoft.VisualStudio.Workload.WDExpress\",\n    )\n\n    for component in suitable_components:\n        # Workaround for `-requiresAny` (only available on VS 2017 > 15.6)\n        with contextlib.suppress(CalledProcessError, OSError, UnicodeDecodeError):\n            path = (\n                subprocess.check_output([\n                    join(root, \"Microsoft Visual Studio\", \"Installer\", \"vswhere.exe\"),\n                    \"-latest\",\n                    \"-prerelease\",\n                    \"-requires\",\n                    component,\n                    \"-property\",\n                    \"installationPath\",\n                    \"-products\",\n                    \"*\",\n                ])\n                .decode(encoding=\"mbcs\", errors=\"strict\")\n                .strip()\n            )\n\n            path = join(path, \"VC\", \"Auxiliary\", \"Build\")\n            if isdir(path):\n                return 15, path\n\n    return None, None  # no suitable component found\n\n\nPLAT_SPEC_TO_RUNTIME = {\n    'x86': 'x86',\n    'x86_amd64': 'x64',\n    'x86_arm': 'arm',\n    'x86_arm64': 'arm64',\n}\n\n\ndef _msvc14_find_vcvarsall(plat_spec):\n    \"\"\"Python 3.8 \"distutils/_msvccompiler.py\" backport\"\"\"\n    _, best_dir = _msvc14_find_vc2017()\n    vcruntime = None\n\n    if plat_spec in PLAT_SPEC_TO_RUNTIME:\n        vcruntime_plat = PLAT_SPEC_TO_RUNTIME[plat_spec]\n    else:\n        vcruntime_plat = 'x64' if 'amd64' in plat_spec else 'x86'\n\n    if best_dir:\n        vcredist = join(\n            best_dir,\n            \"..\",\n            \"..\",\n            \"redist\",\n            \"MSVC\",\n            \"**\",\n            vcruntime_plat,\n            \"Microsoft.VC14*.CRT\",\n            \"vcruntime140.dll\",\n        )\n        try:\n            import glob\n\n            vcruntime = glob.glob(vcredist, recursive=True)[-1]\n        except (ImportError, OSError, LookupError):\n            vcruntime = None\n\n    if not best_dir:\n        best_version, best_dir = _msvc14_find_vc2015()\n        if best_version:\n            vcruntime = join(\n                best_dir,\n                'redist',\n                vcruntime_plat,\n                \"Microsoft.VC140.CRT\",\n                \"vcruntime140.dll\",\n            )\n\n    if not best_dir:\n        return None, None\n\n    vcvarsall = join(best_dir, \"vcvarsall.bat\")\n    if not isfile(vcvarsall):\n        return None, None\n\n    if not vcruntime or not isfile(vcruntime):\n        vcruntime = None\n\n    return vcvarsall, vcruntime\n\n\ndef _msvc14_get_vc_env(plat_spec):\n    \"\"\"Python 3.8 \"distutils/_msvccompiler.py\" backport\"\"\"\n    if \"DISTUTILS_USE_SDK\" in environ:\n        return {key.lower(): value for key, value in environ.items()}\n\n    vcvarsall, vcruntime = _msvc14_find_vcvarsall(plat_spec)\n    if not vcvarsall:\n        raise distutils.errors.DistutilsPlatformError(\"Unable to find vcvarsall.bat\")\n\n    try:\n        out = subprocess.check_output(\n            'cmd /u /c \"{}\" {} && set'.format(vcvarsall, plat_spec),\n            stderr=subprocess.STDOUT,\n        ).decode('utf-16le', errors='replace')\n    except subprocess.CalledProcessError as exc:\n        raise distutils.errors.DistutilsPlatformError(\n            \"Error executing {}\".format(exc.cmd)\n        ) from exc\n\n    env = {\n        key.lower(): value\n        for key, _, value in (line.partition('=') for line in out.splitlines())\n        if key and value\n    }\n\n    if vcruntime:\n        env['py_vcruntime_redist'] = vcruntime\n    return env\n\n\ndef msvc14_get_vc_env(plat_spec):\n    \"\"\"\n    Patched \"distutils._msvccompiler._get_vc_env\" for support extra\n    Microsoft Visual C++ 14.X compilers.\n\n    Set environment without use of \"vcvarsall.bat\".\n\n    Parameters\n    ----------\n    plat_spec: str\n        Target architecture.\n\n    Return\n    ------\n    dict\n        environment\n    \"\"\"\n\n    # Always use backport from CPython 3.8\n    try:\n        return _msvc14_get_vc_env(plat_spec)\n    except distutils.errors.DistutilsPlatformError as exc:\n        _augment_exception(exc, 14.0)\n        raise\n\n\ndef _augment_exception(exc, version, arch=''):\n    \"\"\"\n    Add details to the exception message to help guide the user\n    as to what action will resolve it.\n    \"\"\"\n    # Error if MSVC++ directory not found or environment not set\n    message = exc.args[0]\n\n    if \"vcvarsall\" in message.lower() or \"visual c\" in message.lower():\n        # Special error message if MSVC++ not installed\n        tmpl = 'Microsoft Visual C++ {version:0.1f} or greater is required.'\n        message = tmpl.format(**locals())\n        msdownload = 'www.microsoft.com/download/details.aspx?id=%d'\n        if version == 9.0:\n            if arch.lower().find('ia64') > -1:\n                # For VC++ 9.0, if IA64 support is needed, redirect user\n                # to Windows SDK 7.0.\n                # Note: No download link available from Microsoft.\n                message += ' Get it with \"Microsoft Windows SDK 7.0\"'\n            else:\n                # For VC++ 9.0 redirect user to Vc++ for Python 2.7 :\n                # This redirection link is maintained by Microsoft.\n                # Contact vspython@microsoft.com if it needs updating.\n                message += ' Get it from http://aka.ms/vcpython27'\n        elif version == 10.0:\n            # For VC++ 10.0 Redirect user to Windows SDK 7.1\n            message += ' Get it with \"Microsoft Windows SDK 7.1\": '\n            message += msdownload % 8279\n        elif version >= 14.0:\n            # For VC++ 14.X Redirect user to latest Visual C++ Build Tools\n            message += (\n                ' Get it with \"Microsoft C++ Build Tools\": '\n                r'https://visualstudio.microsoft.com'\n                r'/visual-cpp-build-tools/'\n            )\n\n    exc.args = (message,)\n\n\nclass PlatformInfo:\n    \"\"\"\n    Current and Target Architectures information.\n\n    Parameters\n    ----------\n    arch: str\n        Target architecture.\n    \"\"\"\n\n    current_cpu = environ.get('processor_architecture', '').lower()\n\n    def __init__(self, arch):\n        self.arch = arch.lower().replace('x64', 'amd64')\n\n    @property\n    def target_cpu(self):\n        \"\"\"\n        Return Target CPU architecture.\n\n        Return\n        ------\n        str\n            Target CPU\n        \"\"\"\n        return self.arch[self.arch.find('_') + 1 :]\n\n    def target_is_x86(self):\n        \"\"\"\n        Return True if target CPU is x86 32 bits..\n\n        Return\n        ------\n        bool\n            CPU is x86 32 bits\n        \"\"\"\n        return self.target_cpu == 'x86'\n\n    def current_is_x86(self):\n        \"\"\"\n        Return True if current CPU is x86 32 bits..\n\n        Return\n        ------\n        bool\n            CPU is x86 32 bits\n        \"\"\"\n        return self.current_cpu == 'x86'\n\n    def current_dir(self, hidex86=False, x64=False):\n        \"\"\"\n        Current platform specific subfolder.\n\n        Parameters\n        ----------\n        hidex86: bool\n            return '' and not '\\x86' if architecture is x86.\n        x64: bool\n            return '\\x64' and not '\\amd64' if architecture is amd64.\n\n        Return\n        ------\n        str\n            subfolder: '\\target', or '' (see hidex86 parameter)\n        \"\"\"\n        return (\n            ''\n            if (self.current_cpu == 'x86' and hidex86)\n            else r'\\x64'\n            if (self.current_cpu == 'amd64' and x64)\n            else r'\\%s' % self.current_cpu\n        )\n\n    def target_dir(self, hidex86=False, x64=False):\n        r\"\"\"\n        Target platform specific subfolder.\n\n        Parameters\n        ----------\n        hidex86: bool\n            return '' and not '\\x86' if architecture is x86.\n        x64: bool\n            return '\\x64' and not '\\amd64' if architecture is amd64.\n\n        Return\n        ------\n        str\n            subfolder: '\\current', or '' (see hidex86 parameter)\n        \"\"\"\n        return (\n            ''\n            if (self.target_cpu == 'x86' and hidex86)\n            else r'\\x64'\n            if (self.target_cpu == 'amd64' and x64)\n            else r'\\%s' % self.target_cpu\n        )\n\n    def cross_dir(self, forcex86=False):\n        r\"\"\"\n        Cross platform specific subfolder.\n\n        Parameters\n        ----------\n        forcex86: bool\n            Use 'x86' as current architecture even if current architecture is\n            not x86.\n\n        Return\n        ------\n        str\n            subfolder: '' if target architecture is current architecture,\n            '\\current_target' if not.\n        \"\"\"\n        current = 'x86' if forcex86 else self.current_cpu\n        return (\n            ''\n            if self.target_cpu == current\n            else self.target_dir().replace('\\\\', '\\\\%s_' % current)\n        )\n\n\nclass RegistryInfo:\n    \"\"\"\n    Microsoft Visual Studio related registry information.\n\n    Parameters\n    ----------\n    platform_info: PlatformInfo\n        \"PlatformInfo\" instance.\n    \"\"\"\n\n    HKEYS = (\n        winreg.HKEY_USERS,\n        winreg.HKEY_CURRENT_USER,\n        winreg.HKEY_LOCAL_MACHINE,\n        winreg.HKEY_CLASSES_ROOT,\n    )\n\n    def __init__(self, platform_info):\n        self.pi = platform_info\n\n    @property\n    def visualstudio(self):\n        \"\"\"\n        Microsoft Visual Studio root registry key.\n\n        Return\n        ------\n        str\n            Registry key\n        \"\"\"\n        return 'VisualStudio'\n\n    @property\n    def sxs(self):\n        \"\"\"\n        Microsoft Visual Studio SxS registry key.\n\n        Return\n        ------\n        str\n            Registry key\n        \"\"\"\n        return join(self.visualstudio, 'SxS')\n\n    @property\n    def vc(self):\n        \"\"\"\n        Microsoft Visual C++ VC7 registry key.\n\n        Return\n        ------\n        str\n            Registry key\n        \"\"\"\n        return join(self.sxs, 'VC7')\n\n    @property\n    def vs(self):\n        \"\"\"\n        Microsoft Visual Studio VS7 registry key.\n\n        Return\n        ------\n        str\n            Registry key\n        \"\"\"\n        return join(self.sxs, 'VS7')\n\n    @property\n    def vc_for_python(self):\n        \"\"\"\n        Microsoft Visual C++ for Python registry key.\n\n        Return\n        ------\n        str\n            Registry key\n        \"\"\"\n        return r'DevDiv\\VCForPython'\n\n    @property\n    def microsoft_sdk(self):\n        \"\"\"\n        Microsoft SDK registry key.\n\n        Return\n        ------\n        str\n            Registry key\n        \"\"\"\n        return 'Microsoft SDKs'\n\n    @property\n    def windows_sdk(self):\n        \"\"\"\n        Microsoft Windows/Platform SDK registry key.\n\n        Return\n        ------\n        str\n            Registry key\n        \"\"\"\n        return join(self.microsoft_sdk, 'Windows')\n\n    @property\n    def netfx_sdk(self):\n        \"\"\"\n        Microsoft .NET Framework SDK registry key.\n\n        Return\n        ------\n        str\n            Registry key\n        \"\"\"\n        return join(self.microsoft_sdk, 'NETFXSDK')\n\n    @property\n    def windows_kits_roots(self):\n        \"\"\"\n        Microsoft Windows Kits Roots registry key.\n\n        Return\n        ------\n        str\n            Registry key\n        \"\"\"\n        return r'Windows Kits\\Installed Roots'\n\n    def microsoft(self, key, x86=False):\n        \"\"\"\n        Return key in Microsoft software registry.\n\n        Parameters\n        ----------\n        key: str\n            Registry key path where look.\n        x86: str\n            Force x86 software registry.\n\n        Return\n        ------\n        str\n            Registry key\n        \"\"\"\n        node64 = '' if self.pi.current_is_x86() or x86 else 'Wow6432Node'\n        return join('Software', node64, 'Microsoft', key)\n\n    def lookup(self, key, name):\n        \"\"\"\n        Look for values in registry in Microsoft software registry.\n\n        Parameters\n        ----------\n        key: str\n            Registry key path where look.\n        name: str\n            Value name to find.\n\n        Return\n        ------\n        str\n            value\n        \"\"\"\n        key_read = winreg.KEY_READ\n        openkey = winreg.OpenKey\n        closekey = winreg.CloseKey\n        ms = self.microsoft\n        for hkey in self.HKEYS:\n            bkey = None\n            try:\n                bkey = openkey(hkey, ms(key), 0, key_read)\n            except OSError:\n                if not self.pi.current_is_x86():\n                    try:\n                        bkey = openkey(hkey, ms(key, True), 0, key_read)\n                    except OSError:\n                        continue\n                else:\n                    continue\n            try:\n                return winreg.QueryValueEx(bkey, name)[0]\n            except OSError:\n                pass\n            finally:\n                if bkey:\n                    closekey(bkey)\n        return None\n\n\nclass SystemInfo:\n    \"\"\"\n    Microsoft Windows and Visual Studio related system information.\n\n    Parameters\n    ----------\n    registry_info: RegistryInfo\n        \"RegistryInfo\" instance.\n    vc_ver: float\n        Required Microsoft Visual C++ version.\n    \"\"\"\n\n    # Variables and properties in this class use originals CamelCase variables\n    # names from Microsoft source files for more easy comparison.\n    WinDir = environ.get('WinDir', '')\n    ProgramFiles = environ.get('ProgramFiles', '')\n    ProgramFilesx86 = environ.get('ProgramFiles(x86)', ProgramFiles)\n\n    def __init__(self, registry_info, vc_ver=None):\n        self.ri = registry_info\n        self.pi = self.ri.pi\n\n        self.known_vs_paths = self.find_programdata_vs_vers()\n\n        # Except for VS15+, VC version is aligned with VS version\n        self.vs_ver = self.vc_ver = vc_ver or self._find_latest_available_vs_ver()\n\n    def _find_latest_available_vs_ver(self):\n        \"\"\"\n        Find the latest VC version\n\n        Return\n        ------\n        float\n            version\n        \"\"\"\n        reg_vc_vers = self.find_reg_vs_vers()\n\n        if not (reg_vc_vers or self.known_vs_paths):\n            raise distutils.errors.DistutilsPlatformError(\n                'No Microsoft Visual C++ version found'\n            )\n\n        vc_vers = set(reg_vc_vers)\n        vc_vers.update(self.known_vs_paths)\n        return sorted(vc_vers)[-1]\n\n    def find_reg_vs_vers(self):\n        \"\"\"\n        Find Microsoft Visual Studio versions available in registry.\n\n        Return\n        ------\n        list of float\n            Versions\n        \"\"\"\n        ms = self.ri.microsoft\n        vckeys = (self.ri.vc, self.ri.vc_for_python, self.ri.vs)\n        vs_vers = []\n        for hkey, key in itertools.product(self.ri.HKEYS, vckeys):\n            try:\n                bkey = winreg.OpenKey(hkey, ms(key), 0, winreg.KEY_READ)\n            except OSError:\n                continue\n            with bkey:\n                subkeys, values, _ = winreg.QueryInfoKey(bkey)\n                for i in range(values):\n                    with contextlib.suppress(ValueError):\n                        ver = float(winreg.EnumValue(bkey, i)[0])\n                        if ver not in vs_vers:\n                            vs_vers.append(ver)\n                for i in range(subkeys):\n                    with contextlib.suppress(ValueError):\n                        ver = float(winreg.EnumKey(bkey, i))\n                        if ver not in vs_vers:\n                            vs_vers.append(ver)\n        return sorted(vs_vers)\n\n    def find_programdata_vs_vers(self):\n        r\"\"\"\n        Find Visual studio 2017+ versions from information in\n        \"C:\\ProgramData\\Microsoft\\VisualStudio\\Packages\\_Instances\".\n\n        Return\n        ------\n        dict\n            float version as key, path as value.\n        \"\"\"\n        vs_versions = {}\n        instances_dir = r'C:\\ProgramData\\Microsoft\\VisualStudio\\Packages\\_Instances'\n\n        try:\n            hashed_names = listdir(instances_dir)\n\n        except OSError:\n            # Directory not exists with all Visual Studio versions\n            return vs_versions\n\n        for name in hashed_names:\n            try:\n                # Get VS installation path from \"state.json\" file\n                state_path = join(instances_dir, name, 'state.json')\n                with open(state_path, 'rt', encoding='utf-8') as state_file:\n                    state = json.load(state_file)\n                vs_path = state['installationPath']\n\n                # Raises OSError if this VS installation does not contain VC\n                listdir(join(vs_path, r'VC\\Tools\\MSVC'))\n\n                # Store version and path\n                vs_versions[self._as_float_version(state['installationVersion'])] = (\n                    vs_path\n                )\n\n            except (OSError, KeyError):\n                # Skip if \"state.json\" file is missing or bad format\n                continue\n\n        return vs_versions\n\n    @staticmethod\n    def _as_float_version(version):\n        \"\"\"\n        Return a string version as a simplified float version (major.minor)\n\n        Parameters\n        ----------\n        version: str\n            Version.\n\n        Return\n        ------\n        float\n            version\n        \"\"\"\n        return float('.'.join(version.split('.')[:2]))\n\n    @property\n    def VSInstallDir(self):\n        \"\"\"\n        Microsoft Visual Studio directory.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        # Default path\n        default = join(\n            self.ProgramFilesx86, 'Microsoft Visual Studio %0.1f' % self.vs_ver\n        )\n\n        # Try to get path from registry, if fail use default path\n        return self.ri.lookup(self.ri.vs, '%0.1f' % self.vs_ver) or default\n\n    @property\n    def VCInstallDir(self):\n        \"\"\"\n        Microsoft Visual C++ directory.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        path = self._guess_vc() or self._guess_vc_legacy()\n\n        if not isdir(path):\n            msg = 'Microsoft Visual C++ directory not found'\n            raise distutils.errors.DistutilsPlatformError(msg)\n\n        return path\n\n    def _guess_vc(self):\n        \"\"\"\n        Locate Visual C++ for VS2017+.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        if self.vs_ver <= 14.0:\n            return ''\n\n        try:\n            # First search in known VS paths\n            vs_dir = self.known_vs_paths[self.vs_ver]\n        except KeyError:\n            # Else, search with path from registry\n            vs_dir = self.VSInstallDir\n\n        guess_vc = join(vs_dir, r'VC\\Tools\\MSVC')\n\n        # Subdir with VC exact version as name\n        try:\n            # Update the VC version with real one instead of VS version\n            vc_ver = listdir(guess_vc)[-1]\n            self.vc_ver = self._as_float_version(vc_ver)\n            return join(guess_vc, vc_ver)\n        except (OSError, IndexError):\n            return ''\n\n    def _guess_vc_legacy(self):\n        \"\"\"\n        Locate Visual C++ for versions prior to 2017.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        default = join(\n            self.ProgramFilesx86, r'Microsoft Visual Studio %0.1f\\VC' % self.vs_ver\n        )\n\n        # Try to get \"VC++ for Python\" path from registry as default path\n        reg_path = join(self.ri.vc_for_python, '%0.1f' % self.vs_ver)\n        python_vc = self.ri.lookup(reg_path, 'installdir')\n        default_vc = join(python_vc, 'VC') if python_vc else default\n\n        # Try to get path from registry, if fail use default path\n        return self.ri.lookup(self.ri.vc, '%0.1f' % self.vs_ver) or default_vc\n\n    @property\n    def WindowsSdkVersion(self):\n        \"\"\"\n        Microsoft Windows SDK versions for specified MSVC++ version.\n\n        Return\n        ------\n        tuple of str\n            versions\n        \"\"\"\n        if self.vs_ver <= 9.0:\n            return '7.0', '6.1', '6.0a'\n        elif self.vs_ver == 10.0:\n            return '7.1', '7.0a'\n        elif self.vs_ver == 11.0:\n            return '8.0', '8.0a'\n        elif self.vs_ver == 12.0:\n            return '8.1', '8.1a'\n        elif self.vs_ver >= 14.0:\n            return '10.0', '8.1'\n        return None\n\n    @property\n    def WindowsSdkLastVersion(self):\n        \"\"\"\n        Microsoft Windows SDK last version.\n\n        Return\n        ------\n        str\n            version\n        \"\"\"\n        return self._use_last_dir_name(join(self.WindowsSdkDir, 'lib'))\n\n    @property  # noqa: C901\n    def WindowsSdkDir(self):  # noqa: C901  # is too complex (12)  # FIXME\n        \"\"\"\n        Microsoft Windows SDK directory.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        sdkdir = ''\n        for ver in self.WindowsSdkVersion:\n            # Try to get it from registry\n            loc = join(self.ri.windows_sdk, 'v%s' % ver)\n            sdkdir = self.ri.lookup(loc, 'installationfolder')\n            if sdkdir:\n                break\n        if not sdkdir or not isdir(sdkdir):\n            # Try to get \"VC++ for Python\" version from registry\n            path = join(self.ri.vc_for_python, '%0.1f' % self.vc_ver)\n            install_base = self.ri.lookup(path, 'installdir')\n            if install_base:\n                sdkdir = join(install_base, 'WinSDK')\n        if not sdkdir or not isdir(sdkdir):\n            # If fail, use default new path\n            for ver in self.WindowsSdkVersion:\n                intver = ver[: ver.rfind('.')]\n                path = r'Microsoft SDKs\\Windows Kits\\%s' % intver\n                d = join(self.ProgramFiles, path)\n                if isdir(d):\n                    sdkdir = d\n        if not sdkdir or not isdir(sdkdir):\n            # If fail, use default old path\n            for ver in self.WindowsSdkVersion:\n                path = r'Microsoft SDKs\\Windows\\v%s' % ver\n                d = join(self.ProgramFiles, path)\n                if isdir(d):\n                    sdkdir = d\n        if not sdkdir:\n            # If fail, use Platform SDK\n            sdkdir = join(self.VCInstallDir, 'PlatformSDK')\n        return sdkdir\n\n    @property\n    def WindowsSDKExecutablePath(self):\n        \"\"\"\n        Microsoft Windows SDK executable directory.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        # Find WinSDK NetFx Tools registry dir name\n        if self.vs_ver <= 11.0:\n            netfxver = 35\n            arch = ''\n        else:\n            netfxver = 40\n            hidex86 = True if self.vs_ver <= 12.0 else False\n            arch = self.pi.current_dir(x64=True, hidex86=hidex86)\n        fx = 'WinSDK-NetFx%dTools%s' % (netfxver, arch.replace('\\\\', '-'))\n\n        # list all possibles registry paths\n        regpaths = []\n        if self.vs_ver >= 14.0:\n            for ver in self.NetFxSdkVersion:\n                regpaths += [join(self.ri.netfx_sdk, ver, fx)]\n\n        for ver in self.WindowsSdkVersion:\n            regpaths += [join(self.ri.windows_sdk, 'v%sA' % ver, fx)]\n\n        # Return installation folder from the more recent path\n        for path in regpaths:\n            execpath = self.ri.lookup(path, 'installationfolder')\n            if execpath:\n                return execpath\n\n        return None\n\n    @property\n    def FSharpInstallDir(self):\n        \"\"\"\n        Microsoft Visual F# directory.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        path = join(self.ri.visualstudio, r'%0.1f\\Setup\\F#' % self.vs_ver)\n        return self.ri.lookup(path, 'productdir') or ''\n\n    @property\n    def UniversalCRTSdkDir(self):\n        \"\"\"\n        Microsoft Universal CRT SDK directory.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        # Set Kit Roots versions for specified MSVC++ version\n        vers = ('10', '81') if self.vs_ver >= 14.0 else ()\n\n        # Find path of the more recent Kit\n        for ver in vers:\n            sdkdir = self.ri.lookup(self.ri.windows_kits_roots, 'kitsroot%s' % ver)\n            if sdkdir:\n                return sdkdir or ''\n\n        return None\n\n    @property\n    def UniversalCRTSdkLastVersion(self):\n        \"\"\"\n        Microsoft Universal C Runtime SDK last version.\n\n        Return\n        ------\n        str\n            version\n        \"\"\"\n        return self._use_last_dir_name(join(self.UniversalCRTSdkDir, 'lib'))\n\n    @property\n    def NetFxSdkVersion(self):\n        \"\"\"\n        Microsoft .NET Framework SDK versions.\n\n        Return\n        ------\n        tuple of str\n            versions\n        \"\"\"\n        # Set FxSdk versions for specified VS version\n        return (\n            ('4.7.2', '4.7.1', '4.7', '4.6.2', '4.6.1', '4.6', '4.5.2', '4.5.1', '4.5')\n            if self.vs_ver >= 14.0\n            else ()\n        )\n\n    @property\n    def NetFxSdkDir(self):\n        \"\"\"\n        Microsoft .NET Framework SDK directory.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        sdkdir = ''\n        for ver in self.NetFxSdkVersion:\n            loc = join(self.ri.netfx_sdk, ver)\n            sdkdir = self.ri.lookup(loc, 'kitsinstallationfolder')\n            if sdkdir:\n                break\n        return sdkdir\n\n    @property\n    def FrameworkDir32(self):\n        \"\"\"\n        Microsoft .NET Framework 32bit directory.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        # Default path\n        guess_fw = join(self.WinDir, r'Microsoft.NET\\Framework')\n\n        # Try to get path from registry, if fail use default path\n        return self.ri.lookup(self.ri.vc, 'frameworkdir32') or guess_fw\n\n    @property\n    def FrameworkDir64(self):\n        \"\"\"\n        Microsoft .NET Framework 64bit directory.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        # Default path\n        guess_fw = join(self.WinDir, r'Microsoft.NET\\Framework64')\n\n        # Try to get path from registry, if fail use default path\n        return self.ri.lookup(self.ri.vc, 'frameworkdir64') or guess_fw\n\n    @property\n    def FrameworkVersion32(self):\n        \"\"\"\n        Microsoft .NET Framework 32bit versions.\n\n        Return\n        ------\n        tuple of str\n            versions\n        \"\"\"\n        return self._find_dot_net_versions(32)\n\n    @property\n    def FrameworkVersion64(self):\n        \"\"\"\n        Microsoft .NET Framework 64bit versions.\n\n        Return\n        ------\n        tuple of str\n            versions\n        \"\"\"\n        return self._find_dot_net_versions(64)\n\n    def _find_dot_net_versions(self, bits):\n        \"\"\"\n        Find Microsoft .NET Framework versions.\n\n        Parameters\n        ----------\n        bits: int\n            Platform number of bits: 32 or 64.\n\n        Return\n        ------\n        tuple of str\n            versions\n        \"\"\"\n        # Find actual .NET version in registry\n        reg_ver = self.ri.lookup(self.ri.vc, 'frameworkver%d' % bits)\n        dot_net_dir = getattr(self, 'FrameworkDir%d' % bits)\n        ver = reg_ver or self._use_last_dir_name(dot_net_dir, 'v') or ''\n\n        # Set .NET versions for specified MSVC++ version\n        if self.vs_ver >= 12.0:\n            return ver, 'v4.0'\n        elif self.vs_ver >= 10.0:\n            return 'v4.0.30319' if ver.lower()[:2] != 'v4' else ver, 'v3.5'\n        elif self.vs_ver == 9.0:\n            return 'v3.5', 'v2.0.50727'\n        elif self.vs_ver == 8.0:\n            return 'v3.0', 'v2.0.50727'\n\n    @staticmethod\n    def _use_last_dir_name(path, prefix=''):\n        \"\"\"\n        Return name of the last dir in path or '' if no dir found.\n\n        Parameters\n        ----------\n        path: str\n            Use dirs in this path\n        prefix: str\n            Use only dirs starting by this prefix\n\n        Return\n        ------\n        str\n            name\n        \"\"\"\n        matching_dirs = (\n            dir_name\n            for dir_name in reversed(listdir(path))\n            if isdir(join(path, dir_name)) and dir_name.startswith(prefix)\n        )\n        return next(matching_dirs, None) or ''\n\n\nclass EnvironmentInfo:\n    \"\"\"\n    Return environment variables for specified Microsoft Visual C++ version\n    and platform : Lib, Include, Path and libpath.\n\n    This function is compatible with Microsoft Visual C++ 9.0 to 14.X.\n\n    Script created by analysing Microsoft environment configuration files like\n    \"vcvars[...].bat\", \"SetEnv.Cmd\", \"vcbuildtools.bat\", ...\n\n    Parameters\n    ----------\n    arch: str\n        Target architecture.\n    vc_ver: float\n        Required Microsoft Visual C++ version. If not set, autodetect the last\n        version.\n    vc_min_ver: float\n        Minimum Microsoft Visual C++ version.\n    \"\"\"\n\n    # Variables and properties in this class use originals CamelCase variables\n    # names from Microsoft source files for more easy comparison.\n\n    def __init__(self, arch, vc_ver=None, vc_min_ver=0):\n        self.pi = PlatformInfo(arch)\n        self.ri = RegistryInfo(self.pi)\n        self.si = SystemInfo(self.ri, vc_ver)\n\n        if self.vc_ver < vc_min_ver:\n            err = 'No suitable Microsoft Visual C++ version found'\n            raise distutils.errors.DistutilsPlatformError(err)\n\n    @property\n    def vs_ver(self):\n        \"\"\"\n        Microsoft Visual Studio.\n\n        Return\n        ------\n        float\n            version\n        \"\"\"\n        return self.si.vs_ver\n\n    @property\n    def vc_ver(self):\n        \"\"\"\n        Microsoft Visual C++ version.\n\n        Return\n        ------\n        float\n            version\n        \"\"\"\n        return self.si.vc_ver\n\n    @property\n    def VSTools(self):\n        \"\"\"\n        Microsoft Visual Studio Tools.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        paths = [r'Common7\\IDE', r'Common7\\Tools']\n\n        if self.vs_ver >= 14.0:\n            arch_subdir = self.pi.current_dir(hidex86=True, x64=True)\n            paths += [r'Common7\\IDE\\CommonExtensions\\Microsoft\\TestWindow']\n            paths += [r'Team Tools\\Performance Tools']\n            paths += [r'Team Tools\\Performance Tools%s' % arch_subdir]\n\n        return [join(self.si.VSInstallDir, path) for path in paths]\n\n    @property\n    def VCIncludes(self):\n        \"\"\"\n        Microsoft Visual C++ & Microsoft Foundation Class Includes.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        return [\n            join(self.si.VCInstallDir, 'Include'),\n            join(self.si.VCInstallDir, r'ATLMFC\\Include'),\n        ]\n\n    @property\n    def VCLibraries(self):\n        \"\"\"\n        Microsoft Visual C++ & Microsoft Foundation Class Libraries.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        if self.vs_ver >= 15.0:\n            arch_subdir = self.pi.target_dir(x64=True)\n        else:\n            arch_subdir = self.pi.target_dir(hidex86=True)\n        paths = ['Lib%s' % arch_subdir, r'ATLMFC\\Lib%s' % arch_subdir]\n\n        if self.vs_ver >= 14.0:\n            paths += [r'Lib\\store%s' % arch_subdir]\n\n        return [join(self.si.VCInstallDir, path) for path in paths]\n\n    @property\n    def VCStoreRefs(self):\n        \"\"\"\n        Microsoft Visual C++ store references Libraries.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        if self.vs_ver < 14.0:\n            return []\n        return [join(self.si.VCInstallDir, r'Lib\\store\\references')]\n\n    @property\n    def VCTools(self):\n        \"\"\"\n        Microsoft Visual C++ Tools.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        si = self.si\n        tools = [join(si.VCInstallDir, 'VCPackages')]\n\n        forcex86 = True if self.vs_ver <= 10.0 else False\n        arch_subdir = self.pi.cross_dir(forcex86)\n        if arch_subdir:\n            tools += [join(si.VCInstallDir, 'Bin%s' % arch_subdir)]\n\n        if self.vs_ver == 14.0:\n            path = 'Bin%s' % self.pi.current_dir(hidex86=True)\n            tools += [join(si.VCInstallDir, path)]\n\n        elif self.vs_ver >= 15.0:\n            host_dir = (\n                r'bin\\HostX86%s' if self.pi.current_is_x86() else r'bin\\HostX64%s'\n            )\n            tools += [join(si.VCInstallDir, host_dir % self.pi.target_dir(x64=True))]\n\n            if self.pi.current_cpu != self.pi.target_cpu:\n                tools += [\n                    join(si.VCInstallDir, host_dir % self.pi.current_dir(x64=True))\n                ]\n\n        else:\n            tools += [join(si.VCInstallDir, 'Bin')]\n\n        return tools\n\n    @property\n    def OSLibraries(self):\n        \"\"\"\n        Microsoft Windows SDK Libraries.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        if self.vs_ver <= 10.0:\n            arch_subdir = self.pi.target_dir(hidex86=True, x64=True)\n            return [join(self.si.WindowsSdkDir, 'Lib%s' % arch_subdir)]\n\n        else:\n            arch_subdir = self.pi.target_dir(x64=True)\n            lib = join(self.si.WindowsSdkDir, 'lib')\n            libver = self._sdk_subdir\n            return [join(lib, '%sum%s' % (libver, arch_subdir))]\n\n    @property\n    def OSIncludes(self):\n        \"\"\"\n        Microsoft Windows SDK Include.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        include = join(self.si.WindowsSdkDir, 'include')\n\n        if self.vs_ver <= 10.0:\n            return [include, join(include, 'gl')]\n\n        else:\n            if self.vs_ver >= 14.0:\n                sdkver = self._sdk_subdir\n            else:\n                sdkver = ''\n            return [\n                join(include, '%sshared' % sdkver),\n                join(include, '%sum' % sdkver),\n                join(include, '%swinrt' % sdkver),\n            ]\n\n    @property\n    def OSLibpath(self):\n        \"\"\"\n        Microsoft Windows SDK Libraries Paths.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        ref = join(self.si.WindowsSdkDir, 'References')\n        libpath = []\n\n        if self.vs_ver <= 9.0:\n            libpath += self.OSLibraries\n\n        if self.vs_ver >= 11.0:\n            libpath += [join(ref, r'CommonConfiguration\\Neutral')]\n\n        if self.vs_ver >= 14.0:\n            libpath += [\n                ref,\n                join(self.si.WindowsSdkDir, 'UnionMetadata'),\n                join(ref, 'Windows.Foundation.UniversalApiContract', '1.0.0.0'),\n                join(ref, 'Windows.Foundation.FoundationContract', '1.0.0.0'),\n                join(ref, 'Windows.Networking.Connectivity.WwanContract', '1.0.0.0'),\n                join(\n                    self.si.WindowsSdkDir,\n                    'ExtensionSDKs',\n                    'Microsoft.VCLibs',\n                    '%0.1f' % self.vs_ver,\n                    'References',\n                    'CommonConfiguration',\n                    'neutral',\n                ),\n            ]\n        return libpath\n\n    @property\n    def SdkTools(self):\n        \"\"\"\n        Microsoft Windows SDK Tools.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        return list(self._sdk_tools())\n\n    def _sdk_tools(self):\n        \"\"\"\n        Microsoft Windows SDK Tools paths generator.\n\n        Return\n        ------\n        generator of str\n            paths\n        \"\"\"\n        if self.vs_ver < 15.0:\n            bin_dir = 'Bin' if self.vs_ver <= 11.0 else r'Bin\\x86'\n            yield join(self.si.WindowsSdkDir, bin_dir)\n\n        if not self.pi.current_is_x86():\n            arch_subdir = self.pi.current_dir(x64=True)\n            path = 'Bin%s' % arch_subdir\n            yield join(self.si.WindowsSdkDir, path)\n\n        if self.vs_ver in (10.0, 11.0):\n            if self.pi.target_is_x86():\n                arch_subdir = ''\n            else:\n                arch_subdir = self.pi.current_dir(hidex86=True, x64=True)\n            path = r'Bin\\NETFX 4.0 Tools%s' % arch_subdir\n            yield join(self.si.WindowsSdkDir, path)\n\n        elif self.vs_ver >= 15.0:\n            path = join(self.si.WindowsSdkDir, 'Bin')\n            arch_subdir = self.pi.current_dir(x64=True)\n            sdkver = self.si.WindowsSdkLastVersion\n            yield join(path, '%s%s' % (sdkver, arch_subdir))\n\n        if self.si.WindowsSDKExecutablePath:\n            yield self.si.WindowsSDKExecutablePath\n\n    @property\n    def _sdk_subdir(self):\n        \"\"\"\n        Microsoft Windows SDK version subdir.\n\n        Return\n        ------\n        str\n            subdir\n        \"\"\"\n        ucrtver = self.si.WindowsSdkLastVersion\n        return ('%s\\\\' % ucrtver) if ucrtver else ''\n\n    @property\n    def SdkSetup(self):\n        \"\"\"\n        Microsoft Windows SDK Setup.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        if self.vs_ver > 9.0:\n            return []\n\n        return [join(self.si.WindowsSdkDir, 'Setup')]\n\n    @property\n    def FxTools(self):\n        \"\"\"\n        Microsoft .NET Framework Tools.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        pi = self.pi\n        si = self.si\n\n        if self.vs_ver <= 10.0:\n            include32 = True\n            include64 = not pi.target_is_x86() and not pi.current_is_x86()\n        else:\n            include32 = pi.target_is_x86() or pi.current_is_x86()\n            include64 = pi.current_cpu == 'amd64' or pi.target_cpu == 'amd64'\n\n        tools = []\n        if include32:\n            tools += [join(si.FrameworkDir32, ver) for ver in si.FrameworkVersion32]\n        if include64:\n            tools += [join(si.FrameworkDir64, ver) for ver in si.FrameworkVersion64]\n        return tools\n\n    @property\n    def NetFxSDKLibraries(self):\n        \"\"\"\n        Microsoft .Net Framework SDK Libraries.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        if self.vs_ver < 14.0 or not self.si.NetFxSdkDir:\n            return []\n\n        arch_subdir = self.pi.target_dir(x64=True)\n        return [join(self.si.NetFxSdkDir, r'lib\\um%s' % arch_subdir)]\n\n    @property\n    def NetFxSDKIncludes(self):\n        \"\"\"\n        Microsoft .Net Framework SDK Includes.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        if self.vs_ver < 14.0 or not self.si.NetFxSdkDir:\n            return []\n\n        return [join(self.si.NetFxSdkDir, r'include\\um')]\n\n    @property\n    def VsTDb(self):\n        \"\"\"\n        Microsoft Visual Studio Team System Database.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        return [join(self.si.VSInstallDir, r'VSTSDB\\Deploy')]\n\n    @property\n    def MSBuild(self):\n        \"\"\"\n        Microsoft Build Engine.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        if self.vs_ver < 12.0:\n            return []\n        elif self.vs_ver < 15.0:\n            base_path = self.si.ProgramFilesx86\n            arch_subdir = self.pi.current_dir(hidex86=True)\n        else:\n            base_path = self.si.VSInstallDir\n            arch_subdir = ''\n\n        path = r'MSBuild\\%0.1f\\bin%s' % (self.vs_ver, arch_subdir)\n        build = [join(base_path, path)]\n\n        if self.vs_ver >= 15.0:\n            # Add Roslyn C# & Visual Basic Compiler\n            build += [join(base_path, path, 'Roslyn')]\n\n        return build\n\n    @property\n    def HTMLHelpWorkshop(self):\n        \"\"\"\n        Microsoft HTML Help Workshop.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        if self.vs_ver < 11.0:\n            return []\n\n        return [join(self.si.ProgramFilesx86, 'HTML Help Workshop')]\n\n    @property\n    def UCRTLibraries(self):\n        \"\"\"\n        Microsoft Universal C Runtime SDK Libraries.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        if self.vs_ver < 14.0:\n            return []\n\n        arch_subdir = self.pi.target_dir(x64=True)\n        lib = join(self.si.UniversalCRTSdkDir, 'lib')\n        ucrtver = self._ucrt_subdir\n        return [join(lib, '%sucrt%s' % (ucrtver, arch_subdir))]\n\n    @property\n    def UCRTIncludes(self):\n        \"\"\"\n        Microsoft Universal C Runtime SDK Include.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        if self.vs_ver < 14.0:\n            return []\n\n        include = join(self.si.UniversalCRTSdkDir, 'include')\n        return [join(include, '%sucrt' % self._ucrt_subdir)]\n\n    @property\n    def _ucrt_subdir(self):\n        \"\"\"\n        Microsoft Universal C Runtime SDK version subdir.\n\n        Return\n        ------\n        str\n            subdir\n        \"\"\"\n        ucrtver = self.si.UniversalCRTSdkLastVersion\n        return ('%s\\\\' % ucrtver) if ucrtver else ''\n\n    @property\n    def FSharp(self):\n        \"\"\"\n        Microsoft Visual F#.\n\n        Return\n        ------\n        list of str\n            paths\n        \"\"\"\n        if 11.0 > self.vs_ver > 12.0:\n            return []\n\n        return [self.si.FSharpInstallDir]\n\n    @property\n    def VCRuntimeRedist(self):\n        \"\"\"\n        Microsoft Visual C++ runtime redistributable dll.\n\n        Return\n        ------\n        str\n            path\n        \"\"\"\n        vcruntime = 'vcruntime%d0.dll' % self.vc_ver\n        arch_subdir = self.pi.target_dir(x64=True).strip('\\\\')\n\n        # Installation prefixes candidates\n        prefixes = []\n        tools_path = self.si.VCInstallDir\n        redist_path = dirname(tools_path.replace(r'\\Tools', r'\\Redist'))\n        if isdir(redist_path):\n            # Redist version may not be exactly the same as tools\n            redist_path = join(redist_path, listdir(redist_path)[-1])\n            prefixes += [redist_path, join(redist_path, 'onecore')]\n\n        prefixes += [join(tools_path, 'redist')]  # VS14 legacy path\n\n        # CRT directory\n        crt_dirs = (\n            'Microsoft.VC%d.CRT' % (self.vc_ver * 10),\n            # Sometime store in directory with VS version instead of VC\n            'Microsoft.VC%d.CRT' % (int(self.vs_ver) * 10),\n        )\n\n        # vcruntime path\n        for prefix, crt_dir in itertools.product(prefixes, crt_dirs):\n            path = join(prefix, arch_subdir, crt_dir, vcruntime)\n            if isfile(path):\n                return path\n\n    def return_env(self, exists=True):\n        \"\"\"\n        Return environment dict.\n\n        Parameters\n        ----------\n        exists: bool\n            It True, only return existing paths.\n\n        Return\n        ------\n        dict\n            environment\n        \"\"\"\n        env = dict(\n            include=self._build_paths(\n                'include',\n                [\n                    self.VCIncludes,\n                    self.OSIncludes,\n                    self.UCRTIncludes,\n                    self.NetFxSDKIncludes,\n                ],\n                exists,\n            ),\n            lib=self._build_paths(\n                'lib',\n                [\n                    self.VCLibraries,\n                    self.OSLibraries,\n                    self.FxTools,\n                    self.UCRTLibraries,\n                    self.NetFxSDKLibraries,\n                ],\n                exists,\n            ),\n            libpath=self._build_paths(\n                'libpath',\n                [self.VCLibraries, self.FxTools, self.VCStoreRefs, self.OSLibpath],\n                exists,\n            ),\n            path=self._build_paths(\n                'path',\n                [\n                    self.VCTools,\n                    self.VSTools,\n                    self.VsTDb,\n                    self.SdkTools,\n                    self.SdkSetup,\n                    self.FxTools,\n                    self.MSBuild,\n                    self.HTMLHelpWorkshop,\n                    self.FSharp,\n                ],\n                exists,\n            ),\n        )\n        if self.vs_ver >= 14 and isfile(self.VCRuntimeRedist):\n            env['py_vcruntime_redist'] = self.VCRuntimeRedist\n        return env\n\n    def _build_paths(self, name, spec_path_lists, exists):\n        \"\"\"\n        Given an environment variable name and specified paths,\n        return a pathsep-separated string of paths containing\n        unique, extant, directories from those paths and from\n        the environment variable. Raise an error if no paths\n        are resolved.\n\n        Parameters\n        ----------\n        name: str\n            Environment variable name\n        spec_path_lists: list of str\n            Paths\n        exists: bool\n            It True, only return existing paths.\n\n        Return\n        ------\n        str\n            Pathsep-separated paths\n        \"\"\"\n        # flatten spec_path_lists\n        spec_paths = itertools.chain.from_iterable(spec_path_lists)\n        env_paths = environ.get(name, '').split(pathsep)\n        paths = itertools.chain(spec_paths, env_paths)\n        extant_paths = list(filter(isdir, paths)) if exists else paths\n        if not extant_paths:\n            msg = \"%s environment variable is empty\" % name.upper()\n            raise distutils.errors.DistutilsPlatformError(msg)\n        unique_paths = unique_everseen(extant_paths)\n        return pathsep.join(unique_paths)\n", "setuptools/monkey.py": "\"\"\"\nMonkey patching of distutils.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport functools\nimport inspect\nimport platform\nimport sys\nimport types\nfrom importlib import import_module\nfrom typing import TypeVar\n\nimport distutils.filelist\n\n\n_T = TypeVar(\"_T\")\n\n__all__: list[str] = []\n\"\"\"\nEverything is private. Contact the project team\nif you think you need this functionality.\n\"\"\"\n\n\ndef _get_mro(cls):\n    \"\"\"\n    Returns the bases classes for cls sorted by the MRO.\n\n    Works around an issue on Jython where inspect.getmro will not return all\n    base classes if multiple classes share the same name. Instead, this\n    function will return a tuple containing the class itself, and the contents\n    of cls.__bases__. See https://github.com/pypa/setuptools/issues/1024.\n    \"\"\"\n    if platform.python_implementation() == \"Jython\":\n        return (cls,) + cls.__bases__\n    return inspect.getmro(cls)\n\n\ndef get_unpatched(item: _T) -> _T:\n    lookup = (\n        get_unpatched_class\n        if isinstance(item, type)\n        else get_unpatched_function\n        if isinstance(item, types.FunctionType)\n        else lambda item: None\n    )\n    return lookup(item)\n\n\ndef get_unpatched_class(cls):\n    \"\"\"Protect against re-patching the distutils if reloaded\n\n    Also ensures that no other distutils extension monkeypatched the distutils\n    first.\n    \"\"\"\n    external_bases = (\n        cls for cls in _get_mro(cls) if not cls.__module__.startswith('setuptools')\n    )\n    base = next(external_bases)\n    if not base.__module__.startswith('distutils'):\n        msg = \"distutils has already been patched by %r\" % cls\n        raise AssertionError(msg)\n    return base\n\n\ndef patch_all():\n    import setuptools\n\n    # we can't patch distutils.cmd, alas\n    distutils.core.Command = setuptools.Command\n\n    _patch_distribution_metadata()\n\n    # Install Distribution throughout the distutils\n    for module in distutils.dist, distutils.core, distutils.cmd:\n        module.Distribution = setuptools.dist.Distribution\n\n    # Install the patched Extension\n    distutils.core.Extension = setuptools.extension.Extension\n    distutils.extension.Extension = setuptools.extension.Extension\n    if 'distutils.command.build_ext' in sys.modules:\n        sys.modules[\n            'distutils.command.build_ext'\n        ].Extension = setuptools.extension.Extension\n\n    patch_for_msvc_specialized_compiler()\n\n\ndef _patch_distribution_metadata():\n    from . import _core_metadata\n\n    \"\"\"Patch write_pkg_file and read_pkg_file for higher metadata standards\"\"\"\n    for attr in (\n        'write_pkg_info',\n        'write_pkg_file',\n        'read_pkg_file',\n        'get_metadata_version',\n        'get_fullname',\n    ):\n        new_val = getattr(_core_metadata, attr)\n        setattr(distutils.dist.DistributionMetadata, attr, new_val)\n\n\ndef patch_func(replacement, target_mod, func_name):\n    \"\"\"\n    Patch func_name in target_mod with replacement\n\n    Important - original must be resolved by name to avoid\n    patching an already patched function.\n    \"\"\"\n    original = getattr(target_mod, func_name)\n\n    # set the 'unpatched' attribute on the replacement to\n    # point to the original.\n    vars(replacement).setdefault('unpatched', original)\n\n    # replace the function in the original module\n    setattr(target_mod, func_name, replacement)\n\n\ndef get_unpatched_function(candidate):\n    return candidate.unpatched\n\n\ndef patch_for_msvc_specialized_compiler():\n    \"\"\"\n    Patch functions in distutils to use standalone Microsoft Visual C++\n    compilers.\n    \"\"\"\n    from . import msvc\n\n    if platform.system() != 'Windows':\n        # Compilers only available on Microsoft Windows\n        return\n\n    def patch_params(mod_name, func_name):\n        \"\"\"\n        Prepare the parameters for patch_func to patch indicated function.\n        \"\"\"\n        repl_prefix = 'msvc14_'\n        repl_name = repl_prefix + func_name.lstrip('_')\n        repl = getattr(msvc, repl_name)\n        mod = import_module(mod_name)\n        if not hasattr(mod, func_name):\n            raise ImportError(func_name)\n        return repl, mod, func_name\n\n    # Python 3.5+\n    msvc14 = functools.partial(patch_params, 'distutils._msvccompiler')\n\n    try:\n        # Patch distutils._msvccompiler._get_vc_env\n        patch_func(*msvc14('_get_vc_env'))\n    except ImportError:\n        pass\n", "setuptools/modified.py": "from ._distutils._modified import (\n    newer,\n    newer_pairwise,\n    newer_group,\n    newer_pairwise_group,\n)\n\n__all__ = ['newer', 'newer_pairwise', 'newer_group', 'newer_pairwise_group']\n", "setuptools/_path.py": "import os\nimport sys\nfrom typing import Union\n\nif sys.version_info >= (3, 9):\n    StrPath = Union[str, os.PathLike[str]]  #  Same as _typeshed.StrPath\nelse:\n    StrPath = Union[str, os.PathLike]\n\n\ndef ensure_directory(path):\n    \"\"\"Ensure that the parent directory of `path` exists\"\"\"\n    dirname = os.path.dirname(path)\n    os.makedirs(dirname, exist_ok=True)\n\n\ndef same_path(p1: StrPath, p2: StrPath) -> bool:\n    \"\"\"Differs from os.path.samefile because it does not require paths to exist.\n    Purely string based (no comparison between i-nodes).\n    >>> same_path(\"a/b\", \"./a/b\")\n    True\n    >>> same_path(\"a/b\", \"a/./b\")\n    True\n    >>> same_path(\"a/b\", \"././a/b\")\n    True\n    >>> same_path(\"a/b\", \"./a/b/c/..\")\n    True\n    >>> same_path(\"a/b\", \"../a/b/c\")\n    False\n    >>> same_path(\"a\", \"a/b\")\n    False\n    \"\"\"\n    return normpath(p1) == normpath(p2)\n\n\ndef normpath(filename: StrPath) -> str:\n    \"\"\"Normalize a file/dir name for comparison purposes.\"\"\"\n    # See pkg_resources.normalize_path for notes about cygwin\n    file = os.path.abspath(filename) if sys.platform == 'cygwin' else filename\n    return os.path.normcase(os.path.realpath(os.path.normpath(file)))\n", "setuptools/_entry_points.py": "import functools\nimport operator\nimport itertools\n\nfrom .errors import OptionError\nfrom .extern.jaraco.text import yield_lines\nfrom .extern.jaraco.functools import pass_none\nfrom ._importlib import metadata\nfrom ._itertools import ensure_unique\nfrom .extern.more_itertools import consume\n\n\ndef ensure_valid(ep):\n    \"\"\"\n    Exercise one of the dynamic properties to trigger\n    the pattern match.\n    \"\"\"\n    try:\n        ep.extras\n    except (AttributeError, AssertionError) as ex:\n        # Why both? See https://github.com/python/importlib_metadata/issues/488\n        msg = (\n            f\"Problems to parse {ep}.\\nPlease ensure entry-point follows the spec: \"\n            \"https://packaging.python.org/en/latest/specifications/entry-points/\"\n        )\n        raise OptionError(msg) from ex\n\n\ndef load_group(value, group):\n    \"\"\"\n    Given a value of an entry point or series of entry points,\n    return each as an EntryPoint.\n    \"\"\"\n    # normalize to a single sequence of lines\n    lines = yield_lines(value)\n    text = f'[{group}]\\n' + '\\n'.join(lines)\n    return metadata.EntryPoints._from_text(text)\n\n\ndef by_group_and_name(ep):\n    return ep.group, ep.name\n\n\ndef validate(eps: metadata.EntryPoints):\n    \"\"\"\n    Ensure entry points are unique by group and name and validate each.\n    \"\"\"\n    consume(map(ensure_valid, ensure_unique(eps, key=by_group_and_name)))\n    return eps\n\n\n@functools.singledispatch\ndef load(eps):\n    \"\"\"\n    Given a Distribution.entry_points, produce EntryPoints.\n    \"\"\"\n    groups = itertools.chain.from_iterable(\n        load_group(value, group) for group, value in eps.items()\n    )\n    return validate(metadata.EntryPoints(groups))\n\n\n@load.register(str)\ndef _(eps):\n    r\"\"\"\n    >>> ep, = load('[console_scripts]\\nfoo=bar')\n    >>> ep.group\n    'console_scripts'\n    >>> ep.name\n    'foo'\n    >>> ep.value\n    'bar'\n    \"\"\"\n    return validate(metadata.EntryPoints(metadata.EntryPoints._from_text(eps)))\n\n\nload.register(type(None), lambda x: x)\n\n\n@pass_none\ndef render(eps: metadata.EntryPoints):\n    by_group = operator.attrgetter('group')\n    groups = itertools.groupby(sorted(eps, key=by_group), by_group)\n\n    return '\\n'.join(f'[{group}]\\n{render_items(items)}\\n' for group, items in groups)\n\n\ndef render_items(eps):\n    return '\\n'.join(f'{ep.name} = {ep.value}' for ep in sorted(eps))\n", "setuptools/archive_util.py": "\"\"\"Utilities for extracting common archive formats\"\"\"\n\nimport zipfile\nimport tarfile\nimport os\nimport shutil\nimport posixpath\nimport contextlib\nfrom distutils.errors import DistutilsError\n\nfrom ._path import ensure_directory\n\n__all__ = [\n    \"unpack_archive\",\n    \"unpack_zipfile\",\n    \"unpack_tarfile\",\n    \"default_filter\",\n    \"UnrecognizedFormat\",\n    \"extraction_drivers\",\n    \"unpack_directory\",\n]\n\n\nclass UnrecognizedFormat(DistutilsError):\n    \"\"\"Couldn't recognize the archive type\"\"\"\n\n\ndef default_filter(src, dst):\n    \"\"\"The default progress/filter callback; returns True for all files\"\"\"\n    return dst\n\n\ndef unpack_archive(filename, extract_dir, progress_filter=default_filter, drivers=None):\n    \"\"\"Unpack `filename` to `extract_dir`, or raise ``UnrecognizedFormat``\n\n    `progress_filter` is a function taking two arguments: a source path\n    internal to the archive ('/'-separated), and a filesystem path where it\n    will be extracted.  The callback must return the desired extract path\n    (which may be the same as the one passed in), or else ``None`` to skip\n    that file or directory.  The callback can thus be used to report on the\n    progress of the extraction, as well as to filter the items extracted or\n    alter their extraction paths.\n\n    `drivers`, if supplied, must be a non-empty sequence of functions with the\n    same signature as this function (minus the `drivers` argument), that raise\n    ``UnrecognizedFormat`` if they do not support extracting the designated\n    archive type.  The `drivers` are tried in sequence until one is found that\n    does not raise an error, or until all are exhausted (in which case\n    ``UnrecognizedFormat`` is raised).  If you do not supply a sequence of\n    drivers, the module's ``extraction_drivers`` constant will be used, which\n    means that ``unpack_zipfile`` and ``unpack_tarfile`` will be tried, in that\n    order.\n    \"\"\"\n    for driver in drivers or extraction_drivers:\n        try:\n            driver(filename, extract_dir, progress_filter)\n        except UnrecognizedFormat:\n            continue\n        else:\n            return\n    else:\n        raise UnrecognizedFormat(\"Not a recognized archive type: %s\" % filename)\n\n\ndef unpack_directory(filename, extract_dir, progress_filter=default_filter):\n    \"\"\" \"Unpack\" a directory, using the same interface as for archives\n\n    Raises ``UnrecognizedFormat`` if `filename` is not a directory\n    \"\"\"\n    if not os.path.isdir(filename):\n        raise UnrecognizedFormat(\"%s is not a directory\" % filename)\n\n    paths = {\n        filename: ('', extract_dir),\n    }\n    for base, dirs, files in os.walk(filename):\n        src, dst = paths[base]\n        for d in dirs:\n            paths[os.path.join(base, d)] = src + d + '/', os.path.join(dst, d)\n        for f in files:\n            target = os.path.join(dst, f)\n            target = progress_filter(src + f, target)\n            if not target:\n                # skip non-files\n                continue\n            ensure_directory(target)\n            f = os.path.join(base, f)\n            shutil.copyfile(f, target)\n            shutil.copystat(f, target)\n\n\ndef unpack_zipfile(filename, extract_dir, progress_filter=default_filter):\n    \"\"\"Unpack zip `filename` to `extract_dir`\n\n    Raises ``UnrecognizedFormat`` if `filename` is not a zipfile (as determined\n    by ``zipfile.is_zipfile()``).  See ``unpack_archive()`` for an explanation\n    of the `progress_filter` argument.\n    \"\"\"\n\n    if not zipfile.is_zipfile(filename):\n        raise UnrecognizedFormat(\"%s is not a zip file\" % (filename,))\n\n    with zipfile.ZipFile(filename) as z:\n        _unpack_zipfile_obj(z, extract_dir, progress_filter)\n\n\ndef _unpack_zipfile_obj(zipfile_obj, extract_dir, progress_filter=default_filter):\n    \"\"\"Internal/private API used by other parts of setuptools.\n    Similar to ``unpack_zipfile``, but receives an already opened :obj:`zipfile.ZipFile`\n    object instead of a filename.\n    \"\"\"\n    for info in zipfile_obj.infolist():\n        name = info.filename\n\n        # don't extract absolute paths or ones with .. in them\n        if name.startswith('/') or '..' in name.split('/'):\n            continue\n\n        target = os.path.join(extract_dir, *name.split('/'))\n        target = progress_filter(name, target)\n        if not target:\n            continue\n        if name.endswith('/'):\n            # directory\n            ensure_directory(target)\n        else:\n            # file\n            ensure_directory(target)\n            data = zipfile_obj.read(info.filename)\n            with open(target, 'wb') as f:\n                f.write(data)\n        unix_attributes = info.external_attr >> 16\n        if unix_attributes:\n            os.chmod(target, unix_attributes)\n\n\ndef _resolve_tar_file_or_dir(tar_obj, tar_member_obj):\n    \"\"\"Resolve any links and extract link targets as normal files.\"\"\"\n    while tar_member_obj is not None and (\n        tar_member_obj.islnk() or tar_member_obj.issym()\n    ):\n        linkpath = tar_member_obj.linkname\n        if tar_member_obj.issym():\n            base = posixpath.dirname(tar_member_obj.name)\n            linkpath = posixpath.join(base, linkpath)\n            linkpath = posixpath.normpath(linkpath)\n        tar_member_obj = tar_obj._getmember(linkpath)\n\n    is_file_or_dir = tar_member_obj is not None and (\n        tar_member_obj.isfile() or tar_member_obj.isdir()\n    )\n    if is_file_or_dir:\n        return tar_member_obj\n\n    raise LookupError('Got unknown file type')\n\n\ndef _iter_open_tar(tar_obj, extract_dir, progress_filter):\n    \"\"\"Emit member-destination pairs from a tar archive.\"\"\"\n    # don't do any chowning!\n    tar_obj.chown = lambda *args: None\n\n    with contextlib.closing(tar_obj):\n        for member in tar_obj:\n            name = member.name\n            # don't extract absolute paths or ones with .. in them\n            if name.startswith('/') or '..' in name.split('/'):\n                continue\n\n            prelim_dst = os.path.join(extract_dir, *name.split('/'))\n\n            try:\n                member = _resolve_tar_file_or_dir(tar_obj, member)\n            except LookupError:\n                continue\n\n            final_dst = progress_filter(name, prelim_dst)\n            if not final_dst:\n                continue\n\n            if final_dst.endswith(os.sep):\n                final_dst = final_dst[:-1]\n\n            yield member, final_dst\n\n\ndef unpack_tarfile(filename, extract_dir, progress_filter=default_filter):\n    \"\"\"Unpack tar/tar.gz/tar.bz2 `filename` to `extract_dir`\n\n    Raises ``UnrecognizedFormat`` if `filename` is not a tarfile (as determined\n    by ``tarfile.open()``).  See ``unpack_archive()`` for an explanation\n    of the `progress_filter` argument.\n    \"\"\"\n    try:\n        tarobj = tarfile.open(filename)\n    except tarfile.TarError as e:\n        raise UnrecognizedFormat(\n            \"%s is not a compressed or uncompressed tar file\" % (filename,)\n        ) from e\n\n    for member, final_dst in _iter_open_tar(\n        tarobj,\n        extract_dir,\n        progress_filter,\n    ):\n        try:\n            # XXX Ugh\n            tarobj._extract_member(member, final_dst)\n        except tarfile.ExtractError:\n            # chown/chmod/mkfifo/mknode/makedev failed\n            pass\n\n    return True\n\n\nextraction_drivers = unpack_directory, unpack_zipfile, unpack_tarfile\n", "setuptools/__init__.py": "\"\"\"Extensions to the 'distutils' for large or complex distributions\"\"\"\n\nimport functools\nimport os\nimport re\nfrom typing import TYPE_CHECKING\n\nimport _distutils_hack.override  # noqa: F401\nimport distutils.core\nfrom distutils.errors import DistutilsOptionError\n\nfrom . import logging, monkey\nfrom . import version as _version_module\nfrom .depends import Require\nfrom .discovery import PackageFinder, PEP420PackageFinder\nfrom .dist import Distribution\nfrom .extension import Extension\nfrom .warnings import SetuptoolsDeprecationWarning\n\n__all__ = [\n    'setup',\n    'Distribution',\n    'Command',\n    'Extension',\n    'Require',\n    'SetuptoolsDeprecationWarning',\n    'find_packages',\n    'find_namespace_packages',\n]\n\n__version__ = _version_module.__version__\n\nbootstrap_install_from = None\n\n\nfind_packages = PackageFinder.find\nfind_namespace_packages = PEP420PackageFinder.find\n\n\ndef _install_setup_requires(attrs):\n    # Note: do not use `setuptools.Distribution` directly, as\n    # our PEP 517 backend patch `distutils.core.Distribution`.\n    class MinimalDistribution(distutils.core.Distribution):\n        \"\"\"\n        A minimal version of a distribution for supporting the\n        fetch_build_eggs interface.\n        \"\"\"\n\n        def __init__(self, attrs):\n            _incl = 'dependency_links', 'setup_requires'\n            filtered = {k: attrs[k] for k in set(_incl) & set(attrs)}\n            super().__init__(filtered)\n            # Prevent accidentally triggering discovery with incomplete set of attrs\n            self.set_defaults._disable()\n\n        def _get_project_config_files(self, filenames=None):\n            \"\"\"Ignore ``pyproject.toml``, they are not related to setup_requires\"\"\"\n            try:\n                cfg, toml = super()._split_standard_project_metadata(filenames)\n                return cfg, ()\n            except Exception:\n                return filenames, ()\n\n        def finalize_options(self):\n            \"\"\"\n            Disable finalize_options to avoid building the working set.\n            Ref #2158.\n            \"\"\"\n\n    dist = MinimalDistribution(attrs)\n\n    # Honor setup.cfg's options.\n    dist.parse_config_files(ignore_option_errors=True)\n    if dist.setup_requires:\n        _fetch_build_eggs(dist)\n\n\ndef _fetch_build_eggs(dist):\n    try:\n        dist.fetch_build_eggs(dist.setup_requires)\n    except Exception as ex:\n        msg = \"\"\"\n        It is possible a package already installed in your system\n        contains an version that is invalid according to PEP 440.\n        You can try `pip install --use-pep517` as a workaround for this problem,\n        or rely on a new virtual environment.\n\n        If the problem refers to a package that is not installed yet,\n        please contact that package's maintainers or distributors.\n        \"\"\"\n        if \"InvalidVersion\" in ex.__class__.__name__:\n            if hasattr(ex, \"add_note\"):\n                ex.add_note(msg)  # PEP 678\n            else:\n                dist.announce(f\"\\n{msg}\\n\")\n        raise\n\n\ndef setup(**attrs):\n    # Make sure we have any requirements needed to interpret 'attrs'.\n    logging.configure()\n    _install_setup_requires(attrs)\n    return distutils.core.setup(**attrs)\n\n\nsetup.__doc__ = distutils.core.setup.__doc__\n\nif TYPE_CHECKING:\n    # Work around a mypy issue where type[T] can't be used as a base: https://github.com/python/mypy/issues/10962\n    _Command = distutils.core.Command\nelse:\n    _Command = monkey.get_unpatched(distutils.core.Command)\n\n\nclass Command(_Command):\n    \"\"\"\n    Setuptools internal actions are organized using a *command design pattern*.\n    This means that each action (or group of closely related actions) executed during\n    the build should be implemented as a ``Command`` subclass.\n\n    These commands are abstractions and do not necessarily correspond to a command that\n    can (or should) be executed via a terminal, in a CLI fashion (although historically\n    they would).\n\n    When creating a new command from scratch, custom defined classes **SHOULD** inherit\n    from ``setuptools.Command`` and implement a few mandatory methods.\n    Between these mandatory methods, are listed:\n\n    .. method:: initialize_options(self)\n\n        Set or (reset) all options/attributes/caches used by the command\n        to their default values. Note that these values may be overwritten during\n        the build.\n\n    .. method:: finalize_options(self)\n\n        Set final values for all options/attributes used by the command.\n        Most of the time, each option/attribute/cache should only be set if it does not\n        have any value yet (e.g. ``if self.attr is None: self.attr = val``).\n\n    .. method:: run(self)\n\n        Execute the actions intended by the command.\n        (Side effects **SHOULD** only take place when ``run`` is executed,\n        for example, creating new files or writing to the terminal output).\n\n    A useful analogy for command classes is to think of them as subroutines with local\n    variables called \"options\".  The options are \"declared\" in ``initialize_options()``\n    and \"defined\" (given their final values, aka \"finalized\") in ``finalize_options()``,\n    both of which must be defined by every command class. The \"body\" of the subroutine,\n    (where it does all the work) is the ``run()`` method.\n    Between ``initialize_options()`` and ``finalize_options()``, ``setuptools`` may set\n    the values for options/attributes based on user's input (or circumstance),\n    which means that the implementation should be careful to not overwrite values in\n    ``finalize_options`` unless necessary.\n\n    Please note that other commands (or other parts of setuptools) may also overwrite\n    the values of the command's options/attributes multiple times during the build\n    process.\n    Therefore it is important to consistently implement ``initialize_options()`` and\n    ``finalize_options()``. For example, all derived attributes (or attributes that\n    depend on the value of other attributes) **SHOULD** be recomputed in\n    ``finalize_options``.\n\n    When overwriting existing commands, custom defined classes **MUST** abide by the\n    same APIs implemented by the original class. They also **SHOULD** inherit from the\n    original class.\n    \"\"\"\n\n    command_consumes_arguments = False\n    distribution: Distribution  # override distutils.dist.Distribution with setuptools.dist.Distribution\n\n    def __init__(self, dist: Distribution, **kw):\n        \"\"\"\n        Construct the command for dist, updating\n        vars(self) with any keyword parameters.\n        \"\"\"\n        super().__init__(dist)\n        vars(self).update(kw)\n\n    def _ensure_stringlike(self, option, what, default=None):\n        val = getattr(self, option)\n        if val is None:\n            setattr(self, option, default)\n            return default\n        elif not isinstance(val, str):\n            raise DistutilsOptionError(\n                \"'%s' must be a %s (got `%s`)\" % (option, what, val)\n            )\n        return val\n\n    def ensure_string_list(self, option):\n        r\"\"\"Ensure that 'option' is a list of strings.  If 'option' is\n        currently a string, we split it either on /,\\s*/ or /\\s+/, so\n        \"foo bar baz\", \"foo,bar,baz\", and \"foo,   bar baz\" all become\n        [\"foo\", \"bar\", \"baz\"].\n\n        ..\n           TODO: This method seems to be similar to the one in ``distutils.cmd``\n           Probably it is just here for backward compatibility with old Python versions?\n\n        :meta private:\n        \"\"\"\n        val = getattr(self, option)\n        if val is None:\n            return\n        elif isinstance(val, str):\n            setattr(self, option, re.split(r',\\s*|\\s+', val))\n        else:\n            if isinstance(val, list):\n                ok = all(isinstance(v, str) for v in val)\n            else:\n                ok = False\n            if not ok:\n                raise DistutilsOptionError(\n                    \"'%s' must be a list of strings (got %r)\" % (option, val)\n                )\n\n    def reinitialize_command(self, command, reinit_subcommands=False, **kw):\n        cmd = _Command.reinitialize_command(self, command, reinit_subcommands)\n        vars(cmd).update(kw)\n        return cmd\n\n\ndef _find_all_simple(path):\n    \"\"\"\n    Find all files under 'path'\n    \"\"\"\n    results = (\n        os.path.join(base, file)\n        for base, dirs, files in os.walk(path, followlinks=True)\n        for file in files\n    )\n    return filter(os.path.isfile, results)\n\n\ndef findall(dir=os.curdir):\n    \"\"\"\n    Find all files under 'dir' and return the list of full filenames.\n    Unless dir is '.', return full filenames with dir prepended.\n    \"\"\"\n    files = _find_all_simple(dir)\n    if dir == os.curdir:\n        make_rel = functools.partial(os.path.relpath, start=dir)\n        files = map(make_rel, files)\n    return list(files)\n\n\nclass sic(str):\n    \"\"\"Treat this string as-is (https://en.wikipedia.org/wiki/Sic)\"\"\"\n\n\n# Apply monkey patches\nmonkey.patch_all()\n", "setuptools/build_meta.py": "\"\"\"A PEP 517 interface to setuptools\n\nPreviously, when a user or a command line tool (let's call it a \"frontend\")\nneeded to make a request of setuptools to take a certain action, for\nexample, generating a list of installation requirements, the frontend\nwould call \"setup.py egg_info\" or \"setup.py bdist_wheel\" on the command line.\n\nPEP 517 defines a different method of interfacing with setuptools. Rather\nthan calling \"setup.py\" directly, the frontend should:\n\n  1. Set the current directory to the directory with a setup.py file\n  2. Import this module into a safe python interpreter (one in which\n     setuptools can potentially set global variables or crash hard).\n  3. Call one of the functions defined in PEP 517.\n\nWhat each function does is defined in PEP 517. However, here is a \"casual\"\ndefinition of the functions (this definition should not be relied on for\nbug reports or API stability):\n\n  - `build_wheel`: build a wheel in the folder and return the basename\n  - `get_requires_for_build_wheel`: get the `setup_requires` to build\n  - `prepare_metadata_for_build_wheel`: get the `install_requires`\n  - `build_sdist`: build an sdist in the folder and return the basename\n  - `get_requires_for_build_sdist`: get the `setup_requires` to build\n\nAgain, this is not a formal definition! Just a \"taste\" of the module.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport io\nimport os\nimport shlex\nimport sys\nimport tokenize\nimport shutil\nimport contextlib\nimport tempfile\nimport warnings\nfrom pathlib import Path\nfrom typing import Dict, Iterator, List, Optional, Union, Iterable\n\nimport setuptools\nimport distutils\nfrom . import errors\nfrom ._path import same_path, StrPath\nfrom ._reqs import parse_strings\nfrom .warnings import SetuptoolsDeprecationWarning\nfrom distutils.util import strtobool\n\n\n__all__ = [\n    'get_requires_for_build_sdist',\n    'get_requires_for_build_wheel',\n    'prepare_metadata_for_build_wheel',\n    'build_wheel',\n    'build_sdist',\n    'get_requires_for_build_editable',\n    'prepare_metadata_for_build_editable',\n    'build_editable',\n    '__legacy__',\n    'SetupRequirementsError',\n]\n\nSETUPTOOLS_ENABLE_FEATURES = os.getenv(\"SETUPTOOLS_ENABLE_FEATURES\", \"\").lower()\nLEGACY_EDITABLE = \"legacy-editable\" in SETUPTOOLS_ENABLE_FEATURES.replace(\"_\", \"-\")\n\n\nclass SetupRequirementsError(BaseException):\n    def __init__(self, specifiers):\n        self.specifiers = specifiers\n\n\nclass Distribution(setuptools.dist.Distribution):\n    def fetch_build_eggs(self, specifiers):\n        specifier_list = list(parse_strings(specifiers))\n\n        raise SetupRequirementsError(specifier_list)\n\n    @classmethod\n    @contextlib.contextmanager\n    def patch(cls):\n        \"\"\"\n        Replace\n        distutils.dist.Distribution with this class\n        for the duration of this context.\n        \"\"\"\n        orig = distutils.core.Distribution\n        distutils.core.Distribution = cls\n        try:\n            yield\n        finally:\n            distutils.core.Distribution = orig\n\n\n@contextlib.contextmanager\ndef no_install_setup_requires():\n    \"\"\"Temporarily disable installing setup_requires\n\n    Under PEP 517, the backend reports build dependencies to the frontend,\n    and the frontend is responsible for ensuring they're installed.\n    So setuptools (acting as a backend) should not try to install them.\n    \"\"\"\n    orig = setuptools._install_setup_requires\n    setuptools._install_setup_requires = lambda attrs: None\n    try:\n        yield\n    finally:\n        setuptools._install_setup_requires = orig\n\n\ndef _get_immediate_subdirectories(a_dir):\n    return [\n        name for name in os.listdir(a_dir) if os.path.isdir(os.path.join(a_dir, name))\n    ]\n\n\ndef _file_with_extension(directory: StrPath, extension: str | tuple[str, ...]):\n    matching = (f for f in os.listdir(directory) if f.endswith(extension))\n    try:\n        (file,) = matching\n    except ValueError:\n        raise ValueError(\n            'No distribution was found. Ensure that `setup.py` '\n            'is not empty and that it calls `setup()`.'\n        ) from None\n    return file\n\n\ndef _open_setup_script(setup_script):\n    if not os.path.exists(setup_script):\n        # Supply a default setup.py\n        return io.StringIO(\"from setuptools import setup; setup()\")\n\n    return tokenize.open(setup_script)\n\n\n@contextlib.contextmanager\ndef suppress_known_deprecation():\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'setup.py install is deprecated')\n        yield\n\n\n_ConfigSettings = Optional[Dict[str, Union[str, List[str], None]]]\n\"\"\"\nCurrently the user can run::\n\n    pip install -e . --config-settings key=value\n    python -m build -C--key=value -C key=value\n\n- pip will pass both key and value as strings and overwriting repeated keys\n  (pypa/pip#11059).\n- build will accumulate values associated with repeated keys in a list.\n  It will also accept keys with no associated value.\n  This means that an option passed by build can be ``str | list[str] | None``.\n- PEP 517 specifies that ``config_settings`` is an optional dict.\n\"\"\"\n\n\nclass _ConfigSettingsTranslator:\n    \"\"\"Translate ``config_settings`` into distutils-style command arguments.\n    Only a limited number of options is currently supported.\n    \"\"\"\n\n    # See pypa/setuptools#1928 pypa/setuptools#2491\n\n    def _get_config(self, key: str, config_settings: _ConfigSettings) -> list[str]:\n        \"\"\"\n        Get the value of a specific key in ``config_settings`` as a list of strings.\n\n        >>> fn = _ConfigSettingsTranslator()._get_config\n        >>> fn(\"--global-option\", None)\n        []\n        >>> fn(\"--global-option\", {})\n        []\n        >>> fn(\"--global-option\", {'--global-option': 'foo'})\n        ['foo']\n        >>> fn(\"--global-option\", {'--global-option': ['foo']})\n        ['foo']\n        >>> fn(\"--global-option\", {'--global-option': 'foo'})\n        ['foo']\n        >>> fn(\"--global-option\", {'--global-option': 'foo bar'})\n        ['foo', 'bar']\n        \"\"\"\n        cfg = config_settings or {}\n        opts = cfg.get(key) or []\n        return shlex.split(opts) if isinstance(opts, str) else opts\n\n    def _global_args(self, config_settings: _ConfigSettings) -> Iterator[str]:\n        \"\"\"\n        Let the user specify ``verbose`` or ``quiet`` + escape hatch via\n        ``--global-option``.\n        Note: ``-v``, ``-vv``, ``-vvv`` have similar effects in setuptools,\n        so we just have to cover the basic scenario ``-v``.\n\n        >>> fn = _ConfigSettingsTranslator()._global_args\n        >>> list(fn(None))\n        []\n        >>> list(fn({\"verbose\": \"False\"}))\n        ['-q']\n        >>> list(fn({\"verbose\": \"1\"}))\n        ['-v']\n        >>> list(fn({\"--verbose\": None}))\n        ['-v']\n        >>> list(fn({\"verbose\": \"true\", \"--global-option\": \"-q --no-user-cfg\"}))\n        ['-v', '-q', '--no-user-cfg']\n        >>> list(fn({\"--quiet\": None}))\n        ['-q']\n        \"\"\"\n        cfg = config_settings or {}\n        falsey = {\"false\", \"no\", \"0\", \"off\"}\n        if \"verbose\" in cfg or \"--verbose\" in cfg:\n            level = str(cfg.get(\"verbose\") or cfg.get(\"--verbose\") or \"1\")\n            yield (\"-q\" if level.lower() in falsey else \"-v\")\n        if \"quiet\" in cfg or \"--quiet\" in cfg:\n            level = str(cfg.get(\"quiet\") or cfg.get(\"--quiet\") or \"1\")\n            yield (\"-v\" if level.lower() in falsey else \"-q\")\n\n        yield from self._get_config(\"--global-option\", config_settings)\n\n    def __dist_info_args(self, config_settings: _ConfigSettings) -> Iterator[str]:\n        \"\"\"\n        The ``dist_info`` command accepts ``tag-date`` and ``tag-build``.\n\n        .. warning::\n           We cannot use this yet as it requires the ``sdist`` and ``bdist_wheel``\n           commands run in ``build_sdist`` and ``build_wheel`` to reuse the egg-info\n           directory created in ``prepare_metadata_for_build_wheel``.\n\n        >>> fn = _ConfigSettingsTranslator()._ConfigSettingsTranslator__dist_info_args\n        >>> list(fn(None))\n        []\n        >>> list(fn({\"tag-date\": \"False\"}))\n        ['--no-date']\n        >>> list(fn({\"tag-date\": None}))\n        ['--no-date']\n        >>> list(fn({\"tag-date\": \"true\", \"tag-build\": \".a\"}))\n        ['--tag-date', '--tag-build', '.a']\n        \"\"\"\n        cfg = config_settings or {}\n        if \"tag-date\" in cfg:\n            val = strtobool(str(cfg[\"tag-date\"] or \"false\"))\n            yield (\"--tag-date\" if val else \"--no-date\")\n        if \"tag-build\" in cfg:\n            yield from [\"--tag-build\", str(cfg[\"tag-build\"])]\n\n    def _editable_args(self, config_settings: _ConfigSettings) -> Iterator[str]:\n        \"\"\"\n        The ``editable_wheel`` command accepts ``editable-mode=strict``.\n\n        >>> fn = _ConfigSettingsTranslator()._editable_args\n        >>> list(fn(None))\n        []\n        >>> list(fn({\"editable-mode\": \"strict\"}))\n        ['--mode', 'strict']\n        \"\"\"\n        cfg = config_settings or {}\n        mode = cfg.get(\"editable-mode\") or cfg.get(\"editable_mode\")\n        if not mode:\n            return\n        yield from [\"--mode\", str(mode)]\n\n    def _arbitrary_args(self, config_settings: _ConfigSettings) -> Iterator[str]:\n        \"\"\"\n        Users may expect to pass arbitrary lists of arguments to a command\n        via \"--global-option\" (example provided in PEP 517 of a \"escape hatch\").\n\n        >>> fn = _ConfigSettingsTranslator()._arbitrary_args\n        >>> list(fn(None))\n        []\n        >>> list(fn({}))\n        []\n        >>> list(fn({'--build-option': 'foo'}))\n        ['foo']\n        >>> list(fn({'--build-option': ['foo']}))\n        ['foo']\n        >>> list(fn({'--build-option': 'foo'}))\n        ['foo']\n        >>> list(fn({'--build-option': 'foo bar'}))\n        ['foo', 'bar']\n        >>> list(fn({'--global-option': 'foo'}))\n        []\n        \"\"\"\n        yield from self._get_config(\"--build-option\", config_settings)\n\n\nclass _BuildMetaBackend(_ConfigSettingsTranslator):\n    def _get_build_requires(self, config_settings, requirements):\n        sys.argv = [\n            *sys.argv[:1],\n            *self._global_args(config_settings),\n            \"egg_info\",\n        ]\n        try:\n            with Distribution.patch():\n                self.run_setup()\n        except SetupRequirementsError as e:\n            requirements += e.specifiers\n\n        return requirements\n\n    def run_setup(self, setup_script='setup.py'):\n        # Note that we can reuse our build directory between calls\n        # Correctness comes first, then optimization later\n        __file__ = os.path.abspath(setup_script)\n        __name__ = '__main__'\n\n        with _open_setup_script(__file__) as f:\n            code = f.read().replace(r'\\r\\n', r'\\n')\n\n        try:\n            exec(code, locals())\n        except SystemExit as e:\n            if e.code:\n                raise\n            # We ignore exit code indicating success\n            SetuptoolsDeprecationWarning.emit(\n                \"Running `setup.py` directly as CLI tool is deprecated.\",\n                \"Please avoid using `sys.exit(0)` or similar statements \"\n                \"that don't fit in the paradigm of a configuration file.\",\n                see_url=\"https://blog.ganssle.io/articles/2021/10/\"\n                \"setup-py-deprecated.html\",\n            )\n\n    def get_requires_for_build_wheel(self, config_settings=None):\n        return self._get_build_requires(config_settings, requirements=[])\n\n    def get_requires_for_build_sdist(self, config_settings=None):\n        return self._get_build_requires(config_settings, requirements=[])\n\n    def _bubble_up_info_directory(self, metadata_directory: str, suffix: str) -> str:\n        \"\"\"\n        PEP 517 requires that the .dist-info directory be placed in the\n        metadata_directory. To comply, we MUST copy the directory to the root.\n\n        Returns the basename of the info directory, e.g. `proj-0.0.0.dist-info`.\n        \"\"\"\n        info_dir = self._find_info_directory(metadata_directory, suffix)\n        if not same_path(info_dir.parent, metadata_directory):\n            shutil.move(str(info_dir), metadata_directory)\n            # PEP 517 allow other files and dirs to exist in metadata_directory\n        return info_dir.name\n\n    def _find_info_directory(self, metadata_directory: str, suffix: str) -> Path:\n        for parent, dirs, _ in os.walk(metadata_directory):\n            candidates = [f for f in dirs if f.endswith(suffix)]\n\n            if len(candidates) != 0 or len(dirs) != 1:\n                assert len(candidates) == 1, f\"Multiple {suffix} directories found\"\n                return Path(parent, candidates[0])\n\n        msg = f\"No {suffix} directory found in {metadata_directory}\"\n        raise errors.InternalError(msg)\n\n    def prepare_metadata_for_build_wheel(\n        self, metadata_directory, config_settings=None\n    ):\n        sys.argv = [\n            *sys.argv[:1],\n            *self._global_args(config_settings),\n            \"dist_info\",\n            \"--output-dir\",\n            metadata_directory,\n            \"--keep-egg-info\",\n        ]\n        with no_install_setup_requires():\n            self.run_setup()\n\n        self._bubble_up_info_directory(metadata_directory, \".egg-info\")\n        return self._bubble_up_info_directory(metadata_directory, \".dist-info\")\n\n    def _build_with_temp_dir(\n        self,\n        setup_command: Iterable[str],\n        result_extension: str | tuple[str, ...],\n        result_directory: StrPath,\n        config_settings: _ConfigSettings,\n        arbitrary_args: Iterable[str] = (),\n    ):\n        result_directory = os.path.abspath(result_directory)\n\n        # Build in a temporary directory, then copy to the target.\n        os.makedirs(result_directory, exist_ok=True)\n        temp_opts = {\"prefix\": \".tmp-\", \"dir\": result_directory}\n\n        with tempfile.TemporaryDirectory(**temp_opts) as tmp_dist_dir:\n            sys.argv = [\n                *sys.argv[:1],\n                *self._global_args(config_settings),\n                *setup_command,\n                \"--dist-dir\",\n                tmp_dist_dir,\n                *arbitrary_args,\n            ]\n            with no_install_setup_requires():\n                self.run_setup()\n\n            result_basename = _file_with_extension(tmp_dist_dir, result_extension)\n            result_path = os.path.join(result_directory, result_basename)\n            if os.path.exists(result_path):\n                # os.rename will fail overwriting on non-Unix.\n                os.remove(result_path)\n            os.rename(os.path.join(tmp_dist_dir, result_basename), result_path)\n\n        return result_basename\n\n    def build_wheel(\n        self,\n        wheel_directory: StrPath,\n        config_settings: _ConfigSettings = None,\n        metadata_directory: StrPath | None = None,\n    ):\n        with suppress_known_deprecation():\n            return self._build_with_temp_dir(\n                ['bdist_wheel'],\n                '.whl',\n                wheel_directory,\n                config_settings,\n                self._arbitrary_args(config_settings),\n            )\n\n    def build_sdist(\n        self, sdist_directory: StrPath, config_settings: _ConfigSettings = None\n    ):\n        return self._build_with_temp_dir(\n            ['sdist', '--formats', 'gztar'], '.tar.gz', sdist_directory, config_settings\n        )\n\n    def _get_dist_info_dir(self, metadata_directory: StrPath | None) -> str | None:\n        if not metadata_directory:\n            return None\n        dist_info_candidates = list(Path(metadata_directory).glob(\"*.dist-info\"))\n        assert len(dist_info_candidates) <= 1\n        return str(dist_info_candidates[0]) if dist_info_candidates else None\n\n    if not LEGACY_EDITABLE:\n        # PEP660 hooks:\n        # build_editable\n        # get_requires_for_build_editable\n        # prepare_metadata_for_build_editable\n        def build_editable(\n            self,\n            wheel_directory: StrPath,\n            config_settings: _ConfigSettings = None,\n            metadata_directory: str | None = None,\n        ):\n            # XXX can or should we hide our editable_wheel command normally?\n            info_dir = self._get_dist_info_dir(metadata_directory)\n            opts = [\"--dist-info-dir\", info_dir] if info_dir else []\n            cmd = [\"editable_wheel\", *opts, *self._editable_args(config_settings)]\n            with suppress_known_deprecation():\n                return self._build_with_temp_dir(\n                    cmd, \".whl\", wheel_directory, config_settings\n                )\n\n        def get_requires_for_build_editable(self, config_settings=None):\n            return self.get_requires_for_build_wheel(config_settings)\n\n        def prepare_metadata_for_build_editable(\n            self, metadata_directory, config_settings=None\n        ):\n            return self.prepare_metadata_for_build_wheel(\n                metadata_directory, config_settings\n            )\n\n\nclass _BuildMetaLegacyBackend(_BuildMetaBackend):\n    \"\"\"Compatibility backend for setuptools\n\n    This is a version of setuptools.build_meta that endeavors\n    to maintain backwards\n    compatibility with pre-PEP 517 modes of invocation. It\n    exists as a temporary\n    bridge between the old packaging mechanism and the new\n    packaging mechanism,\n    and will eventually be removed.\n    \"\"\"\n\n    def run_setup(self, setup_script='setup.py'):\n        # In order to maintain compatibility with scripts assuming that\n        # the setup.py script is in a directory on the PYTHONPATH, inject\n        # '' into sys.path. (pypa/setuptools#1642)\n        sys_path = list(sys.path)  # Save the original path\n\n        script_dir = os.path.dirname(os.path.abspath(setup_script))\n        if script_dir not in sys.path:\n            sys.path.insert(0, script_dir)\n\n        # Some setup.py scripts (e.g. in pygame and numpy) use sys.argv[0] to\n        # get the directory of the source code. They expect it to refer to the\n        # setup.py script.\n        sys_argv_0 = sys.argv[0]\n        sys.argv[0] = setup_script\n\n        try:\n            super().run_setup(setup_script=setup_script)\n        finally:\n            # While PEP 517 frontends should be calling each hook in a fresh\n            # subprocess according to the standard (and thus it should not be\n            # strictly necessary to restore the old sys.path), we'll restore\n            # the original path so that the path manipulation does not persist\n            # within the hook after run_setup is called.\n            sys.path[:] = sys_path\n            sys.argv[0] = sys_argv_0\n\n\n# The primary backend\n_BACKEND = _BuildMetaBackend()\n\nget_requires_for_build_wheel = _BACKEND.get_requires_for_build_wheel\nget_requires_for_build_sdist = _BACKEND.get_requires_for_build_sdist\nprepare_metadata_for_build_wheel = _BACKEND.prepare_metadata_for_build_wheel\nbuild_wheel = _BACKEND.build_wheel\nbuild_sdist = _BACKEND.build_sdist\n\nif not LEGACY_EDITABLE:\n    get_requires_for_build_editable = _BACKEND.get_requires_for_build_editable\n    prepare_metadata_for_build_editable = _BACKEND.prepare_metadata_for_build_editable\n    build_editable = _BACKEND.build_editable\n\n\n# The legacy backend\n__legacy__ = _BuildMetaLegacyBackend()\n", "setuptools/unicode_utils.py": "import unicodedata\nimport sys\nfrom configparser import ConfigParser\n\nfrom .compat import py39\nfrom .warnings import SetuptoolsDeprecationWarning\n\n\n# HFS Plus uses decomposed UTF-8\ndef decompose(path):\n    if isinstance(path, str):\n        return unicodedata.normalize('NFD', path)\n    try:\n        path = path.decode('utf-8')\n        path = unicodedata.normalize('NFD', path)\n        path = path.encode('utf-8')\n    except UnicodeError:\n        pass  # Not UTF-8\n    return path\n\n\ndef filesys_decode(path):\n    \"\"\"\n    Ensure that the given path is decoded,\n    ``None`` when no expected encoding works\n    \"\"\"\n\n    if isinstance(path, str):\n        return path\n\n    fs_enc = sys.getfilesystemencoding() or 'utf-8'\n    candidates = fs_enc, 'utf-8'\n\n    for enc in candidates:\n        try:\n            return path.decode(enc)\n        except UnicodeDecodeError:\n            continue\n\n    return None\n\n\ndef try_encode(string, enc):\n    \"turn unicode encoding into a functional routine\"\n    try:\n        return string.encode(enc)\n    except UnicodeEncodeError:\n        return None\n\n\ndef _read_utf8_with_fallback(file: str, fallback_encoding=py39.LOCALE_ENCODING) -> str:\n    \"\"\"\n    First try to read the file with UTF-8, if there is an error fallback to a\n    different encoding (\"locale\" by default). Returns the content of the file.\n    Also useful when reading files that might have been produced by an older version of\n    setuptools.\n    \"\"\"\n    try:\n        with open(file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n    except UnicodeDecodeError:  # pragma: no cover\n        _Utf8EncodingNeeded.emit(file=file, fallback_encoding=fallback_encoding)\n        with open(file, \"r\", encoding=fallback_encoding) as f:\n            return f.read()\n\n\ndef _cfg_read_utf8_with_fallback(\n    cfg: ConfigParser, file: str, fallback_encoding=py39.LOCALE_ENCODING\n) -> None:\n    \"\"\"Same idea as :func:`_read_utf8_with_fallback`, but for the\n    :meth:`ConfigParser.read` method.\n\n    This method may call ``cfg.clear()``.\n    \"\"\"\n    try:\n        cfg.read(file, encoding=\"utf-8\")\n    except UnicodeDecodeError:  # pragma: no cover\n        _Utf8EncodingNeeded.emit(file=file, fallback_encoding=fallback_encoding)\n        cfg.clear()\n        cfg.read(file, encoding=fallback_encoding)\n\n\nclass _Utf8EncodingNeeded(SetuptoolsDeprecationWarning):\n    _SUMMARY = \"\"\"\n    `encoding=\"utf-8\"` fails with {file!r}, trying `encoding={fallback_encoding!r}`.\n    \"\"\"\n\n    _DETAILS = \"\"\"\n    Fallback behaviour for UTF-8 is considered **deprecated** and future versions of\n    `setuptools` may not implement it.\n\n    Please encode {file!r} with \"utf-8\" to ensure future builds will succeed.\n\n    If this file was produced by `setuptools` itself, cleaning up the cached files\n    and re-building/re-installing the package with a newer version of `setuptools`\n    (e.g. by updating `build-system.requires` in its `pyproject.toml`)\n    might solve the problem.\n    \"\"\"\n    # TODO: Add a deadline?\n    #       Will we be able to remove this?\n    #       The question comes to mind mainly because of sdists that have been produced\n    #       by old versions of setuptools and published to PyPI...\n", "setuptools/_importlib.py": "import sys\n\n\ndef disable_importlib_metadata_finder(metadata):\n    \"\"\"\n    Ensure importlib_metadata doesn't provide older, incompatible\n    Distributions.\n\n    Workaround for #3102.\n    \"\"\"\n    try:\n        import importlib_metadata\n    except ImportError:\n        return\n    except AttributeError:\n        from .warnings import SetuptoolsWarning\n\n        SetuptoolsWarning.emit(\n            \"Incompatibility problem.\",\n            \"\"\"\n            `importlib-metadata` version is incompatible with `setuptools`.\n            This problem is likely to be solved by installing an updated version of\n            `importlib-metadata`.\n            \"\"\",\n            see_url=\"https://github.com/python/importlib_metadata/issues/396\",\n        )  # Ensure a descriptive message is shown.\n        raise  # This exception can be suppressed by _distutils_hack\n\n    if importlib_metadata is metadata:\n        return\n    to_remove = [\n        ob\n        for ob in sys.meta_path\n        if isinstance(ob, importlib_metadata.MetadataPathFinder)\n    ]\n    for item in to_remove:\n        sys.meta_path.remove(item)\n\n\nif sys.version_info < (3, 10):\n    from setuptools.extern import importlib_metadata as metadata\n\n    disable_importlib_metadata_finder(metadata)\nelse:\n    import importlib.metadata as metadata  # noqa: F401\n\n\nif sys.version_info < (3, 9):\n    from setuptools.extern import importlib_resources as resources\nelse:\n    import importlib.resources as resources  # noqa: F401\n", "setuptools/namespaces.py": "import os\nfrom distutils import log\nimport itertools\n\nfrom .compat import py39\n\n\nflatten = itertools.chain.from_iterable\n\n\nclass Installer:\n    nspkg_ext = '-nspkg.pth'\n\n    def install_namespaces(self):\n        nsp = self._get_all_ns_packages()\n        if not nsp:\n            return\n        filename = self._get_nspkg_file()\n        self.outputs.append(filename)\n        log.info(\"Installing %s\", filename)\n        lines = map(self._gen_nspkg_line, nsp)\n\n        if self.dry_run:\n            # always generate the lines, even in dry run\n            list(lines)\n            return\n\n        with open(filename, 'wt', encoding=py39.LOCALE_ENCODING) as f:\n            # Requires encoding=\"locale\" instead of \"utf-8\" (python/cpython#77102).\n            f.writelines(lines)\n\n    def uninstall_namespaces(self):\n        filename = self._get_nspkg_file()\n        if not os.path.exists(filename):\n            return\n        log.info(\"Removing %s\", filename)\n        os.remove(filename)\n\n    def _get_nspkg_file(self):\n        filename, _ = os.path.splitext(self._get_target())\n        return filename + self.nspkg_ext\n\n    def _get_target(self):\n        return self.target\n\n    _nspkg_tmpl = (\n        \"import sys, types, os\",\n        \"p = os.path.join(%(root)s, *%(pth)r)\",\n        \"importlib = __import__('importlib.util')\",\n        \"__import__('importlib.machinery')\",\n        (\n            \"m = \"\n            \"sys.modules.setdefault(%(pkg)r, \"\n            \"importlib.util.module_from_spec(\"\n            \"importlib.machinery.PathFinder.find_spec(%(pkg)r, \"\n            \"[os.path.dirname(p)])))\"\n        ),\n        (\"m = m or \" \"sys.modules.setdefault(%(pkg)r, types.ModuleType(%(pkg)r))\"),\n        \"mp = (m or []) and m.__dict__.setdefault('__path__',[])\",\n        \"(p not in mp) and mp.append(p)\",\n    )\n    \"lines for the namespace installer\"\n\n    _nspkg_tmpl_multi = ('m and setattr(sys.modules[%(parent)r], %(child)r, m)',)\n    \"additional line(s) when a parent package is indicated\"\n\n    def _get_root(self):\n        return \"sys._getframe(1).f_locals['sitedir']\"\n\n    def _gen_nspkg_line(self, pkg):\n        pth = tuple(pkg.split('.'))\n        root = self._get_root()\n        tmpl_lines = self._nspkg_tmpl\n        parent, sep, child = pkg.rpartition('.')\n        if parent:\n            tmpl_lines += self._nspkg_tmpl_multi\n        return ';'.join(tmpl_lines) % locals() + '\\n'\n\n    def _get_all_ns_packages(self):\n        \"\"\"Return sorted list of all package namespaces\"\"\"\n        pkgs = self.distribution.namespace_packages or []\n        return sorted(set(flatten(map(self._pkg_names, pkgs))))\n\n    @staticmethod\n    def _pkg_names(pkg):\n        \"\"\"\n        Given a namespace package, yield the components of that\n        package.\n\n        >>> names = Installer._pkg_names('a.b.c')\n        >>> set(names) == set(['a', 'a.b', 'a.b.c'])\n        True\n        \"\"\"\n        parts = pkg.split('.')\n        while parts:\n            yield '.'.join(parts)\n            parts.pop()\n\n\nclass DevelopInstaller(Installer):\n    def _get_root(self):\n        return repr(str(self.egg_path))\n\n    def _get_target(self):\n        return self.egg_link\n", "setuptools/windows_support.py": "import platform\n\n\ndef windows_only(func):\n    if platform.system() != 'Windows':\n        return lambda *args, **kwargs: None\n    return func\n\n\n@windows_only\ndef hide_file(path):\n    \"\"\"\n    Set the hidden attribute on a file or directory.\n\n    From https://stackoverflow.com/questions/19622133/\n\n    `path` must be text.\n    \"\"\"\n    import ctypes\n\n    __import__('ctypes.wintypes')\n    SetFileAttributes = ctypes.windll.kernel32.SetFileAttributesW\n    SetFileAttributes.argtypes = ctypes.wintypes.LPWSTR, ctypes.wintypes.DWORD\n    SetFileAttributes.restype = ctypes.wintypes.BOOL\n\n    FILE_ATTRIBUTE_HIDDEN = 0x02\n\n    ret = SetFileAttributes(path, FILE_ATTRIBUTE_HIDDEN)\n    if not ret:\n        raise ctypes.WinError()\n", "setuptools/_reqs.py": "from functools import lru_cache\nfrom typing import Callable, Iterable, Iterator, TypeVar, Union, overload\n\nimport setuptools.extern.jaraco.text as text\nfrom setuptools.extern.packaging.requirements import Requirement\n\n_T = TypeVar(\"_T\")\n_StrOrIter = Union[str, Iterable[str]]\n\n\nparse_req: Callable[[str], Requirement] = lru_cache()(Requirement)\n# Setuptools parses the same requirement many times\n# (e.g. first for validation than for normalisation),\n# so it might be worth to cache.\n\n\ndef parse_strings(strs: _StrOrIter) -> Iterator[str]:\n    \"\"\"\n    Yield requirement strings for each specification in `strs`.\n\n    `strs` must be a string, or a (possibly-nested) iterable thereof.\n    \"\"\"\n    return text.join_continuation(map(text.drop_comment, text.yield_lines(strs)))\n\n\n@overload\ndef parse(strs: _StrOrIter) -> Iterator[Requirement]: ...\n\n\n@overload\ndef parse(strs: _StrOrIter, parser: Callable[[str], _T]) -> Iterator[_T]: ...\n\n\ndef parse(strs, parser=parse_req):\n    \"\"\"\n    Replacement for ``pkg_resources.parse_requirements`` that uses ``packaging``.\n    \"\"\"\n    return map(parser, parse_strings(strs))\n", "setuptools/package_index.py": "\"\"\"PyPI and direct package downloading.\"\"\"\n\nimport sys\nimport subprocess\nimport os\nimport re\nimport io\nimport shutil\nimport socket\nimport base64\nimport hashlib\nimport itertools\nimport configparser\nimport html\nimport http.client\nimport urllib.parse\nimport urllib.request\nimport urllib.error\nfrom functools import wraps\n\nimport setuptools\nfrom pkg_resources import (\n    CHECKOUT_DIST,\n    Distribution,\n    BINARY_DIST,\n    normalize_path,\n    SOURCE_DIST,\n    Environment,\n    find_distributions,\n    safe_name,\n    safe_version,\n    to_filename,\n    Requirement,\n    DEVELOP_DIST,\n    EGG_DIST,\n    parse_version,\n)\nfrom distutils import log\nfrom distutils.errors import DistutilsError\nfrom fnmatch import translate\nfrom setuptools.wheel import Wheel\nfrom setuptools.extern.more_itertools import unique_everseen\n\nfrom .unicode_utils import _read_utf8_with_fallback, _cfg_read_utf8_with_fallback\n\n\nEGG_FRAGMENT = re.compile(r'^egg=([-A-Za-z0-9_.+!]+)$')\nHREF = re.compile(r\"\"\"href\\s*=\\s*['\"]?([^'\"> ]+)\"\"\", re.I)\nPYPI_MD5 = re.compile(\n    r'<a href=\"([^\"#]+)\">([^<]+)</a>\\n\\s+\\(<a (?:title=\"MD5 hash\"\\n\\s+)'\n    r'href=\"[^?]+\\?:action=show_md5&amp;digest=([0-9a-f]{32})\">md5</a>\\)'\n)\nURL_SCHEME = re.compile('([-+.a-z0-9]{2,}):', re.I).match\nEXTENSIONS = \".tar.gz .tar.bz2 .tar .zip .tgz\".split()\n\n__all__ = [\n    'PackageIndex',\n    'distros_for_url',\n    'parse_bdist_wininst',\n    'interpret_distro_name',\n]\n\n_SOCKET_TIMEOUT = 15\n\n_tmpl = \"setuptools/{setuptools.__version__} Python-urllib/{py_major}\"\nuser_agent = _tmpl.format(\n    py_major='{}.{}'.format(*sys.version_info), setuptools=setuptools\n)\n\n\ndef parse_requirement_arg(spec):\n    try:\n        return Requirement.parse(spec)\n    except ValueError as e:\n        raise DistutilsError(\n            \"Not a URL, existing file, or requirement spec: %r\" % (spec,)\n        ) from e\n\n\ndef parse_bdist_wininst(name):\n    \"\"\"Return (base,pyversion) or (None,None) for possible .exe name\"\"\"\n\n    lower = name.lower()\n    base, py_ver, plat = None, None, None\n\n    if lower.endswith('.exe'):\n        if lower.endswith('.win32.exe'):\n            base = name[:-10]\n            plat = 'win32'\n        elif lower.startswith('.win32-py', -16):\n            py_ver = name[-7:-4]\n            base = name[:-16]\n            plat = 'win32'\n        elif lower.endswith('.win-amd64.exe'):\n            base = name[:-14]\n            plat = 'win-amd64'\n        elif lower.startswith('.win-amd64-py', -20):\n            py_ver = name[-7:-4]\n            base = name[:-20]\n            plat = 'win-amd64'\n    return base, py_ver, plat\n\n\ndef egg_info_for_url(url):\n    parts = urllib.parse.urlparse(url)\n    scheme, server, path, parameters, query, fragment = parts\n    base = urllib.parse.unquote(path.split('/')[-1])\n    if server == 'sourceforge.net' and base == 'download':  # XXX Yuck\n        base = urllib.parse.unquote(path.split('/')[-2])\n    if '#' in base:\n        base, fragment = base.split('#', 1)\n    return base, fragment\n\n\ndef distros_for_url(url, metadata=None):\n    \"\"\"Yield egg or source distribution objects that might be found at a URL\"\"\"\n    base, fragment = egg_info_for_url(url)\n    yield from distros_for_location(url, base, metadata)\n    if fragment:\n        match = EGG_FRAGMENT.match(fragment)\n        if match:\n            yield from interpret_distro_name(\n                url, match.group(1), metadata, precedence=CHECKOUT_DIST\n            )\n\n\ndef distros_for_location(location, basename, metadata=None):\n    \"\"\"Yield egg or source distribution objects based on basename\"\"\"\n    if basename.endswith('.egg.zip'):\n        basename = basename[:-4]  # strip the .zip\n    if basename.endswith('.egg') and '-' in basename:\n        # only one, unambiguous interpretation\n        return [Distribution.from_location(location, basename, metadata)]\n    if basename.endswith('.whl') and '-' in basename:\n        wheel = Wheel(basename)\n        if not wheel.is_compatible():\n            return []\n        return [\n            Distribution(\n                location=location,\n                project_name=wheel.project_name,\n                version=wheel.version,\n                # Increase priority over eggs.\n                precedence=EGG_DIST + 1,\n            )\n        ]\n    if basename.endswith('.exe'):\n        win_base, py_ver, platform = parse_bdist_wininst(basename)\n        if win_base is not None:\n            return interpret_distro_name(\n                location, win_base, metadata, py_ver, BINARY_DIST, platform\n            )\n    # Try source distro extensions (.zip, .tgz, etc.)\n    #\n    for ext in EXTENSIONS:\n        if basename.endswith(ext):\n            basename = basename[: -len(ext)]\n            return interpret_distro_name(location, basename, metadata)\n    return []  # no extension matched\n\n\ndef distros_for_filename(filename, metadata=None):\n    \"\"\"Yield possible egg or source distribution objects based on a filename\"\"\"\n    return distros_for_location(\n        normalize_path(filename), os.path.basename(filename), metadata\n    )\n\n\ndef interpret_distro_name(\n    location, basename, metadata, py_version=None, precedence=SOURCE_DIST, platform=None\n):\n    \"\"\"Generate the interpretation of a source distro name\n\n    Note: if `location` is a filesystem filename, you should call\n    ``pkg_resources.normalize_path()`` on it before passing it to this\n    routine!\n    \"\"\"\n\n    parts = basename.split('-')\n    if not py_version and any(re.match(r'py\\d\\.\\d$', p) for p in parts[2:]):\n        # it is a bdist_dumb, not an sdist -- bail out\n        return\n\n    # find the pivot (p) that splits the name from the version.\n    # infer the version as the first item that has a digit.\n    for p in range(len(parts)):\n        if parts[p][:1].isdigit():\n            break\n    else:\n        p = len(parts)\n\n    yield Distribution(\n        location,\n        metadata,\n        '-'.join(parts[:p]),\n        '-'.join(parts[p:]),\n        py_version=py_version,\n        precedence=precedence,\n        platform=platform,\n    )\n\n\ndef unique_values(func):\n    \"\"\"\n    Wrap a function returning an iterable such that the resulting iterable\n    only ever yields unique items.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        return unique_everseen(func(*args, **kwargs))\n\n    return wrapper\n\n\nREL = re.compile(r\"\"\"<([^>]*\\srel\\s{0,10}=\\s{0,10}['\"]?([^'\" >]+)[^>]*)>\"\"\", re.I)\n\"\"\"\nRegex for an HTML tag with 'rel=\"val\"' attributes.\n\"\"\"\n\n\n@unique_values\ndef find_external_links(url, page):\n    \"\"\"Find rel=\"homepage\" and rel=\"download\" links in `page`, yielding URLs\"\"\"\n\n    for match in REL.finditer(page):\n        tag, rel = match.groups()\n        rels = set(map(str.strip, rel.lower().split(',')))\n        if 'homepage' in rels or 'download' in rels:\n            for match in HREF.finditer(tag):\n                yield urllib.parse.urljoin(url, htmldecode(match.group(1)))\n\n    for tag in (\"<th>Home Page\", \"<th>Download URL\"):\n        pos = page.find(tag)\n        if pos != -1:\n            match = HREF.search(page, pos)\n            if match:\n                yield urllib.parse.urljoin(url, htmldecode(match.group(1)))\n\n\nclass ContentChecker:\n    \"\"\"\n    A null content checker that defines the interface for checking content\n    \"\"\"\n\n    def feed(self, block):\n        \"\"\"\n        Feed a block of data to the hash.\n        \"\"\"\n        return\n\n    def is_valid(self):\n        \"\"\"\n        Check the hash. Return False if validation fails.\n        \"\"\"\n        return True\n\n    def report(self, reporter, template):\n        \"\"\"\n        Call reporter with information about the checker (hash name)\n        substituted into the template.\n        \"\"\"\n        return\n\n\nclass HashChecker(ContentChecker):\n    pattern = re.compile(\n        r'(?P<hash_name>sha1|sha224|sha384|sha256|sha512|md5)='\n        r'(?P<expected>[a-f0-9]+)'\n    )\n\n    def __init__(self, hash_name, expected):\n        self.hash_name = hash_name\n        self.hash = hashlib.new(hash_name)\n        self.expected = expected\n\n    @classmethod\n    def from_url(cls, url):\n        \"Construct a (possibly null) ContentChecker from a URL\"\n        fragment = urllib.parse.urlparse(url)[-1]\n        if not fragment:\n            return ContentChecker()\n        match = cls.pattern.search(fragment)\n        if not match:\n            return ContentChecker()\n        return cls(**match.groupdict())\n\n    def feed(self, block):\n        self.hash.update(block)\n\n    def is_valid(self):\n        return self.hash.hexdigest() == self.expected\n\n    def report(self, reporter, template):\n        msg = template % self.hash_name\n        return reporter(msg)\n\n\nclass PackageIndex(Environment):\n    \"\"\"A distribution index that scans web pages for download URLs\"\"\"\n\n    def __init__(\n        self,\n        index_url=\"https://pypi.org/simple/\",\n        hosts=('*',),\n        ca_bundle=None,\n        verify_ssl=True,\n        *args,\n        **kw,\n    ):\n        super().__init__(*args, **kw)\n        self.index_url = index_url + \"/\"[: not index_url.endswith('/')]\n        self.scanned_urls = {}\n        self.fetched_urls = {}\n        self.package_pages = {}\n        self.allows = re.compile('|'.join(map(translate, hosts))).match\n        self.to_scan = []\n        self.opener = urllib.request.urlopen\n\n    def add(self, dist):\n        # ignore invalid versions\n        try:\n            parse_version(dist.version)\n        except Exception:\n            return None\n        return super().add(dist)\n\n    # FIXME: 'PackageIndex.process_url' is too complex (14)\n    def process_url(self, url, retrieve=False):  # noqa: C901\n        \"\"\"Evaluate a URL as a possible download, and maybe retrieve it\"\"\"\n        if url in self.scanned_urls and not retrieve:\n            return\n        self.scanned_urls[url] = True\n        if not URL_SCHEME(url):\n            self.process_filename(url)\n            return\n        else:\n            dists = list(distros_for_url(url))\n            if dists:\n                if not self.url_ok(url):\n                    return\n                self.debug(\"Found link: %s\", url)\n\n        if dists or not retrieve or url in self.fetched_urls:\n            list(map(self.add, dists))\n            return  # don't need the actual page\n\n        if not self.url_ok(url):\n            self.fetched_urls[url] = True\n            return\n\n        self.info(\"Reading %s\", url)\n        self.fetched_urls[url] = True  # prevent multiple fetch attempts\n        tmpl = \"Download error on %s: %%s -- Some packages may not be found!\"\n        f = self.open_url(url, tmpl % url)\n        if f is None:\n            return\n        if isinstance(f, urllib.error.HTTPError) and f.code == 401:\n            self.info(\"Authentication error: %s\" % f.msg)\n        self.fetched_urls[f.url] = True\n        if 'html' not in f.headers.get('content-type', '').lower():\n            f.close()  # not html, we can't process it\n            return\n\n        base = f.url  # handle redirects\n        page = f.read()\n        if not isinstance(page, str):\n            # In Python 3 and got bytes but want str.\n            if isinstance(f, urllib.error.HTTPError):\n                # Errors have no charset, assume latin1:\n                charset = 'latin-1'\n            else:\n                charset = f.headers.get_param('charset') or 'latin-1'\n            page = page.decode(charset, \"ignore\")\n        f.close()\n        for match in HREF.finditer(page):\n            link = urllib.parse.urljoin(base, htmldecode(match.group(1)))\n            self.process_url(link)\n        if url.startswith(self.index_url) and getattr(f, 'code', None) != 404:\n            page = self.process_index(url, page)\n\n    def process_filename(self, fn, nested=False):\n        # process filenames or directories\n        if not os.path.exists(fn):\n            self.warn(\"Not found: %s\", fn)\n            return\n\n        if os.path.isdir(fn) and not nested:\n            path = os.path.realpath(fn)\n            for item in os.listdir(path):\n                self.process_filename(os.path.join(path, item), True)\n\n        dists = distros_for_filename(fn)\n        if dists:\n            self.debug(\"Found: %s\", fn)\n            list(map(self.add, dists))\n\n    def url_ok(self, url, fatal=False):\n        s = URL_SCHEME(url)\n        is_file = s and s.group(1).lower() == 'file'\n        if is_file or self.allows(urllib.parse.urlparse(url)[1]):\n            return True\n        msg = (\n            \"\\nNote: Bypassing %s (disallowed host; see \"\n            \"https://setuptools.pypa.io/en/latest/deprecated/\"\n            \"easy_install.html#restricting-downloads-with-allow-hosts for details).\\n\"\n        )\n        if fatal:\n            raise DistutilsError(msg % url)\n        else:\n            self.warn(msg, url)\n            return False\n\n    def scan_egg_links(self, search_path):\n        dirs = filter(os.path.isdir, search_path)\n        egg_links = (\n            (path, entry)\n            for path in dirs\n            for entry in os.listdir(path)\n            if entry.endswith('.egg-link')\n        )\n        list(itertools.starmap(self.scan_egg_link, egg_links))\n\n    def scan_egg_link(self, path, entry):\n        content = _read_utf8_with_fallback(os.path.join(path, entry))\n        # filter non-empty lines\n        lines = list(filter(None, map(str.strip, content.splitlines())))\n\n        if len(lines) != 2:\n            # format is not recognized; punt\n            return\n\n        egg_path, setup_path = lines\n\n        for dist in find_distributions(os.path.join(path, egg_path)):\n            dist.location = os.path.join(path, *lines)\n            dist.precedence = SOURCE_DIST\n            self.add(dist)\n\n    def _scan(self, link):\n        # Process a URL to see if it's for a package page\n        NO_MATCH_SENTINEL = None, None\n        if not link.startswith(self.index_url):\n            return NO_MATCH_SENTINEL\n\n        parts = list(map(urllib.parse.unquote, link[len(self.index_url) :].split('/')))\n        if len(parts) != 2 or '#' in parts[1]:\n            return NO_MATCH_SENTINEL\n\n        # it's a package page, sanitize and index it\n        pkg = safe_name(parts[0])\n        ver = safe_version(parts[1])\n        self.package_pages.setdefault(pkg.lower(), {})[link] = True\n        return to_filename(pkg), to_filename(ver)\n\n    def process_index(self, url, page):\n        \"\"\"Process the contents of a PyPI page\"\"\"\n\n        # process an index page into the package-page index\n        for match in HREF.finditer(page):\n            try:\n                self._scan(urllib.parse.urljoin(url, htmldecode(match.group(1))))\n            except ValueError:\n                pass\n\n        pkg, ver = self._scan(url)  # ensure this page is in the page index\n        if not pkg:\n            return \"\"  # no sense double-scanning non-package pages\n\n        # process individual package page\n        for new_url in find_external_links(url, page):\n            # Process the found URL\n            base, frag = egg_info_for_url(new_url)\n            if base.endswith('.py') and not frag:\n                if ver:\n                    new_url += '#egg=%s-%s' % (pkg, ver)\n                else:\n                    self.need_version_info(url)\n            self.scan_url(new_url)\n\n        return PYPI_MD5.sub(\n            lambda m: '<a href=\"%s#md5=%s\">%s</a>' % m.group(1, 3, 2), page\n        )\n\n    def need_version_info(self, url):\n        self.scan_all(\n            \"Page at %s links to .py file(s) without version info; an index \"\n            \"scan is required.\",\n            url,\n        )\n\n    def scan_all(self, msg=None, *args):\n        if self.index_url not in self.fetched_urls:\n            if msg:\n                self.warn(msg, *args)\n            self.info(\"Scanning index of all packages (this may take a while)\")\n        self.scan_url(self.index_url)\n\n    def find_packages(self, requirement):\n        self.scan_url(self.index_url + requirement.unsafe_name + '/')\n\n        if not self.package_pages.get(requirement.key):\n            # Fall back to safe version of the name\n            self.scan_url(self.index_url + requirement.project_name + '/')\n\n        if not self.package_pages.get(requirement.key):\n            # We couldn't find the target package, so search the index page too\n            self.not_found_in_index(requirement)\n\n        for url in list(self.package_pages.get(requirement.key, ())):\n            # scan each page that might be related to the desired package\n            self.scan_url(url)\n\n    def obtain(self, requirement, installer=None):\n        self.prescan()\n        self.find_packages(requirement)\n        for dist in self[requirement.key]:\n            if dist in requirement:\n                return dist\n            self.debug(\"%s does not match %s\", requirement, dist)\n        return super().obtain(requirement, installer)\n\n    def check_hash(self, checker, filename, tfp):\n        \"\"\"\n        checker is a ContentChecker\n        \"\"\"\n        checker.report(self.debug, \"Validating %%s checksum for %s\" % filename)\n        if not checker.is_valid():\n            tfp.close()\n            os.unlink(filename)\n            raise DistutilsError(\n                \"%s validation failed for %s; \"\n                \"possible download problem?\"\n                % (checker.hash.name, os.path.basename(filename))\n            )\n\n    def add_find_links(self, urls):\n        \"\"\"Add `urls` to the list that will be prescanned for searches\"\"\"\n        for url in urls:\n            if (\n                self.to_scan is None  # if we have already \"gone online\"\n                or not URL_SCHEME(url)  # or it's a local file/directory\n                or url.startswith('file:')\n                or list(distros_for_url(url))  # or a direct package link\n            ):\n                # then go ahead and process it now\n                self.scan_url(url)\n            else:\n                # otherwise, defer retrieval till later\n                self.to_scan.append(url)\n\n    def prescan(self):\n        \"\"\"Scan urls scheduled for prescanning (e.g. --find-links)\"\"\"\n        if self.to_scan:\n            list(map(self.scan_url, self.to_scan))\n        self.to_scan = None  # from now on, go ahead and process immediately\n\n    def not_found_in_index(self, requirement):\n        if self[requirement.key]:  # we've seen at least one distro\n            meth, msg = self.info, \"Couldn't retrieve index page for %r\"\n        else:  # no distros seen for this name, might be misspelled\n            meth, msg = (\n                self.warn,\n                \"Couldn't find index page for %r (maybe misspelled?)\",\n            )\n        meth(msg, requirement.unsafe_name)\n        self.scan_all()\n\n    def download(self, spec, tmpdir):\n        \"\"\"Locate and/or download `spec` to `tmpdir`, returning a local path\n\n        `spec` may be a ``Requirement`` object, or a string containing a URL,\n        an existing local filename, or a project/version requirement spec\n        (i.e. the string form of a ``Requirement`` object).  If it is the URL\n        of a .py file with an unambiguous ``#egg=name-version`` tag (i.e., one\n        that escapes ``-`` as ``_`` throughout), a trivial ``setup.py`` is\n        automatically created alongside the downloaded file.\n\n        If `spec` is a ``Requirement`` object or a string containing a\n        project/version requirement spec, this method returns the location of\n        a matching distribution (possibly after downloading it to `tmpdir`).\n        If `spec` is a locally existing file or directory name, it is simply\n        returned unchanged.  If `spec` is a URL, it is downloaded to a subpath\n        of `tmpdir`, and the local filename is returned.  Various errors may be\n        raised if a problem occurs during downloading.\n        \"\"\"\n        if not isinstance(spec, Requirement):\n            scheme = URL_SCHEME(spec)\n            if scheme:\n                # It's a url, download it to tmpdir\n                found = self._download_url(spec, tmpdir)\n                base, fragment = egg_info_for_url(spec)\n                if base.endswith('.py'):\n                    found = self.gen_setup(found, fragment, tmpdir)\n                return found\n            elif os.path.exists(spec):\n                # Existing file or directory, just return it\n                return spec\n            else:\n                spec = parse_requirement_arg(spec)\n        return getattr(self.fetch_distribution(spec, tmpdir), 'location', None)\n\n    def fetch_distribution(  # noqa: C901  # is too complex (14)  # FIXME\n        self,\n        requirement,\n        tmpdir,\n        force_scan=False,\n        source=False,\n        develop_ok=False,\n        local_index=None,\n    ):\n        \"\"\"Obtain a distribution suitable for fulfilling `requirement`\n\n        `requirement` must be a ``pkg_resources.Requirement`` instance.\n        If necessary, or if the `force_scan` flag is set, the requirement is\n        searched for in the (online) package index as well as the locally\n        installed packages.  If a distribution matching `requirement` is found,\n        the returned distribution's ``location`` is the value you would have\n        gotten from calling the ``download()`` method with the matching\n        distribution's URL or filename.  If no matching distribution is found,\n        ``None`` is returned.\n\n        If the `source` flag is set, only source distributions and source\n        checkout links will be considered.  Unless the `develop_ok` flag is\n        set, development and system eggs (i.e., those using the ``.egg-info``\n        format) will be ignored.\n        \"\"\"\n        # process a Requirement\n        self.info(\"Searching for %s\", requirement)\n        skipped = set()\n        dist = None\n\n        def find(req, env=None):\n            if env is None:\n                env = self\n            # Find a matching distribution; may be called more than once\n\n            for dist in env[req.key]:\n                if dist.precedence == DEVELOP_DIST and not develop_ok:\n                    if dist not in skipped:\n                        self.warn(\n                            \"Skipping development or system egg: %s\",\n                            dist,\n                        )\n                        skipped.add(dist)\n                    continue\n\n                test = dist in req and (dist.precedence <= SOURCE_DIST or not source)\n                if test:\n                    loc = self.download(dist.location, tmpdir)\n                    dist.download_location = loc\n                    if os.path.exists(dist.download_location):\n                        return dist\n\n            return None\n\n        if force_scan:\n            self.prescan()\n            self.find_packages(requirement)\n            dist = find(requirement)\n\n        if not dist and local_index is not None:\n            dist = find(requirement, local_index)\n\n        if dist is None:\n            if self.to_scan is not None:\n                self.prescan()\n            dist = find(requirement)\n\n        if dist is None and not force_scan:\n            self.find_packages(requirement)\n            dist = find(requirement)\n\n        if dist is None:\n            self.warn(\n                \"No local packages or working download links found for %s%s\",\n                (source and \"a source distribution of \" or \"\"),\n                requirement,\n            )\n            return None\n        else:\n            self.info(\"Best match: %s\", dist)\n            return dist.clone(location=dist.download_location)\n\n    def fetch(self, requirement, tmpdir, force_scan=False, source=False):\n        \"\"\"Obtain a file suitable for fulfilling `requirement`\n\n        DEPRECATED; use the ``fetch_distribution()`` method now instead.  For\n        backward compatibility, this routine is identical but returns the\n        ``location`` of the downloaded distribution instead of a distribution\n        object.\n        \"\"\"\n        dist = self.fetch_distribution(requirement, tmpdir, force_scan, source)\n        if dist is not None:\n            return dist.location\n        return None\n\n    def gen_setup(self, filename, fragment, tmpdir):\n        match = EGG_FRAGMENT.match(fragment)\n        dists = (\n            match\n            and [\n                d\n                for d in interpret_distro_name(filename, match.group(1), None)\n                if d.version\n            ]\n            or []\n        )\n\n        if len(dists) == 1:  # unambiguous ``#egg`` fragment\n            basename = os.path.basename(filename)\n\n            # Make sure the file has been downloaded to the temp dir.\n            if os.path.dirname(filename) != tmpdir:\n                dst = os.path.join(tmpdir, basename)\n                if not (os.path.exists(dst) and os.path.samefile(filename, dst)):\n                    shutil.copy2(filename, dst)\n                    filename = dst\n\n            with open(os.path.join(tmpdir, 'setup.py'), 'w', encoding=\"utf-8\") as file:\n                file.write(\n                    \"from setuptools import setup\\n\"\n                    \"setup(name=%r, version=%r, py_modules=[%r])\\n\"\n                    % (\n                        dists[0].project_name,\n                        dists[0].version,\n                        os.path.splitext(basename)[0],\n                    )\n                )\n            return filename\n\n        elif match:\n            raise DistutilsError(\n                \"Can't unambiguously interpret project/version identifier %r; \"\n                \"any dashes in the name or version should be escaped using \"\n                \"underscores. %r\" % (fragment, dists)\n            )\n        else:\n            raise DistutilsError(\n                \"Can't process plain .py files without an '#egg=name-version'\"\n                \" suffix to enable automatic setup script generation.\"\n            )\n\n    dl_blocksize = 8192\n\n    def _download_to(self, url, filename):\n        self.info(\"Downloading %s\", url)\n        # Download the file\n        fp = None\n        try:\n            checker = HashChecker.from_url(url)\n            fp = self.open_url(url)\n            if isinstance(fp, urllib.error.HTTPError):\n                raise DistutilsError(\n                    \"Can't download %s: %s %s\" % (url, fp.code, fp.msg)\n                )\n            headers = fp.info()\n            blocknum = 0\n            bs = self.dl_blocksize\n            size = -1\n            if \"content-length\" in headers:\n                # Some servers return multiple Content-Length headers :(\n                sizes = headers.get_all('Content-Length')\n                size = max(map(int, sizes))\n                self.reporthook(url, filename, blocknum, bs, size)\n            with open(filename, 'wb') as tfp:\n                while True:\n                    block = fp.read(bs)\n                    if block:\n                        checker.feed(block)\n                        tfp.write(block)\n                        blocknum += 1\n                        self.reporthook(url, filename, blocknum, bs, size)\n                    else:\n                        break\n                self.check_hash(checker, filename, tfp)\n            return headers\n        finally:\n            if fp:\n                fp.close()\n\n    def reporthook(self, url, filename, blocknum, blksize, size):\n        pass  # no-op\n\n    # FIXME:\n    def open_url(self, url, warning=None):  # noqa: C901  # is too complex (12)\n        if url.startswith('file:'):\n            return local_open(url)\n        try:\n            return open_with_auth(url, self.opener)\n        except (ValueError, http.client.InvalidURL) as v:\n            msg = ' '.join([str(arg) for arg in v.args])\n            if warning:\n                self.warn(warning, msg)\n            else:\n                raise DistutilsError('%s %s' % (url, msg)) from v\n        except urllib.error.HTTPError as v:\n            return v\n        except urllib.error.URLError as v:\n            if warning:\n                self.warn(warning, v.reason)\n            else:\n                raise DistutilsError(\n                    \"Download error for %s: %s\" % (url, v.reason)\n                ) from v\n        except http.client.BadStatusLine as v:\n            if warning:\n                self.warn(warning, v.line)\n            else:\n                raise DistutilsError(\n                    '%s returned a bad status line. The server might be '\n                    'down, %s' % (url, v.line)\n                ) from v\n        except (http.client.HTTPException, OSError) as v:\n            if warning:\n                self.warn(warning, v)\n            else:\n                raise DistutilsError(\"Download error for %s: %s\" % (url, v)) from v\n\n    def _download_url(self, url, tmpdir):\n        # Determine download filename\n        #\n        name, fragment = egg_info_for_url(url)\n        if name:\n            while '..' in name:\n                name = name.replace('..', '.').replace('\\\\', '_')\n        else:\n            name = \"__downloaded__\"  # default if URL has no path contents\n\n        if name.endswith('.egg.zip'):\n            name = name[:-4]  # strip the extra .zip before download\n\n        filename = os.path.join(tmpdir, name)\n\n        return self._download_vcs(url, filename) or self._download_other(url, filename)\n\n    @staticmethod\n    def _resolve_vcs(url):\n        \"\"\"\n        >>> rvcs = PackageIndex._resolve_vcs\n        >>> rvcs('git+http://foo/bar')\n        'git'\n        >>> rvcs('hg+https://foo/bar')\n        'hg'\n        >>> rvcs('git:myhost')\n        'git'\n        >>> rvcs('hg:myhost')\n        >>> rvcs('http://foo/bar')\n        \"\"\"\n        scheme = urllib.parse.urlsplit(url).scheme\n        pre, sep, post = scheme.partition('+')\n        # svn and git have their own protocol; hg does not\n        allowed = set(['svn', 'git'] + ['hg'] * bool(sep))\n        return next(iter({pre} & allowed), None)\n\n    def _download_vcs(self, url, spec_filename):\n        vcs = self._resolve_vcs(url)\n        if not vcs:\n            return\n        if vcs == 'svn':\n            raise DistutilsError(\n                f\"Invalid config, SVN download is not supported: {url}\"\n            )\n\n        filename, _, _ = spec_filename.partition('#')\n        url, rev = self._vcs_split_rev_from_url(url)\n\n        self.info(f\"Doing {vcs} clone from {url} to {filename}\")\n        subprocess.check_call([vcs, 'clone', '--quiet', url, filename])\n\n        co_commands = dict(\n            git=[vcs, '-C', filename, 'checkout', '--quiet', rev],\n            hg=[vcs, '--cwd', filename, 'up', '-C', '-r', rev, '-q'],\n        )\n        if rev is not None:\n            self.info(f\"Checking out {rev}\")\n            subprocess.check_call(co_commands[vcs])\n\n        return filename\n\n    def _download_other(self, url, filename):\n        scheme = urllib.parse.urlsplit(url).scheme\n        if scheme == 'file':  # pragma: no cover\n            return urllib.request.url2pathname(urllib.parse.urlparse(url).path)\n        # raise error if not allowed\n        self.url_ok(url, True)\n        return self._attempt_download(url, filename)\n\n    def scan_url(self, url):\n        self.process_url(url, True)\n\n    def _attempt_download(self, url, filename):\n        headers = self._download_to(url, filename)\n        if 'html' in headers.get('content-type', '').lower():\n            return self._invalid_download_html(url, headers, filename)\n        else:\n            return filename\n\n    def _invalid_download_html(self, url, headers, filename):\n        os.unlink(filename)\n        raise DistutilsError(f\"Unexpected HTML page found at {url}\")\n\n    @staticmethod\n    def _vcs_split_rev_from_url(url):\n        \"\"\"\n        Given a possible VCS URL, return a clean URL and resolved revision if any.\n\n        >>> vsrfu = PackageIndex._vcs_split_rev_from_url\n        >>> vsrfu('git+https://github.com/pypa/setuptools@v69.0.0#egg-info=setuptools')\n        ('https://github.com/pypa/setuptools', 'v69.0.0')\n        >>> vsrfu('git+https://github.com/pypa/setuptools#egg-info=setuptools')\n        ('https://github.com/pypa/setuptools', None)\n        >>> vsrfu('http://foo/bar')\n        ('http://foo/bar', None)\n        \"\"\"\n        parts = urllib.parse.urlsplit(url)\n\n        clean_scheme = parts.scheme.split('+', 1)[-1]\n\n        # Some fragment identification fails\n        no_fragment_path, _, _ = parts.path.partition('#')\n\n        pre, sep, post = no_fragment_path.rpartition('@')\n        clean_path, rev = (pre, post) if sep else (post, None)\n\n        resolved = parts._replace(\n            scheme=clean_scheme,\n            path=clean_path,\n            # discard the fragment\n            fragment='',\n        ).geturl()\n\n        return resolved, rev\n\n    def debug(self, msg, *args):\n        log.debug(msg, *args)\n\n    def info(self, msg, *args):\n        log.info(msg, *args)\n\n    def warn(self, msg, *args):\n        log.warn(msg, *args)\n\n\n# This pattern matches a character entity reference (a decimal numeric\n# references, a hexadecimal numeric reference, or a named reference).\nentity_sub = re.compile(r'&(#(\\d+|x[\\da-fA-F]+)|[\\w.:-]+);?').sub\n\n\ndef decode_entity(match):\n    what = match.group(0)\n    return html.unescape(what)\n\n\ndef htmldecode(text):\n    \"\"\"\n    Decode HTML entities in the given text.\n\n    >>> htmldecode(\n    ...     'https://../package_name-0.1.2.tar.gz'\n    ...     '?tokena=A&amp;tokenb=B\">package_name-0.1.2.tar.gz')\n    'https://../package_name-0.1.2.tar.gz?tokena=A&tokenb=B\">package_name-0.1.2.tar.gz'\n    \"\"\"\n    return entity_sub(decode_entity, text)\n\n\ndef socket_timeout(timeout=15):\n    def _socket_timeout(func):\n        def _socket_timeout(*args, **kwargs):\n            old_timeout = socket.getdefaulttimeout()\n            socket.setdefaulttimeout(timeout)\n            try:\n                return func(*args, **kwargs)\n            finally:\n                socket.setdefaulttimeout(old_timeout)\n\n        return _socket_timeout\n\n    return _socket_timeout\n\n\ndef _encode_auth(auth):\n    \"\"\"\n    Encode auth from a URL suitable for an HTTP header.\n    >>> str(_encode_auth('username%3Apassword'))\n    'dXNlcm5hbWU6cGFzc3dvcmQ='\n\n    Long auth strings should not cause a newline to be inserted.\n    >>> long_auth = 'username:' + 'password'*10\n    >>> chr(10) in str(_encode_auth(long_auth))\n    False\n    \"\"\"\n    auth_s = urllib.parse.unquote(auth)\n    # convert to bytes\n    auth_bytes = auth_s.encode()\n    encoded_bytes = base64.b64encode(auth_bytes)\n    # convert back to a string\n    encoded = encoded_bytes.decode()\n    # strip the trailing carriage return\n    return encoded.replace('\\n', '')\n\n\nclass Credential:\n    \"\"\"\n    A username/password pair. Use like a namedtuple.\n    \"\"\"\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def __iter__(self):\n        yield self.username\n        yield self.password\n\n    def __str__(self):\n        return '%(username)s:%(password)s' % vars(self)\n\n\nclass PyPIConfig(configparser.RawConfigParser):\n    def __init__(self):\n        \"\"\"\n        Load from ~/.pypirc\n        \"\"\"\n        defaults = dict.fromkeys(['username', 'password', 'repository'], '')\n        super().__init__(defaults)\n\n        rc = os.path.join(os.path.expanduser('~'), '.pypirc')\n        if os.path.exists(rc):\n            _cfg_read_utf8_with_fallback(self, rc)\n\n    @property\n    def creds_by_repository(self):\n        sections_with_repositories = [\n            section\n            for section in self.sections()\n            if self.get(section, 'repository').strip()\n        ]\n\n        return dict(map(self._get_repo_cred, sections_with_repositories))\n\n    def _get_repo_cred(self, section):\n        repo = self.get(section, 'repository').strip()\n        return repo, Credential(\n            self.get(section, 'username').strip(),\n            self.get(section, 'password').strip(),\n        )\n\n    def find_credential(self, url):\n        \"\"\"\n        If the URL indicated appears to be a repository defined in this\n        config, return the credential for that repository.\n        \"\"\"\n        for repository, cred in self.creds_by_repository.items():\n            if url.startswith(repository):\n                return cred\n        return None\n\n\ndef open_with_auth(url, opener=urllib.request.urlopen):\n    \"\"\"Open a urllib2 request, handling HTTP authentication\"\"\"\n\n    parsed = urllib.parse.urlparse(url)\n    scheme, netloc, path, params, query, frag = parsed\n\n    # Double scheme does not raise on macOS as revealed by a\n    # failing test. We would expect \"nonnumeric port\". Refs #20.\n    if netloc.endswith(':'):\n        raise http.client.InvalidURL(\"nonnumeric port: ''\")\n\n    if scheme in ('http', 'https'):\n        auth, address = _splituser(netloc)\n    else:\n        auth = None\n\n    if not auth:\n        cred = PyPIConfig().find_credential(url)\n        if cred:\n            auth = str(cred)\n            info = cred.username, url\n            log.info('Authenticating as %s for %s (from .pypirc)', *info)\n\n    if auth:\n        auth = \"Basic \" + _encode_auth(auth)\n        parts = scheme, address, path, params, query, frag\n        new_url = urllib.parse.urlunparse(parts)\n        request = urllib.request.Request(new_url)\n        request.add_header(\"Authorization\", auth)\n    else:\n        request = urllib.request.Request(url)\n\n    request.add_header('User-Agent', user_agent)\n    fp = opener(request)\n\n    if auth:\n        # Put authentication info back into request URL if same host,\n        # so that links found on the page will work\n        s2, h2, path2, param2, query2, frag2 = urllib.parse.urlparse(fp.url)\n        if s2 == scheme and h2 == address:\n            parts = s2, netloc, path2, param2, query2, frag2\n            fp.url = urllib.parse.urlunparse(parts)\n\n    return fp\n\n\n# copy of urllib.parse._splituser from Python 3.8\ndef _splituser(host):\n    \"\"\"splituser('user[:passwd]@host[:port]')\n    --> 'user[:passwd]', 'host[:port]'.\"\"\"\n    user, delim, host = host.rpartition('@')\n    return (user if delim else None), host\n\n\n# adding a timeout to avoid freezing package_index\nopen_with_auth = socket_timeout(_SOCKET_TIMEOUT)(open_with_auth)\n\n\ndef fix_sf_url(url):\n    return url  # backward compatibility\n\n\ndef local_open(url):\n    \"\"\"Read a local path, with special support for directories\"\"\"\n    scheme, server, path, param, query, frag = urllib.parse.urlparse(url)\n    filename = urllib.request.url2pathname(path)\n    if os.path.isfile(filename):\n        return urllib.request.urlopen(url)\n    elif path.endswith('/') and os.path.isdir(filename):\n        files = []\n        for f in os.listdir(filename):\n            filepath = os.path.join(filename, f)\n            if f == 'index.html':\n                body = _read_utf8_with_fallback(filepath)\n                break\n            elif os.path.isdir(filepath):\n                f += '/'\n            files.append('<a href=\"{name}\">{name}</a>'.format(name=f))\n        else:\n            tmpl = (\n                \"<html><head><title>{url}</title>\" \"</head><body>{files}</body></html>\"\n            )\n            body = tmpl.format(url=url, files='\\n'.join(files))\n        status, message = 200, \"OK\"\n    else:\n        status, message, body = 404, \"Path not found\", \"Not found\"\n\n    headers = {'content-type': 'text/html'}\n    body_stream = io.StringIO(body)\n    return urllib.error.HTTPError(url, status, message, headers, body_stream)\n", "setuptools/compat/py310.py": "import sys\n\n\n__all__ = ['tomllib']\n\n\nif sys.version_info >= (3, 11):\n    import tomllib\nelse:  # pragma: no cover\n    from setuptools.extern import tomli as tomllib\n", "setuptools/compat/py39.py": "import sys\n\n# Explicitly use the ``\"locale\"`` encoding in versions that support it,\n# otherwise just rely on the implicit handling of ``encoding=None``.\n# Since all platforms that support ``EncodingWarning`` also support\n# ``encoding=\"locale\"``, this can be used to suppress the warning.\n# However, please try to use UTF-8 when possible\n# (.pth files are the notorious exception: python/cpython#77102, pypa/setuptools#3937).\nLOCALE_ENCODING = \"locale\" if sys.version_info >= (3, 10) else None\n", "setuptools/compat/__init__.py": "", "setuptools/compat/py311.py": "from __future__ import annotations\n\nimport shutil\nimport sys\nfrom typing import Any, Callable, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from _typeshed import StrOrBytesPath, ExcInfo\n\n# Same as shutil._OnExcCallback from typeshed\n_OnExcCallback = Callable[[Callable[..., Any], str, BaseException], object]\n\n\ndef shutil_rmtree(\n    path: StrOrBytesPath,\n    ignore_errors: bool = False,\n    onexc: _OnExcCallback | None = None,\n) -> None:\n    if sys.version_info >= (3, 12):\n        return shutil.rmtree(path, ignore_errors, onexc=onexc)\n\n    def _handler(fn: Callable[..., Any], path: str, excinfo: ExcInfo) -> None:\n        if onexc:\n            onexc(fn, path, excinfo[1])\n\n    return shutil.rmtree(path, ignore_errors, onerror=_handler)\n", "setuptools/_vendor/ordered_set.py": "\"\"\"\nAn OrderedSet is a custom MutableSet that remembers its order, so that every\nentry has an index that can be looked up.\n\nBased on a recipe originally posted to ActiveState Recipes by Raymond Hettiger,\nand released under the MIT license.\n\"\"\"\nimport itertools as it\nfrom collections import deque\n\ntry:\n    # Python 3\n    from collections.abc import MutableSet, Sequence\nexcept ImportError:\n    # Python 2.7\n    from collections import MutableSet, Sequence\n\nSLICE_ALL = slice(None)\n__version__ = \"3.1\"\n\n\ndef is_iterable(obj):\n    \"\"\"\n    Are we being asked to look up a list of things, instead of a single thing?\n    We check for the `__iter__` attribute so that this can cover types that\n    don't have to be known by this module, such as NumPy arrays.\n\n    Strings, however, should be considered as atomic values to look up, not\n    iterables. The same goes for tuples, since they are immutable and therefore\n    valid entries.\n\n    We don't need to check for the Python 2 `unicode` type, because it doesn't\n    have an `__iter__` attribute anyway.\n    \"\"\"\n    return (\n        hasattr(obj, \"__iter__\")\n        and not isinstance(obj, str)\n        and not isinstance(obj, tuple)\n    )\n\n\nclass OrderedSet(MutableSet, Sequence):\n    \"\"\"\n    An OrderedSet is a custom MutableSet that remembers its order, so that\n    every entry has an index that can be looked up.\n\n    Example:\n        >>> OrderedSet([1, 1, 2, 3, 2])\n        OrderedSet([1, 2, 3])\n    \"\"\"\n\n    def __init__(self, iterable=None):\n        self.items = []\n        self.map = {}\n        if iterable is not None:\n            self |= iterable\n\n    def __len__(self):\n        \"\"\"\n        Returns the number of unique elements in the ordered set\n\n        Example:\n            >>> len(OrderedSet([]))\n            0\n            >>> len(OrderedSet([1, 2]))\n            2\n        \"\"\"\n        return len(self.items)\n\n    def __getitem__(self, index):\n        \"\"\"\n        Get the item at a given index.\n\n        If `index` is a slice, you will get back that slice of items, as a\n        new OrderedSet.\n\n        If `index` is a list or a similar iterable, you'll get a list of\n        items corresponding to those indices. This is similar to NumPy's\n        \"fancy indexing\". The result is not an OrderedSet because you may ask\n        for duplicate indices, and the number of elements returned should be\n        the number of elements asked for.\n\n        Example:\n            >>> oset = OrderedSet([1, 2, 3])\n            >>> oset[1]\n            2\n        \"\"\"\n        if isinstance(index, slice) and index == SLICE_ALL:\n            return self.copy()\n        elif is_iterable(index):\n            return [self.items[i] for i in index]\n        elif hasattr(index, \"__index__\") or isinstance(index, slice):\n            result = self.items[index]\n            if isinstance(result, list):\n                return self.__class__(result)\n            else:\n                return result\n        else:\n            raise TypeError(\"Don't know how to index an OrderedSet by %r\" % index)\n\n    def copy(self):\n        \"\"\"\n        Return a shallow copy of this object.\n\n        Example:\n            >>> this = OrderedSet([1, 2, 3])\n            >>> other = this.copy()\n            >>> this == other\n            True\n            >>> this is other\n            False\n        \"\"\"\n        return self.__class__(self)\n\n    def __getstate__(self):\n        if len(self) == 0:\n            # The state can't be an empty list.\n            # We need to return a truthy value, or else __setstate__ won't be run.\n            #\n            # This could have been done more gracefully by always putting the state\n            # in a tuple, but this way is backwards- and forwards- compatible with\n            # previous versions of OrderedSet.\n            return (None,)\n        else:\n            return list(self)\n\n    def __setstate__(self, state):\n        if state == (None,):\n            self.__init__([])\n        else:\n            self.__init__(state)\n\n    def __contains__(self, key):\n        \"\"\"\n        Test if the item is in this ordered set\n\n        Example:\n            >>> 1 in OrderedSet([1, 3, 2])\n            True\n            >>> 5 in OrderedSet([1, 3, 2])\n            False\n        \"\"\"\n        return key in self.map\n\n    def add(self, key):\n        \"\"\"\n        Add `key` as an item to this OrderedSet, then return its index.\n\n        If `key` is already in the OrderedSet, return the index it already\n        had.\n\n        Example:\n            >>> oset = OrderedSet()\n            >>> oset.append(3)\n            0\n            >>> print(oset)\n            OrderedSet([3])\n        \"\"\"\n        if key not in self.map:\n            self.map[key] = len(self.items)\n            self.items.append(key)\n        return self.map[key]\n\n    append = add\n\n    def update(self, sequence):\n        \"\"\"\n        Update the set with the given iterable sequence, then return the index\n        of the last element inserted.\n\n        Example:\n            >>> oset = OrderedSet([1, 2, 3])\n            >>> oset.update([3, 1, 5, 1, 4])\n            4\n            >>> print(oset)\n            OrderedSet([1, 2, 3, 5, 4])\n        \"\"\"\n        item_index = None\n        try:\n            for item in sequence:\n                item_index = self.add(item)\n        except TypeError:\n            raise ValueError(\n                \"Argument needs to be an iterable, got %s\" % type(sequence)\n            )\n        return item_index\n\n    def index(self, key):\n        \"\"\"\n        Get the index of a given entry, raising an IndexError if it's not\n        present.\n\n        `key` can be an iterable of entries that is not a string, in which case\n        this returns a list of indices.\n\n        Example:\n            >>> oset = OrderedSet([1, 2, 3])\n            >>> oset.index(2)\n            1\n        \"\"\"\n        if is_iterable(key):\n            return [self.index(subkey) for subkey in key]\n        return self.map[key]\n\n    # Provide some compatibility with pd.Index\n    get_loc = index\n    get_indexer = index\n\n    def pop(self):\n        \"\"\"\n        Remove and return the last element from the set.\n\n        Raises KeyError if the set is empty.\n\n        Example:\n            >>> oset = OrderedSet([1, 2, 3])\n            >>> oset.pop()\n            3\n        \"\"\"\n        if not self.items:\n            raise KeyError(\"Set is empty\")\n\n        elem = self.items[-1]\n        del self.items[-1]\n        del self.map[elem]\n        return elem\n\n    def discard(self, key):\n        \"\"\"\n        Remove an element.  Do not raise an exception if absent.\n\n        The MutableSet mixin uses this to implement the .remove() method, which\n        *does* raise an error when asked to remove a non-existent item.\n\n        Example:\n            >>> oset = OrderedSet([1, 2, 3])\n            >>> oset.discard(2)\n            >>> print(oset)\n            OrderedSet([1, 3])\n            >>> oset.discard(2)\n            >>> print(oset)\n            OrderedSet([1, 3])\n        \"\"\"\n        if key in self:\n            i = self.map[key]\n            del self.items[i]\n            del self.map[key]\n            for k, v in self.map.items():\n                if v >= i:\n                    self.map[k] = v - 1\n\n    def clear(self):\n        \"\"\"\n        Remove all items from this OrderedSet.\n        \"\"\"\n        del self.items[:]\n        self.map.clear()\n\n    def __iter__(self):\n        \"\"\"\n        Example:\n            >>> list(iter(OrderedSet([1, 2, 3])))\n            [1, 2, 3]\n        \"\"\"\n        return iter(self.items)\n\n    def __reversed__(self):\n        \"\"\"\n        Example:\n            >>> list(reversed(OrderedSet([1, 2, 3])))\n            [3, 2, 1]\n        \"\"\"\n        return reversed(self.items)\n\n    def __repr__(self):\n        if not self:\n            return \"%s()\" % (self.__class__.__name__,)\n        return \"%s(%r)\" % (self.__class__.__name__, list(self))\n\n    def __eq__(self, other):\n        \"\"\"\n        Returns true if the containers have the same items. If `other` is a\n        Sequence, then order is checked, otherwise it is ignored.\n\n        Example:\n            >>> oset = OrderedSet([1, 3, 2])\n            >>> oset == [1, 3, 2]\n            True\n            >>> oset == [1, 2, 3]\n            False\n            >>> oset == [2, 3]\n            False\n            >>> oset == OrderedSet([3, 2, 1])\n            False\n        \"\"\"\n        # In Python 2 deque is not a Sequence, so treat it as one for\n        # consistent behavior with Python 3.\n        if isinstance(other, (Sequence, deque)):\n            # Check that this OrderedSet contains the same elements, in the\n            # same order, as the other object.\n            return list(self) == list(other)\n        try:\n            other_as_set = set(other)\n        except TypeError:\n            # If `other` can't be converted into a set, it's not equal.\n            return False\n        else:\n            return set(self) == other_as_set\n\n    def union(self, *sets):\n        \"\"\"\n        Combines all unique items.\n        Each items order is defined by its first appearance.\n\n        Example:\n            >>> oset = OrderedSet.union(OrderedSet([3, 1, 4, 1, 5]), [1, 3], [2, 0])\n            >>> print(oset)\n            OrderedSet([3, 1, 4, 5, 2, 0])\n            >>> oset.union([8, 9])\n            OrderedSet([3, 1, 4, 5, 2, 0, 8, 9])\n            >>> oset | {10}\n            OrderedSet([3, 1, 4, 5, 2, 0, 10])\n        \"\"\"\n        cls = self.__class__ if isinstance(self, OrderedSet) else OrderedSet\n        containers = map(list, it.chain([self], sets))\n        items = it.chain.from_iterable(containers)\n        return cls(items)\n\n    def __and__(self, other):\n        # the parent implementation of this is backwards\n        return self.intersection(other)\n\n    def intersection(self, *sets):\n        \"\"\"\n        Returns elements in common between all sets. Order is defined only\n        by the first set.\n\n        Example:\n            >>> oset = OrderedSet.intersection(OrderedSet([0, 1, 2, 3]), [1, 2, 3])\n            >>> print(oset)\n            OrderedSet([1, 2, 3])\n            >>> oset.intersection([2, 4, 5], [1, 2, 3, 4])\n            OrderedSet([2])\n            >>> oset.intersection()\n            OrderedSet([1, 2, 3])\n        \"\"\"\n        cls = self.__class__ if isinstance(self, OrderedSet) else OrderedSet\n        if sets:\n            common = set.intersection(*map(set, sets))\n            items = (item for item in self if item in common)\n        else:\n            items = self\n        return cls(items)\n\n    def difference(self, *sets):\n        \"\"\"\n        Returns all elements that are in this set but not the others.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).difference(OrderedSet([2]))\n            OrderedSet([1, 3])\n            >>> OrderedSet([1, 2, 3]).difference(OrderedSet([2]), OrderedSet([3]))\n            OrderedSet([1])\n            >>> OrderedSet([1, 2, 3]) - OrderedSet([2])\n            OrderedSet([1, 3])\n            >>> OrderedSet([1, 2, 3]).difference()\n            OrderedSet([1, 2, 3])\n        \"\"\"\n        cls = self.__class__\n        if sets:\n            other = set.union(*map(set, sets))\n            items = (item for item in self if item not in other)\n        else:\n            items = self\n        return cls(items)\n\n    def issubset(self, other):\n        \"\"\"\n        Report whether another set contains this set.\n\n        Example:\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2})\n            False\n            >>> OrderedSet([1, 2, 3]).issubset({1, 2, 3, 4})\n            True\n            >>> OrderedSet([1, 2, 3]).issubset({1, 4, 3, 5})\n            False\n        \"\"\"\n        if len(self) > len(other):  # Fast check for obvious cases\n            return False\n        return all(item in other for item in self)\n\n    def issuperset(self, other):\n        \"\"\"\n        Report whether this set contains another set.\n\n        Example:\n            >>> OrderedSet([1, 2]).issuperset([1, 2, 3])\n            False\n            >>> OrderedSet([1, 2, 3, 4]).issuperset({1, 2, 3})\n            True\n            >>> OrderedSet([1, 4, 3, 5]).issuperset({1, 2, 3})\n            False\n        \"\"\"\n        if len(self) < len(other):  # Fast check for obvious cases\n            return False\n        return all(item in self for item in other)\n\n    def symmetric_difference(self, other):\n        \"\"\"\n        Return the symmetric difference of two OrderedSets as a new set.\n        That is, the new set will contain all elements that are in exactly\n        one of the sets.\n\n        Their order will be preserved, with elements from `self` preceding\n        elements from `other`.\n\n        Example:\n            >>> this = OrderedSet([1, 4, 3, 5, 7])\n            >>> other = OrderedSet([9, 7, 1, 3, 2])\n            >>> this.symmetric_difference(other)\n            OrderedSet([4, 5, 9, 2])\n        \"\"\"\n        cls = self.__class__ if isinstance(self, OrderedSet) else OrderedSet\n        diff1 = cls(self).difference(other)\n        diff2 = cls(other).difference(self)\n        return diff1.union(diff2)\n\n    def _update_items(self, items):\n        \"\"\"\n        Replace the 'items' list of this OrderedSet with a new one, updating\n        self.map accordingly.\n        \"\"\"\n        self.items = items\n        self.map = {item: idx for (idx, item) in enumerate(items)}\n\n    def difference_update(self, *sets):\n        \"\"\"\n        Update this OrderedSet to remove items from one or more other sets.\n\n        Example:\n            >>> this = OrderedSet([1, 2, 3])\n            >>> this.difference_update(OrderedSet([2, 4]))\n            >>> print(this)\n            OrderedSet([1, 3])\n\n            >>> this = OrderedSet([1, 2, 3, 4, 5])\n            >>> this.difference_update(OrderedSet([2, 4]), OrderedSet([1, 4, 6]))\n            >>> print(this)\n            OrderedSet([3, 5])\n        \"\"\"\n        items_to_remove = set()\n        for other in sets:\n            items_to_remove |= set(other)\n        self._update_items([item for item in self.items if item not in items_to_remove])\n\n    def intersection_update(self, other):\n        \"\"\"\n        Update this OrderedSet to keep only items in another set, preserving\n        their order in this set.\n\n        Example:\n            >>> this = OrderedSet([1, 4, 3, 5, 7])\n            >>> other = OrderedSet([9, 7, 1, 3, 2])\n            >>> this.intersection_update(other)\n            >>> print(this)\n            OrderedSet([1, 3, 7])\n        \"\"\"\n        other = set(other)\n        self._update_items([item for item in self.items if item in other])\n\n    def symmetric_difference_update(self, other):\n        \"\"\"\n        Update this OrderedSet to remove items from another set, then\n        add items from the other set that were not present in this set.\n\n        Example:\n            >>> this = OrderedSet([1, 4, 3, 5, 7])\n            >>> other = OrderedSet([9, 7, 1, 3, 2])\n            >>> this.symmetric_difference_update(other)\n            >>> print(this)\n            OrderedSet([4, 5, 9, 2])\n        \"\"\"\n        items_to_add = [item for item in other if item not in self]\n        items_to_remove = set(other)\n        self._update_items(\n            [item for item in self.items if item not in items_to_remove] + items_to_add\n        )\n", "setuptools/_vendor/zipp.py": "import io\nimport posixpath\nimport zipfile\nimport itertools\nimport contextlib\nimport sys\nimport pathlib\n\nif sys.version_info < (3, 7):\n    from collections import OrderedDict\nelse:\n    OrderedDict = dict\n\n\n__all__ = ['Path']\n\n\ndef _parents(path):\n    \"\"\"\n    Given a path with elements separated by\n    posixpath.sep, generate all parents of that path.\n\n    >>> list(_parents('b/d'))\n    ['b']\n    >>> list(_parents('/b/d/'))\n    ['/b']\n    >>> list(_parents('b/d/f/'))\n    ['b/d', 'b']\n    >>> list(_parents('b'))\n    []\n    >>> list(_parents(''))\n    []\n    \"\"\"\n    return itertools.islice(_ancestry(path), 1, None)\n\n\ndef _ancestry(path):\n    \"\"\"\n    Given a path with elements separated by\n    posixpath.sep, generate all elements of that path\n\n    >>> list(_ancestry('b/d'))\n    ['b/d', 'b']\n    >>> list(_ancestry('/b/d/'))\n    ['/b/d', '/b']\n    >>> list(_ancestry('b/d/f/'))\n    ['b/d/f', 'b/d', 'b']\n    >>> list(_ancestry('b'))\n    ['b']\n    >>> list(_ancestry(''))\n    []\n    \"\"\"\n    path = path.rstrip(posixpath.sep)\n    while path and path != posixpath.sep:\n        yield path\n        path, tail = posixpath.split(path)\n\n\n_dedupe = OrderedDict.fromkeys\n\"\"\"Deduplicate an iterable in original order\"\"\"\n\n\ndef _difference(minuend, subtrahend):\n    \"\"\"\n    Return items in minuend not in subtrahend, retaining order\n    with O(1) lookup.\n    \"\"\"\n    return itertools.filterfalse(set(subtrahend).__contains__, minuend)\n\n\nclass CompleteDirs(zipfile.ZipFile):\n    \"\"\"\n    A ZipFile subclass that ensures that implied directories\n    are always included in the namelist.\n    \"\"\"\n\n    @staticmethod\n    def _implied_dirs(names):\n        parents = itertools.chain.from_iterable(map(_parents, names))\n        as_dirs = (p + posixpath.sep for p in parents)\n        return _dedupe(_difference(as_dirs, names))\n\n    def namelist(self):\n        names = super(CompleteDirs, self).namelist()\n        return names + list(self._implied_dirs(names))\n\n    def _name_set(self):\n        return set(self.namelist())\n\n    def resolve_dir(self, name):\n        \"\"\"\n        If the name represents a directory, return that name\n        as a directory (with the trailing slash).\n        \"\"\"\n        names = self._name_set()\n        dirname = name + '/'\n        dir_match = name not in names and dirname in names\n        return dirname if dir_match else name\n\n    @classmethod\n    def make(cls, source):\n        \"\"\"\n        Given a source (filename or zipfile), return an\n        appropriate CompleteDirs subclass.\n        \"\"\"\n        if isinstance(source, CompleteDirs):\n            return source\n\n        if not isinstance(source, zipfile.ZipFile):\n            return cls(_pathlib_compat(source))\n\n        # Only allow for FastLookup when supplied zipfile is read-only\n        if 'r' not in source.mode:\n            cls = CompleteDirs\n\n        source.__class__ = cls\n        return source\n\n\nclass FastLookup(CompleteDirs):\n    \"\"\"\n    ZipFile subclass to ensure implicit\n    dirs exist and are resolved rapidly.\n    \"\"\"\n\n    def namelist(self):\n        with contextlib.suppress(AttributeError):\n            return self.__names\n        self.__names = super(FastLookup, self).namelist()\n        return self.__names\n\n    def _name_set(self):\n        with contextlib.suppress(AttributeError):\n            return self.__lookup\n        self.__lookup = super(FastLookup, self)._name_set()\n        return self.__lookup\n\n\ndef _pathlib_compat(path):\n    \"\"\"\n    For path-like objects, convert to a filename for compatibility\n    on Python 3.6.1 and earlier.\n    \"\"\"\n    try:\n        return path.__fspath__()\n    except AttributeError:\n        return str(path)\n\n\nclass Path:\n    \"\"\"\n    A pathlib-compatible interface for zip files.\n\n    Consider a zip file with this structure::\n\n        .\n        \u251c\u2500\u2500 a.txt\n        \u2514\u2500\u2500 b\n            \u251c\u2500\u2500 c.txt\n            \u2514\u2500\u2500 d\n                \u2514\u2500\u2500 e.txt\n\n    >>> data = io.BytesIO()\n    >>> zf = zipfile.ZipFile(data, 'w')\n    >>> zf.writestr('a.txt', 'content of a')\n    >>> zf.writestr('b/c.txt', 'content of c')\n    >>> zf.writestr('b/d/e.txt', 'content of e')\n    >>> zf.filename = 'mem/abcde.zip'\n\n    Path accepts the zipfile object itself or a filename\n\n    >>> root = Path(zf)\n\n    From there, several path operations are available.\n\n    Directory iteration (including the zip file itself):\n\n    >>> a, b = root.iterdir()\n    >>> a\n    Path('mem/abcde.zip', 'a.txt')\n    >>> b\n    Path('mem/abcde.zip', 'b/')\n\n    name property:\n\n    >>> b.name\n    'b'\n\n    join with divide operator:\n\n    >>> c = b / 'c.txt'\n    >>> c\n    Path('mem/abcde.zip', 'b/c.txt')\n    >>> c.name\n    'c.txt'\n\n    Read text:\n\n    >>> c.read_text()\n    'content of c'\n\n    existence:\n\n    >>> c.exists()\n    True\n    >>> (b / 'missing.txt').exists()\n    False\n\n    Coercion to string:\n\n    >>> import os\n    >>> str(c).replace(os.sep, posixpath.sep)\n    'mem/abcde.zip/b/c.txt'\n\n    At the root, ``name``, ``filename``, and ``parent``\n    resolve to the zipfile. Note these attributes are not\n    valid and will raise a ``ValueError`` if the zipfile\n    has no filename.\n\n    >>> root.name\n    'abcde.zip'\n    >>> str(root.filename).replace(os.sep, posixpath.sep)\n    'mem/abcde.zip'\n    >>> str(root.parent)\n    'mem'\n    \"\"\"\n\n    __repr = \"{self.__class__.__name__}({self.root.filename!r}, {self.at!r})\"\n\n    def __init__(self, root, at=\"\"):\n        \"\"\"\n        Construct a Path from a ZipFile or filename.\n\n        Note: When the source is an existing ZipFile object,\n        its type (__class__) will be mutated to a\n        specialized type. If the caller wishes to retain the\n        original type, the caller should either create a\n        separate ZipFile object or pass a filename.\n        \"\"\"\n        self.root = FastLookup.make(root)\n        self.at = at\n\n    def open(self, mode='r', *args, pwd=None, **kwargs):\n        \"\"\"\n        Open this entry as text or binary following the semantics\n        of ``pathlib.Path.open()`` by passing arguments through\n        to io.TextIOWrapper().\n        \"\"\"\n        if self.is_dir():\n            raise IsADirectoryError(self)\n        zip_mode = mode[0]\n        if not self.exists() and zip_mode == 'r':\n            raise FileNotFoundError(self)\n        stream = self.root.open(self.at, zip_mode, pwd=pwd)\n        if 'b' in mode:\n            if args or kwargs:\n                raise ValueError(\"encoding args invalid for binary operation\")\n            return stream\n        return io.TextIOWrapper(stream, *args, **kwargs)\n\n    @property\n    def name(self):\n        return pathlib.Path(self.at).name or self.filename.name\n\n    @property\n    def suffix(self):\n        return pathlib.Path(self.at).suffix or self.filename.suffix\n\n    @property\n    def suffixes(self):\n        return pathlib.Path(self.at).suffixes or self.filename.suffixes\n\n    @property\n    def stem(self):\n        return pathlib.Path(self.at).stem or self.filename.stem\n\n    @property\n    def filename(self):\n        return pathlib.Path(self.root.filename).joinpath(self.at)\n\n    def read_text(self, *args, **kwargs):\n        with self.open('r', *args, **kwargs) as strm:\n            return strm.read()\n\n    def read_bytes(self):\n        with self.open('rb') as strm:\n            return strm.read()\n\n    def _is_child(self, path):\n        return posixpath.dirname(path.at.rstrip(\"/\")) == self.at.rstrip(\"/\")\n\n    def _next(self, at):\n        return self.__class__(self.root, at)\n\n    def is_dir(self):\n        return not self.at or self.at.endswith(\"/\")\n\n    def is_file(self):\n        return self.exists() and not self.is_dir()\n\n    def exists(self):\n        return self.at in self.root._name_set()\n\n    def iterdir(self):\n        if not self.is_dir():\n            raise ValueError(\"Can't listdir a file\")\n        subs = map(self._next, self.root.namelist())\n        return filter(self._is_child, subs)\n\n    def __str__(self):\n        return posixpath.join(self.root.filename, self.at)\n\n    def __repr__(self):\n        return self.__repr.format(self=self)\n\n    def joinpath(self, *other):\n        next = posixpath.join(self.at, *map(_pathlib_compat, other))\n        return self._next(self.root.resolve_dir(next))\n\n    __truediv__ = joinpath\n\n    @property\n    def parent(self):\n        if not self.at:\n            return self.filename.parent\n        parent_at = posixpath.dirname(self.at.rstrip('/'))\n        if parent_at:\n            parent_at += '/'\n        return self._next(parent_at)\n", "setuptools/_vendor/__init__.py": "", "setuptools/_vendor/jaraco/__init__.py": "", "setuptools/_vendor/jaraco/context.py": "from __future__ import annotations\n\nimport contextlib\nimport functools\nimport operator\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport urllib.request\nimport warnings\nfrom typing import Iterator\n\n\nif sys.version_info < (3, 12):\n    from setuptools.extern.backports import tarfile\nelse:\n    import tarfile\n\n\n@contextlib.contextmanager\ndef pushd(dir: str | os.PathLike) -> Iterator[str | os.PathLike]:\n    \"\"\"\n    >>> tmp_path = getfixture('tmp_path')\n    >>> with pushd(tmp_path):\n    ...     assert os.getcwd() == os.fspath(tmp_path)\n    >>> assert os.getcwd() != os.fspath(tmp_path)\n    \"\"\"\n\n    orig = os.getcwd()\n    os.chdir(dir)\n    try:\n        yield dir\n    finally:\n        os.chdir(orig)\n\n\n@contextlib.contextmanager\ndef tarball(\n    url, target_dir: str | os.PathLike | None = None\n) -> Iterator[str | os.PathLike]:\n    \"\"\"\n    Get a tarball, extract it, yield, then clean up.\n\n    >>> import urllib.request\n    >>> url = getfixture('tarfile_served')\n    >>> target = getfixture('tmp_path') / 'out'\n    >>> tb = tarball(url, target_dir=target)\n    >>> import pathlib\n    >>> with tb as extracted:\n    ...     contents = pathlib.Path(extracted, 'contents.txt').read_text(encoding='utf-8')\n    >>> assert not os.path.exists(extracted)\n    \"\"\"\n    if target_dir is None:\n        target_dir = os.path.basename(url).replace('.tar.gz', '').replace('.tgz', '')\n    # In the tar command, use --strip-components=1 to strip the first path and\n    #  then\n    #  use -C to cause the files to be extracted to {target_dir}. This ensures\n    #  that we always know where the files were extracted.\n    os.mkdir(target_dir)\n    try:\n        req = urllib.request.urlopen(url)\n        with tarfile.open(fileobj=req, mode='r|*') as tf:\n            tf.extractall(path=target_dir, filter=strip_first_component)\n        yield target_dir\n    finally:\n        shutil.rmtree(target_dir)\n\n\ndef strip_first_component(\n    member: tarfile.TarInfo,\n    path,\n) -> tarfile.TarInfo:\n    _, member.name = member.name.split('/', 1)\n    return member\n\n\ndef _compose(*cmgrs):\n    \"\"\"\n    Compose any number of dependent context managers into a single one.\n\n    The last, innermost context manager may take arbitrary arguments, but\n    each successive context manager should accept the result from the\n    previous as a single parameter.\n\n    Like :func:`jaraco.functools.compose`, behavior works from right to\n    left, so the context manager should be indicated from outermost to\n    innermost.\n\n    Example, to create a context manager to change to a temporary\n    directory:\n\n    >>> temp_dir_as_cwd = _compose(pushd, temp_dir)\n    >>> with temp_dir_as_cwd() as dir:\n    ...     assert os.path.samefile(os.getcwd(), dir)\n    \"\"\"\n\n    def compose_two(inner, outer):\n        def composed(*args, **kwargs):\n            with inner(*args, **kwargs) as saved, outer(saved) as res:\n                yield res\n\n        return contextlib.contextmanager(composed)\n\n    return functools.reduce(compose_two, reversed(cmgrs))\n\n\ntarball_cwd = _compose(pushd, tarball)\n\n\n@contextlib.contextmanager\ndef tarball_context(*args, **kwargs):\n    warnings.warn(\n        \"tarball_context is deprecated. Use tarball or tarball_cwd instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    pushd_ctx = kwargs.pop('pushd', pushd)\n    with tarball(*args, **kwargs) as tball, pushd_ctx(tball) as dir:\n        yield dir\n\n\ndef infer_compression(url):\n    \"\"\"\n    Given a URL or filename, infer the compression code for tar.\n\n    >>> infer_compression('http://foo/bar.tar.gz')\n    'z'\n    >>> infer_compression('http://foo/bar.tgz')\n    'z'\n    >>> infer_compression('file.bz')\n    'j'\n    >>> infer_compression('file.xz')\n    'J'\n    \"\"\"\n    warnings.warn(\n        \"infer_compression is deprecated with no replacement\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    # cheat and just assume it's the last two characters\n    compression_indicator = url[-2:]\n    mapping = dict(gz='z', bz='j', xz='J')\n    # Assume 'z' (gzip) if no match\n    return mapping.get(compression_indicator, 'z')\n\n\n@contextlib.contextmanager\ndef temp_dir(remover=shutil.rmtree):\n    \"\"\"\n    Create a temporary directory context. Pass a custom remover\n    to override the removal behavior.\n\n    >>> import pathlib\n    >>> with temp_dir() as the_dir:\n    ...     assert os.path.isdir(the_dir)\n    ...     _ = pathlib.Path(the_dir).joinpath('somefile').write_text('contents', encoding='utf-8')\n    >>> assert not os.path.exists(the_dir)\n    \"\"\"\n    temp_dir = tempfile.mkdtemp()\n    try:\n        yield temp_dir\n    finally:\n        remover(temp_dir)\n\n\n@contextlib.contextmanager\ndef repo_context(url, branch=None, quiet=True, dest_ctx=temp_dir):\n    \"\"\"\n    Check out the repo indicated by url.\n\n    If dest_ctx is supplied, it should be a context manager\n    to yield the target directory for the check out.\n    \"\"\"\n    exe = 'git' if 'git' in url else 'hg'\n    with dest_ctx() as repo_dir:\n        cmd = [exe, 'clone', url, repo_dir]\n        if branch:\n            cmd.extend(['--branch', branch])\n        devnull = open(os.path.devnull, 'w')\n        stdout = devnull if quiet else None\n        subprocess.check_call(cmd, stdout=stdout)\n        yield repo_dir\n\n\ndef null():\n    \"\"\"\n    A null context suitable to stand in for a meaningful context.\n\n    >>> with null() as value:\n    ...     assert value is None\n\n    This context is most useful when dealing with two or more code\n    branches but only some need a context. Wrap the others in a null\n    context to provide symmetry across all options.\n    \"\"\"\n    warnings.warn(\n        \"null is deprecated. Use contextlib.nullcontext\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return contextlib.nullcontext()\n\n\nclass ExceptionTrap:\n    \"\"\"\n    A context manager that will catch certain exceptions and provide an\n    indication they occurred.\n\n    >>> with ExceptionTrap() as trap:\n    ...     raise Exception()\n    >>> bool(trap)\n    True\n\n    >>> with ExceptionTrap() as trap:\n    ...     pass\n    >>> bool(trap)\n    False\n\n    >>> with ExceptionTrap(ValueError) as trap:\n    ...     raise ValueError(\"1 + 1 is not 3\")\n    >>> bool(trap)\n    True\n    >>> trap.value\n    ValueError('1 + 1 is not 3')\n    >>> trap.tb\n    <traceback object at ...>\n\n    >>> with ExceptionTrap(ValueError) as trap:\n    ...     raise Exception()\n    Traceback (most recent call last):\n    ...\n    Exception\n\n    >>> bool(trap)\n    False\n    \"\"\"\n\n    exc_info = None, None, None\n\n    def __init__(self, exceptions=(Exception,)):\n        self.exceptions = exceptions\n\n    def __enter__(self):\n        return self\n\n    @property\n    def type(self):\n        return self.exc_info[0]\n\n    @property\n    def value(self):\n        return self.exc_info[1]\n\n    @property\n    def tb(self):\n        return self.exc_info[2]\n\n    def __exit__(self, *exc_info):\n        type = exc_info[0]\n        matches = type and issubclass(type, self.exceptions)\n        if matches:\n            self.exc_info = exc_info\n        return matches\n\n    def __bool__(self):\n        return bool(self.type)\n\n    def raises(self, func, *, _test=bool):\n        \"\"\"\n        Wrap func and replace the result with the truth\n        value of the trap (True if an exception occurred).\n\n        First, give the decorator an alias to support Python 3.8\n        Syntax.\n\n        >>> raises = ExceptionTrap(ValueError).raises\n\n        Now decorate a function that always fails.\n\n        >>> @raises\n        ... def fail():\n        ...     raise ValueError('failed')\n        >>> fail()\n        True\n        \"\"\"\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with ExceptionTrap(self.exceptions) as trap:\n                func(*args, **kwargs)\n            return _test(trap)\n\n        return wrapper\n\n    def passes(self, func):\n        \"\"\"\n        Wrap func and replace the result with the truth\n        value of the trap (True if no exception).\n\n        First, give the decorator an alias to support Python 3.8\n        Syntax.\n\n        >>> passes = ExceptionTrap(ValueError).passes\n\n        Now decorate a function that always fails.\n\n        >>> @passes\n        ... def fail():\n        ...     raise ValueError('failed')\n\n        >>> fail()\n        False\n        \"\"\"\n        return self.raises(func, _test=operator.not_)\n\n\nclass suppress(contextlib.suppress, contextlib.ContextDecorator):\n    \"\"\"\n    A version of contextlib.suppress with decorator support.\n\n    >>> @suppress(KeyError)\n    ... def key_error():\n    ...     {}['']\n    >>> key_error()\n    \"\"\"\n\n\nclass on_interrupt(contextlib.ContextDecorator):\n    \"\"\"\n    Replace a KeyboardInterrupt with SystemExit(1)\n\n    >>> def do_interrupt():\n    ...     raise KeyboardInterrupt()\n    >>> on_interrupt('error')(do_interrupt)()\n    Traceback (most recent call last):\n    ...\n    SystemExit: 1\n    >>> on_interrupt('error', code=255)(do_interrupt)()\n    Traceback (most recent call last):\n    ...\n    SystemExit: 255\n    >>> on_interrupt('suppress')(do_interrupt)()\n    >>> with __import__('pytest').raises(KeyboardInterrupt):\n    ...     on_interrupt('ignore')(do_interrupt)()\n    \"\"\"\n\n    def __init__(self, action='error', /, code=1):\n        self.action = action\n        self.code = code\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exctype, excinst, exctb):\n        if exctype is not KeyboardInterrupt or self.action == 'ignore':\n            return\n        elif self.action == 'error':\n            raise SystemExit(self.code) from excinst\n        return self.action == 'suppress'\n", "setuptools/_vendor/jaraco/text/__init__.py": "import re\nimport itertools\nimport textwrap\nimport functools\n\ntry:\n    from importlib.resources import files  # type: ignore\nexcept ImportError:  # pragma: nocover\n    from setuptools.extern.importlib_resources import files  # type: ignore\n\nfrom setuptools.extern.jaraco.functools import compose, method_cache\nfrom setuptools.extern.jaraco.context import ExceptionTrap\n\n\ndef substitution(old, new):\n    \"\"\"\n    Return a function that will perform a substitution on a string\n    \"\"\"\n    return lambda s: s.replace(old, new)\n\n\ndef multi_substitution(*substitutions):\n    \"\"\"\n    Take a sequence of pairs specifying substitutions, and create\n    a function that performs those substitutions.\n\n    >>> multi_substitution(('foo', 'bar'), ('bar', 'baz'))('foo')\n    'baz'\n    \"\"\"\n    substitutions = itertools.starmap(substitution, substitutions)\n    # compose function applies last function first, so reverse the\n    #  substitutions to get the expected order.\n    substitutions = reversed(tuple(substitutions))\n    return compose(*substitutions)\n\n\nclass FoldedCase(str):\n    \"\"\"\n    A case insensitive string class; behaves just like str\n    except compares equal when the only variation is case.\n\n    >>> s = FoldedCase('hello world')\n\n    >>> s == 'Hello World'\n    True\n\n    >>> 'Hello World' == s\n    True\n\n    >>> s != 'Hello World'\n    False\n\n    >>> s.index('O')\n    4\n\n    >>> s.split('O')\n    ['hell', ' w', 'rld']\n\n    >>> sorted(map(FoldedCase, ['GAMMA', 'alpha', 'Beta']))\n    ['alpha', 'Beta', 'GAMMA']\n\n    Sequence membership is straightforward.\n\n    >>> \"Hello World\" in [s]\n    True\n    >>> s in [\"Hello World\"]\n    True\n\n    You may test for set inclusion, but candidate and elements\n    must both be folded.\n\n    >>> FoldedCase(\"Hello World\") in {s}\n    True\n    >>> s in {FoldedCase(\"Hello World\")}\n    True\n\n    String inclusion works as long as the FoldedCase object\n    is on the right.\n\n    >>> \"hello\" in FoldedCase(\"Hello World\")\n    True\n\n    But not if the FoldedCase object is on the left:\n\n    >>> FoldedCase('hello') in 'Hello World'\n    False\n\n    In that case, use ``in_``:\n\n    >>> FoldedCase('hello').in_('Hello World')\n    True\n\n    >>> FoldedCase('hello') > FoldedCase('Hello')\n    False\n    \"\"\"\n\n    def __lt__(self, other):\n        return self.lower() < other.lower()\n\n    def __gt__(self, other):\n        return self.lower() > other.lower()\n\n    def __eq__(self, other):\n        return self.lower() == other.lower()\n\n    def __ne__(self, other):\n        return self.lower() != other.lower()\n\n    def __hash__(self):\n        return hash(self.lower())\n\n    def __contains__(self, other):\n        return super().lower().__contains__(other.lower())\n\n    def in_(self, other):\n        \"Does self appear in other?\"\n        return self in FoldedCase(other)\n\n    # cache lower since it's likely to be called frequently.\n    @method_cache\n    def lower(self):\n        return super().lower()\n\n    def index(self, sub):\n        return self.lower().index(sub.lower())\n\n    def split(self, splitter=' ', maxsplit=0):\n        pattern = re.compile(re.escape(splitter), re.I)\n        return pattern.split(self, maxsplit)\n\n\n# Python 3.8 compatibility\n_unicode_trap = ExceptionTrap(UnicodeDecodeError)\n\n\n@_unicode_trap.passes\ndef is_decodable(value):\n    r\"\"\"\n    Return True if the supplied value is decodable (using the default\n    encoding).\n\n    >>> is_decodable(b'\\xff')\n    False\n    >>> is_decodable(b'\\x32')\n    True\n    \"\"\"\n    value.decode()\n\n\ndef is_binary(value):\n    r\"\"\"\n    Return True if the value appears to be binary (that is, it's a byte\n    string and isn't decodable).\n\n    >>> is_binary(b'\\xff')\n    True\n    >>> is_binary('\\xff')\n    False\n    \"\"\"\n    return isinstance(value, bytes) and not is_decodable(value)\n\n\ndef trim(s):\n    r\"\"\"\n    Trim something like a docstring to remove the whitespace that\n    is common due to indentation and formatting.\n\n    >>> trim(\"\\n\\tfoo = bar\\n\\t\\tbar = baz\\n\")\n    'foo = bar\\n\\tbar = baz'\n    \"\"\"\n    return textwrap.dedent(s).strip()\n\n\ndef wrap(s):\n    \"\"\"\n    Wrap lines of text, retaining existing newlines as\n    paragraph markers.\n\n    >>> print(wrap(lorem_ipsum))\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n    eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad\n    minim veniam, quis nostrud exercitation ullamco laboris nisi ut\n    aliquip ex ea commodo consequat. Duis aute irure dolor in\n    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla\n    pariatur. Excepteur sint occaecat cupidatat non proident, sunt in\n    culpa qui officia deserunt mollit anim id est laborum.\n    <BLANKLINE>\n    Curabitur pretium tincidunt lacus. Nulla gravida orci a odio. Nullam\n    varius, turpis et commodo pharetra, est eros bibendum elit, nec luctus\n    magna felis sollicitudin mauris. Integer in mauris eu nibh euismod\n    gravida. Duis ac tellus et risus vulputate vehicula. Donec lobortis\n    risus a elit. Etiam tempor. Ut ullamcorper, ligula eu tempor congue,\n    eros est euismod turpis, id tincidunt sapien risus a quam. Maecenas\n    fermentum consequat mi. Donec fermentum. Pellentesque malesuada nulla\n    a mi. Duis sapien sem, aliquet nec, commodo eget, consequat quis,\n    neque. Aliquam faucibus, elit ut dictum aliquet, felis nisl adipiscing\n    sapien, sed malesuada diam lacus eget erat. Cras mollis scelerisque\n    nunc. Nullam arcu. Aliquam consequat. Curabitur augue lorem, dapibus\n    quis, laoreet et, pretium ac, nisi. Aenean magna nisl, mollis quis,\n    molestie eu, feugiat in, orci. In hac habitasse platea dictumst.\n    \"\"\"\n    paragraphs = s.splitlines()\n    wrapped = ('\\n'.join(textwrap.wrap(para)) for para in paragraphs)\n    return '\\n\\n'.join(wrapped)\n\n\ndef unwrap(s):\n    r\"\"\"\n    Given a multi-line string, return an unwrapped version.\n\n    >>> wrapped = wrap(lorem_ipsum)\n    >>> wrapped.count('\\n')\n    20\n    >>> unwrapped = unwrap(wrapped)\n    >>> unwrapped.count('\\n')\n    1\n    >>> print(unwrapped)\n    Lorem ipsum dolor sit amet, consectetur adipiscing ...\n    Curabitur pretium tincidunt lacus. Nulla gravida orci ...\n\n    \"\"\"\n    paragraphs = re.split(r'\\n\\n+', s)\n    cleaned = (para.replace('\\n', ' ') for para in paragraphs)\n    return '\\n'.join(cleaned)\n\n\n\n\nclass Splitter(object):\n    \"\"\"object that will split a string with the given arguments for each call\n\n    >>> s = Splitter(',')\n    >>> s('hello, world, this is your, master calling')\n    ['hello', ' world', ' this is your', ' master calling']\n    \"\"\"\n\n    def __init__(self, *args):\n        self.args = args\n\n    def __call__(self, s):\n        return s.split(*self.args)\n\n\ndef indent(string, prefix=' ' * 4):\n    \"\"\"\n    >>> indent('foo')\n    '    foo'\n    \"\"\"\n    return prefix + string\n\n\nclass WordSet(tuple):\n    \"\"\"\n    Given an identifier, return the words that identifier represents,\n    whether in camel case, underscore-separated, etc.\n\n    >>> WordSet.parse(\"camelCase\")\n    ('camel', 'Case')\n\n    >>> WordSet.parse(\"under_sep\")\n    ('under', 'sep')\n\n    Acronyms should be retained\n\n    >>> WordSet.parse(\"firstSNL\")\n    ('first', 'SNL')\n\n    >>> WordSet.parse(\"you_and_I\")\n    ('you', 'and', 'I')\n\n    >>> WordSet.parse(\"A simple test\")\n    ('A', 'simple', 'test')\n\n    Multiple caps should not interfere with the first cap of another word.\n\n    >>> WordSet.parse(\"myABCClass\")\n    ('my', 'ABC', 'Class')\n\n    The result is a WordSet, so you can get the form you need.\n\n    >>> WordSet.parse(\"myABCClass\").underscore_separated()\n    'my_ABC_Class'\n\n    >>> WordSet.parse('a-command').camel_case()\n    'ACommand'\n\n    >>> WordSet.parse('someIdentifier').lowered().space_separated()\n    'some identifier'\n\n    Slices of the result should return another WordSet.\n\n    >>> WordSet.parse('taken-out-of-context')[1:].underscore_separated()\n    'out_of_context'\n\n    >>> WordSet.from_class_name(WordSet()).lowered().space_separated()\n    'word set'\n\n    >>> example = WordSet.parse('figured it out')\n    >>> example.headless_camel_case()\n    'figuredItOut'\n    >>> example.dash_separated()\n    'figured-it-out'\n\n    \"\"\"\n\n    _pattern = re.compile('([A-Z]?[a-z]+)|([A-Z]+(?![a-z]))')\n\n    def capitalized(self):\n        return WordSet(word.capitalize() for word in self)\n\n    def lowered(self):\n        return WordSet(word.lower() for word in self)\n\n    def camel_case(self):\n        return ''.join(self.capitalized())\n\n    def headless_camel_case(self):\n        words = iter(self)\n        first = next(words).lower()\n        new_words = itertools.chain((first,), WordSet(words).camel_case())\n        return ''.join(new_words)\n\n    def underscore_separated(self):\n        return '_'.join(self)\n\n    def dash_separated(self):\n        return '-'.join(self)\n\n    def space_separated(self):\n        return ' '.join(self)\n\n    def trim_right(self, item):\n        \"\"\"\n        Remove the item from the end of the set.\n\n        >>> WordSet.parse('foo bar').trim_right('foo')\n        ('foo', 'bar')\n        >>> WordSet.parse('foo bar').trim_right('bar')\n        ('foo',)\n        >>> WordSet.parse('').trim_right('bar')\n        ()\n        \"\"\"\n        return self[:-1] if self and self[-1] == item else self\n\n    def trim_left(self, item):\n        \"\"\"\n        Remove the item from the beginning of the set.\n\n        >>> WordSet.parse('foo bar').trim_left('foo')\n        ('bar',)\n        >>> WordSet.parse('foo bar').trim_left('bar')\n        ('foo', 'bar')\n        >>> WordSet.parse('').trim_left('bar')\n        ()\n        \"\"\"\n        return self[1:] if self and self[0] == item else self\n\n    def trim(self, item):\n        \"\"\"\n        >>> WordSet.parse('foo bar').trim('foo')\n        ('bar',)\n        \"\"\"\n        return self.trim_left(item).trim_right(item)\n\n    def __getitem__(self, item):\n        result = super(WordSet, self).__getitem__(item)\n        if isinstance(item, slice):\n            result = WordSet(result)\n        return result\n\n    @classmethod\n    def parse(cls, identifier):\n        matches = cls._pattern.finditer(identifier)\n        return WordSet(match.group(0) for match in matches)\n\n    @classmethod\n    def from_class_name(cls, subject):\n        return cls.parse(subject.__class__.__name__)\n\n\n# for backward compatibility\nwords = WordSet.parse\n\n\ndef simple_html_strip(s):\n    r\"\"\"\n    Remove HTML from the string `s`.\n\n    >>> str(simple_html_strip(''))\n    ''\n\n    >>> print(simple_html_strip('A <bold>stormy</bold> day in paradise'))\n    A stormy day in paradise\n\n    >>> print(simple_html_strip('Somebody <!-- do not --> tell the truth.'))\n    Somebody  tell the truth.\n\n    >>> print(simple_html_strip('What about<br/>\\nmultiple lines?'))\n    What about\n    multiple lines?\n    \"\"\"\n    html_stripper = re.compile('(<!--.*?-->)|(<[^>]*>)|([^<]+)', re.DOTALL)\n    texts = (match.group(3) or '' for match in html_stripper.finditer(s))\n    return ''.join(texts)\n\n\nclass SeparatedValues(str):\n    \"\"\"\n    A string separated by a separator. Overrides __iter__ for getting\n    the values.\n\n    >>> list(SeparatedValues('a,b,c'))\n    ['a', 'b', 'c']\n\n    Whitespace is stripped and empty values are discarded.\n\n    >>> list(SeparatedValues(' a,   b   , c,  '))\n    ['a', 'b', 'c']\n    \"\"\"\n\n    separator = ','\n\n    def __iter__(self):\n        parts = self.split(self.separator)\n        return filter(None, (part.strip() for part in parts))\n\n\nclass Stripper:\n    r\"\"\"\n    Given a series of lines, find the common prefix and strip it from them.\n\n    >>> lines = [\n    ...     'abcdefg\\n',\n    ...     'abc\\n',\n    ...     'abcde\\n',\n    ... ]\n    >>> res = Stripper.strip_prefix(lines)\n    >>> res.prefix\n    'abc'\n    >>> list(res.lines)\n    ['defg\\n', '\\n', 'de\\n']\n\n    If no prefix is common, nothing should be stripped.\n\n    >>> lines = [\n    ...     'abcd\\n',\n    ...     '1234\\n',\n    ... ]\n    >>> res = Stripper.strip_prefix(lines)\n    >>> res.prefix = ''\n    >>> list(res.lines)\n    ['abcd\\n', '1234\\n']\n    \"\"\"\n\n    def __init__(self, prefix, lines):\n        self.prefix = prefix\n        self.lines = map(self, lines)\n\n    @classmethod\n    def strip_prefix(cls, lines):\n        prefix_lines, lines = itertools.tee(lines)\n        prefix = functools.reduce(cls.common_prefix, prefix_lines)\n        return cls(prefix, lines)\n\n    def __call__(self, line):\n        if not self.prefix:\n            return line\n        null, prefix, rest = line.partition(self.prefix)\n        return rest\n\n    @staticmethod\n    def common_prefix(s1, s2):\n        \"\"\"\n        Return the common prefix of two lines.\n        \"\"\"\n        index = min(len(s1), len(s2))\n        while s1[:index] != s2[:index]:\n            index -= 1\n        return s1[:index]\n\n\ndef remove_prefix(text, prefix):\n    \"\"\"\n    Remove the prefix from the text if it exists.\n\n    >>> remove_prefix('underwhelming performance', 'underwhelming ')\n    'performance'\n\n    >>> remove_prefix('something special', 'sample')\n    'something special'\n    \"\"\"\n    null, prefix, rest = text.rpartition(prefix)\n    return rest\n\n\ndef remove_suffix(text, suffix):\n    \"\"\"\n    Remove the suffix from the text if it exists.\n\n    >>> remove_suffix('name.git', '.git')\n    'name'\n\n    >>> remove_suffix('something special', 'sample')\n    'something special'\n    \"\"\"\n    rest, suffix, null = text.partition(suffix)\n    return rest\n\n\ndef normalize_newlines(text):\n    r\"\"\"\n    Replace alternate newlines with the canonical newline.\n\n    >>> normalize_newlines('Lorem Ipsum\\u2029')\n    'Lorem Ipsum\\n'\n    >>> normalize_newlines('Lorem Ipsum\\r\\n')\n    'Lorem Ipsum\\n'\n    >>> normalize_newlines('Lorem Ipsum\\x85')\n    'Lorem Ipsum\\n'\n    \"\"\"\n    newlines = ['\\r\\n', '\\r', '\\n', '\\u0085', '\\u2028', '\\u2029']\n    pattern = '|'.join(newlines)\n    return re.sub(pattern, '\\n', text)\n\n\ndef _nonblank(str):\n    return str and not str.startswith('#')\n\n\n@functools.singledispatch\ndef yield_lines(iterable):\n    r\"\"\"\n    Yield valid lines of a string or iterable.\n\n    >>> list(yield_lines(''))\n    []\n    >>> list(yield_lines(['foo', 'bar']))\n    ['foo', 'bar']\n    >>> list(yield_lines('foo\\nbar'))\n    ['foo', 'bar']\n    >>> list(yield_lines('\\nfoo\\n#bar\\nbaz #comment'))\n    ['foo', 'baz #comment']\n    >>> list(yield_lines(['foo\\nbar', 'baz', 'bing\\n\\n\\n']))\n    ['foo', 'bar', 'baz', 'bing']\n    \"\"\"\n    return itertools.chain.from_iterable(map(yield_lines, iterable))\n\n\n@yield_lines.register(str)\ndef _(text):\n    return filter(_nonblank, map(str.strip, text.splitlines()))\n\n\ndef drop_comment(line):\n    \"\"\"\n    Drop comments.\n\n    >>> drop_comment('foo # bar')\n    'foo'\n\n    A hash without a space may be in a URL.\n\n    >>> drop_comment('http://example.com/foo#bar')\n    'http://example.com/foo#bar'\n    \"\"\"\n    return line.partition(' #')[0]\n\n\ndef join_continuation(lines):\n    r\"\"\"\n    Join lines continued by a trailing backslash.\n\n    >>> list(join_continuation(['foo \\\\', 'bar', 'baz']))\n    ['foobar', 'baz']\n    >>> list(join_continuation(['foo \\\\', 'bar', 'baz']))\n    ['foobar', 'baz']\n    >>> list(join_continuation(['foo \\\\', 'bar \\\\', 'baz']))\n    ['foobarbaz']\n\n    Not sure why, but...\n    The character preceeding the backslash is also elided.\n\n    >>> list(join_continuation(['goo\\\\', 'dly']))\n    ['godly']\n\n    A terrible idea, but...\n    If no line is available to continue, suppress the lines.\n\n    >>> list(join_continuation(['foo', 'bar\\\\', 'baz\\\\']))\n    ['foo']\n    \"\"\"\n    lines = iter(lines)\n    for item in lines:\n        while item.endswith('\\\\'):\n            try:\n                item = item[:-2].strip() + next(lines)\n            except StopIteration:\n                return\n        yield item\n", "setuptools/_vendor/jaraco/functools/__init__.py": "import collections.abc\nimport functools\nimport inspect\nimport itertools\nimport operator\nimport time\nimport types\nimport warnings\n\nimport setuptools.extern.more_itertools\n\n\ndef compose(*funcs):\n    \"\"\"\n    Compose any number of unary functions into a single unary function.\n\n    >>> import textwrap\n    >>> expected = str.strip(textwrap.dedent(compose.__doc__))\n    >>> strip_and_dedent = compose(str.strip, textwrap.dedent)\n    >>> strip_and_dedent(compose.__doc__) == expected\n    True\n\n    Compose also allows the innermost function to take arbitrary arguments.\n\n    >>> round_three = lambda x: round(x, ndigits=3)\n    >>> f = compose(round_three, int.__truediv__)\n    >>> [f(3*x, x+1) for x in range(1,10)]\n    [1.5, 2.0, 2.25, 2.4, 2.5, 2.571, 2.625, 2.667, 2.7]\n    \"\"\"\n\n    def compose_two(f1, f2):\n        return lambda *args, **kwargs: f1(f2(*args, **kwargs))\n\n    return functools.reduce(compose_two, funcs)\n\n\ndef once(func):\n    \"\"\"\n    Decorate func so it's only ever called the first time.\n\n    This decorator can ensure that an expensive or non-idempotent function\n    will not be expensive on subsequent calls and is idempotent.\n\n    >>> add_three = once(lambda a: a+3)\n    >>> add_three(3)\n    6\n    >>> add_three(9)\n    6\n    >>> add_three('12')\n    6\n\n    To reset the stored value, simply clear the property ``saved_result``.\n\n    >>> del add_three.saved_result\n    >>> add_three(9)\n    12\n    >>> add_three(8)\n    12\n\n    Or invoke 'reset()' on it.\n\n    >>> add_three.reset()\n    >>> add_three(-3)\n    0\n    >>> add_three(0)\n    0\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        if not hasattr(wrapper, 'saved_result'):\n            wrapper.saved_result = func(*args, **kwargs)\n        return wrapper.saved_result\n\n    wrapper.reset = lambda: vars(wrapper).__delitem__('saved_result')\n    return wrapper\n\n\ndef method_cache(method, cache_wrapper=functools.lru_cache()):\n    \"\"\"\n    Wrap lru_cache to support storing the cache data in the object instances.\n\n    Abstracts the common paradigm where the method explicitly saves an\n    underscore-prefixed protected property on first call and returns that\n    subsequently.\n\n    >>> class MyClass:\n    ...     calls = 0\n    ...\n    ...     @method_cache\n    ...     def method(self, value):\n    ...         self.calls += 1\n    ...         return value\n\n    >>> a = MyClass()\n    >>> a.method(3)\n    3\n    >>> for x in range(75):\n    ...     res = a.method(x)\n    >>> a.calls\n    75\n\n    Note that the apparent behavior will be exactly like that of lru_cache\n    except that the cache is stored on each instance, so values in one\n    instance will not flush values from another, and when an instance is\n    deleted, so are the cached values for that instance.\n\n    >>> b = MyClass()\n    >>> for x in range(35):\n    ...     res = b.method(x)\n    >>> b.calls\n    35\n    >>> a.method(0)\n    0\n    >>> a.calls\n    75\n\n    Note that if method had been decorated with ``functools.lru_cache()``,\n    a.calls would have been 76 (due to the cached value of 0 having been\n    flushed by the 'b' instance).\n\n    Clear the cache with ``.cache_clear()``\n\n    >>> a.method.cache_clear()\n\n    Same for a method that hasn't yet been called.\n\n    >>> c = MyClass()\n    >>> c.method.cache_clear()\n\n    Another cache wrapper may be supplied:\n\n    >>> cache = functools.lru_cache(maxsize=2)\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\n    >>> a = MyClass()\n    >>> a.method2()\n    3\n\n    Caution - do not subsequently wrap the method with another decorator, such\n    as ``@property``, which changes the semantics of the function.\n\n    See also\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\n    for another implementation and additional justification.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        # it's the first call, replace the method with a cached, bound method\n        bound_method = types.MethodType(method, self)\n        cached_method = cache_wrapper(bound_method)\n        setattr(self, method.__name__, cached_method)\n        return cached_method(*args, **kwargs)\n\n    # Support cache clear even before cache has been created.\n    wrapper.cache_clear = lambda: None\n\n    return _special_method_cache(method, cache_wrapper) or wrapper\n\n\ndef _special_method_cache(method, cache_wrapper):\n    \"\"\"\n    Because Python treats special methods differently, it's not\n    possible to use instance attributes to implement the cached\n    methods.\n\n    Instead, install the wrapper method under a different name\n    and return a simple proxy to that wrapper.\n\n    https://github.com/jaraco/jaraco.functools/issues/5\n    \"\"\"\n    name = method.__name__\n    special_names = '__getattr__', '__getitem__'\n\n    if name not in special_names:\n        return None\n\n    wrapper_name = '__cached' + name\n\n    def proxy(self, /, *args, **kwargs):\n        if wrapper_name not in vars(self):\n            bound = types.MethodType(method, self)\n            cache = cache_wrapper(bound)\n            setattr(self, wrapper_name, cache)\n        else:\n            cache = getattr(self, wrapper_name)\n        return cache(*args, **kwargs)\n\n    return proxy\n\n\ndef apply(transform):\n    \"\"\"\n    Decorate a function with a transform function that is\n    invoked on results returned from the decorated function.\n\n    >>> @apply(reversed)\n    ... def get_numbers(start):\n    ...     \"doc for get_numbers\"\n    ...     return range(start, start+3)\n    >>> list(get_numbers(4))\n    [6, 5, 4]\n    >>> get_numbers.__doc__\n    'doc for get_numbers'\n    \"\"\"\n\n    def wrap(func):\n        return functools.wraps(func)(compose(transform, func))\n\n    return wrap\n\n\ndef result_invoke(action):\n    r\"\"\"\n    Decorate a function with an action function that is\n    invoked on the results returned from the decorated\n    function (for its side effect), then return the original\n    result.\n\n    >>> @result_invoke(print)\n    ... def add_two(a, b):\n    ...     return a + b\n    >>> x = add_two(2, 3)\n    5\n    >>> x\n    5\n    \"\"\"\n\n    def wrap(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            action(result)\n            return result\n\n        return wrapper\n\n    return wrap\n\n\ndef invoke(f, /, *args, **kwargs):\n    \"\"\"\n    Call a function for its side effect after initialization.\n\n    The benefit of using the decorator instead of simply invoking a function\n    after defining it is that it makes explicit the author's intent for the\n    function to be called immediately. Whereas if one simply calls the\n    function immediately, it's less obvious if that was intentional or\n    incidental. It also avoids repeating the name - the two actions, defining\n    the function and calling it immediately are modeled separately, but linked\n    by the decorator construct.\n\n    The benefit of having a function construct (opposed to just invoking some\n    behavior inline) is to serve as a scope in which the behavior occurs. It\n    avoids polluting the global namespace with local variables, provides an\n    anchor on which to attach documentation (docstring), keeps the behavior\n    logically separated (instead of conceptually separated or not separated at\n    all), and provides potential to re-use the behavior for testing or other\n    purposes.\n\n    This function is named as a pithy way to communicate, \"call this function\n    primarily for its side effect\", or \"while defining this function, also\n    take it aside and call it\". It exists because there's no Python construct\n    for \"define and call\" (nor should there be, as decorators serve this need\n    just fine). The behavior happens immediately and synchronously.\n\n    >>> @invoke\n    ... def func(): print(\"called\")\n    called\n    >>> func()\n    called\n\n    Use functools.partial to pass parameters to the initial call\n\n    >>> @functools.partial(invoke, name='bingo')\n    ... def func(name): print('called with', name)\n    called with bingo\n    \"\"\"\n    f(*args, **kwargs)\n    return f\n\n\nclass Throttler:\n    \"\"\"Rate-limit a function (or other callable).\"\"\"\n\n    def __init__(self, func, max_rate=float('Inf')):\n        if isinstance(func, Throttler):\n            func = func.func\n        self.func = func\n        self.max_rate = max_rate\n        self.reset()\n\n    def reset(self):\n        self.last_called = 0\n\n    def __call__(self, *args, **kwargs):\n        self._wait()\n        return self.func(*args, **kwargs)\n\n    def _wait(self):\n        \"\"\"Ensure at least 1/max_rate seconds from last call.\"\"\"\n        elapsed = time.time() - self.last_called\n        must_wait = 1 / self.max_rate - elapsed\n        time.sleep(max(0, must_wait))\n        self.last_called = time.time()\n\n    def __get__(self, obj, owner=None):\n        return first_invoke(self._wait, functools.partial(self.func, obj))\n\n\ndef first_invoke(func1, func2):\n    \"\"\"\n    Return a function that when invoked will invoke func1 without\n    any parameters (for its side effect) and then invoke func2\n    with whatever parameters were passed, returning its result.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        func1()\n        return func2(*args, **kwargs)\n\n    return wrapper\n\n\nmethod_caller = first_invoke(\n    lambda: warnings.warn(\n        '`jaraco.functools.method_caller` is deprecated, '\n        'use `operator.methodcaller` instead',\n        DeprecationWarning,\n        stacklevel=3,\n    ),\n    operator.methodcaller,\n)\n\n\ndef retry_call(func, cleanup=lambda: None, retries=0, trap=()):\n    \"\"\"\n    Given a callable func, trap the indicated exceptions\n    for up to 'retries' times, invoking cleanup on the\n    exception. On the final attempt, allow any exceptions\n    to propagate.\n    \"\"\"\n    attempts = itertools.count() if retries == float('inf') else range(retries)\n    for _ in attempts:\n        try:\n            return func()\n        except trap:\n            cleanup()\n\n    return func()\n\n\ndef retry(*r_args, **r_kwargs):\n    \"\"\"\n    Decorator wrapper for retry_call. Accepts arguments to retry_call\n    except func and then returns a decorator for the decorated function.\n\n    Ex:\n\n    >>> @retry(retries=3)\n    ... def my_func(a, b):\n    ...     \"this is my funk\"\n    ...     print(a, b)\n    >>> my_func.__doc__\n    'this is my funk'\n    \"\"\"\n\n    def decorate(func):\n        @functools.wraps(func)\n        def wrapper(*f_args, **f_kwargs):\n            bound = functools.partial(func, *f_args, **f_kwargs)\n            return retry_call(bound, *r_args, **r_kwargs)\n\n        return wrapper\n\n    return decorate\n\n\ndef print_yielded(func):\n    \"\"\"\n    Convert a generator into a function that prints all yielded elements.\n\n    >>> @print_yielded\n    ... def x():\n    ...     yield 3; yield None\n    >>> x()\n    3\n    None\n    \"\"\"\n    print_all = functools.partial(map, print)\n    print_results = compose(more_itertools.consume, print_all, func)\n    return functools.wraps(func)(print_results)\n\n\ndef pass_none(func):\n    \"\"\"\n    Wrap func so it's not called if its first param is None.\n\n    >>> print_text = pass_none(print)\n    >>> print_text('text')\n    text\n    >>> print_text(None)\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(param, /, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n        return None\n\n    return wrapper\n\n\ndef assign_params(func, namespace):\n    \"\"\"\n    Assign parameters from namespace where func solicits.\n\n    >>> def func(x, y=3):\n    ...     print(x, y)\n    >>> assigned = assign_params(func, dict(x=2, z=4))\n    >>> assigned()\n    2 3\n\n    The usual errors are raised if a function doesn't receive\n    its required parameters:\n\n    >>> assigned = assign_params(func, dict(y=3, z=4))\n    >>> assigned()\n    Traceback (most recent call last):\n    TypeError: func() ...argument...\n\n    It even works on methods:\n\n    >>> class Handler:\n    ...     def meth(self, arg):\n    ...         print(arg)\n    >>> assign_params(Handler().meth, dict(arg='crystal', foo='clear'))()\n    crystal\n    \"\"\"\n    sig = inspect.signature(func)\n    params = sig.parameters.keys()\n    call_ns = {k: namespace[k] for k in params if k in namespace}\n    return functools.partial(func, **call_ns)\n\n\ndef save_method_args(method):\n    \"\"\"\n    Wrap a method such that when it is called, the args and kwargs are\n    saved on the method.\n\n    >>> class MyClass:\n    ...     @save_method_args\n    ...     def method(self, a, b):\n    ...         print(a, b)\n    >>> my_ob = MyClass()\n    >>> my_ob.method(1, 2)\n    1 2\n    >>> my_ob._saved_method.args\n    (1, 2)\n    >>> my_ob._saved_method.kwargs\n    {}\n    >>> my_ob.method(a=3, b='foo')\n    3 foo\n    >>> my_ob._saved_method.args\n    ()\n    >>> my_ob._saved_method.kwargs == dict(a=3, b='foo')\n    True\n\n    The arguments are stored on the instance, allowing for\n    different instance to save different args.\n\n    >>> your_ob = MyClass()\n    >>> your_ob.method({str('x'): 3}, b=[4])\n    {'x': 3} [4]\n    >>> your_ob._saved_method.args\n    ({'x': 3},)\n    >>> my_ob._saved_method.args\n    ()\n    \"\"\"\n    args_and_kwargs = collections.namedtuple('args_and_kwargs', 'args kwargs')\n\n    @functools.wraps(method)\n    def wrapper(self, /, *args, **kwargs):\n        attr_name = '_saved_' + method.__name__\n        attr = args_and_kwargs(args, kwargs)\n        setattr(self, attr_name, attr)\n        return method(self, *args, **kwargs)\n\n    return wrapper\n\n\ndef except_(*exceptions, replace=None, use=None):\n    \"\"\"\n    Replace the indicated exceptions, if raised, with the indicated\n    literal replacement or evaluated expression (if present).\n\n    >>> safe_int = except_(ValueError)(int)\n    >>> safe_int('five')\n    >>> safe_int('5')\n    5\n\n    Specify a literal replacement with ``replace``.\n\n    >>> safe_int_r = except_(ValueError, replace=0)(int)\n    >>> safe_int_r('five')\n    0\n\n    Provide an expression to ``use`` to pass through particular parameters.\n\n    >>> safe_int_pt = except_(ValueError, use='args[0]')(int)\n    >>> safe_int_pt('five')\n    'five'\n\n    \"\"\"\n\n    def decorate(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except exceptions:\n                try:\n                    return eval(use)\n                except TypeError:\n                    return replace\n\n        return wrapper\n\n    return decorate\n\n\ndef identity(x):\n    \"\"\"\n    Return the argument.\n\n    >>> o = object()\n    >>> identity(o) is o\n    True\n    \"\"\"\n    return x\n\n\ndef bypass_when(check, *, _op=identity):\n    \"\"\"\n    Decorate a function to return its parameter when ``check``.\n\n    >>> bypassed = []  # False\n\n    >>> @bypass_when(bypassed)\n    ... def double(x):\n    ...     return x * 2\n    >>> double(2)\n    4\n    >>> bypassed[:] = [object()]  # True\n    >>> double(2)\n    2\n    \"\"\"\n\n    def decorate(func):\n        @functools.wraps(func)\n        def wrapper(param, /):\n            return param if _op(check) else func(param)\n\n        return wrapper\n\n    return decorate\n\n\ndef bypass_unless(check):\n    \"\"\"\n    Decorate a function to return its parameter unless ``check``.\n\n    >>> enabled = [object()]  # True\n\n    >>> @bypass_unless(enabled)\n    ... def double(x):\n    ...     return x * 2\n    >>> double(2)\n    4\n    >>> del enabled[:]  # False\n    >>> double(2)\n    2\n    \"\"\"\n    return bypass_when(check, _op=operator.not_)\n\n\n@functools.singledispatch\ndef _splat_inner(args, func):\n    \"\"\"Splat args to func.\"\"\"\n    return func(*args)\n\n\n@_splat_inner.register\ndef _(args: collections.abc.Mapping, func):\n    \"\"\"Splat kargs to func as kwargs.\"\"\"\n    return func(**args)\n\n\ndef splat(func):\n    \"\"\"\n    Wrap func to expect its parameters to be passed positionally in a tuple.\n\n    Has a similar effect to that of ``itertools.starmap`` over\n    simple ``map``.\n\n    >>> pairs = [(-1, 1), (0, 2)]\n    >>> setuptools.extern.more_itertools.consume(itertools.starmap(print, pairs))\n    -1 1\n    0 2\n    >>> setuptools.extern.more_itertools.consume(map(splat(print), pairs))\n    -1 1\n    0 2\n\n    The approach generalizes to other iterators that don't have a \"star\"\n    equivalent, such as a \"starfilter\".\n\n    >>> list(filter(splat(operator.add), pairs))\n    [(0, 2)]\n\n    Splat also accepts a mapping argument.\n\n    >>> def is_nice(msg, code):\n    ...     return \"smile\" in msg or code == 0\n    >>> msgs = [\n    ...     dict(msg='smile!', code=20),\n    ...     dict(msg='error :(', code=1),\n    ...     dict(msg='unknown', code=0),\n    ... ]\n    >>> for msg in filter(splat(is_nice), msgs):\n    ...     print(msg)\n    {'msg': 'smile!', 'code': 20}\n    {'msg': 'unknown', 'code': 0}\n    \"\"\"\n    return functools.wraps(func)(functools.partial(_splat_inner, func=func))\n", "setuptools/_vendor/tomli/_re.py": "# SPDX-License-Identifier: MIT\n# SPDX-FileCopyrightText: 2021 Taneli Hukkinen\n# Licensed to PSF under a Contributor Agreement.\n\nfrom __future__ import annotations\n\nfrom datetime import date, datetime, time, timedelta, timezone, tzinfo\nfrom functools import lru_cache\nimport re\nfrom typing import Any\n\nfrom ._types import ParseFloat\n\n# E.g.\n# - 00:32:00.999999\n# - 00:32:00\n_TIME_RE_STR = r\"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:\\.([0-9]{1,6})[0-9]*)?\"\n\nRE_NUMBER = re.compile(\n    r\"\"\"\n0\n(?:\n    x[0-9A-Fa-f](?:_?[0-9A-Fa-f])*   # hex\n    |\n    b[01](?:_?[01])*                 # bin\n    |\n    o[0-7](?:_?[0-7])*               # oct\n)\n|\n[+-]?(?:0|[1-9](?:_?[0-9])*)         # dec, integer part\n(?P<floatpart>\n    (?:\\.[0-9](?:_?[0-9])*)?         # optional fractional part\n    (?:[eE][+-]?[0-9](?:_?[0-9])*)?  # optional exponent part\n)\n\"\"\",\n    flags=re.VERBOSE,\n)\nRE_LOCALTIME = re.compile(_TIME_RE_STR)\nRE_DATETIME = re.compile(\n    rf\"\"\"\n([0-9]{{4}})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])  # date, e.g. 1988-10-27\n(?:\n    [Tt ]\n    {_TIME_RE_STR}\n    (?:([Zz])|([+-])([01][0-9]|2[0-3]):([0-5][0-9]))?  # optional time offset\n)?\n\"\"\",\n    flags=re.VERBOSE,\n)\n\n\ndef match_to_datetime(match: re.Match) -> datetime | date:\n    \"\"\"Convert a `RE_DATETIME` match to `datetime.datetime` or `datetime.date`.\n\n    Raises ValueError if the match does not correspond to a valid date\n    or datetime.\n    \"\"\"\n    (\n        year_str,\n        month_str,\n        day_str,\n        hour_str,\n        minute_str,\n        sec_str,\n        micros_str,\n        zulu_time,\n        offset_sign_str,\n        offset_hour_str,\n        offset_minute_str,\n    ) = match.groups()\n    year, month, day = int(year_str), int(month_str), int(day_str)\n    if hour_str is None:\n        return date(year, month, day)\n    hour, minute, sec = int(hour_str), int(minute_str), int(sec_str)\n    micros = int(micros_str.ljust(6, \"0\")) if micros_str else 0\n    if offset_sign_str:\n        tz: tzinfo | None = cached_tz(\n            offset_hour_str, offset_minute_str, offset_sign_str\n        )\n    elif zulu_time:\n        tz = timezone.utc\n    else:  # local date-time\n        tz = None\n    return datetime(year, month, day, hour, minute, sec, micros, tzinfo=tz)\n\n\n@lru_cache(maxsize=None)\ndef cached_tz(hour_str: str, minute_str: str, sign_str: str) -> timezone:\n    sign = 1 if sign_str == \"+\" else -1\n    return timezone(\n        timedelta(\n            hours=sign * int(hour_str),\n            minutes=sign * int(minute_str),\n        )\n    )\n\n\ndef match_to_localtime(match: re.Match) -> time:\n    hour_str, minute_str, sec_str, micros_str = match.groups()\n    micros = int(micros_str.ljust(6, \"0\")) if micros_str else 0\n    return time(int(hour_str), int(minute_str), int(sec_str), micros)\n\n\ndef match_to_number(match: re.Match, parse_float: ParseFloat) -> Any:\n    if match.group(\"floatpart\"):\n        return parse_float(match.group())\n    return int(match.group(), 0)\n", "setuptools/_vendor/tomli/_types.py": "# SPDX-License-Identifier: MIT\n# SPDX-FileCopyrightText: 2021 Taneli Hukkinen\n# Licensed to PSF under a Contributor Agreement.\n\nfrom typing import Any, Callable, Tuple\n\n# Type annotations\nParseFloat = Callable[[str], Any]\nKey = Tuple[str, ...]\nPos = int\n", "setuptools/_vendor/tomli/_parser.py": "# SPDX-License-Identifier: MIT\n# SPDX-FileCopyrightText: 2021 Taneli Hukkinen\n# Licensed to PSF under a Contributor Agreement.\n\nfrom __future__ import annotations\n\nfrom collections.abc import Iterable\nimport string\nfrom types import MappingProxyType\nfrom typing import Any, BinaryIO, NamedTuple\n\nfrom ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)\nfrom ._types import Key, ParseFloat, Pos\n\nASCII_CTRL = frozenset(chr(i) for i in range(32)) | frozenset(chr(127))\n\n# Neither of these sets include quotation mark or backslash. They are\n# currently handled as separate cases in the parser functions.\nILLEGAL_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\")\nILLEGAL_MULTILINE_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\")\n\nILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS\nILLEGAL_MULTILINE_LITERAL_STR_CHARS = ILLEGAL_MULTILINE_BASIC_STR_CHARS\n\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\n\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\n\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return\n        '\\\\\"': \"\\u0022\",  # quote\n        \"\\\\\\\\\": \"\\u005C\",  # backslash\n    }\n)\n\n\nclass TOMLDecodeError(ValueError):\n    \"\"\"An error raised if a document is not valid TOML.\"\"\"\n\n\ndef load(__fp: BinaryIO, *, parse_float: ParseFloat = float) -> dict[str, Any]:\n    \"\"\"Parse TOML from a binary file object.\"\"\"\n    b = __fp.read()\n    try:\n        s = b.decode()\n    except AttributeError:\n        raise TypeError(\n            \"File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`\"\n        ) from None\n    return loads(s, parse_float=parse_float)\n\n\ndef loads(__s: str, *, parse_float: ParseFloat = float) -> dict[str, Any]:  # noqa: C901\n    \"\"\"Parse TOML from a string.\"\"\"\n\n    # The spec allows converting \"\\r\\n\" to \"\\n\", even in string\n    # literals. Let's do so to simplify parsing.\n    src = __s.replace(\"\\r\\n\", \"\\n\")\n    pos = 0\n    out = Output(NestedDict(), Flags())\n    header: Key = ()\n    parse_float = make_safe_parse_float(parse_float)\n\n    # Parse one statement at a time\n    # (typically means one line in TOML source)\n    while True:\n        # 1. Skip line leading whitespace\n        pos = skip_chars(src, pos, TOML_WS)\n\n        # 2. Parse rules. Expect one of the following:\n        #    - end of file\n        #    - end of line\n        #    - comment\n        #    - key/value pair\n        #    - append dict to list (and move to its namespace)\n        #    - create dict (and move to its namespace)\n        # Skip trailing whitespace when applicable.\n        try:\n            char = src[pos]\n        except IndexError:\n            break\n        if char == \"\\n\":\n            pos += 1\n            continue\n        if char in KEY_INITIAL_CHARS:\n            pos = key_value_rule(src, pos, out, header, parse_float)\n            pos = skip_chars(src, pos, TOML_WS)\n        elif char == \"[\":\n            try:\n                second_char: str | None = src[pos + 1]\n            except IndexError:\n                second_char = None\n            out.flags.finalize_pending()\n            if second_char == \"[\":\n                pos, header = create_list_rule(src, pos, out)\n            else:\n                pos, header = create_dict_rule(src, pos, out)\n            pos = skip_chars(src, pos, TOML_WS)\n        elif char != \"#\":\n            raise suffixed_err(src, pos, \"Invalid statement\")\n\n        # 3. Skip comment\n        pos = skip_comment(src, pos)\n\n        # 4. Expect end of line or end of file\n        try:\n            char = src[pos]\n        except IndexError:\n            break\n        if char != \"\\n\":\n            raise suffixed_err(\n                src, pos, \"Expected newline or end of document after a statement\"\n            )\n        pos += 1\n\n    return out.data.dict\n\n\nclass Flags:\n    \"\"\"Flags that map to parsed keys/namespaces.\"\"\"\n\n    # Marks an immutable namespace (inline array or inline table).\n    FROZEN = 0\n    # Marks a nest that has been explicitly created and can no longer\n    # be opened using the \"[table]\" syntax.\n    EXPLICIT_NEST = 1\n\n    def __init__(self) -> None:\n        self._flags: dict[str, dict] = {}\n        self._pending_flags: set[tuple[Key, int]] = set()\n\n    def add_pending(self, key: Key, flag: int) -> None:\n        self._pending_flags.add((key, flag))\n\n    def finalize_pending(self) -> None:\n        for key, flag in self._pending_flags:\n            self.set(key, flag, recursive=False)\n        self._pending_flags.clear()\n\n    def unset_all(self, key: Key) -> None:\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return\n            cont = cont[k][\"nested\"]\n        cont.pop(key[-1], None)\n\n    def set(self, key: Key, flag: int, *, recursive: bool) -> None:  # noqa: A003\n        cont = self._flags\n        key_parent, key_stem = key[:-1], key[-1]\n        for k in key_parent:\n            if k not in cont:\n                cont[k] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n            cont = cont[k][\"nested\"]\n        if key_stem not in cont:\n            cont[key_stem] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n        cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add(flag)\n\n    def is_(self, key: Key, flag: int) -> bool:\n        if not key:\n            return False  # document root has no flags\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return False\n            inner_cont = cont[k]\n            if flag in inner_cont[\"recursive_flags\"]:\n                return True\n            cont = inner_cont[\"nested\"]\n        key_stem = key[-1]\n        if key_stem in cont:\n            cont = cont[key_stem]\n            return flag in cont[\"flags\"] or flag in cont[\"recursive_flags\"]\n        return False\n\n\nclass NestedDict:\n    def __init__(self) -> None:\n        # The parsed content of the TOML document\n        self.dict: dict[str, Any] = {}\n\n    def get_or_create_nest(\n        self,\n        key: Key,\n        *,\n        access_lists: bool = True,\n    ) -> dict:\n        cont: Any = self.dict\n        for k in key:\n            if k not in cont:\n                cont[k] = {}\n            cont = cont[k]\n            if access_lists and isinstance(cont, list):\n                cont = cont[-1]\n            if not isinstance(cont, dict):\n                raise KeyError(\"There is no nest behind this key\")\n        return cont\n\n    def append_nest_to_list(self, key: Key) -> None:\n        cont = self.get_or_create_nest(key[:-1])\n        last_key = key[-1]\n        if last_key in cont:\n            list_ = cont[last_key]\n            if not isinstance(list_, list):\n                raise KeyError(\"An object other than list found behind this key\")\n            list_.append({})\n        else:\n            cont[last_key] = [{}]\n\n\nclass Output(NamedTuple):\n    data: NestedDict\n    flags: Flags\n\n\ndef skip_chars(src: str, pos: Pos, chars: Iterable[str]) -> Pos:\n    try:\n        while src[pos] in chars:\n            pos += 1\n    except IndexError:\n        pass\n    return pos\n\n\ndef skip_until(\n    src: str,\n    pos: Pos,\n    expect: str,\n    *,\n    error_on: frozenset[str],\n    error_on_eof: bool,\n) -> Pos:\n    try:\n        new_pos = src.index(expect, pos)\n    except ValueError:\n        new_pos = len(src)\n        if error_on_eof:\n            raise suffixed_err(src, new_pos, f\"Expected {expect!r}\") from None\n\n    if not error_on.isdisjoint(src[pos:new_pos]):\n        while src[pos] not in error_on:\n            pos += 1\n        raise suffixed_err(src, pos, f\"Found invalid character {src[pos]!r}\")\n    return new_pos\n\n\ndef skip_comment(src: str, pos: Pos) -> Pos:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char == \"#\":\n        return skip_until(\n            src, pos + 1, \"\\n\", error_on=ILLEGAL_COMMENT_CHARS, error_on_eof=False\n        )\n    return pos\n\n\ndef skip_comments_and_array_ws(src: str, pos: Pos) -> Pos:\n    while True:\n        pos_before_skip = pos\n        pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)\n        pos = skip_comment(src, pos)\n        if pos == pos_before_skip:\n            return pos\n\n\ndef create_dict_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:\n    pos += 1  # Skip \"[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n\n    if out.flags.is_(key, Flags.EXPLICIT_NEST) or out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Cannot declare {key} twice\")\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)\n    try:\n        out.data.get_or_create_nest(key)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n\n    if not src.startswith(\"]\", pos):\n        raise suffixed_err(src, pos, \"Expected ']' at the end of a table declaration\")\n    return pos + 1, key\n\n\ndef create_list_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:\n    pos += 2  # Skip \"[[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n\n    if out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")\n    # Free the namespace now that it points to another empty list item...\n    out.flags.unset_all(key)\n    # ...but this key precisely is still prohibited from table declaration\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)\n    try:\n        out.data.append_nest_to_list(key)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n\n    if not src.startswith(\"]]\", pos):\n        raise suffixed_err(src, pos, \"Expected ']]' at the end of an array declaration\")\n    return pos + 2, key\n\n\ndef key_value_rule(\n    src: str, pos: Pos, out: Output, header: Key, parse_float: ParseFloat\n) -> Pos:\n    pos, key, value = parse_key_value_pair(src, pos, parse_float)\n    key_parent, key_stem = key[:-1], key[-1]\n    abs_key_parent = header + key_parent\n\n    relative_path_cont_keys = (header + key[:i] for i in range(1, len(key)))\n    for cont_key in relative_path_cont_keys:\n        # Check that dotted key syntax does not redefine an existing table\n        if out.flags.is_(cont_key, Flags.EXPLICIT_NEST):\n            raise suffixed_err(src, pos, f\"Cannot redefine namespace {cont_key}\")\n        # Containers in the relative path can't be opened with the table syntax or\n        # dotted key/value syntax in following table sections.\n        out.flags.add_pending(cont_key, Flags.EXPLICIT_NEST)\n\n    if out.flags.is_(abs_key_parent, Flags.FROZEN):\n        raise suffixed_err(\n            src, pos, f\"Cannot mutate immutable namespace {abs_key_parent}\"\n        )\n\n    try:\n        nest = out.data.get_or_create_nest(abs_key_parent)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n    if key_stem in nest:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\")\n    # Mark inline table and array namespaces recursively immutable\n    if isinstance(value, (dict, list)):\n        out.flags.set(header + key, Flags.FROZEN, recursive=True)\n    nest[key_stem] = value\n    return pos\n\n\ndef parse_key_value_pair(\n    src: str, pos: Pos, parse_float: ParseFloat\n) -> tuple[Pos, Key, Any]:\n    pos, key = parse_key(src, pos)\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char != \"=\":\n        raise suffixed_err(src, pos, \"Expected '=' after a key in a key/value pair\")\n    pos += 1\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, value = parse_value(src, pos, parse_float)\n    return pos, key, value\n\n\ndef parse_key(src: str, pos: Pos) -> tuple[Pos, Key]:\n    pos, key_part = parse_key_part(src, pos)\n    key: Key = (key_part,)\n    pos = skip_chars(src, pos, TOML_WS)\n    while True:\n        try:\n            char: str | None = src[pos]\n        except IndexError:\n            char = None\n        if char != \".\":\n            return pos, key\n        pos += 1\n        pos = skip_chars(src, pos, TOML_WS)\n        pos, key_part = parse_key_part(src, pos)\n        key += (key_part,)\n        pos = skip_chars(src, pos, TOML_WS)\n\n\ndef parse_key_part(src: str, pos: Pos) -> tuple[Pos, str]:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char in BARE_KEY_CHARS:\n        start_pos = pos\n        pos = skip_chars(src, pos, BARE_KEY_CHARS)\n        return pos, src[start_pos:pos]\n    if char == \"'\":\n        return parse_literal_str(src, pos)\n    if char == '\"':\n        return parse_one_line_basic_str(src, pos)\n    raise suffixed_err(src, pos, \"Invalid initial character for a key part\")\n\n\ndef parse_one_line_basic_str(src: str, pos: Pos) -> tuple[Pos, str]:\n    pos += 1\n    return parse_basic_str(src, pos, multiline=False)\n\n\ndef parse_array(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, list]:\n    pos += 1\n    array: list = []\n\n    pos = skip_comments_and_array_ws(src, pos)\n    if src.startswith(\"]\", pos):\n        return pos + 1, array\n    while True:\n        pos, val = parse_value(src, pos, parse_float)\n        array.append(val)\n        pos = skip_comments_and_array_ws(src, pos)\n\n        c = src[pos : pos + 1]\n        if c == \"]\":\n            return pos + 1, array\n        if c != \",\":\n            raise suffixed_err(src, pos, \"Unclosed array\")\n        pos += 1\n\n        pos = skip_comments_and_array_ws(src, pos)\n        if src.startswith(\"]\", pos):\n            return pos + 1, array\n\n\ndef parse_inline_table(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, dict]:\n    pos += 1\n    nested_dict = NestedDict()\n    flags = Flags()\n\n    pos = skip_chars(src, pos, TOML_WS)\n    if src.startswith(\"}\", pos):\n        return pos + 1, nested_dict.dict\n    while True:\n        pos, key, value = parse_key_value_pair(src, pos, parse_float)\n        key_parent, key_stem = key[:-1], key[-1]\n        if flags.is_(key, Flags.FROZEN):\n            raise suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")\n        try:\n            nest = nested_dict.get_or_create_nest(key_parent, access_lists=False)\n        except KeyError:\n            raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n        if key_stem in nest:\n            raise suffixed_err(src, pos, f\"Duplicate inline table key {key_stem!r}\")\n        nest[key_stem] = value\n        pos = skip_chars(src, pos, TOML_WS)\n        c = src[pos : pos + 1]\n        if c == \"}\":\n            return pos + 1, nested_dict.dict\n        if c != \",\":\n            raise suffixed_err(src, pos, \"Unclosed inline table\")\n        if isinstance(value, (dict, list)):\n            flags.set(key, Flags.FROZEN, recursive=True)\n        pos += 1\n        pos = skip_chars(src, pos, TOML_WS)\n\n\ndef parse_basic_str_escape(\n    src: str, pos: Pos, *, multiline: bool = False\n) -> tuple[Pos, str]:\n    escape_id = src[pos : pos + 2]\n    pos += 2\n    if multiline and escape_id in {\"\\\\ \", \"\\\\\\t\", \"\\\\\\n\"}:\n        # Skip whitespace until next non-whitespace character or end of\n        # the doc. Error if non-whitespace is found before newline.\n        if escape_id != \"\\\\\\n\":\n            pos = skip_chars(src, pos, TOML_WS)\n            try:\n                char = src[pos]\n            except IndexError:\n                return pos, \"\"\n            if char != \"\\n\":\n                raise suffixed_err(src, pos, \"Unescaped '\\\\' in a string\")\n            pos += 1\n        pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)\n        return pos, \"\"\n    if escape_id == \"\\\\u\":\n        return parse_hex_char(src, pos, 4)\n    if escape_id == \"\\\\U\":\n        return parse_hex_char(src, pos, 8)\n    try:\n        return pos, BASIC_STR_ESCAPE_REPLACEMENTS[escape_id]\n    except KeyError:\n        raise suffixed_err(src, pos, \"Unescaped '\\\\' in a string\") from None\n\n\ndef parse_basic_str_escape_multiline(src: str, pos: Pos) -> tuple[Pos, str]:\n    return parse_basic_str_escape(src, pos, multiline=True)\n\n\ndef parse_hex_char(src: str, pos: Pos, hex_len: int) -> tuple[Pos, str]:\n    hex_str = src[pos : pos + hex_len]\n    if len(hex_str) != hex_len or not HEXDIGIT_CHARS.issuperset(hex_str):\n        raise suffixed_err(src, pos, \"Invalid hex value\")\n    pos += hex_len\n    hex_int = int(hex_str, 16)\n    if not is_unicode_scalar_value(hex_int):\n        raise suffixed_err(src, pos, \"Escaped character is not a Unicode scalar value\")\n    return pos, chr(hex_int)\n\n\ndef parse_literal_str(src: str, pos: Pos) -> tuple[Pos, str]:\n    pos += 1  # Skip starting apostrophe\n    start_pos = pos\n    pos = skip_until(\n        src, pos, \"'\", error_on=ILLEGAL_LITERAL_STR_CHARS, error_on_eof=True\n    )\n    return pos + 1, src[start_pos:pos]  # Skip ending apostrophe\n\n\ndef parse_multiline_str(src: str, pos: Pos, *, literal: bool) -> tuple[Pos, str]:\n    pos += 3\n    if src.startswith(\"\\n\", pos):\n        pos += 1\n\n    if literal:\n        delim = \"'\"\n        end_pos = skip_until(\n            src,\n            pos,\n            \"'''\",\n            error_on=ILLEGAL_MULTILINE_LITERAL_STR_CHARS,\n            error_on_eof=True,\n        )\n        result = src[pos:end_pos]\n        pos = end_pos + 3\n    else:\n        delim = '\"'\n        pos, result = parse_basic_str(src, pos, multiline=True)\n\n    # Add at maximum two extra apostrophes/quotes if the end sequence\n    # is 4 or 5 chars long instead of just 3.\n    if not src.startswith(delim, pos):\n        return pos, result\n    pos += 1\n    if not src.startswith(delim, pos):\n        return pos, result + delim\n    pos += 1\n    return pos, result + (delim * 2)\n\n\ndef parse_basic_str(src: str, pos: Pos, *, multiline: bool) -> tuple[Pos, str]:\n    if multiline:\n        error_on = ILLEGAL_MULTILINE_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape_multiline\n    else:\n        error_on = ILLEGAL_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape\n    result = \"\"\n    start_pos = pos\n    while True:\n        try:\n            char = src[pos]\n        except IndexError:\n            raise suffixed_err(src, pos, \"Unterminated string\") from None\n        if char == '\"':\n            if not multiline:\n                return pos + 1, result + src[start_pos:pos]\n            if src.startswith('\"\"\"', pos):\n                return pos + 3, result + src[start_pos:pos]\n            pos += 1\n            continue\n        if char == \"\\\\\":\n            result += src[start_pos:pos]\n            pos, parsed_escape = parse_escapes(src, pos)\n            result += parsed_escape\n            start_pos = pos\n            continue\n        if char in error_on:\n            raise suffixed_err(src, pos, f\"Illegal character {char!r}\")\n        pos += 1\n\n\ndef parse_value(  # noqa: C901\n    src: str, pos: Pos, parse_float: ParseFloat\n) -> tuple[Pos, Any]:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n\n    # IMPORTANT: order conditions based on speed of checking and likelihood\n\n    # Basic strings\n    if char == '\"':\n        if src.startswith('\"\"\"', pos):\n            return parse_multiline_str(src, pos, literal=False)\n        return parse_one_line_basic_str(src, pos)\n\n    # Literal strings\n    if char == \"'\":\n        if src.startswith(\"'''\", pos):\n            return parse_multiline_str(src, pos, literal=True)\n        return parse_literal_str(src, pos)\n\n    # Booleans\n    if char == \"t\":\n        if src.startswith(\"true\", pos):\n            return pos + 4, True\n    if char == \"f\":\n        if src.startswith(\"false\", pos):\n            return pos + 5, False\n\n    # Arrays\n    if char == \"[\":\n        return parse_array(src, pos, parse_float)\n\n    # Inline tables\n    if char == \"{\":\n        return parse_inline_table(src, pos, parse_float)\n\n    # Dates and times\n    datetime_match = RE_DATETIME.match(src, pos)\n    if datetime_match:\n        try:\n            datetime_obj = match_to_datetime(datetime_match)\n        except ValueError as e:\n            raise suffixed_err(src, pos, \"Invalid date or datetime\") from e\n        return datetime_match.end(), datetime_obj\n    localtime_match = RE_LOCALTIME.match(src, pos)\n    if localtime_match:\n        return localtime_match.end(), match_to_localtime(localtime_match)\n\n    # Integers and \"normal\" floats.\n    # The regex will greedily match any type starting with a decimal\n    # char, so needs to be located after handling of dates and times.\n    number_match = RE_NUMBER.match(src, pos)\n    if number_match:\n        return number_match.end(), match_to_number(number_match, parse_float)\n\n    # Special floats\n    first_three = src[pos : pos + 3]\n    if first_three in {\"inf\", \"nan\"}:\n        return pos + 3, parse_float(first_three)\n    first_four = src[pos : pos + 4]\n    if first_four in {\"-inf\", \"+inf\", \"-nan\", \"+nan\"}:\n        return pos + 4, parse_float(first_four)\n\n    raise suffixed_err(src, pos, \"Invalid value\")\n\n\ndef suffixed_err(src: str, pos: Pos, msg: str) -> TOMLDecodeError:\n    \"\"\"Return a `TOMLDecodeError` where error message is suffixed with\n    coordinates in source.\"\"\"\n\n    def coord_repr(src: str, pos: Pos) -> str:\n        if pos >= len(src):\n            return \"end of document\"\n        line = src.count(\"\\n\", 0, pos) + 1\n        if line == 1:\n            column = pos + 1\n        else:\n            column = pos - src.rindex(\"\\n\", 0, pos)\n        return f\"line {line}, column {column}\"\n\n    return TOMLDecodeError(f\"{msg} (at {coord_repr(src, pos)})\")\n\n\ndef is_unicode_scalar_value(codepoint: int) -> bool:\n    return (0 <= codepoint <= 55295) or (57344 <= codepoint <= 1114111)\n\n\ndef make_safe_parse_float(parse_float: ParseFloat) -> ParseFloat:\n    \"\"\"A decorator to make `parse_float` safe.\n\n    `parse_float` must not return dicts or lists, because these types\n    would be mixed with parsed TOML tables and arrays, thus confusing\n    the parser. The returned decorated callable raises `ValueError`\n    instead of returning illegal types.\n    \"\"\"\n    # The default `float` callable never returns illegal types. Optimize it.\n    if parse_float is float:  # type: ignore[comparison-overlap]\n        return float\n\n    def safe_parse_float(float_str: str) -> Any:\n        float_value = parse_float(float_str)\n        if isinstance(float_value, (dict, list)):\n            raise ValueError(\"parse_float must not return dicts or lists\")\n        return float_value\n\n    return safe_parse_float\n", "setuptools/_vendor/tomli/__init__.py": "# SPDX-License-Identifier: MIT\n# SPDX-FileCopyrightText: 2021 Taneli Hukkinen\n# Licensed to PSF under a Contributor Agreement.\n\n__all__ = (\"loads\", \"load\", \"TOMLDecodeError\")\n__version__ = \"2.0.1\"  # DO NOT EDIT THIS LINE MANUALLY. LET bump2version UTILITY DO IT\n\nfrom ._parser import TOMLDecodeError, load, loads\n\n# Pretend this exception was created here.\nTOMLDecodeError.__module__ = __name__\n", "setuptools/_vendor/wheel/wheelfile.py": "from __future__ import annotations\n\nimport csv\nimport hashlib\nimport os.path\nimport re\nimport stat\nimport time\nfrom io import StringIO, TextIOWrapper\nfrom zipfile import ZIP_DEFLATED, ZipFile, ZipInfo\n\nfrom .util import log, urlsafe_b64decode, urlsafe_b64encode\n\n# Non-greedy matching of an optional build number may be too clever (more\n# invalid wheel filenames will match). Separate regex for .dist-info?\nWHEEL_INFO_RE = re.compile(\n    r\"\"\"^(?P<namever>(?P<name>[^\\s-]+?)-(?P<ver>[^\\s-]+?))(-(?P<build>\\d[^\\s-]*))?\n     -(?P<pyver>[^\\s-]+?)-(?P<abi>[^\\s-]+?)-(?P<plat>\\S+)\\.whl$\"\"\",\n    re.VERBOSE,\n)\nMINIMUM_TIMESTAMP = 315532800  # 1980-01-01 00:00:00 UTC\n\n\ndef get_zipinfo_datetime(timestamp=None):\n    # Some applications need reproducible .whl files, but they can't do this without\n    # forcing the timestamp of the individual ZipInfo objects. See issue #143.\n    timestamp = int(os.environ.get(\"SOURCE_DATE_EPOCH\", timestamp or time.time()))\n    timestamp = max(timestamp, MINIMUM_TIMESTAMP)\n    return time.gmtime(timestamp)[0:6]\n\n\nclass WheelFile(ZipFile):\n    \"\"\"A ZipFile derivative class that also reads SHA-256 hashes from\n    .dist-info/RECORD and checks any read files against those.\n    \"\"\"\n\n    _default_algorithm = hashlib.sha256\n\n    def __init__(self, file, mode=\"r\", compression=ZIP_DEFLATED):\n        basename = os.path.basename(file)\n        self.parsed_filename = WHEEL_INFO_RE.match(basename)\n        if not basename.endswith(\".whl\") or self.parsed_filename is None:\n            raise WheelError(f\"Bad wheel filename {basename!r}\")\n\n        ZipFile.__init__(self, file, mode, compression=compression, allowZip64=True)\n\n        self.dist_info_path = \"{}.dist-info\".format(\n            self.parsed_filename.group(\"namever\")\n        )\n        self.record_path = self.dist_info_path + \"/RECORD\"\n        self._file_hashes = {}\n        self._file_sizes = {}\n        if mode == \"r\":\n            # Ignore RECORD and any embedded wheel signatures\n            self._file_hashes[self.record_path] = None, None\n            self._file_hashes[self.record_path + \".jws\"] = None, None\n            self._file_hashes[self.record_path + \".p7s\"] = None, None\n\n            # Fill in the expected hashes by reading them from RECORD\n            try:\n                record = self.open(self.record_path)\n            except KeyError:\n                raise WheelError(f\"Missing {self.record_path} file\") from None\n\n            with record:\n                for line in csv.reader(\n                    TextIOWrapper(record, newline=\"\", encoding=\"utf-8\")\n                ):\n                    path, hash_sum, size = line\n                    if not hash_sum:\n                        continue\n\n                    algorithm, hash_sum = hash_sum.split(\"=\")\n                    try:\n                        hashlib.new(algorithm)\n                    except ValueError:\n                        raise WheelError(\n                            f\"Unsupported hash algorithm: {algorithm}\"\n                        ) from None\n\n                    if algorithm.lower() in {\"md5\", \"sha1\"}:\n                        raise WheelError(\n                            f\"Weak hash algorithm ({algorithm}) is not permitted by \"\n                            f\"PEP 427\"\n                        )\n\n                    self._file_hashes[path] = (\n                        algorithm,\n                        urlsafe_b64decode(hash_sum.encode(\"ascii\")),\n                    )\n\n    def open(self, name_or_info, mode=\"r\", pwd=None):\n        def _update_crc(newdata):\n            eof = ef._eof\n            update_crc_orig(newdata)\n            running_hash.update(newdata)\n            if eof and running_hash.digest() != expected_hash:\n                raise WheelError(f\"Hash mismatch for file '{ef_name}'\")\n\n        ef_name = (\n            name_or_info.filename if isinstance(name_or_info, ZipInfo) else name_or_info\n        )\n        if (\n            mode == \"r\"\n            and not ef_name.endswith(\"/\")\n            and ef_name not in self._file_hashes\n        ):\n            raise WheelError(f\"No hash found for file '{ef_name}'\")\n\n        ef = ZipFile.open(self, name_or_info, mode, pwd)\n        if mode == \"r\" and not ef_name.endswith(\"/\"):\n            algorithm, expected_hash = self._file_hashes[ef_name]\n            if expected_hash is not None:\n                # Monkey patch the _update_crc method to also check for the hash from\n                # RECORD\n                running_hash = hashlib.new(algorithm)\n                update_crc_orig, ef._update_crc = ef._update_crc, _update_crc\n\n        return ef\n\n    def write_files(self, base_dir):\n        log.info(f\"creating '{self.filename}' and adding '{base_dir}' to it\")\n        deferred = []\n        for root, dirnames, filenames in os.walk(base_dir):\n            # Sort the directory names so that `os.walk` will walk them in a\n            # defined order on the next iteration.\n            dirnames.sort()\n            for name in sorted(filenames):\n                path = os.path.normpath(os.path.join(root, name))\n                if os.path.isfile(path):\n                    arcname = os.path.relpath(path, base_dir).replace(os.path.sep, \"/\")\n                    if arcname == self.record_path:\n                        pass\n                    elif root.endswith(\".dist-info\"):\n                        deferred.append((path, arcname))\n                    else:\n                        self.write(path, arcname)\n\n        deferred.sort()\n        for path, arcname in deferred:\n            self.write(path, arcname)\n\n    def write(self, filename, arcname=None, compress_type=None):\n        with open(filename, \"rb\") as f:\n            st = os.fstat(f.fileno())\n            data = f.read()\n\n        zinfo = ZipInfo(\n            arcname or filename, date_time=get_zipinfo_datetime(st.st_mtime)\n        )\n        zinfo.external_attr = (stat.S_IMODE(st.st_mode) | stat.S_IFMT(st.st_mode)) << 16\n        zinfo.compress_type = compress_type or self.compression\n        self.writestr(zinfo, data, compress_type)\n\n    def writestr(self, zinfo_or_arcname, data, compress_type=None):\n        if isinstance(zinfo_or_arcname, str):\n            zinfo_or_arcname = ZipInfo(\n                zinfo_or_arcname, date_time=get_zipinfo_datetime()\n            )\n            zinfo_or_arcname.compress_type = self.compression\n            zinfo_or_arcname.external_attr = (0o664 | stat.S_IFREG) << 16\n\n        if isinstance(data, str):\n            data = data.encode(\"utf-8\")\n\n        ZipFile.writestr(self, zinfo_or_arcname, data, compress_type)\n        fname = (\n            zinfo_or_arcname.filename\n            if isinstance(zinfo_or_arcname, ZipInfo)\n            else zinfo_or_arcname\n        )\n        log.info(f\"adding '{fname}'\")\n        if fname != self.record_path:\n            hash_ = self._default_algorithm(data)\n            self._file_hashes[fname] = (\n                hash_.name,\n                urlsafe_b64encode(hash_.digest()).decode(\"ascii\"),\n            )\n            self._file_sizes[fname] = len(data)\n\n    def close(self):\n        # Write RECORD\n        if self.fp is not None and self.mode == \"w\" and self._file_hashes:\n            data = StringIO()\n            writer = csv.writer(data, delimiter=\",\", quotechar='\"', lineterminator=\"\\n\")\n            writer.writerows(\n                (\n                    (fname, algorithm + \"=\" + hash_, self._file_sizes[fname])\n                    for fname, (algorithm, hash_) in self._file_hashes.items()\n                )\n            )\n            writer.writerow((format(self.record_path), \"\", \"\"))\n            self.writestr(self.record_path, data.getvalue())\n\n        ZipFile.close(self)\n\n\nclass WheelError(Exception):\n    pass\n", "setuptools/_vendor/wheel/util.py": "from __future__ import annotations\n\nimport base64\nimport logging\n\nlog = logging.getLogger(\"wheel\")\n\n# ensure Python logging is configured\ntry:\n    __import__(\"setuptools.logging\")\nexcept ImportError:\n    # setuptools < ??\n    from . import _setuptools_logging\n\n    _setuptools_logging.configure()\n\n\ndef urlsafe_b64encode(data: bytes) -> bytes:\n    \"\"\"urlsafe_b64encode without padding\"\"\"\n    return base64.urlsafe_b64encode(data).rstrip(b\"=\")\n\n\ndef urlsafe_b64decode(data: bytes) -> bytes:\n    \"\"\"urlsafe_b64decode without padding\"\"\"\n    pad = b\"=\" * (4 - (len(data) & 3))\n    return base64.urlsafe_b64decode(data + pad)\n", "setuptools/_vendor/wheel/__init__.py": "from __future__ import annotations\n\n__version__ = \"0.43.0\"\n", "setuptools/_vendor/wheel/macosx_libfile.py": "\"\"\"\nThis module contains function to analyse dynamic library\nheaders to extract system information\n\nCurrently only for MacOSX\n\nLibrary file on macosx system starts with Mach-O or Fat field.\nThis can be distinguish by first 32 bites and it is called magic number.\nProper value of magic number is with suffix _MAGIC. Suffix _CIGAM means\nreversed bytes order.\nBoth fields can occur in two types: 32 and 64 bytes.\n\nFAT field inform that this library contains few version of library\n(typically for different types version). It contains\ninformation where Mach-O headers starts.\n\nEach section started with Mach-O header contains one library\n(So if file starts with this field it contains only one version).\n\nAfter filed Mach-O there are section fields.\nEach of them starts with two fields:\ncmd - magic number for this command\ncmdsize - total size occupied by this section information.\n\nIn this case only sections LC_VERSION_MIN_MACOSX (for macosx 10.13 and earlier)\nand LC_BUILD_VERSION (for macosx 10.14 and newer) are interesting,\nbecause them contains information about minimal system version.\n\nImportant remarks:\n- For fat files this implementation looks for maximum number version.\n  It not check if it is 32 or 64 and do not compare it with currently built package.\n  So it is possible to false report higher version that needed.\n- All structures signatures are taken form macosx header files.\n- I think that binary format will be more stable than `otool` output.\n  and if apple introduce some changes both implementation will need to be updated.\n- The system compile will set the deployment target no lower than\n  11.0 for arm64 builds. For \"Universal 2\" builds use the x86_64 deployment\n  target when the arm64 target is 11.0.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport ctypes\nimport os\nimport sys\n\n\"\"\"here the needed const and struct from mach-o header files\"\"\"\n\nFAT_MAGIC = 0xCAFEBABE\nFAT_CIGAM = 0xBEBAFECA\nFAT_MAGIC_64 = 0xCAFEBABF\nFAT_CIGAM_64 = 0xBFBAFECA\nMH_MAGIC = 0xFEEDFACE\nMH_CIGAM = 0xCEFAEDFE\nMH_MAGIC_64 = 0xFEEDFACF\nMH_CIGAM_64 = 0xCFFAEDFE\n\nLC_VERSION_MIN_MACOSX = 0x24\nLC_BUILD_VERSION = 0x32\n\nCPU_TYPE_ARM64 = 0x0100000C\n\nmach_header_fields = [\n    (\"magic\", ctypes.c_uint32),\n    (\"cputype\", ctypes.c_int),\n    (\"cpusubtype\", ctypes.c_int),\n    (\"filetype\", ctypes.c_uint32),\n    (\"ncmds\", ctypes.c_uint32),\n    (\"sizeofcmds\", ctypes.c_uint32),\n    (\"flags\", ctypes.c_uint32),\n]\n\"\"\"\nstruct mach_header {\n    uint32_t\tmagic;\t\t/* mach magic number identifier */\n    cpu_type_t\tcputype;\t/* cpu specifier */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier */\n    uint32_t\tfiletype;\t/* type of file */\n    uint32_t\tncmds;\t\t/* number of load commands */\n    uint32_t\tsizeofcmds;\t/* the size of all the load commands */\n    uint32_t\tflags;\t\t/* flags */\n};\ntypedef integer_t cpu_type_t;\ntypedef integer_t cpu_subtype_t;\n\"\"\"\n\nmach_header_fields_64 = mach_header_fields + [(\"reserved\", ctypes.c_uint32)]\n\"\"\"\nstruct mach_header_64 {\n    uint32_t\tmagic;\t\t/* mach magic number identifier */\n    cpu_type_t\tcputype;\t/* cpu specifier */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier */\n    uint32_t\tfiletype;\t/* type of file */\n    uint32_t\tncmds;\t\t/* number of load commands */\n    uint32_t\tsizeofcmds;\t/* the size of all the load commands */\n    uint32_t\tflags;\t\t/* flags */\n    uint32_t\treserved;\t/* reserved */\n};\n\"\"\"\n\nfat_header_fields = [(\"magic\", ctypes.c_uint32), (\"nfat_arch\", ctypes.c_uint32)]\n\"\"\"\nstruct fat_header {\n    uint32_t\tmagic;\t\t/* FAT_MAGIC or FAT_MAGIC_64 */\n    uint32_t\tnfat_arch;\t/* number of structs that follow */\n};\n\"\"\"\n\nfat_arch_fields = [\n    (\"cputype\", ctypes.c_int),\n    (\"cpusubtype\", ctypes.c_int),\n    (\"offset\", ctypes.c_uint32),\n    (\"size\", ctypes.c_uint32),\n    (\"align\", ctypes.c_uint32),\n]\n\"\"\"\nstruct fat_arch {\n    cpu_type_t\tcputype;\t/* cpu specifier (int) */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier (int) */\n    uint32_t\toffset;\t\t/* file offset to this object file */\n    uint32_t\tsize;\t\t/* size of this object file */\n    uint32_t\talign;\t\t/* alignment as a power of 2 */\n};\n\"\"\"\n\nfat_arch_64_fields = [\n    (\"cputype\", ctypes.c_int),\n    (\"cpusubtype\", ctypes.c_int),\n    (\"offset\", ctypes.c_uint64),\n    (\"size\", ctypes.c_uint64),\n    (\"align\", ctypes.c_uint32),\n    (\"reserved\", ctypes.c_uint32),\n]\n\"\"\"\nstruct fat_arch_64 {\n    cpu_type_t\tcputype;\t/* cpu specifier (int) */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier (int) */\n    uint64_t\toffset;\t\t/* file offset to this object file */\n    uint64_t\tsize;\t\t/* size of this object file */\n    uint32_t\talign;\t\t/* alignment as a power of 2 */\n    uint32_t\treserved;\t/* reserved */\n};\n\"\"\"\n\nsegment_base_fields = [(\"cmd\", ctypes.c_uint32), (\"cmdsize\", ctypes.c_uint32)]\n\"\"\"base for reading segment info\"\"\"\n\nsegment_command_fields = [\n    (\"cmd\", ctypes.c_uint32),\n    (\"cmdsize\", ctypes.c_uint32),\n    (\"segname\", ctypes.c_char * 16),\n    (\"vmaddr\", ctypes.c_uint32),\n    (\"vmsize\", ctypes.c_uint32),\n    (\"fileoff\", ctypes.c_uint32),\n    (\"filesize\", ctypes.c_uint32),\n    (\"maxprot\", ctypes.c_int),\n    (\"initprot\", ctypes.c_int),\n    (\"nsects\", ctypes.c_uint32),\n    (\"flags\", ctypes.c_uint32),\n]\n\"\"\"\nstruct segment_command { /* for 32-bit architectures */\n    uint32_t\tcmd;\t\t/* LC_SEGMENT */\n    uint32_t\tcmdsize;\t/* includes sizeof section structs */\n    char\t\tsegname[16];\t/* segment name */\n    uint32_t\tvmaddr;\t\t/* memory address of this segment */\n    uint32_t\tvmsize;\t\t/* memory size of this segment */\n    uint32_t\tfileoff;\t/* file offset of this segment */\n    uint32_t\tfilesize;\t/* amount to map from the file */\n    vm_prot_t\tmaxprot;\t/* maximum VM protection */\n    vm_prot_t\tinitprot;\t/* initial VM protection */\n    uint32_t\tnsects;\t\t/* number of sections in segment */\n    uint32_t\tflags;\t\t/* flags */\n};\ntypedef int vm_prot_t;\n\"\"\"\n\nsegment_command_fields_64 = [\n    (\"cmd\", ctypes.c_uint32),\n    (\"cmdsize\", ctypes.c_uint32),\n    (\"segname\", ctypes.c_char * 16),\n    (\"vmaddr\", ctypes.c_uint64),\n    (\"vmsize\", ctypes.c_uint64),\n    (\"fileoff\", ctypes.c_uint64),\n    (\"filesize\", ctypes.c_uint64),\n    (\"maxprot\", ctypes.c_int),\n    (\"initprot\", ctypes.c_int),\n    (\"nsects\", ctypes.c_uint32),\n    (\"flags\", ctypes.c_uint32),\n]\n\"\"\"\nstruct segment_command_64 { /* for 64-bit architectures */\n    uint32_t\tcmd;\t\t/* LC_SEGMENT_64 */\n    uint32_t\tcmdsize;\t/* includes sizeof section_64 structs */\n    char\t\tsegname[16];\t/* segment name */\n    uint64_t\tvmaddr;\t\t/* memory address of this segment */\n    uint64_t\tvmsize;\t\t/* memory size of this segment */\n    uint64_t\tfileoff;\t/* file offset of this segment */\n    uint64_t\tfilesize;\t/* amount to map from the file */\n    vm_prot_t\tmaxprot;\t/* maximum VM protection */\n    vm_prot_t\tinitprot;\t/* initial VM protection */\n    uint32_t\tnsects;\t\t/* number of sections in segment */\n    uint32_t\tflags;\t\t/* flags */\n};\n\"\"\"\n\nversion_min_command_fields = segment_base_fields + [\n    (\"version\", ctypes.c_uint32),\n    (\"sdk\", ctypes.c_uint32),\n]\n\"\"\"\nstruct version_min_command {\n    uint32_t\tcmd;\t\t/* LC_VERSION_MIN_MACOSX or\n                               LC_VERSION_MIN_IPHONEOS or\n                               LC_VERSION_MIN_WATCHOS or\n                               LC_VERSION_MIN_TVOS */\n    uint32_t\tcmdsize;\t/* sizeof(struct min_version_command) */\n    uint32_t\tversion;\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n    uint32_t\tsdk;\t\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n};\n\"\"\"\n\nbuild_version_command_fields = segment_base_fields + [\n    (\"platform\", ctypes.c_uint32),\n    (\"minos\", ctypes.c_uint32),\n    (\"sdk\", ctypes.c_uint32),\n    (\"ntools\", ctypes.c_uint32),\n]\n\"\"\"\nstruct build_version_command {\n    uint32_t\tcmd;\t\t/* LC_BUILD_VERSION */\n    uint32_t\tcmdsize;\t/* sizeof(struct build_version_command) plus */\n                                /* ntools * sizeof(struct build_tool_version) */\n    uint32_t\tplatform;\t/* platform */\n    uint32_t\tminos;\t\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n    uint32_t\tsdk;\t\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n    uint32_t\tntools;\t\t/* number of tool entries following this */\n};\n\"\"\"\n\n\ndef swap32(x):\n    return (\n        ((x << 24) & 0xFF000000)\n        | ((x << 8) & 0x00FF0000)\n        | ((x >> 8) & 0x0000FF00)\n        | ((x >> 24) & 0x000000FF)\n    )\n\n\ndef get_base_class_and_magic_number(lib_file, seek=None):\n    if seek is None:\n        seek = lib_file.tell()\n    else:\n        lib_file.seek(seek)\n    magic_number = ctypes.c_uint32.from_buffer_copy(\n        lib_file.read(ctypes.sizeof(ctypes.c_uint32))\n    ).value\n\n    # Handle wrong byte order\n    if magic_number in [FAT_CIGAM, FAT_CIGAM_64, MH_CIGAM, MH_CIGAM_64]:\n        if sys.byteorder == \"little\":\n            BaseClass = ctypes.BigEndianStructure\n        else:\n            BaseClass = ctypes.LittleEndianStructure\n\n        magic_number = swap32(magic_number)\n    else:\n        BaseClass = ctypes.Structure\n\n    lib_file.seek(seek)\n    return BaseClass, magic_number\n\n\ndef read_data(struct_class, lib_file):\n    return struct_class.from_buffer_copy(lib_file.read(ctypes.sizeof(struct_class)))\n\n\ndef extract_macosx_min_system_version(path_to_lib):\n    with open(path_to_lib, \"rb\") as lib_file:\n        BaseClass, magic_number = get_base_class_and_magic_number(lib_file, 0)\n        if magic_number not in [FAT_MAGIC, FAT_MAGIC_64, MH_MAGIC, MH_MAGIC_64]:\n            return\n\n        if magic_number in [FAT_MAGIC, FAT_CIGAM_64]:\n\n            class FatHeader(BaseClass):\n                _fields_ = fat_header_fields\n\n            fat_header = read_data(FatHeader, lib_file)\n            if magic_number == FAT_MAGIC:\n\n                class FatArch(BaseClass):\n                    _fields_ = fat_arch_fields\n\n            else:\n\n                class FatArch(BaseClass):\n                    _fields_ = fat_arch_64_fields\n\n            fat_arch_list = [\n                read_data(FatArch, lib_file) for _ in range(fat_header.nfat_arch)\n            ]\n\n            versions_list = []\n            for el in fat_arch_list:\n                try:\n                    version = read_mach_header(lib_file, el.offset)\n                    if version is not None:\n                        if el.cputype == CPU_TYPE_ARM64 and len(fat_arch_list) != 1:\n                            # Xcode will not set the deployment target below 11.0.0\n                            # for the arm64 architecture. Ignore the arm64 deployment\n                            # in fat binaries when the target is 11.0.0, that way\n                            # the other architectures can select a lower deployment\n                            # target.\n                            # This is safe because there is no arm64 variant for\n                            # macOS 10.15 or earlier.\n                            if version == (11, 0, 0):\n                                continue\n                        versions_list.append(version)\n                except ValueError:\n                    pass\n\n            if len(versions_list) > 0:\n                return max(versions_list)\n            else:\n                return None\n\n        else:\n            try:\n                return read_mach_header(lib_file, 0)\n            except ValueError:\n                \"\"\"when some error during read library files\"\"\"\n                return None\n\n\ndef read_mach_header(lib_file, seek=None):\n    \"\"\"\n    This function parses a Mach-O header and extracts\n    information about the minimal macOS version.\n\n    :param lib_file: reference to opened library file with pointer\n    \"\"\"\n    base_class, magic_number = get_base_class_and_magic_number(lib_file, seek)\n    arch = \"32\" if magic_number == MH_MAGIC else \"64\"\n\n    class SegmentBase(base_class):\n        _fields_ = segment_base_fields\n\n    if arch == \"32\":\n\n        class MachHeader(base_class):\n            _fields_ = mach_header_fields\n\n    else:\n\n        class MachHeader(base_class):\n            _fields_ = mach_header_fields_64\n\n    mach_header = read_data(MachHeader, lib_file)\n    for _i in range(mach_header.ncmds):\n        pos = lib_file.tell()\n        segment_base = read_data(SegmentBase, lib_file)\n        lib_file.seek(pos)\n        if segment_base.cmd == LC_VERSION_MIN_MACOSX:\n\n            class VersionMinCommand(base_class):\n                _fields_ = version_min_command_fields\n\n            version_info = read_data(VersionMinCommand, lib_file)\n            return parse_version(version_info.version)\n        elif segment_base.cmd == LC_BUILD_VERSION:\n\n            class VersionBuild(base_class):\n                _fields_ = build_version_command_fields\n\n            version_info = read_data(VersionBuild, lib_file)\n            return parse_version(version_info.minos)\n        else:\n            lib_file.seek(pos + segment_base.cmdsize)\n            continue\n\n\ndef parse_version(version):\n    x = (version & 0xFFFF0000) >> 16\n    y = (version & 0x0000FF00) >> 8\n    z = version & 0x000000FF\n    return x, y, z\n\n\ndef calculate_macosx_platform_tag(archive_root, platform_tag):\n    \"\"\"\n    Calculate proper macosx platform tag basing on files which are included to wheel\n\n    Example platform tag `macosx-10.14-x86_64`\n    \"\"\"\n    prefix, base_version, suffix = platform_tag.split(\"-\")\n    base_version = tuple(int(x) for x in base_version.split(\".\"))\n    base_version = base_version[:2]\n    if base_version[0] > 10:\n        base_version = (base_version[0], 0)\n    assert len(base_version) == 2\n    if \"MACOSX_DEPLOYMENT_TARGET\" in os.environ:\n        deploy_target = tuple(\n            int(x) for x in os.environ[\"MACOSX_DEPLOYMENT_TARGET\"].split(\".\")\n        )\n        deploy_target = deploy_target[:2]\n        if deploy_target[0] > 10:\n            deploy_target = (deploy_target[0], 0)\n        if deploy_target < base_version:\n            sys.stderr.write(\n                \"[WARNING] MACOSX_DEPLOYMENT_TARGET is set to a lower value ({}) than \"\n                \"the version on which the Python interpreter was compiled ({}), and \"\n                \"will be ignored.\\n\".format(\n                    \".\".join(str(x) for x in deploy_target),\n                    \".\".join(str(x) for x in base_version),\n                )\n            )\n        else:\n            base_version = deploy_target\n\n    assert len(base_version) == 2\n    start_version = base_version\n    versions_dict = {}\n    for dirpath, _dirnames, filenames in os.walk(archive_root):\n        for filename in filenames:\n            if filename.endswith(\".dylib\") or filename.endswith(\".so\"):\n                lib_path = os.path.join(dirpath, filename)\n                min_ver = extract_macosx_min_system_version(lib_path)\n                if min_ver is not None:\n                    min_ver = min_ver[0:2]\n                    if min_ver[0] > 10:\n                        min_ver = (min_ver[0], 0)\n                    versions_dict[lib_path] = min_ver\n\n    if len(versions_dict) > 0:\n        base_version = max(base_version, max(versions_dict.values()))\n\n    # macosx platform tag do not support minor bugfix release\n    fin_base_version = \"_\".join([str(x) for x in base_version])\n    if start_version < base_version:\n        problematic_files = [k for k, v in versions_dict.items() if v > start_version]\n        problematic_files = \"\\n\".join(problematic_files)\n        if len(problematic_files) == 1:\n            files_form = \"this file\"\n        else:\n            files_form = \"these files\"\n        error_message = (\n            \"[WARNING] This wheel needs a higher macOS version than {}  \"\n            \"To silence this warning, set MACOSX_DEPLOYMENT_TARGET to at least \"\n            + fin_base_version\n            + \" or recreate \"\n            + files_form\n            + \" with lower \"\n            \"MACOSX_DEPLOYMENT_TARGET:  \\n\" + problematic_files\n        )\n\n        if \"MACOSX_DEPLOYMENT_TARGET\" in os.environ:\n            error_message = error_message.format(\n                \"is set in MACOSX_DEPLOYMENT_TARGET variable.\"\n            )\n        else:\n            error_message = error_message.format(\n                \"the version your Python interpreter is compiled against.\"\n            )\n\n        sys.stderr.write(error_message)\n\n    platform_tag = prefix + \"_\" + fin_base_version + \"_\" + suffix\n    return platform_tag\n", "setuptools/_vendor/importlib_resources/_itertools.py": "from itertools import filterfalse\n\nfrom typing import (\n    Callable,\n    Iterable,\n    Iterator,\n    Optional,\n    Set,\n    TypeVar,\n    Union,\n)\n\n# Type and type variable definitions\n_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\ndef unique_everseen(\n    iterable: Iterable[_T], key: Optional[Callable[[_T], _U]] = None\n) -> Iterator[_T]:\n    \"List unique elements, preserving order. Remember all elements ever seen.\"\n    # unique_everseen('AAAABBBCCDAABBB') --> A B C D\n    # unique_everseen('ABBCcAD', str.lower) --> A B C D\n    seen: Set[Union[_T, _U]] = set()\n    seen_add = seen.add\n    if key is None:\n        for element in filterfalse(seen.__contains__, iterable):\n            seen_add(element)\n            yield element\n    else:\n        for element in iterable:\n            k = key(element)\n            if k not in seen:\n                seen_add(k)\n                yield element\n", "setuptools/_vendor/importlib_resources/_common.py": "import os\nimport pathlib\nimport tempfile\nimport functools\nimport contextlib\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport itertools\n\nfrom typing import Union, Optional, cast\nfrom .abc import ResourceReader, Traversable\n\nfrom ._compat import wrap_spec\n\nPackage = Union[types.ModuleType, str]\nAnchor = Package\n\n\ndef package_to_anchor(func):\n    \"\"\"\n    Replace 'package' parameter as 'anchor' and warn about the change.\n\n    Other errors should fall through.\n\n    >>> files('a', 'b')\n    Traceback (most recent call last):\n    TypeError: files() takes from 0 to 1 positional arguments but 2 were given\n    \"\"\"\n    undefined = object()\n\n    @functools.wraps(func)\n    def wrapper(anchor=undefined, package=undefined):\n        if package is not undefined:\n            if anchor is not undefined:\n                return func(anchor, package)\n            warnings.warn(\n                \"First parameter to files is renamed to 'anchor'\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            return func(package)\n        elif anchor is undefined:\n            return func()\n        return func(anchor)\n\n    return wrapper\n\n\n@package_to_anchor\ndef files(anchor: Optional[Anchor] = None) -> Traversable:\n    \"\"\"\n    Get a Traversable resource for an anchor.\n    \"\"\"\n    return from_package(resolve(anchor))\n\n\ndef get_resource_reader(package: types.ModuleType) -> Optional[ResourceReader]:\n    \"\"\"\n    Return the package's loader if it's a ResourceReader.\n    \"\"\"\n    # We can't use\n    # a issubclass() check here because apparently abc.'s __subclasscheck__()\n    # hook wants to create a weak reference to the object, but\n    # zipimport.zipimporter does not support weak references, resulting in a\n    # TypeError.  That seems terrible.\n    spec = package.__spec__\n    reader = getattr(spec.loader, 'get_resource_reader', None)  # type: ignore\n    if reader is None:\n        return None\n    return reader(spec.name)  # type: ignore\n\n\n@functools.singledispatch\ndef resolve(cand: Optional[Anchor]) -> types.ModuleType:\n    return cast(types.ModuleType, cand)\n\n\n@resolve.register\ndef _(cand: str) -> types.ModuleType:\n    return importlib.import_module(cand)\n\n\n@resolve.register\ndef _(cand: None) -> types.ModuleType:\n    return resolve(_infer_caller().f_globals['__name__'])\n\n\ndef _infer_caller():\n    \"\"\"\n    Walk the stack and find the frame of the first caller not in this module.\n    \"\"\"\n\n    def is_this_file(frame_info):\n        return frame_info.filename == __file__\n\n    def is_wrapper(frame_info):\n        return frame_info.function == 'wrapper'\n\n    not_this_file = itertools.filterfalse(is_this_file, inspect.stack())\n    # also exclude 'wrapper' due to singledispatch in the call stack\n    callers = itertools.filterfalse(is_wrapper, not_this_file)\n    return next(callers).frame\n\n\ndef from_package(package: types.ModuleType):\n    \"\"\"\n    Return a Traversable object for the given package.\n\n    \"\"\"\n    spec = wrap_spec(package)\n    reader = spec.loader.get_resource_reader(spec.name)\n    return reader.files()\n\n\n@contextlib.contextmanager\ndef _tempfile(\n    reader,\n    suffix='',\n    # gh-93353: Keep a reference to call os.remove() in late Python\n    # finalization.\n    *,\n    _os_remove=os.remove,\n):\n    # Not using tempfile.NamedTemporaryFile as it leads to deeper 'try'\n    # blocks due to the need to close the temporary file to work on Windows\n    # properly.\n    fd, raw_path = tempfile.mkstemp(suffix=suffix)\n    try:\n        try:\n            os.write(fd, reader())\n        finally:\n            os.close(fd)\n        del reader\n        yield pathlib.Path(raw_path)\n    finally:\n        try:\n            _os_remove(raw_path)\n        except FileNotFoundError:\n            pass\n\n\ndef _temp_file(path):\n    return _tempfile(path.read_bytes, suffix=path.name)\n\n\ndef _is_present_dir(path: Traversable) -> bool:\n    \"\"\"\n    Some Traversables implement ``is_dir()`` to raise an\n    exception (i.e. ``FileNotFoundError``) when the\n    directory doesn't exist. This function wraps that call\n    to always return a boolean and only return True\n    if there's a dir and it exists.\n    \"\"\"\n    with contextlib.suppress(FileNotFoundError):\n        return path.is_dir()\n    return False\n\n\n@functools.singledispatch\ndef as_file(path):\n    \"\"\"\n    Given a Traversable object, return that object as a\n    path on the local file system in a context manager.\n    \"\"\"\n    return _temp_dir(path) if _is_present_dir(path) else _temp_file(path)\n\n\n@as_file.register(pathlib.Path)\n@contextlib.contextmanager\ndef _(path):\n    \"\"\"\n    Degenerate behavior for pathlib.Path objects.\n    \"\"\"\n    yield path\n\n\n@contextlib.contextmanager\ndef _temp_path(dir: tempfile.TemporaryDirectory):\n    \"\"\"\n    Wrap tempfile.TemporyDirectory to return a pathlib object.\n    \"\"\"\n    with dir as result:\n        yield pathlib.Path(result)\n\n\n@contextlib.contextmanager\ndef _temp_dir(path):\n    \"\"\"\n    Given a traversable dir, recursively replicate the whole tree\n    to the file system in a context manager.\n    \"\"\"\n    assert path.is_dir()\n    with _temp_path(tempfile.TemporaryDirectory()) as temp_dir:\n        yield _write_contents(temp_dir, path)\n\n\ndef _write_contents(target, source):\n    child = target.joinpath(source.name)\n    if source.is_dir():\n        child.mkdir()\n        for item in source.iterdir():\n            _write_contents(child, item)\n    else:\n        child.write_bytes(source.read_bytes())\n    return child\n", "setuptools/_vendor/importlib_resources/simple.py": "\"\"\"\nInterface adapters for low-level readers.\n\"\"\"\n\nimport abc\nimport io\nimport itertools\nfrom typing import BinaryIO, List\n\nfrom .abc import Traversable, TraversableResources\n\n\nclass SimpleReader(abc.ABC):\n    \"\"\"\n    The minimum, low-level interface required from a resource\n    provider.\n    \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def package(self) -> str:\n        \"\"\"\n        The name of the package for which this reader loads resources.\n        \"\"\"\n\n    @abc.abstractmethod\n    def children(self) -> List['SimpleReader']:\n        \"\"\"\n        Obtain an iterable of SimpleReader for available\n        child containers (e.g. directories).\n        \"\"\"\n\n    @abc.abstractmethod\n    def resources(self) -> List[str]:\n        \"\"\"\n        Obtain available named resources for this virtual package.\n        \"\"\"\n\n    @abc.abstractmethod\n    def open_binary(self, resource: str) -> BinaryIO:\n        \"\"\"\n        Obtain a File-like for a named resource.\n        \"\"\"\n\n    @property\n    def name(self):\n        return self.package.split('.')[-1]\n\n\nclass ResourceContainer(Traversable):\n    \"\"\"\n    Traversable container for a package's resources via its reader.\n    \"\"\"\n\n    def __init__(self, reader: SimpleReader):\n        self.reader = reader\n\n    def is_dir(self):\n        return True\n\n    def is_file(self):\n        return False\n\n    def iterdir(self):\n        files = (ResourceHandle(self, name) for name in self.reader.resources)\n        dirs = map(ResourceContainer, self.reader.children())\n        return itertools.chain(files, dirs)\n\n    def open(self, *args, **kwargs):\n        raise IsADirectoryError()\n\n\nclass ResourceHandle(Traversable):\n    \"\"\"\n    Handle to a named resource in a ResourceReader.\n    \"\"\"\n\n    def __init__(self, parent: ResourceContainer, name: str):\n        self.parent = parent\n        self.name = name  # type: ignore\n\n    def is_file(self):\n        return True\n\n    def is_dir(self):\n        return False\n\n    def open(self, mode='r', *args, **kwargs):\n        stream = self.parent.reader.open_binary(self.name)\n        if 'b' not in mode:\n            stream = io.TextIOWrapper(*args, **kwargs)\n        return stream\n\n    def joinpath(self, name):\n        raise RuntimeError(\"Cannot traverse into a resource\")\n\n\nclass TraversableReader(TraversableResources, SimpleReader):\n    \"\"\"\n    A TraversableResources based on SimpleReader. Resource providers\n    may derive from this class to provide the TraversableResources\n    interface by supplying the SimpleReader interface.\n    \"\"\"\n\n    def files(self):\n        return ResourceContainer(self)\n", "setuptools/_vendor/importlib_resources/abc.py": "import abc\nimport io\nimport itertools\nimport pathlib\nfrom typing import Any, BinaryIO, Iterable, Iterator, NoReturn, Text, Optional\n\nfrom ._compat import runtime_checkable, Protocol, StrPath\n\n\n__all__ = [\"ResourceReader\", \"Traversable\", \"TraversableResources\"]\n\n\nclass ResourceReader(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for loaders to provide resource reading support.\"\"\"\n\n    @abc.abstractmethod\n    def open_resource(self, resource: Text) -> BinaryIO:\n        \"\"\"Return an opened, file-like object for binary reading.\n\n        The 'resource' argument is expected to represent only a file name.\n        If the resource cannot be found, FileNotFoundError is raised.\n        \"\"\"\n        # This deliberately raises FileNotFoundError instead of\n        # NotImplementedError so that if this method is accidentally called,\n        # it'll still do the right thing.\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def resource_path(self, resource: Text) -> Text:\n        \"\"\"Return the file system path to the specified resource.\n\n        The 'resource' argument is expected to represent only a file name.\n        If the resource does not exist on the file system, raise\n        FileNotFoundError.\n        \"\"\"\n        # This deliberately raises FileNotFoundError instead of\n        # NotImplementedError so that if this method is accidentally called,\n        # it'll still do the right thing.\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def is_resource(self, path: Text) -> bool:\n        \"\"\"Return True if the named 'path' is a resource.\n\n        Files are resources, directories are not.\n        \"\"\"\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def contents(self) -> Iterable[str]:\n        \"\"\"Return an iterable of entries in `package`.\"\"\"\n        raise FileNotFoundError\n\n\nclass TraversalError(Exception):\n    pass\n\n\n@runtime_checkable\nclass Traversable(Protocol):\n    \"\"\"\n    An object with a subset of pathlib.Path methods suitable for\n    traversing directories and opening files.\n\n    Any exceptions that occur when accessing the backing resource\n    may propagate unaltered.\n    \"\"\"\n\n    @abc.abstractmethod\n    def iterdir(self) -> Iterator[\"Traversable\"]:\n        \"\"\"\n        Yield Traversable objects in self\n        \"\"\"\n\n    def read_bytes(self) -> bytes:\n        \"\"\"\n        Read contents of self as bytes\n        \"\"\"\n        with self.open('rb') as strm:\n            return strm.read()\n\n    def read_text(self, encoding: Optional[str] = None) -> str:\n        \"\"\"\n        Read contents of self as text\n        \"\"\"\n        with self.open(encoding=encoding) as strm:\n            return strm.read()\n\n    @abc.abstractmethod\n    def is_dir(self) -> bool:\n        \"\"\"\n        Return True if self is a directory\n        \"\"\"\n\n    @abc.abstractmethod\n    def is_file(self) -> bool:\n        \"\"\"\n        Return True if self is a file\n        \"\"\"\n\n    def joinpath(self, *descendants: StrPath) -> \"Traversable\":\n        \"\"\"\n        Return Traversable resolved with any descendants applied.\n\n        Each descendant should be a path segment relative to self\n        and each may contain multiple levels separated by\n        ``posixpath.sep`` (``/``).\n        \"\"\"\n        if not descendants:\n            return self\n        names = itertools.chain.from_iterable(\n            path.parts for path in map(pathlib.PurePosixPath, descendants)\n        )\n        target = next(names)\n        matches = (\n            traversable for traversable in self.iterdir() if traversable.name == target\n        )\n        try:\n            match = next(matches)\n        except StopIteration:\n            raise TraversalError(\n                \"Target not found during traversal.\", target, list(names)\n            )\n        return match.joinpath(*names)\n\n    def __truediv__(self, child: StrPath) -> \"Traversable\":\n        \"\"\"\n        Return Traversable child in self\n        \"\"\"\n        return self.joinpath(child)\n\n    @abc.abstractmethod\n    def open(self, mode='r', *args, **kwargs):\n        \"\"\"\n        mode may be 'r' or 'rb' to open as text or binary. Return a handle\n        suitable for reading (same as pathlib.Path.open).\n\n        When opening as text, accepts encoding parameters such as those\n        accepted by io.TextIOWrapper.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        The base name of this object without any parent references.\n        \"\"\"\n\n\nclass TraversableResources(ResourceReader):\n    \"\"\"\n    The required interface for providing traversable\n    resources.\n    \"\"\"\n\n    @abc.abstractmethod\n    def files(self) -> \"Traversable\":\n        \"\"\"Return a Traversable object for the loaded package.\"\"\"\n\n    def open_resource(self, resource: StrPath) -> io.BufferedReader:\n        return self.files().joinpath(resource).open('rb')\n\n    def resource_path(self, resource: Any) -> NoReturn:\n        raise FileNotFoundError(resource)\n\n    def is_resource(self, path: StrPath) -> bool:\n        return self.files().joinpath(path).is_file()\n\n    def contents(self) -> Iterator[str]:\n        return (item.name for item in self.files().iterdir())\n", "setuptools/_vendor/importlib_resources/readers.py": "import collections\nimport pathlib\nimport operator\n\nfrom . import abc\n\nfrom ._itertools import unique_everseen\nfrom ._compat import ZipPath\n\n\ndef remove_duplicates(items):\n    return iter(collections.OrderedDict.fromkeys(items))\n\n\nclass FileReader(abc.TraversableResources):\n    def __init__(self, loader):\n        self.path = pathlib.Path(loader.path).parent\n\n    def resource_path(self, resource):\n        \"\"\"\n        Return the file system path to prevent\n        `resources.path()` from creating a temporary\n        copy.\n        \"\"\"\n        return str(self.path.joinpath(resource))\n\n    def files(self):\n        return self.path\n\n\nclass ZipReader(abc.TraversableResources):\n    def __init__(self, loader, module):\n        _, _, name = module.rpartition('.')\n        self.prefix = loader.prefix.replace('\\\\', '/') + name + '/'\n        self.archive = loader.archive\n\n    def open_resource(self, resource):\n        try:\n            return super().open_resource(resource)\n        except KeyError as exc:\n            raise FileNotFoundError(exc.args[0])\n\n    def is_resource(self, path):\n        # workaround for `zipfile.Path.is_file` returning true\n        # for non-existent paths.\n        target = self.files().joinpath(path)\n        return target.is_file() and target.exists()\n\n    def files(self):\n        return ZipPath(self.archive, self.prefix)\n\n\nclass MultiplexedPath(abc.Traversable):\n    \"\"\"\n    Given a series of Traversable objects, implement a merged\n    version of the interface across all objects. Useful for\n    namespace packages which may be multihomed at a single\n    name.\n    \"\"\"\n\n    def __init__(self, *paths):\n        self._paths = list(map(pathlib.Path, remove_duplicates(paths)))\n        if not self._paths:\n            message = 'MultiplexedPath must contain at least one path'\n            raise FileNotFoundError(message)\n        if not all(path.is_dir() for path in self._paths):\n            raise NotADirectoryError('MultiplexedPath only supports directories')\n\n    def iterdir(self):\n        files = (file for path in self._paths for file in path.iterdir())\n        return unique_everseen(files, key=operator.attrgetter('name'))\n\n    def read_bytes(self):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    def read_text(self, *args, **kwargs):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    def is_dir(self):\n        return True\n\n    def is_file(self):\n        return False\n\n    def joinpath(self, *descendants):\n        try:\n            return super().joinpath(*descendants)\n        except abc.TraversalError:\n            # One of the paths did not resolve (a directory does not exist).\n            # Just return something that will not exist.\n            return self._paths[0].joinpath(*descendants)\n\n    def open(self, *args, **kwargs):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    @property\n    def name(self):\n        return self._paths[0].name\n\n    def __repr__(self):\n        paths = ', '.join(f\"'{path}'\" for path in self._paths)\n        return f'MultiplexedPath({paths})'\n\n\nclass NamespaceReader(abc.TraversableResources):\n    def __init__(self, namespace_path):\n        if 'NamespacePath' not in str(namespace_path):\n            raise ValueError('Invalid path')\n        self.path = MultiplexedPath(*list(namespace_path))\n\n    def resource_path(self, resource):\n        \"\"\"\n        Return the file system path to prevent\n        `resources.path()` from creating a temporary\n        copy.\n        \"\"\"\n        return str(self.path.joinpath(resource))\n\n    def files(self):\n        return self.path\n", "setuptools/_vendor/importlib_resources/_legacy.py": "import functools\nimport os\nimport pathlib\nimport types\nimport warnings\n\nfrom typing import Union, Iterable, ContextManager, BinaryIO, TextIO, Any\n\nfrom . import _common\n\nPackage = Union[types.ModuleType, str]\nResource = str\n\n\ndef deprecated(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        warnings.warn(\n            f\"{func.__name__} is deprecated. Use files() instead. \"\n            \"Refer to https://importlib-resources.readthedocs.io\"\n            \"/en/latest/using.html#migrating-from-legacy for migration advice.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return func(*args, **kwargs)\n\n    return wrapper\n\n\ndef normalize_path(path: Any) -> str:\n    \"\"\"Normalize a path by ensuring it is a string.\n\n    If the resulting string contains path separators, an exception is raised.\n    \"\"\"\n    str_path = str(path)\n    parent, file_name = os.path.split(str_path)\n    if parent:\n        raise ValueError(f'{path!r} must be only a file name')\n    return file_name\n\n\n@deprecated\ndef open_binary(package: Package, resource: Resource) -> BinaryIO:\n    \"\"\"Return a file-like object opened for binary reading of the resource.\"\"\"\n    return (_common.files(package) / normalize_path(resource)).open('rb')\n\n\n@deprecated\ndef read_binary(package: Package, resource: Resource) -> bytes:\n    \"\"\"Return the binary contents of the resource.\"\"\"\n    return (_common.files(package) / normalize_path(resource)).read_bytes()\n\n\n@deprecated\ndef open_text(\n    package: Package,\n    resource: Resource,\n    encoding: str = 'utf-8',\n    errors: str = 'strict',\n) -> TextIO:\n    \"\"\"Return a file-like object opened for text reading of the resource.\"\"\"\n    return (_common.files(package) / normalize_path(resource)).open(\n        'r', encoding=encoding, errors=errors\n    )\n\n\n@deprecated\ndef read_text(\n    package: Package,\n    resource: Resource,\n    encoding: str = 'utf-8',\n    errors: str = 'strict',\n) -> str:\n    \"\"\"Return the decoded string of the resource.\n\n    The decoding-related arguments have the same semantics as those of\n    bytes.decode().\n    \"\"\"\n    with open_text(package, resource, encoding, errors) as fp:\n        return fp.read()\n\n\n@deprecated\ndef contents(package: Package) -> Iterable[str]:\n    \"\"\"Return an iterable of entries in `package`.\n\n    Note that not all entries are resources.  Specifically, directories are\n    not considered resources.  Use `is_resource()` on each entry returned here\n    to check if it is a resource or not.\n    \"\"\"\n    return [path.name for path in _common.files(package).iterdir()]\n\n\n@deprecated\ndef is_resource(package: Package, name: str) -> bool:\n    \"\"\"True if `name` is a resource inside `package`.\n\n    Directories are *not* resources.\n    \"\"\"\n    resource = normalize_path(name)\n    return any(\n        traversable.name == resource and traversable.is_file()\n        for traversable in _common.files(package).iterdir()\n    )\n\n\n@deprecated\ndef path(\n    package: Package,\n    resource: Resource,\n) -> ContextManager[pathlib.Path]:\n    \"\"\"A context manager providing a file path object to the resource.\n\n    If the resource does not already exist on its own on the file system,\n    a temporary file will be created. If the file was created, the file\n    will be deleted upon exiting the context manager (no exception is\n    raised if the file was deleted prior to the context manager\n    exiting).\n    \"\"\"\n    return _common.as_file(_common.files(package) / normalize_path(resource))\n", "setuptools/_vendor/importlib_resources/_adapters.py": "from contextlib import suppress\nfrom io import TextIOWrapper\n\nfrom . import abc\n\n\nclass SpecLoaderAdapter:\n    \"\"\"\n    Adapt a package spec to adapt the underlying loader.\n    \"\"\"\n\n    def __init__(self, spec, adapter=lambda spec: spec.loader):\n        self.spec = spec\n        self.loader = adapter(spec)\n\n    def __getattr__(self, name):\n        return getattr(self.spec, name)\n\n\nclass TraversableResourcesLoader:\n    \"\"\"\n    Adapt a loader to provide TraversableResources.\n    \"\"\"\n\n    def __init__(self, spec):\n        self.spec = spec\n\n    def get_resource_reader(self, name):\n        return CompatibilityFiles(self.spec)._native()\n\n\ndef _io_wrapper(file, mode='r', *args, **kwargs):\n    if mode == 'r':\n        return TextIOWrapper(file, *args, **kwargs)\n    elif mode == 'rb':\n        return file\n    raise ValueError(\n        \"Invalid mode value '{}', only 'r' and 'rb' are supported\".format(mode)\n    )\n\n\nclass CompatibilityFiles:\n    \"\"\"\n    Adapter for an existing or non-existent resource reader\n    to provide a compatibility .files().\n    \"\"\"\n\n    class SpecPath(abc.Traversable):\n        \"\"\"\n        Path tied to a module spec.\n        Can be read and exposes the resource reader children.\n        \"\"\"\n\n        def __init__(self, spec, reader):\n            self._spec = spec\n            self._reader = reader\n\n        def iterdir(self):\n            if not self._reader:\n                return iter(())\n            return iter(\n                CompatibilityFiles.ChildPath(self._reader, path)\n                for path in self._reader.contents()\n            )\n\n        def is_file(self):\n            return False\n\n        is_dir = is_file\n\n        def joinpath(self, other):\n            if not self._reader:\n                return CompatibilityFiles.OrphanPath(other)\n            return CompatibilityFiles.ChildPath(self._reader, other)\n\n        @property\n        def name(self):\n            return self._spec.name\n\n        def open(self, mode='r', *args, **kwargs):\n            return _io_wrapper(self._reader.open_resource(None), mode, *args, **kwargs)\n\n    class ChildPath(abc.Traversable):\n        \"\"\"\n        Path tied to a resource reader child.\n        Can be read but doesn't expose any meaningful children.\n        \"\"\"\n\n        def __init__(self, reader, name):\n            self._reader = reader\n            self._name = name\n\n        def iterdir(self):\n            return iter(())\n\n        def is_file(self):\n            return self._reader.is_resource(self.name)\n\n        def is_dir(self):\n            return not self.is_file()\n\n        def joinpath(self, other):\n            return CompatibilityFiles.OrphanPath(self.name, other)\n\n        @property\n        def name(self):\n            return self._name\n\n        def open(self, mode='r', *args, **kwargs):\n            return _io_wrapper(\n                self._reader.open_resource(self.name), mode, *args, **kwargs\n            )\n\n    class OrphanPath(abc.Traversable):\n        \"\"\"\n        Orphan path, not tied to a module spec or resource reader.\n        Can't be read and doesn't expose any meaningful children.\n        \"\"\"\n\n        def __init__(self, *path_parts):\n            if len(path_parts) < 1:\n                raise ValueError('Need at least one path part to construct a path')\n            self._path = path_parts\n\n        def iterdir(self):\n            return iter(())\n\n        def is_file(self):\n            return False\n\n        is_dir = is_file\n\n        def joinpath(self, other):\n            return CompatibilityFiles.OrphanPath(*self._path, other)\n\n        @property\n        def name(self):\n            return self._path[-1]\n\n        def open(self, mode='r', *args, **kwargs):\n            raise FileNotFoundError(\"Can't open orphan path\")\n\n    def __init__(self, spec):\n        self.spec = spec\n\n    @property\n    def _reader(self):\n        with suppress(AttributeError):\n            return self.spec.loader.get_resource_reader(self.spec.name)\n\n    def _native(self):\n        \"\"\"\n        Return the native reader if it supports files().\n        \"\"\"\n        reader = self._reader\n        return reader if hasattr(reader, 'files') else self\n\n    def __getattr__(self, attr):\n        return getattr(self._reader, attr)\n\n    def files(self):\n        return CompatibilityFiles.SpecPath(self.spec, self._reader)\n\n\ndef wrap_spec(package):\n    \"\"\"\n    Construct a package spec with traversable compatibility\n    on the spec/loader/reader.\n    \"\"\"\n    return SpecLoaderAdapter(package.__spec__, TraversableResourcesLoader)\n", "setuptools/_vendor/importlib_resources/_compat.py": "# flake8: noqa\n\nimport abc\nimport os\nimport sys\nimport pathlib\nfrom contextlib import suppress\nfrom typing import Union\n\n\nif sys.version_info >= (3, 10):\n    from zipfile import Path as ZipPath  # type: ignore\nelse:\n    from ..zipp import Path as ZipPath  # type: ignore\n\n\ntry:\n    from typing import runtime_checkable  # type: ignore\nexcept ImportError:\n\n    def runtime_checkable(cls):  # type: ignore\n        return cls\n\n\ntry:\n    from typing import Protocol  # type: ignore\nexcept ImportError:\n    Protocol = abc.ABC  # type: ignore\n\n\nclass TraversableResourcesLoader:\n    \"\"\"\n    Adapt loaders to provide TraversableResources and other\n    compatibility.\n\n    Used primarily for Python 3.9 and earlier where the native\n    loaders do not yet implement TraversableResources.\n    \"\"\"\n\n    def __init__(self, spec):\n        self.spec = spec\n\n    @property\n    def path(self):\n        return self.spec.origin\n\n    def get_resource_reader(self, name):\n        from . import readers, _adapters\n\n        def _zip_reader(spec):\n            with suppress(AttributeError):\n                return readers.ZipReader(spec.loader, spec.name)\n\n        def _namespace_reader(spec):\n            with suppress(AttributeError, ValueError):\n                return readers.NamespaceReader(spec.submodule_search_locations)\n\n        def _available_reader(spec):\n            with suppress(AttributeError):\n                return spec.loader.get_resource_reader(spec.name)\n\n        def _native_reader(spec):\n            reader = _available_reader(spec)\n            return reader if hasattr(reader, 'files') else None\n\n        def _file_reader(spec):\n            try:\n                path = pathlib.Path(self.path)\n            except TypeError:\n                return None\n            if path.exists():\n                return readers.FileReader(self)\n\n        return (\n            # native reader if it supplies 'files'\n            _native_reader(self.spec)\n            or\n            # local ZipReader if a zip module\n            _zip_reader(self.spec)\n            or\n            # local NamespaceReader if a namespace module\n            _namespace_reader(self.spec)\n            or\n            # local FileReader\n            _file_reader(self.spec)\n            # fallback - adapt the spec ResourceReader to TraversableReader\n            or _adapters.CompatibilityFiles(self.spec)\n        )\n\n\ndef wrap_spec(package):\n    \"\"\"\n    Construct a package spec with traversable compatibility\n    on the spec/loader/reader.\n\n    Supersedes _adapters.wrap_spec to use TraversableResourcesLoader\n    from above for older Python compatibility (<3.10).\n    \"\"\"\n    from . import _adapters\n\n    return _adapters.SpecLoaderAdapter(package.__spec__, TraversableResourcesLoader)\n\n\nif sys.version_info >= (3, 9):\n    StrPath = Union[str, os.PathLike[str]]\nelse:\n    # PathLike is only subscriptable at runtime in 3.9+\n    StrPath = Union[str, \"os.PathLike[str]\"]\n", "setuptools/_vendor/importlib_resources/__init__.py": "\"\"\"Read resources contained within a package.\"\"\"\n\nfrom ._common import (\n    as_file,\n    files,\n    Package,\n)\n\nfrom ._legacy import (\n    contents,\n    open_binary,\n    read_binary,\n    open_text,\n    read_text,\n    is_resource,\n    path,\n    Resource,\n)\n\nfrom .abc import ResourceReader\n\n\n__all__ = [\n    'Package',\n    'Resource',\n    'ResourceReader',\n    'as_file',\n    'contents',\n    'files',\n    'is_resource',\n    'open_binary',\n    'open_text',\n    'path',\n    'read_binary',\n    'read_text',\n]\n", "setuptools/_vendor/packaging/tags.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport logging\nimport platform\nimport re\nimport struct\nimport subprocess\nimport sys\nimport sysconfig\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom typing import (\n    Dict,\n    FrozenSet,\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    Sequence,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom . import _manylinux, _musllinux\n\nlogger = logging.getLogger(__name__)\n\nPythonVersion = Sequence[int]\nMacVersion = Tuple[int, int]\n\nINTERPRETER_SHORT_NAMES: Dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}\n\n\n_32_BIT_INTERPRETER = struct.calcsize(\"P\") == 4\n\n\nclass Tag:\n    \"\"\"\n    A representation of the tag triple for a wheel.\n\n    Instances are considered immutable and thus are hashable. Equality checking\n    is also supported.\n    \"\"\"\n\n    __slots__ = [\"_interpreter\", \"_abi\", \"_platform\", \"_hash\"]\n\n    def __init__(self, interpreter: str, abi: str, platform: str) -> None:\n        self._interpreter = interpreter.lower()\n        self._abi = abi.lower()\n        self._platform = platform.lower()\n        # The __hash__ of every single element in a Set[Tag] will be evaluated each time\n        # that a set calls its `.disjoint()` method, which may be called hundreds of\n        # times when scanning a page of links for packages with tags matching that\n        # Set[Tag]. Pre-computing the value here produces significant speedups for\n        # downstream consumers.\n        self._hash = hash((self._interpreter, self._abi, self._platform))\n\n    @property\n    def interpreter(self) -> str:\n        return self._interpreter\n\n    @property\n    def abi(self) -> str:\n        return self._abi\n\n    @property\n    def platform(self) -> str:\n        return self._platform\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Tag):\n            return NotImplemented\n\n        return (\n            (self._hash == other._hash)  # Short-circuit ASAP for perf reasons.\n            and (self._platform == other._platform)\n            and (self._abi == other._abi)\n            and (self._interpreter == other._interpreter)\n        )\n\n    def __hash__(self) -> int:\n        return self._hash\n\n    def __str__(self) -> str:\n        return f\"{self._interpreter}-{self._abi}-{self._platform}\"\n\n    def __repr__(self) -> str:\n        return f\"<{self} @ {id(self)}>\"\n\n\ndef parse_tag(tag: str) -> FrozenSet[Tag]:\n    \"\"\"\n    Parses the provided tag (e.g. `py3-none-any`) into a frozenset of Tag instances.\n\n    Returning a set is required due to the possibility that the tag is a\n    compressed tag set.\n    \"\"\"\n    tags = set()\n    interpreters, abis, platforms = tag.split(\"-\")\n    for interpreter in interpreters.split(\".\"):\n        for abi in abis.split(\".\"):\n            for platform_ in platforms.split(\".\"):\n                tags.add(Tag(interpreter, abi, platform_))\n    return frozenset(tags)\n\n\ndef _get_config_var(name: str, warn: bool = False) -> Union[int, str, None]:\n    value: Union[int, str, None] = sysconfig.get_config_var(name)\n    if value is None and warn:\n        logger.debug(\n            \"Config variable '%s' is unset, Python ABI tag may be incorrect\", name\n        )\n    return value\n\n\ndef _normalize_string(string: str) -> str:\n    return string.replace(\".\", \"_\").replace(\"-\", \"_\").replace(\" \", \"_\")\n\n\ndef _is_threaded_cpython(abis: List[str]) -> bool:\n    \"\"\"\n    Determine if the ABI corresponds to a threaded (`--disable-gil`) build.\n\n    The threaded builds are indicated by a \"t\" in the abiflags.\n    \"\"\"\n    if len(abis) == 0:\n        return False\n    # expect e.g., cp313\n    m = re.match(r\"cp\\d+(.*)\", abis[0])\n    if not m:\n        return False\n    abiflags = m.group(1)\n    return \"t\" in abiflags\n\n\ndef _abi3_applies(python_version: PythonVersion, threading: bool) -> bool:\n    \"\"\"\n    Determine if the Python version supports abi3.\n\n    PEP 384 was first implemented in Python 3.2. The threaded (`--disable-gil`)\n    builds do not support abi3.\n    \"\"\"\n    return len(python_version) > 1 and tuple(python_version) >= (3, 2) and not threading\n\n\ndef _cpython_abis(py_version: PythonVersion, warn: bool = False) -> List[str]:\n    py_version = tuple(py_version)  # To allow for version comparison.\n    abis = []\n    version = _version_nodot(py_version[:2])\n    threading = debug = pymalloc = ucs4 = \"\"\n    with_debug = _get_config_var(\"Py_DEBUG\", warn)\n    has_refcount = hasattr(sys, \"gettotalrefcount\")\n    # Windows doesn't set Py_DEBUG, so checking for support of debug-compiled\n    # extension modules is the best option.\n    # https://github.com/pypa/pip/issues/3383#issuecomment-173267692\n    has_ext = \"_d.pyd\" in EXTENSION_SUFFIXES\n    if with_debug or (with_debug is None and (has_refcount or has_ext)):\n        debug = \"d\"\n    if py_version >= (3, 13) and _get_config_var(\"Py_GIL_DISABLED\", warn):\n        threading = \"t\"\n    if py_version < (3, 8):\n        with_pymalloc = _get_config_var(\"WITH_PYMALLOC\", warn)\n        if with_pymalloc or with_pymalloc is None:\n            pymalloc = \"m\"\n        if py_version < (3, 3):\n            unicode_size = _get_config_var(\"Py_UNICODE_SIZE\", warn)\n            if unicode_size == 4 or (\n                unicode_size is None and sys.maxunicode == 0x10FFFF\n            ):\n                ucs4 = \"u\"\n    elif debug:\n        # Debug builds can also load \"normal\" extension modules.\n        # We can also assume no UCS-4 or pymalloc requirement.\n        abis.append(f\"cp{version}{threading}\")\n    abis.insert(0, f\"cp{version}{threading}{debug}{pymalloc}{ucs4}\")\n    return abis\n\n\ndef cpython_tags(\n    python_version: Optional[PythonVersion] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a CPython interpreter.\n\n    The tags consist of:\n    - cp<python_version>-<abi>-<platform>\n    - cp<python_version>-abi3-<platform>\n    - cp<python_version>-none-<platform>\n    - cp<less than python_version>-abi3-<platform>  # Older Python versions down to 3.2.\n\n    If python_version only specifies a major version then user-provided ABIs and\n    the 'none' ABItag will be used.\n\n    If 'abi3' or 'none' are specified in 'abis' then they will be yielded at\n    their normal position and not at the beginning.\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n\n    interpreter = f\"cp{_version_nodot(python_version[:2])}\"\n\n    if abis is None:\n        if len(python_version) > 1:\n            abis = _cpython_abis(python_version, warn)\n        else:\n            abis = []\n    abis = list(abis)\n    # 'abi3' and 'none' are explicitly handled later.\n    for explicit_abi in (\"abi3\", \"none\"):\n        try:\n            abis.remove(explicit_abi)\n        except ValueError:\n            pass\n\n    platforms = list(platforms or platform_tags())\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n    threading = _is_threaded_cpython(abis)\n    use_abi3 = _abi3_applies(python_version, threading)\n    if use_abi3:\n        yield from (Tag(interpreter, \"abi3\", platform_) for platform_ in platforms)\n    yield from (Tag(interpreter, \"none\", platform_) for platform_ in platforms)\n\n    if use_abi3:\n        for minor_version in range(python_version[1] - 1, 1, -1):\n            for platform_ in platforms:\n                interpreter = \"cp{version}\".format(\n                    version=_version_nodot((python_version[0], minor_version))\n                )\n                yield Tag(interpreter, \"abi3\", platform_)\n\n\ndef _generic_abi() -> List[str]:\n    \"\"\"\n    Return the ABI tag based on EXT_SUFFIX.\n    \"\"\"\n    # The following are examples of `EXT_SUFFIX`.\n    # We want to keep the parts which are related to the ABI and remove the\n    # parts which are related to the platform:\n    # - linux:   '.cpython-310-x86_64-linux-gnu.so' => cp310\n    # - mac:     '.cpython-310-darwin.so'           => cp310\n    # - win:     '.cp310-win_amd64.pyd'             => cp310\n    # - win:     '.pyd'                             => cp37 (uses _cpython_abis())\n    # - pypy:    '.pypy38-pp73-x86_64-linux-gnu.so' => pypy38_pp73\n    # - graalpy: '.graalpy-38-native-x86_64-darwin.dylib'\n    #                                               => graalpy_38_native\n\n    ext_suffix = _get_config_var(\"EXT_SUFFIX\", warn=True)\n    if not isinstance(ext_suffix, str) or ext_suffix[0] != \".\":\n        raise SystemError(\"invalid sysconfig.get_config_var('EXT_SUFFIX')\")\n    parts = ext_suffix.split(\".\")\n    if len(parts) < 3:\n        # CPython3.7 and earlier uses \".pyd\" on Windows.\n        return _cpython_abis(sys.version_info[:2])\n    soabi = parts[1]\n    if soabi.startswith(\"cpython\"):\n        # non-windows\n        abi = \"cp\" + soabi.split(\"-\")[1]\n    elif soabi.startswith(\"cp\"):\n        # windows\n        abi = soabi.split(\"-\")[0]\n    elif soabi.startswith(\"pypy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:2])\n    elif soabi.startswith(\"graalpy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:3])\n    elif soabi:\n        # pyston, ironpython, others?\n        abi = soabi\n    else:\n        return []\n    return [_normalize_string(abi)]\n\n\ndef generic_tags(\n    interpreter: Optional[str] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a generic interpreter.\n\n    The tags consist of:\n    - <interpreter>-<abi>-<platform>\n\n    The \"none\" ABI will be added if it was not explicitly provided.\n    \"\"\"\n    if not interpreter:\n        interp_name = interpreter_name()\n        interp_version = interpreter_version(warn=warn)\n        interpreter = \"\".join([interp_name, interp_version])\n    if abis is None:\n        abis = _generic_abi()\n    else:\n        abis = list(abis)\n    platforms = list(platforms or platform_tags())\n    if \"none\" not in abis:\n        abis.append(\"none\")\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n\ndef _py_interpreter_range(py_version: PythonVersion) -> Iterator[str]:\n    \"\"\"\n    Yields Python versions in descending order.\n\n    After the latest version, the major-only version will be yielded, and then\n    all previous versions of that major version.\n    \"\"\"\n    if len(py_version) > 1:\n        yield f\"py{_version_nodot(py_version[:2])}\"\n    yield f\"py{py_version[0]}\"\n    if len(py_version) > 1:\n        for minor in range(py_version[1] - 1, -1, -1):\n            yield f\"py{_version_nodot((py_version[0], minor))}\"\n\n\ndef compatible_tags(\n    python_version: Optional[PythonVersion] = None,\n    interpreter: Optional[str] = None,\n    platforms: Optional[Iterable[str]] = None,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the sequence of tags that are compatible with a specific version of Python.\n\n    The tags consist of:\n    - py*-none-<platform>\n    - <interpreter>-none-any  # ... if `interpreter` is provided.\n    - py*-none-any\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n    platforms = list(platforms or platform_tags())\n    for version in _py_interpreter_range(python_version):\n        for platform_ in platforms:\n            yield Tag(version, \"none\", platform_)\n    if interpreter:\n        yield Tag(interpreter, \"none\", \"any\")\n    for version in _py_interpreter_range(python_version):\n        yield Tag(version, \"none\", \"any\")\n\n\ndef _mac_arch(arch: str, is_32bit: bool = _32_BIT_INTERPRETER) -> str:\n    if not is_32bit:\n        return arch\n\n    if arch.startswith(\"ppc\"):\n        return \"ppc\"\n\n    return \"i386\"\n\n\ndef _mac_binary_formats(version: MacVersion, cpu_arch: str) -> List[str]:\n    formats = [cpu_arch]\n    if cpu_arch == \"x86_64\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat64\", \"fat32\"])\n\n    elif cpu_arch == \"i386\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat32\", \"fat\"])\n\n    elif cpu_arch == \"ppc64\":\n        # TODO: Need to care about 32-bit PPC for ppc64 through 10.2?\n        if version > (10, 5) or version < (10, 4):\n            return []\n        formats.append(\"fat64\")\n\n    elif cpu_arch == \"ppc\":\n        if version > (10, 6):\n            return []\n        formats.extend([\"fat32\", \"fat\"])\n\n    if cpu_arch in {\"arm64\", \"x86_64\"}:\n        formats.append(\"universal2\")\n\n    if cpu_arch in {\"x86_64\", \"i386\", \"ppc64\", \"ppc\", \"intel\"}:\n        formats.append(\"universal\")\n\n    return formats\n\n\ndef mac_platforms(\n    version: Optional[MacVersion] = None, arch: Optional[str] = None\n) -> Iterator[str]:\n    \"\"\"\n    Yields the platform tags for a macOS system.\n\n    The `version` parameter is a two-item tuple specifying the macOS version to\n    generate platform tags for. The `arch` parameter is the CPU architecture to\n    generate platform tags for. Both parameters default to the appropriate value\n    for the current system.\n    \"\"\"\n    version_str, _, cpu_arch = platform.mac_ver()\n    if version is None:\n        version = cast(\"MacVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n        if version == (10, 16):\n            # When built against an older macOS SDK, Python will report macOS 10.16\n            # instead of the real version.\n            version_str = subprocess.run(\n                [\n                    sys.executable,\n                    \"-sS\",\n                    \"-c\",\n                    \"import platform; print(platform.mac_ver()[0])\",\n                ],\n                check=True,\n                env={\"SYSTEM_VERSION_COMPAT\": \"0\"},\n                stdout=subprocess.PIPE,\n                text=True,\n            ).stdout\n            version = cast(\"MacVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n    else:\n        version = version\n    if arch is None:\n        arch = _mac_arch(cpu_arch)\n    else:\n        arch = arch\n\n    if (10, 0) <= version and version < (11, 0):\n        # Prior to Mac OS 11, each yearly release of Mac OS bumped the\n        # \"minor\" version number.  The major version was always 10.\n        for minor_version in range(version[1], -1, -1):\n            compat_version = 10, minor_version\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=10, minor=minor_version, binary_format=binary_format\n                )\n\n    if version >= (11, 0):\n        # Starting with Mac OS 11, each yearly release bumps the major version\n        # number.   The minor versions are now the midyear updates.\n        for major_version in range(version[0], 10, -1):\n            compat_version = major_version, 0\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=major_version, minor=0, binary_format=binary_format\n                )\n\n    if version >= (11, 0):\n        # Mac OS 11 on x86_64 is compatible with binaries from previous releases.\n        # Arm64 support was introduced in 11.0, so no Arm binaries from previous\n        # releases exist.\n        #\n        # However, the \"universal2\" binary format can have a\n        # macOS version earlier than 11.0 when the x86_64 part of the binary supports\n        # that version of macOS.\n        if arch == \"x86_64\":\n            for minor_version in range(16, 3, -1):\n                compat_version = 10, minor_version\n                binary_formats = _mac_binary_formats(compat_version, arch)\n                for binary_format in binary_formats:\n                    yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                        major=compat_version[0],\n                        minor=compat_version[1],\n                        binary_format=binary_format,\n                    )\n        else:\n            for minor_version in range(16, 3, -1):\n                compat_version = 10, minor_version\n                binary_format = \"universal2\"\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=compat_version[0],\n                    minor=compat_version[1],\n                    binary_format=binary_format,\n                )\n\n\ndef _linux_platforms(is_32bit: bool = _32_BIT_INTERPRETER) -> Iterator[str]:\n    linux = _normalize_string(sysconfig.get_platform())\n    if not linux.startswith(\"linux_\"):\n        # we should never be here, just yield the sysconfig one and return\n        yield linux\n        return\n    if is_32bit:\n        if linux == \"linux_x86_64\":\n            linux = \"linux_i686\"\n        elif linux == \"linux_aarch64\":\n            linux = \"linux_armv8l\"\n    _, arch = linux.split(\"_\", 1)\n    archs = {\"armv8l\": [\"armv8l\", \"armv7l\"]}.get(arch, [arch])\n    yield from _manylinux.platform_tags(archs)\n    yield from _musllinux.platform_tags(archs)\n    for arch in archs:\n        yield f\"linux_{arch}\"\n\n\ndef _generic_platforms() -> Iterator[str]:\n    yield _normalize_string(sysconfig.get_platform())\n\n\ndef platform_tags() -> Iterator[str]:\n    \"\"\"\n    Provides the platform tags for this installation.\n    \"\"\"\n    if platform.system() == \"Darwin\":\n        return mac_platforms()\n    elif platform.system() == \"Linux\":\n        return _linux_platforms()\n    else:\n        return _generic_platforms()\n\n\ndef interpreter_name() -> str:\n    \"\"\"\n    Returns the name of the running interpreter.\n\n    Some implementations have a reserved, two-letter abbreviation which will\n    be returned when appropriate.\n    \"\"\"\n    name = sys.implementation.name\n    return INTERPRETER_SHORT_NAMES.get(name) or name\n\n\ndef interpreter_version(*, warn: bool = False) -> str:\n    \"\"\"\n    Returns the version of the running interpreter.\n    \"\"\"\n    version = _get_config_var(\"py_version_nodot\", warn=warn)\n    if version:\n        version = str(version)\n    else:\n        version = _version_nodot(sys.version_info[:2])\n    return version\n\n\ndef _version_nodot(version: PythonVersion) -> str:\n    return \"\".join(map(str, version))\n\n\ndef sys_tags(*, warn: bool = False) -> Iterator[Tag]:\n    \"\"\"\n    Returns the sequence of tag triples for the running interpreter.\n\n    The order of the sequence corresponds to priority order for the\n    interpreter, from most to least important.\n    \"\"\"\n\n    interp_name = interpreter_name()\n    if interp_name == \"cp\":\n        yield from cpython_tags(warn=warn)\n    else:\n        yield from generic_tags()\n\n    if interp_name == \"pp\":\n        interp = \"pp3\"\n    elif interp_name == \"cp\":\n        interp = \"cp\" + interpreter_version(warn=warn)\n    else:\n        interp = None\n    yield from compatible_tags(interpreter=interp)\n", "setuptools/_vendor/packaging/_musllinux.py": "\"\"\"PEP 656 support.\n\nThis module implements logic to detect if the currently running Python is\nlinked against musl, and what musl version is used.\n\"\"\"\n\nimport functools\nimport re\nimport subprocess\nimport sys\nfrom typing import Iterator, NamedTuple, Optional, Sequence\n\nfrom ._elffile import ELFFile\n\n\nclass _MuslVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _parse_musl_version(output: str) -> Optional[_MuslVersion]:\n    lines = [n for n in (n.strip() for n in output.splitlines()) if n]\n    if len(lines) < 2 or lines[0][:4] != \"musl\":\n        return None\n    m = re.match(r\"Version (\\d+)\\.(\\d+)\", lines[1])\n    if not m:\n        return None\n    return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))\n\n\n@functools.lru_cache()\ndef _get_musl_version(executable: str) -> Optional[_MuslVersion]:\n    \"\"\"Detect currently-running musl runtime version.\n\n    This is done by checking the specified executable's dynamic linking\n    information, and invoking the loader to parse its output for a version\n    string. If the loader is musl, the output would be something like::\n\n        musl libc (x86_64)\n        Version 1.2.2\n        Dynamic Program Loader\n    \"\"\"\n    try:\n        with open(executable, \"rb\") as f:\n            ld = ELFFile(f).interpreter\n    except (OSError, TypeError, ValueError):\n        return None\n    if ld is None or \"musl\" not in ld:\n        return None\n    proc = subprocess.run([ld], stderr=subprocess.PIPE, text=True)\n    return _parse_musl_version(proc.stderr)\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate musllinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be musllinux-compatible.\n\n    :returns: An iterator of compatible musllinux tags.\n    \"\"\"\n    sys_musl = _get_musl_version(sys.executable)\n    if sys_musl is None:  # Python not dynamically linked against musl.\n        return\n    for arch in archs:\n        for minor in range(sys_musl.minor, -1, -1):\n            yield f\"musllinux_{sys_musl.major}_{minor}_{arch}\"\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import sysconfig\n\n    plat = sysconfig.get_platform()\n    assert plat.startswith(\"linux-\"), \"not linux\"\n\n    print(\"plat:\", plat)\n    print(\"musl:\", _get_musl_version(sys.executable))\n    print(\"tags:\", end=\" \")\n    for t in platform_tags(re.sub(r\"[.-]\", \"_\", plat.split(\"-\", 1)[-1])):\n        print(t, end=\"\\n      \")\n", "setuptools/_vendor/packaging/_manylinux.py": "import collections\nimport contextlib\nimport functools\nimport os\nimport re\nimport sys\nimport warnings\nfrom typing import Dict, Generator, Iterator, NamedTuple, Optional, Sequence, Tuple\n\nfrom ._elffile import EIClass, EIData, ELFFile, EMachine\n\nEF_ARM_ABIMASK = 0xFF000000\nEF_ARM_ABI_VER5 = 0x05000000\nEF_ARM_ABI_FLOAT_HARD = 0x00000400\n\n\n# `os.PathLike` not a generic type until Python 3.9, so sticking with `str`\n# as the type for `path` until then.\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[Optional[ELFFile], None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None\n\n\ndef _is_linux_armhf(executable: str) -> bool:\n    # hard-float ABI can be detected from the ELF header of the running\n    # process\n    # https://static.docs.arm.com/ihi0044/g/aaelf32.pdf\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.Arm\n            and f.flags & EF_ARM_ABIMASK == EF_ARM_ABI_VER5\n            and f.flags & EF_ARM_ABI_FLOAT_HARD == EF_ARM_ABI_FLOAT_HARD\n        )\n\n\ndef _is_linux_i686(executable: str) -> bool:\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.I386\n        )\n\n\ndef _have_compatible_abi(executable: str, archs: Sequence[str]) -> bool:\n    if \"armv7l\" in archs:\n        return _is_linux_armhf(executable)\n    if \"i686\" in archs:\n        return _is_linux_i686(executable)\n    allowed_archs = {\n        \"x86_64\",\n        \"aarch64\",\n        \"ppc64\",\n        \"ppc64le\",\n        \"s390x\",\n        \"loongarch64\",\n        \"riscv64\",\n    }\n    return any(arch in allowed_archs for arch in archs)\n\n\n# If glibc ever changes its major version, we need to know what the last\n# minor version was, so we can build the complete list of all versions.\n# For now, guess what the highest minor version might be, assume it will\n# be 50 for testing. Once this actually happens, update the dictionary\n# with the actual value.\n_LAST_GLIBC_MINOR: Dict[int, int] = collections.defaultdict(lambda: 50)\n\n\nclass _GLibCVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _glibc_version_string_confstr() -> Optional[str]:\n    \"\"\"\n    Primary implementation of glibc_version_string using os.confstr.\n    \"\"\"\n    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely\n    # to be broken or missing. This strategy is used in the standard library\n    # platform module.\n    # https://github.com/python/cpython/blob/fcf1d003bf4f0100c/Lib/platform.py#L175-L183\n    try:\n        # Should be a string like \"glibc 2.17\".\n        version_string: Optional[str] = os.confstr(\"CS_GNU_LIBC_VERSION\")\n        assert version_string is not None\n        _, version = version_string.rsplit()\n    except (AssertionError, AttributeError, OSError, ValueError):\n        # os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)...\n        return None\n    return version\n\n\ndef _glibc_version_string_ctypes() -> Optional[str]:\n    \"\"\"\n    Fallback implementation of glibc_version_string using ctypes.\n    \"\"\"\n    try:\n        import ctypes\n    except ImportError:\n        return None\n\n    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen\n    # manpage says, \"If filename is NULL, then the returned handle is for the\n    # main program\". This way we can let the linker do the work to figure out\n    # which libc our process is actually using.\n    #\n    # We must also handle the special case where the executable is not a\n    # dynamically linked executable. This can occur when using musl libc,\n    # for example. In this situation, dlopen() will error, leading to an\n    # OSError. Interestingly, at least in the case of musl, there is no\n    # errno set on the OSError. The single string argument used to construct\n    # OSError comes from libc itself and is therefore not portable to\n    # hard code here. In any case, failure to call dlopen() means we\n    # can proceed, so we bail on our attempt.\n    try:\n        process_namespace = ctypes.CDLL(None)\n    except OSError:\n        return None\n\n    try:\n        gnu_get_libc_version = process_namespace.gnu_get_libc_version\n    except AttributeError:\n        # Symbol doesn't exist -> therefore, we are not linked to\n        # glibc.\n        return None\n\n    # Call gnu_get_libc_version, which returns a string like \"2.5\"\n    gnu_get_libc_version.restype = ctypes.c_char_p\n    version_str: str = gnu_get_libc_version()\n    # py2 / py3 compatibility:\n    if not isinstance(version_str, str):\n        version_str = version_str.decode(\"ascii\")\n\n    return version_str\n\n\ndef _glibc_version_string() -> Optional[str]:\n    \"\"\"Returns glibc version string, or None if not using glibc.\"\"\"\n    return _glibc_version_string_confstr() or _glibc_version_string_ctypes()\n\n\ndef _parse_glibc_version(version_str: str) -> Tuple[int, int]:\n    \"\"\"Parse glibc version.\n\n    We use a regexp instead of str.split because we want to discard any\n    random junk that might come after the minor version -- this might happen\n    in patched/forked versions of glibc (e.g. Linaro's version of glibc\n    uses version strings like \"2.20-2014.11\"). See gh-3588.\n    \"\"\"\n    m = re.match(r\"(?P<major>[0-9]+)\\.(?P<minor>[0-9]+)\", version_str)\n    if not m:\n        warnings.warn(\n            f\"Expected glibc version with 2 components major.minor,\"\n            f\" got: {version_str}\",\n            RuntimeWarning,\n        )\n        return -1, -1\n    return int(m.group(\"major\")), int(m.group(\"minor\"))\n\n\n@functools.lru_cache()\ndef _get_glibc_version() -> Tuple[int, int]:\n    version_str = _glibc_version_string()\n    if version_str is None:\n        return (-1, -1)\n    return _parse_glibc_version(version_str)\n\n\n# From PEP 513, PEP 600\ndef _is_compatible(arch: str, version: _GLibCVersion) -> bool:\n    sys_glibc = _get_glibc_version()\n    if sys_glibc < version:\n        return False\n    # Check for presence of _manylinux module.\n    try:\n        import _manylinux\n    except ImportError:\n        return True\n    if hasattr(_manylinux, \"manylinux_compatible\"):\n        result = _manylinux.manylinux_compatible(version[0], version[1], arch)\n        if result is not None:\n            return bool(result)\n        return True\n    if version == _GLibCVersion(2, 5):\n        if hasattr(_manylinux, \"manylinux1_compatible\"):\n            return bool(_manylinux.manylinux1_compatible)\n    if version == _GLibCVersion(2, 12):\n        if hasattr(_manylinux, \"manylinux2010_compatible\"):\n            return bool(_manylinux.manylinux2010_compatible)\n    if version == _GLibCVersion(2, 17):\n        if hasattr(_manylinux, \"manylinux2014_compatible\"):\n            return bool(_manylinux.manylinux2014_compatible)\n    return True\n\n\n_LEGACY_MANYLINUX_MAP = {\n    # CentOS 7 w/ glibc 2.17 (PEP 599)\n    (2, 17): \"manylinux2014\",\n    # CentOS 6 w/ glibc 2.12 (PEP 571)\n    (2, 12): \"manylinux2010\",\n    # CentOS 5 w/ glibc 2.5 (PEP 513)\n    (2, 5): \"manylinux1\",\n}\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate manylinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be manylinux-compatible.\n\n    :returns: An iterator of compatible manylinux tags.\n    \"\"\"\n    if not _have_compatible_abi(sys.executable, archs):\n        return\n    # Oldest glibc to be supported regardless of architecture is (2, 17).\n    too_old_glibc2 = _GLibCVersion(2, 16)\n    if set(archs) & {\"x86_64\", \"i686\"}:\n        # On x86/i686 also oldest glibc to be supported is (2, 5).\n        too_old_glibc2 = _GLibCVersion(2, 4)\n    current_glibc = _GLibCVersion(*_get_glibc_version())\n    glibc_max_list = [current_glibc]\n    # We can assume compatibility across glibc major versions.\n    # https://sourceware.org/bugzilla/show_bug.cgi?id=24636\n    #\n    # Build a list of maximum glibc versions so that we can\n    # output the canonical list of all glibc from current_glibc\n    # down to too_old_glibc2, including all intermediary versions.\n    for glibc_major in range(current_glibc.major - 1, 1, -1):\n        glibc_minor = _LAST_GLIBC_MINOR[glibc_major]\n        glibc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))\n    for arch in archs:\n        for glibc_max in glibc_max_list:\n            if glibc_max.major == too_old_glibc2.major:\n                min_minor = too_old_glibc2.minor\n            else:\n                # For other glibc major versions oldest supported is (x, 0).\n                min_minor = -1\n            for glibc_minor in range(glibc_max.minor, min_minor, -1):\n                glibc_version = _GLibCVersion(glibc_max.major, glibc_minor)\n                tag = \"manylinux_{}_{}\".format(*glibc_version)\n                if _is_compatible(arch, glibc_version):\n                    yield f\"{tag}_{arch}\"\n                # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.\n                if glibc_version in _LEGACY_MANYLINUX_MAP:\n                    legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]\n                    if _is_compatible(arch, glibc_version):\n                        yield f\"{legacy_tag}_{arch}\"\n", "setuptools/_vendor/packaging/_tokenizer.py": "import contextlib\nimport re\nfrom dataclasses import dataclass\nfrom typing import Dict, Iterator, NoReturn, Optional, Tuple, Union\n\nfrom .specifiers import Specifier\n\n\n@dataclass\nclass Token:\n    name: str\n    text: str\n    position: int\n\n\nclass ParserSyntaxError(Exception):\n    \"\"\"The provided source text could not be parsed correctly.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        source: str,\n        span: Tuple[int, int],\n    ) -> None:\n        self.span = span\n        self.message = message\n        self.source = source\n\n        super().__init__()\n\n    def __str__(self) -> str:\n        marker = \" \" * self.span[0] + \"~\" * (self.span[1] - self.span[0]) + \"^\"\n        return \"\\n    \".join([self.message, self.source, marker])\n\n\nDEFAULT_RULES: \"Dict[str, Union[str, re.Pattern[str]]]\" = {\n    \"LEFT_PARENTHESIS\": r\"\\(\",\n    \"RIGHT_PARENTHESIS\": r\"\\)\",\n    \"LEFT_BRACKET\": r\"\\[\",\n    \"RIGHT_BRACKET\": r\"\\]\",\n    \"SEMICOLON\": r\";\",\n    \"COMMA\": r\",\",\n    \"QUOTED_STRING\": re.compile(\n        r\"\"\"\n            (\n                ('[^']*')\n                |\n                (\"[^\"]*\")\n            )\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"OP\": r\"(===|==|~=|!=|<=|>=|<|>)\",\n    \"BOOLOP\": r\"\\b(or|and)\\b\",\n    \"IN\": r\"\\bin\\b\",\n    \"NOT\": r\"\\bnot\\b\",\n    \"VARIABLE\": re.compile(\n        r\"\"\"\n            \\b(\n                python_version\n                |python_full_version\n                |os[._]name\n                |sys[._]platform\n                |platform_(release|system)\n                |platform[._](version|machine|python_implementation)\n                |python_implementation\n                |implementation_(name|version)\n                |extra\n            )\\b\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"SPECIFIER\": re.compile(\n        Specifier._operator_regex_str + Specifier._version_regex_str,\n        re.VERBOSE | re.IGNORECASE,\n    ),\n    \"AT\": r\"\\@\",\n    \"URL\": r\"[^ \\t]+\",\n    \"IDENTIFIER\": r\"\\b[a-zA-Z0-9][a-zA-Z0-9._-]*\\b\",\n    \"VERSION_PREFIX_TRAIL\": r\"\\.\\*\",\n    \"VERSION_LOCAL_LABEL_TRAIL\": r\"\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*\",\n    \"WS\": r\"[ \\t]+\",\n    \"END\": r\"$\",\n}\n\n\nclass Tokenizer:\n    \"\"\"Context-sensitive token parsing.\n\n    Provides methods to examine the input stream to check whether the next token\n    matches.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        *,\n        rules: \"Dict[str, Union[str, re.Pattern[str]]]\",\n    ) -> None:\n        self.source = source\n        self.rules: Dict[str, re.Pattern[str]] = {\n            name: re.compile(pattern) for name, pattern in rules.items()\n        }\n        self.next_token: Optional[Token] = None\n        self.position = 0\n\n    def consume(self, name: str) -> None:\n        \"\"\"Move beyond provided token name, if at current position.\"\"\"\n        if self.check(name):\n            self.read()\n\n    def check(self, name: str, *, peek: bool = False) -> bool:\n        \"\"\"Check whether the next token has the provided name.\n\n        By default, if the check succeeds, the token *must* be read before\n        another check. If `peek` is set to `True`, the token is not loaded and\n        would need to be checked again.\n        \"\"\"\n        assert (\n            self.next_token is None\n        ), f\"Cannot check for {name!r}, already have {self.next_token!r}\"\n        assert name in self.rules, f\"Unknown token name: {name!r}\"\n\n        expression = self.rules[name]\n\n        match = expression.match(self.source, self.position)\n        if match is None:\n            return False\n        if not peek:\n            self.next_token = Token(name, match[0], self.position)\n        return True\n\n    def expect(self, name: str, *, expected: str) -> Token:\n        \"\"\"Expect a certain token name next, failing with a syntax error otherwise.\n\n        The token is *not* read.\n        \"\"\"\n        if not self.check(name):\n            raise self.raise_syntax_error(f\"Expected {expected}\")\n        return self.read()\n\n    def read(self) -> Token:\n        \"\"\"Consume the next token and return it.\"\"\"\n        token = self.next_token\n        assert token is not None\n\n        self.position += len(token.text)\n        self.next_token = None\n\n        return token\n\n    def raise_syntax_error(\n        self,\n        message: str,\n        *,\n        span_start: Optional[int] = None,\n        span_end: Optional[int] = None,\n    ) -> NoReturn:\n        \"\"\"Raise ParserSyntaxError at the given position.\"\"\"\n        span = (\n            self.position if span_start is None else span_start,\n            self.position if span_end is None else span_end,\n        )\n        raise ParserSyntaxError(\n            message,\n            source=self.source,\n            span=span,\n        )\n\n    @contextlib.contextmanager\n    def enclosing_tokens(\n        self, open_token: str, close_token: str, *, around: str\n    ) -> Iterator[None]:\n        if self.check(open_token):\n            open_position = self.position\n            self.read()\n        else:\n            open_position = None\n\n        yield\n\n        if open_position is None:\n            return\n\n        if not self.check(close_token):\n            self.raise_syntax_error(\n                f\"Expected matching {close_token} for {open_token}, after {around}\",\n                span_start=open_position,\n            )\n\n        self.read()\n", "setuptools/_vendor/packaging/_structures.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nclass InfinityType:\n    def __repr__(self) -> str:\n        return \"Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return False\n\n    def __le__(self, other: object) -> bool:\n        return False\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return True\n\n    def __ge__(self, other: object) -> bool:\n        return True\n\n    def __neg__(self: object) -> \"NegativeInfinityType\":\n        return NegativeInfinity\n\n\nInfinity = InfinityType()\n\n\nclass NegativeInfinityType:\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return True\n\n    def __le__(self, other: object) -> bool:\n        return True\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return False\n\n    def __ge__(self, other: object) -> bool:\n        return False\n\n    def __neg__(self: object) -> InfinityType:\n        return Infinity\n\n\nNegativeInfinity = NegativeInfinityType()\n", "setuptools/_vendor/packaging/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport re\nfrom typing import FrozenSet, NewType, Tuple, Union, cast\n\nfrom .tags import Tag, parse_tag\nfrom .version import InvalidVersion, Version\n\nBuildTag = Union[Tuple[()], Tuple[int, str]]\nNormalizedName = NewType(\"NormalizedName\", str)\n\n\nclass InvalidName(ValueError):\n    \"\"\"\n    An invalid distribution name; users should refer to the packaging user guide.\n    \"\"\"\n\n\nclass InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\n\n\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n\n\n# Core metadata spec for `Name`\n_validate_regex = re.compile(\n    r\"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$\", re.IGNORECASE\n)\n_canonicalize_regex = re.compile(r\"[-_.]+\")\n_normalized_regex = re.compile(r\"^([a-z0-9]|[a-z0-9]([a-z0-9-](?!--))*[a-z0-9])$\")\n# PEP 427: The build number must start with a digit.\n_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\n\n\ndef canonicalize_name(name: str, *, validate: bool = False) -> NormalizedName:\n    if validate and not _validate_regex.match(name):\n        raise InvalidName(f\"name is invalid: {name!r}\")\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\n\n\ndef is_normalized_name(name: str) -> bool:\n    return _normalized_regex.match(name) is not None\n\n\ndef canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    This is very similar to Version.__str__, but has one subtle difference\n    with the way it handles the release segment.\n    \"\"\"\n    if isinstance(version, str):\n        try:\n            parsed = Version(version)\n        except InvalidVersion:\n            # Legacy versions cannot be normalized\n            return version\n    else:\n        parsed = version\n\n    parts = []\n\n    # Epoch\n    if parsed.epoch != 0:\n        parts.append(f\"{parsed.epoch}!\")\n\n    # Release segment\n    release_segment = \".\".join(str(x) for x in parsed.release)\n    if strip_trailing_zero:\n        # NB: This strips trailing '.0's to normalize\n        release_segment = re.sub(r\"(\\.0)+$\", \"\", release_segment)\n    parts.append(release_segment)\n\n    # Pre-release\n    if parsed.pre is not None:\n        parts.append(\"\".join(str(x) for x in parsed.pre))\n\n    # Post-release\n    if parsed.post is not None:\n        parts.append(f\".post{parsed.post}\")\n\n    # Development release\n    if parsed.dev is not None:\n        parts.append(f\".dev{parsed.dev}\")\n\n    # Local version segment\n    if parsed.local is not None:\n        parts.append(f\"+{parsed.local}\")\n\n    return \"\".join(parts)\n\n\ndef parse_wheel_filename(\n    filename: str,\n) -> Tuple[NormalizedName, Version, BuildTag, FrozenSet[Tag]]:\n    if not filename.endswith(\".whl\"):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (extension must be '.whl'): {filename}\"\n        )\n\n    filename = filename[:-4]\n    dashes = filename.count(\"-\")\n    if dashes not in (4, 5):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (wrong number of parts): {filename}\"\n        )\n\n    parts = filename.split(\"-\", dashes - 2)\n    name_part = parts[0]\n    # See PEP 427 for the rules on escaping the project name.\n    if \"__\" in name_part or re.match(r\"^[\\w\\d._]*$\", name_part, re.UNICODE) is None:\n        raise InvalidWheelFilename(f\"Invalid project name: {filename}\")\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(parts[1])\n    except InvalidVersion as e:\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (invalid version): {filename}\"\n        ) from e\n\n    if dashes == 5:\n        build_part = parts[2]\n        build_match = _build_tag_regex.match(build_part)\n        if build_match is None:\n            raise InvalidWheelFilename(\n                f\"Invalid build number: {build_part} in '{filename}'\"\n            )\n        build = cast(BuildTag, (int(build_match.group(1)), build_match.group(2)))\n    else:\n        build = ()\n    tags = parse_tag(parts[-1])\n    return (name, version, build, tags)\n\n\ndef parse_sdist_filename(filename: str) -> Tuple[NormalizedName, Version]:\n    if filename.endswith(\".tar.gz\"):\n        file_stem = filename[: -len(\".tar.gz\")]\n    elif filename.endswith(\".zip\"):\n        file_stem = filename[: -len(\".zip\")]\n    else:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (extension must be '.tar.gz' or '.zip'):\"\n            f\" {filename}\"\n        )\n\n    # We are requiring a PEP 440 version, which cannot contain dashes,\n    # so we split on the last dash.\n    name_part, sep, version_part = file_stem.rpartition(\"-\")\n    if not sep:\n        raise InvalidSdistFilename(f\"Invalid sdist filename: {filename}\")\n\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(version_part)\n    except InvalidVersion as e:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (invalid version): {filename}\"\n        ) from e\n\n    return (name, version)\n", "setuptools/_vendor/packaging/version.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.version import parse, Version\n\"\"\"\n\nimport itertools\nimport re\nfrom typing import Any, Callable, NamedTuple, Optional, SupportsInt, Tuple, Union\n\nfrom ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType\n\n__all__ = [\"VERSION_PATTERN\", \"parse\", \"Version\", \"InvalidVersion\"]\n\nLocalType = Tuple[Union[int, str], ...]\n\nCmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]\nCmpLocalType = Union[\n    NegativeInfinityType,\n    Tuple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], ...],\n]\nCmpKey = Tuple[\n    int,\n    Tuple[int, ...],\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpLocalType,\n]\nVersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n\n\nclass _Version(NamedTuple):\n    epoch: int\n    release: Tuple[int, ...]\n    dev: Optional[Tuple[str, int]]\n    pre: Optional[Tuple[str, int]]\n    post: Optional[Tuple[str, int]]\n    local: Optional[LocalType]\n\n\ndef parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"\n    return Version(version)\n\n\nclass InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.\n\n    >>> Version(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.version.InvalidVersion: Invalid version: 'invalid'\n    \"\"\"\n\n\nclass _BaseVersion:\n    _key: Tuple[Any, ...]\n\n    def __hash__(self) -> int:\n        return hash(self._key)\n\n    # Please keep the duplicated `isinstance` check\n    # in the six comparisons hereunder\n    # unless you find a way to avoid adding overhead function calls.\n    def __lt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key < other._key\n\n    def __le__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key <= other._key\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key == other._key\n\n    def __ge__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key >= other._key\n\n    def __gt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key > other._key\n\n    def __ne__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key != other._key\n\n\n# Deliberately not anchored to the start and end of the string, to make it\n# easier for 3rd party code to reuse\n_VERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>alpha|a|beta|b|preview|pre|c|rc)\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\\.]?\n                (?P<post_l>post|rev|r)\n                [-_\\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\\.]?\n            (?P<dev_l>dev)\n            [-_\\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n\"\"\"\n\nVERSION_PATTERN = _VERSION_PATTERN\n\"\"\"\nA string containing the regular expression used to match a valid version.\n\nThe pattern is not anchored at either end, and is intended for embedding in larger\nexpressions (for example, matching a version number as part of a file name). The\nregular expression should be compiled with the ``re.VERBOSE`` and ``re.IGNORECASE``\nflags set.\n\n:meta hide-value:\n\"\"\"\n\n\nclass Version(_BaseVersion):\n    \"\"\"This class abstracts handling of a project's versions.\n\n    A :class:`Version` instance is comparison aware and can be compared and\n    sorted using the standard Python interfaces.\n\n    >>> v1 = Version(\"1.0a5\")\n    >>> v2 = Version(\"1.0\")\n    >>> v1\n    <Version('1.0a5')>\n    >>> v2\n    <Version('1.0')>\n    >>> v1 < v2\n    True\n    >>> v1 == v2\n    False\n    >>> v1 > v2\n    False\n    >>> v1 >= v2\n    False\n    >>> v1 <= v2\n    True\n    \"\"\"\n\n    _regex = re.compile(r\"^\\s*\" + VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE)\n    _key: CmpKey\n\n    def __init__(self, version: str) -> None:\n        \"\"\"Initialize a Version object.\n\n        :param version:\n            The string representation of a version which will be parsed and normalized\n            before use.\n        :raises InvalidVersion:\n            If the ``version`` does not conform to PEP 440 in any way then this\n            exception will be raised.\n        \"\"\"\n\n        # Validate the version and parse it into pieces\n        match = self._regex.search(version)\n        if not match:\n            raise InvalidVersion(f\"Invalid version: '{version}'\")\n\n        # Store the parsed out pieces of the version\n        self._version = _Version(\n            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,\n            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),\n            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),\n            post=_parse_letter_version(\n                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")\n            ),\n            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),\n            local=_parse_local_version(match.group(\"local\")),\n        )\n\n        # Generate a key which will be used for sorting\n        self._key = _cmpkey(\n            self._version.epoch,\n            self._version.release,\n            self._version.pre,\n            self._version.post,\n            self._version.dev,\n            self._version.local,\n        )\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Version that shows all internal state.\n\n        >>> Version('1.0.0')\n        <Version('1.0.0')>\n        \"\"\"\n        return f\"<Version('{self}')>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the version that can be rounded-tripped.\n\n        >>> str(Version(\"1.0a5\"))\n        '1.0a5'\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        # Pre-release\n        if self.pre is not None:\n            parts.append(\"\".join(str(x) for x in self.pre))\n\n        # Post-release\n        if self.post is not None:\n            parts.append(f\".post{self.post}\")\n\n        # Development release\n        if self.dev is not None:\n            parts.append(f\".dev{self.dev}\")\n\n        # Local version segment\n        if self.local is not None:\n            parts.append(f\"+{self.local}\")\n\n        return \"\".join(parts)\n\n    @property\n    def epoch(self) -> int:\n        \"\"\"The epoch of the version.\n\n        >>> Version(\"2.0.0\").epoch\n        0\n        >>> Version(\"1!2.0.0\").epoch\n        1\n        \"\"\"\n        return self._version.epoch\n\n    @property\n    def release(self) -> Tuple[int, ...]:\n        \"\"\"The components of the \"release\" segment of the version.\n\n        >>> Version(\"1.2.3\").release\n        (1, 2, 3)\n        >>> Version(\"2.0.0\").release\n        (2, 0, 0)\n        >>> Version(\"1!2.0.0.post0\").release\n        (2, 0, 0)\n\n        Includes trailing zeroes but not the epoch or any pre-release / development /\n        post-release suffixes.\n        \"\"\"\n        return self._version.release\n\n    @property\n    def pre(self) -> Optional[Tuple[str, int]]:\n        \"\"\"The pre-release segment of the version.\n\n        >>> print(Version(\"1.2.3\").pre)\n        None\n        >>> Version(\"1.2.3a1\").pre\n        ('a', 1)\n        >>> Version(\"1.2.3b1\").pre\n        ('b', 1)\n        >>> Version(\"1.2.3rc1\").pre\n        ('rc', 1)\n        \"\"\"\n        return self._version.pre\n\n    @property\n    def post(self) -> Optional[int]:\n        \"\"\"The post-release number of the version.\n\n        >>> print(Version(\"1.2.3\").post)\n        None\n        >>> Version(\"1.2.3.post1\").post\n        1\n        \"\"\"\n        return self._version.post[1] if self._version.post else None\n\n    @property\n    def dev(self) -> Optional[int]:\n        \"\"\"The development number of the version.\n\n        >>> print(Version(\"1.2.3\").dev)\n        None\n        >>> Version(\"1.2.3.dev1\").dev\n        1\n        \"\"\"\n        return self._version.dev[1] if self._version.dev else None\n\n    @property\n    def local(self) -> Optional[str]:\n        \"\"\"The local version segment of the version.\n\n        >>> print(Version(\"1.2.3\").local)\n        None\n        >>> Version(\"1.2.3+abc\").local\n        'abc'\n        \"\"\"\n        if self._version.local:\n            return \".\".join(str(x) for x in self._version.local)\n        else:\n            return None\n\n    @property\n    def public(self) -> str:\n        \"\"\"The public portion of the version.\n\n        >>> Version(\"1.2.3\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc.dev1\").public\n        '1.2.3'\n        \"\"\"\n        return str(self).split(\"+\", 1)[0]\n\n    @property\n    def base_version(self) -> str:\n        \"\"\"The \"base version\" of the version.\n\n        >>> Version(\"1.2.3\").base_version\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").base_version\n        '1.2.3'\n        >>> Version(\"1!1.2.3+abc.dev1\").base_version\n        '1!1.2.3'\n\n        The \"base version\" is the public version of the project without any pre or post\n        release markers.\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        return \"\".join(parts)\n\n    @property\n    def is_prerelease(self) -> bool:\n        \"\"\"Whether this version is a pre-release.\n\n        >>> Version(\"1.2.3\").is_prerelease\n        False\n        >>> Version(\"1.2.3a1\").is_prerelease\n        True\n        >>> Version(\"1.2.3b1\").is_prerelease\n        True\n        >>> Version(\"1.2.3rc1\").is_prerelease\n        True\n        >>> Version(\"1.2.3dev1\").is_prerelease\n        True\n        \"\"\"\n        return self.dev is not None or self.pre is not None\n\n    @property\n    def is_postrelease(self) -> bool:\n        \"\"\"Whether this version is a post-release.\n\n        >>> Version(\"1.2.3\").is_postrelease\n        False\n        >>> Version(\"1.2.3.post1\").is_postrelease\n        True\n        \"\"\"\n        return self.post is not None\n\n    @property\n    def is_devrelease(self) -> bool:\n        \"\"\"Whether this version is a development release.\n\n        >>> Version(\"1.2.3\").is_devrelease\n        False\n        >>> Version(\"1.2.3.dev1\").is_devrelease\n        True\n        \"\"\"\n        return self.dev is not None\n\n    @property\n    def major(self) -> int:\n        \"\"\"The first item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").major\n        1\n        \"\"\"\n        return self.release[0] if len(self.release) >= 1 else 0\n\n    @property\n    def minor(self) -> int:\n        \"\"\"The second item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").minor\n        2\n        >>> Version(\"1\").minor\n        0\n        \"\"\"\n        return self.release[1] if len(self.release) >= 2 else 0\n\n    @property\n    def micro(self) -> int:\n        \"\"\"The third item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").micro\n        3\n        >>> Version(\"1\").micro\n        0\n        \"\"\"\n        return self.release[2] if len(self.release) >= 3 else 0\n\n\ndef _parse_letter_version(\n    letter: Optional[str], number: Union[str, bytes, SupportsInt, None]\n) -> Optional[Tuple[str, int]]:\n\n    if letter:\n        # We consider there to be an implicit 0 in a pre-release if there is\n        # not a numeral associated with it.\n        if number is None:\n            number = 0\n\n        # We normalize any letters to their lower case form\n        letter = letter.lower()\n\n        # We consider some words to be alternate spellings of other words and\n        # in those cases we want to normalize the spellings to our preferred\n        # spelling.\n        if letter == \"alpha\":\n            letter = \"a\"\n        elif letter == \"beta\":\n            letter = \"b\"\n        elif letter in [\"c\", \"pre\", \"preview\"]:\n            letter = \"rc\"\n        elif letter in [\"rev\", \"r\"]:\n            letter = \"post\"\n\n        return letter, int(number)\n    if not letter and number:\n        # We assume if we are given a number, but we are not given a letter\n        # then this is using the implicit post release syntax (e.g. 1.0-1)\n        letter = \"post\"\n\n        return letter, int(number)\n\n    return None\n\n\n_local_version_separators = re.compile(r\"[\\._-]\")\n\n\ndef _parse_local_version(local: Optional[str]) -> Optional[LocalType]:\n    \"\"\"\n    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").\n    \"\"\"\n    if local is not None:\n        return tuple(\n            part.lower() if not part.isdigit() else int(part)\n            for part in _local_version_separators.split(local)\n        )\n    return None\n\n\ndef _cmpkey(\n    epoch: int,\n    release: Tuple[int, ...],\n    pre: Optional[Tuple[str, int]],\n    post: Optional[Tuple[str, int]],\n    dev: Optional[Tuple[str, int]],\n    local: Optional[LocalType],\n) -> CmpKey:\n\n    # When we compare a release version, we want to compare it with all of the\n    # trailing zeros removed. So we'll use a reverse the list, drop all the now\n    # leading zeros until we come to something non zero, then take the rest\n    # re-reverse it back into the correct order and make it a tuple and use\n    # that for our sorting key.\n    _release = tuple(\n        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))\n    )\n\n    # We need to \"trick\" the sorting algorithm to put 1.0.dev0 before 1.0a0.\n    # We'll do this by abusing the pre segment, but we _only_ want to do this\n    # if there is not a pre or a post segment. If we have one of those then\n    # the normal sorting rules will handle this case correctly.\n    if pre is None and post is None and dev is not None:\n        _pre: CmpPrePostDevType = NegativeInfinity\n    # Versions without a pre-release (except as noted above) should sort after\n    # those with one.\n    elif pre is None:\n        _pre = Infinity\n    else:\n        _pre = pre\n\n    # Versions without a post segment should sort before those with one.\n    if post is None:\n        _post: CmpPrePostDevType = NegativeInfinity\n\n    else:\n        _post = post\n\n    # Versions without a development segment should sort after those with one.\n    if dev is None:\n        _dev: CmpPrePostDevType = Infinity\n\n    else:\n        _dev = dev\n\n    if local is None:\n        # Versions without a local segment should sort before those with one.\n        _local: CmpLocalType = NegativeInfinity\n    else:\n        # Versions with a local segment need that segment parsed to implement\n        # the sorting rules in PEP440.\n        # - Alpha numeric segments sort before numeric segments\n        # - Alpha numeric segments sort lexicographically\n        # - Numeric segments sort numerically\n        # - Shorter versions sort before longer versions when the prefixes\n        #   match exactly\n        _local = tuple(\n            (i, \"\") if isinstance(i, int) else (NegativeInfinity, i) for i in local\n        )\n\n    return epoch, _release, _pre, _post, _dev, _local\n", "setuptools/_vendor/packaging/_elffile.py": "\"\"\"\nELF file parser.\n\nThis provides a class ``ELFFile`` that parses an ELF executable in a similar\ninterface to ``ZipFile``. Only the read interface is implemented.\n\nBased on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca\nELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html\n\"\"\"\n\nimport enum\nimport os\nimport struct\nfrom typing import IO, Optional, Tuple\n\n\nclass ELFInvalid(ValueError):\n    pass\n\n\nclass EIClass(enum.IntEnum):\n    C32 = 1\n    C64 = 2\n\n\nclass EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\n\n\nclass EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40\n    X8664 = 62\n    AArc64 = 183\n\n\nclass ELFFile:\n    \"\"\"\n    Representation of an ELF executable.\n    \"\"\"\n\n    def __init__(self, f: IO[bytes]) -> None:\n        self._f = f\n\n        try:\n            ident = self._read(\"16B\")\n        except struct.error:\n            raise ELFInvalid(\"unable to parse identification\")\n        magic = bytes(ident[:4])\n        if magic != b\"\\x7fELF\":\n            raise ELFInvalid(f\"invalid magic: {magic!r}\")\n\n        self.capacity = ident[4]  # Format for program header (bitness).\n        self.encoding = ident[5]  # Data structure encoding (endianness).\n\n        try:\n            # e_fmt: Format for program header.\n            # p_fmt: Format for section header.\n            # p_idx: Indexes to find p_type, p_offset, and p_filesz.\n            e_fmt, self._p_fmt, self._p_idx = {\n                (1, 1): (\"<HHIIIIIHHH\", \"<IIIIIIII\", (0, 1, 4)),  # 32-bit LSB.\n                (1, 2): (\">HHIIIIIHHH\", \">IIIIIIII\", (0, 1, 4)),  # 32-bit MSB.\n                (2, 1): (\"<HHIQQQIHHH\", \"<IIQQQQQQ\", (0, 2, 5)),  # 64-bit LSB.\n                (2, 2): (\">HHIQQQIHHH\", \">IIQQQQQQ\", (0, 2, 5)),  # 64-bit MSB.\n            }[(self.capacity, self.encoding)]\n        except KeyError:\n            raise ELFInvalid(\n                f\"unrecognized capacity ({self.capacity}) or \"\n                f\"encoding ({self.encoding})\"\n            )\n\n        try:\n            (\n                _,\n                self.machine,  # Architecture type.\n                _,\n                _,\n                self._e_phoff,  # Offset of program header.\n                _,\n                self.flags,  # Processor-specific flags.\n                _,\n                self._e_phentsize,  # Size of section.\n                self._e_phnum,  # Number of sections.\n            ) = self._read(e_fmt)\n        except struct.error as e:\n            raise ELFInvalid(\"unable to parse machine and section information\") from e\n\n    def _read(self, fmt: str) -> Tuple[int, ...]:\n        return struct.unpack(fmt, self._f.read(struct.calcsize(fmt)))\n\n    @property\n    def interpreter(self) -> Optional[str]:\n        \"\"\"\n        The path recorded in the ``PT_INTERP`` section header.\n        \"\"\"\n        for index in range(self._e_phnum):\n            self._f.seek(self._e_phoff + self._e_phentsize * index)\n            try:\n                data = self._read(self._p_fmt)\n            except struct.error:\n                continue\n            if data[self._p_idx[0]] != 3:  # Not PT_INTERP.\n                continue\n            self._f.seek(data[self._p_idx[1]])\n            return os.fsdecode(self._f.read(data[self._p_idx[2]])).strip(\"\\0\")\n        return None\n", "setuptools/_vendor/packaging/requirements.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom typing import Any, Iterator, Optional, Set\n\nfrom ._parser import parse_requirement as _parse_requirement\nfrom ._tokenizer import ParserSyntaxError\nfrom .markers import Marker, _normalize_extra_values\nfrom .specifiers import SpecifierSet\nfrom .utils import canonicalize_name\n\n\nclass InvalidRequirement(ValueError):\n    \"\"\"\n    An invalid requirement was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass Requirement:\n    \"\"\"Parse a requirement.\n\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"\n\n    # TODO: Can we test whether something is contained within a requirement?\n    #       If so how do we do that? Do we need to test against the _name_ of\n    #       the thing as well as the version? What about the markers?\n    # TODO: Can we normalize the name and extra name?\n\n    def __init__(self, requirement_string: str) -> None:\n        try:\n            parsed = _parse_requirement(requirement_string)\n        except ParserSyntaxError as e:\n            raise InvalidRequirement(str(e)) from e\n\n        self.name: str = parsed.name\n        self.url: Optional[str] = parsed.url or None\n        self.extras: Set[str] = set(parsed.extras or [])\n        self.specifier: SpecifierSet = SpecifierSet(parsed.specifier)\n        self.marker: Optional[Marker] = None\n        if parsed.marker is not None:\n            self.marker = Marker.__new__(Marker)\n            self.marker._markers = _normalize_extra_values(parsed.marker)\n\n    def _iter_parts(self, name: str) -> Iterator[str]:\n        yield name\n\n        if self.extras:\n            formatted_extras = \",\".join(sorted(self.extras))\n            yield f\"[{formatted_extras}]\"\n\n        if self.specifier:\n            yield str(self.specifier)\n\n        if self.url:\n            yield f\"@ {self.url}\"\n            if self.marker:\n                yield \" \"\n\n        if self.marker:\n            yield f\"; {self.marker}\"\n\n    def __str__(self) -> str:\n        return \"\".join(self._iter_parts(self.name))\n\n    def __repr__(self) -> str:\n        return f\"<Requirement('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.__class__.__name__,\n                *self._iter_parts(canonicalize_name(self.name)),\n            )\n        )\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Requirement):\n            return NotImplemented\n\n        return (\n            canonicalize_name(self.name) == canonicalize_name(other.name)\n            and self.extras == other.extras\n            and self.specifier == other.specifier\n            and self.url == other.url\n            and self.marker == other.marker\n        )\n", "setuptools/_vendor/packaging/_parser.py": "\"\"\"Handwritten parser of dependency specifiers.\n\nThe docstring for each __parse_* function contains ENBF-inspired grammar representing\nthe implementation.\n\"\"\"\n\nimport ast\nfrom typing import Any, List, NamedTuple, Optional, Tuple, Union\n\nfrom ._tokenizer import DEFAULT_RULES, Tokenizer\n\n\nclass Node:\n    def __init__(self, value: str) -> None:\n        self.value = value\n\n    def __str__(self) -> str:\n        return self.value\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}('{self}')>\"\n\n    def serialize(self) -> str:\n        raise NotImplementedError\n\n\nclass Variable(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nclass Value(Node):\n    def serialize(self) -> str:\n        return f'\"{self}\"'\n\n\nclass Op(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nMarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]\n# mypy does not support recursive type definition\n# https://github.com/python/mypy/issues/731\nMarkerAtom = Any\nMarkerList = List[Any]\n\n\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: List[str]\n    specifier: str\n    marker: Optional[MarkerList]\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier\n# --------------------------------------------------------------------------------------\ndef parse_requirement(source: str) -> ParsedRequirement:\n    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:\n    \"\"\"\n    requirement = WS? IDENTIFIER WS? extras WS? requirement_details\n    \"\"\"\n    tokenizer.consume(\"WS\")\n\n    name_token = tokenizer.expect(\n        \"IDENTIFIER\", expected=\"package name at the start of dependency specifier\"\n    )\n    name = name_token.text\n    tokenizer.consume(\"WS\")\n\n    extras = _parse_extras(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    url, specifier, marker = _parse_requirement_details(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of dependency specifier\")\n\n    return ParsedRequirement(name, url, extras, specifier, marker)\n\n\ndef _parse_requirement_details(\n    tokenizer: Tokenizer,\n) -> Tuple[str, str, Optional[MarkerList]]:\n    \"\"\"\n    requirement_details = AT URL (WS requirement_marker?)?\n                        | specifier WS? (requirement_marker)?\n    \"\"\"\n\n    specifier = \"\"\n    url = \"\"\n    marker = None\n\n    if tokenizer.check(\"AT\"):\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        url_start = tokenizer.position\n        url = tokenizer.expect(\"URL\", expected=\"URL after @\").text\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        tokenizer.expect(\"WS\", expected=\"whitespace after URL\")\n\n        # The input might end after whitespace.\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer, span_start=url_start, after=\"URL and whitespace\"\n        )\n    else:\n        specifier_start = tokenizer.position\n        specifier = _parse_specifier(tokenizer)\n        tokenizer.consume(\"WS\")\n\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer,\n            span_start=specifier_start,\n            after=(\n                \"version specifier\"\n                if specifier\n                else \"name and no valid version specifier\"\n            ),\n        )\n\n    return (url, specifier, marker)\n\n\ndef _parse_requirement_marker(\n    tokenizer: Tokenizer, *, span_start: int, after: str\n) -> MarkerList:\n    \"\"\"\n    requirement_marker = SEMICOLON marker WS?\n    \"\"\"\n\n    if not tokenizer.check(\"SEMICOLON\"):\n        tokenizer.raise_syntax_error(\n            f\"Expected end or semicolon (after {after})\",\n            span_start=span_start,\n        )\n    tokenizer.read()\n\n    marker = _parse_marker(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    return marker\n\n\ndef _parse_extras(tokenizer: Tokenizer) -> List[str]:\n    \"\"\"\n    extras = (LEFT_BRACKET wsp* extras_list? wsp* RIGHT_BRACKET)?\n    \"\"\"\n    if not tokenizer.check(\"LEFT_BRACKET\", peek=True):\n        return []\n\n    with tokenizer.enclosing_tokens(\n        \"LEFT_BRACKET\",\n        \"RIGHT_BRACKET\",\n        around=\"extras\",\n    ):\n        tokenizer.consume(\"WS\")\n        extras = _parse_extras_list(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return extras\n\n\ndef _parse_extras_list(tokenizer: Tokenizer) -> List[str]:\n    \"\"\"\n    extras_list = identifier (wsp* ',' wsp* identifier)*\n    \"\"\"\n    extras: List[str] = []\n\n    if not tokenizer.check(\"IDENTIFIER\"):\n        return extras\n\n    extras.append(tokenizer.read().text)\n\n    while True:\n        tokenizer.consume(\"WS\")\n        if tokenizer.check(\"IDENTIFIER\", peek=True):\n            tokenizer.raise_syntax_error(\"Expected comma between extra names\")\n        elif not tokenizer.check(\"COMMA\"):\n            break\n\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        extra_token = tokenizer.expect(\"IDENTIFIER\", expected=\"extra name after comma\")\n        extras.append(extra_token.text)\n\n    return extras\n\n\ndef _parse_specifier(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    specifier = LEFT_PARENTHESIS WS? version_many WS? RIGHT_PARENTHESIS\n              | WS? version_many WS?\n    \"\"\"\n    with tokenizer.enclosing_tokens(\n        \"LEFT_PARENTHESIS\",\n        \"RIGHT_PARENTHESIS\",\n        around=\"version specifier\",\n    ):\n        tokenizer.consume(\"WS\")\n        parsed_specifiers = _parse_version_many(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\ndef _parse_version_many(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    version_many = (SPECIFIER (WS? COMMA WS? SPECIFIER)*)?\n    \"\"\"\n    parsed_specifiers = \"\"\n    while tokenizer.check(\"SPECIFIER\"):\n        span_start = tokenizer.position\n        parsed_specifiers += tokenizer.read().text\n        if tokenizer.check(\"VERSION_PREFIX_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \".* suffix can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position + 1,\n            )\n        if tokenizer.check(\"VERSION_LOCAL_LABEL_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \"Local version label can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position,\n            )\n        tokenizer.consume(\"WS\")\n        if not tokenizer.check(\"COMMA\"):\n            break\n        parsed_specifiers += tokenizer.read().text\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for marker expression\n# --------------------------------------------------------------------------------------\ndef parse_marker(source: str) -> MarkerList:\n    return _parse_full_marker(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_full_marker(tokenizer: Tokenizer) -> MarkerList:\n    retval = _parse_marker(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of marker expression\")\n    return retval\n\n\ndef _parse_marker(tokenizer: Tokenizer) -> MarkerList:\n    \"\"\"\n    marker = marker_atom (BOOLOP marker_atom)+\n    \"\"\"\n    expression = [_parse_marker_atom(tokenizer)]\n    while tokenizer.check(\"BOOLOP\"):\n        token = tokenizer.read()\n        expr_right = _parse_marker_atom(tokenizer)\n        expression.extend((token.text, expr_right))\n    return expression\n\n\ndef _parse_marker_atom(tokenizer: Tokenizer) -> MarkerAtom:\n    \"\"\"\n    marker_atom = WS? LEFT_PARENTHESIS WS? marker WS? RIGHT_PARENTHESIS WS?\n                | WS? marker_item WS?\n    \"\"\"\n\n    tokenizer.consume(\"WS\")\n    if tokenizer.check(\"LEFT_PARENTHESIS\", peek=True):\n        with tokenizer.enclosing_tokens(\n            \"LEFT_PARENTHESIS\",\n            \"RIGHT_PARENTHESIS\",\n            around=\"marker expression\",\n        ):\n            tokenizer.consume(\"WS\")\n            marker: MarkerAtom = _parse_marker(tokenizer)\n            tokenizer.consume(\"WS\")\n    else:\n        marker = _parse_marker_item(tokenizer)\n    tokenizer.consume(\"WS\")\n    return marker\n\n\ndef _parse_marker_item(tokenizer: Tokenizer) -> MarkerItem:\n    \"\"\"\n    marker_item = WS? marker_var WS? marker_op WS? marker_var WS?\n    \"\"\"\n    tokenizer.consume(\"WS\")\n    marker_var_left = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_op = _parse_marker_op(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_var_right = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    return (marker_var_left, marker_op, marker_var_right)\n\n\ndef _parse_marker_var(tokenizer: Tokenizer) -> MarkerVar:\n    \"\"\"\n    marker_var = VARIABLE | QUOTED_STRING\n    \"\"\"\n    if tokenizer.check(\"VARIABLE\"):\n        return process_env_var(tokenizer.read().text.replace(\".\", \"_\"))\n    elif tokenizer.check(\"QUOTED_STRING\"):\n        return process_python_str(tokenizer.read().text)\n    else:\n        tokenizer.raise_syntax_error(\n            message=\"Expected a marker variable or quoted string\"\n        )\n\n\ndef process_env_var(env_var: str) -> Variable:\n    if env_var in (\"platform_python_implementation\", \"python_implementation\"):\n        return Variable(\"platform_python_implementation\")\n    else:\n        return Variable(env_var)\n\n\ndef process_python_str(python_str: str) -> Value:\n    value = ast.literal_eval(python_str)\n    return Value(str(value))\n\n\ndef _parse_marker_op(tokenizer: Tokenizer) -> Op:\n    \"\"\"\n    marker_op = IN | NOT IN | OP\n    \"\"\"\n    if tokenizer.check(\"IN\"):\n        tokenizer.read()\n        return Op(\"in\")\n    elif tokenizer.check(\"NOT\"):\n        tokenizer.read()\n        tokenizer.expect(\"WS\", expected=\"whitespace after 'not'\")\n        tokenizer.expect(\"IN\", expected=\"'in' after 'not'\")\n        return Op(\"not in\")\n    elif tokenizer.check(\"OP\"):\n        return Op(tokenizer.read().text)\n    else:\n        return tokenizer.raise_syntax_error(\n            \"Expected marker operator, one of \"\n            \"<=, <, !=, ==, >=, >, ~=, ===, in, not in\"\n        )\n", "setuptools/_vendor/packaging/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n__title__ = \"packaging\"\n__summary__ = \"Core utilities for Python packages\"\n__uri__ = \"https://github.com/pypa/packaging\"\n\n__version__ = \"24.0\"\n\n__author__ = \"Donald Stufft and individual contributors\"\n__email__ = \"donald@stufft.io\"\n\n__license__ = \"BSD-2-Clause or Apache-2.0\"\n__copyright__ = \"2014 %s\" % __author__\n", "setuptools/_vendor/packaging/specifiers.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier\n    from packaging.version import Version\n\"\"\"\n\nimport abc\nimport itertools\nimport re\nfrom typing import Callable, Iterable, Iterator, List, Optional, Tuple, TypeVar, Union\n\nfrom .utils import canonicalize_version\nfrom .version import Version\n\nUnparsedVersion = Union[Version, str]\nUnparsedVersionVar = TypeVar(\"UnparsedVersionVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[Version, str], bool]\n\n\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\n\n\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n\n    >>> Specifier(\"lolwat\")\n    Traceback (most recent call last):\n        ...\n    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'\n    \"\"\"\n\n\nclass BaseSpecifier(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __str__(self) -> str:\n        \"\"\"\n        Returns the str representation of this Specifier-like object. This\n        should be representative of the Specifier itself.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Returns a hash value for this Specifier-like object.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Returns a boolean representing whether or not the two Specifier-like\n        objects are equal.\n\n        :param other: The other object to check against.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def prereleases(self) -> Optional[bool]:\n        \"\"\"Whether or not pre-releases as a whole are allowed.\n\n        This can be set to either ``True`` or ``False`` to explicitly enable or disable\n        prereleases or it can be set to ``None`` (the default) to use default semantics.\n        \"\"\"\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        \"\"\"Setter for :attr:`prereleases`.\n\n        :param value: The value to set.\n        \"\"\"\n\n    @abc.abstractmethod\n    def contains(self, item: str, prereleases: Optional[bool] = None) -> bool:\n        \"\"\"\n        Determines if the given item is contained within this specifier.\n        \"\"\"\n\n    @abc.abstractmethod\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"\n        Takes an iterable of items and filters them so that only items which\n        are contained within this specifier are allowed in it.\n        \"\"\"\n\n\nclass Specifier(BaseSpecifier):\n    \"\"\"This class abstracts handling of version specifiers.\n\n    .. tip::\n\n        It is generally not required to instantiate this manually. You should instead\n        prefer to work with :class:`SpecifierSet` instead, which can parse\n        comma-separated version specifiers (which is what package metadata contains).\n    \"\"\"\n\n    _operator_regex_str = r\"\"\"\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        \"\"\"\n    _version_regex_str = r\"\"\"\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \\s*\n                [^\\s;)]*  # The arbitrary version can be just about anything,\n                          # we match everything except for whitespace, a\n                          # semi-colon for marker support, and a closing paren\n                          # since versions can be enclosed in them.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n\n                # You cannot use a wild card and a pre-release, post-release, a dev or\n                # local version together so group them with a | and make them optional.\n                (?:\n                    \\.\\*  # Wild card syntax of .*\n                    |\n                    (?:                                  # pre release\n                        [-_\\.]?\n                        (alpha|beta|preview|pre|a|b|c|rc)\n                        [-_\\.]?\n                        [0-9]*\n                    )?\n                    (?:                                  # post release\n                        (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                    )?\n                    (?:[-_\\.]?dev[-_\\.]?[0-9]*)?         # dev release\n                    (?:\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*)? # local\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n        )\n        \"\"\"\n\n    _regex = re.compile(\n        r\"^\\s*\" + _operator_regex_str + _version_regex_str + r\"\\s*$\",\n        re.VERBOSE | re.IGNORECASE,\n    )\n\n    _operators = {\n        \"~=\": \"compatible\",\n        \"==\": \"equal\",\n        \"!=\": \"not_equal\",\n        \"<=\": \"less_than_equal\",\n        \">=\": \"greater_than_equal\",\n        \"<\": \"less_than\",\n        \">\": \"greater_than\",\n        \"===\": \"arbitrary\",\n    }\n\n    def __init__(self, spec: str = \"\", prereleases: Optional[bool] = None) -> None:\n        \"\"\"Initialize a Specifier instance.\n\n        :param spec:\n            The string representation of a specifier which will be parsed and\n            normalized before use.\n        :param prereleases:\n            This tells the specifier if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n        :raises InvalidSpecifier:\n            If the given specifier is invalid (i.e. bad syntax).\n        \"\"\"\n        match = self._regex.search(spec)\n        if not match:\n            raise InvalidSpecifier(f\"Invalid specifier: '{spec}'\")\n\n        self._spec: Tuple[str, str] = (\n            match.group(\"operator\").strip(),\n            match.group(\"version\").strip(),\n        )\n\n        # Store whether or not this Specifier should accept prereleases\n        self._prereleases = prereleases\n\n    # https://github.com/python/mypy/pull/13475#pullrequestreview-1079784515\n    @property  # type: ignore[override]\n    def prereleases(self) -> bool:\n        # If there is an explicit prereleases set for this, then we'll just\n        # blindly use that.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # Look at all of our specifiers and determine if they are inclusive\n        # operators, and if they are if they are including an explicit\n        # prerelease.\n        operator, version = self._spec\n        if operator in [\"==\", \">=\", \"<=\", \"~=\", \"===\"]:\n            # The == specifier can include a trailing .*, if it does we\n            # want to remove before parsing.\n            if operator == \"==\" and version.endswith(\".*\"):\n                version = version[:-2]\n\n            # Parse the version, and if it is a pre-release than this\n            # specifier allows pre-releases.\n            if Version(version).is_prerelease:\n                return True\n\n        return False\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    @property\n    def operator(self) -> str:\n        \"\"\"The operator of this specifier.\n\n        >>> Specifier(\"==1.2.3\").operator\n        '=='\n        \"\"\"\n        return self._spec[0]\n\n    @property\n    def version(self) -> str:\n        \"\"\"The version of this specifier.\n\n        >>> Specifier(\"==1.2.3\").version\n        '1.2.3'\n        \"\"\"\n        return self._spec[1]\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Specifier that shows all internal state.\n\n        >>> Specifier('>=1.0.0')\n        <Specifier('>=1.0.0')>\n        >>> Specifier('>=1.0.0', prereleases=False)\n        <Specifier('>=1.0.0', prereleases=False)>\n        >>> Specifier('>=1.0.0', prereleases=True)\n        <Specifier('>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<{self.__class__.__name__}({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the Specifier that can be round-tripped.\n\n        >>> str(Specifier('>=1.0.0'))\n        '>=1.0.0'\n        >>> str(Specifier('>=1.0.0', prereleases=False))\n        '>=1.0.0'\n        \"\"\"\n        return \"{}{}\".format(*self._spec)\n\n    @property\n    def _canonical_spec(self) -> Tuple[str, str]:\n        canonical_version = canonicalize_version(\n            self._spec[1],\n            strip_trailing_zero=(self._spec[0] != \"~=\"),\n        )\n        return self._spec[0], canonical_version\n\n    def __hash__(self) -> int:\n        return hash(self._canonical_spec)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two Specifier-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> Specifier(\"==1.2.3\") == Specifier(\"== 1.2.3.0\")\n        True\n        >>> (Specifier(\"==1.2.3\", prereleases=False) ==\n        ...  Specifier(\"==1.2.3\", prereleases=True))\n        True\n        >>> Specifier(\"==1.2.3\") == \"==1.2.3\"\n        True\n        >>> Specifier(\"==1.2.3\") == Specifier(\"==1.2.4\")\n        False\n        >>> Specifier(\"==1.2.3\") == Specifier(\"~=1.2.3\")\n        False\n        \"\"\"\n        if isinstance(other, str):\n            try:\n                other = self.__class__(str(other))\n            except InvalidSpecifier:\n                return NotImplemented\n        elif not isinstance(other, self.__class__):\n            return NotImplemented\n\n        return self._canonical_spec == other._canonical_spec\n\n    def _get_operator(self, op: str) -> CallableOperator:\n        operator_callable: CallableOperator = getattr(\n            self, f\"_compare_{self._operators[op]}\"\n        )\n        return operator_callable\n\n    def _compare_compatible(self, prospective: Version, spec: str) -> bool:\n\n        # Compatible releases have an equivalent combination of >= and ==. That\n        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to\n        # implement this in terms of the other specifiers instead of\n        # implementing it ourselves. The only thing we need to do is construct\n        # the other specifiers.\n\n        # We want everything but the last item in the version, but we want to\n        # ignore suffix segments.\n        prefix = _version_join(\n            list(itertools.takewhile(_is_not_suffix, _version_split(spec)))[:-1]\n        )\n\n        # Add the prefix notation to the end of our string\n        prefix += \".*\"\n\n        return self._get_operator(\">=\")(prospective, spec) and self._get_operator(\"==\")(\n            prospective, prefix\n        )\n\n    def _compare_equal(self, prospective: Version, spec: str) -> bool:\n\n        # We need special logic to handle prefix matching\n        if spec.endswith(\".*\"):\n            # In the case of prefix matching we want to ignore local segment.\n            normalized_prospective = canonicalize_version(\n                prospective.public, strip_trailing_zero=False\n            )\n            # Get the normalized version string ignoring the trailing .*\n            normalized_spec = canonicalize_version(spec[:-2], strip_trailing_zero=False)\n            # Split the spec out by bangs and dots, and pretend that there is\n            # an implicit dot in between a release segment and a pre-release segment.\n            split_spec = _version_split(normalized_spec)\n\n            # Split the prospective version out by bangs and dots, and pretend\n            # that there is an implicit dot in between a release segment and\n            # a pre-release segment.\n            split_prospective = _version_split(normalized_prospective)\n\n            # 0-pad the prospective version before shortening it to get the correct\n            # shortened version.\n            padded_prospective, _ = _pad_version(split_prospective, split_spec)\n\n            # Shorten the prospective version to be the same length as the spec\n            # so that we can determine if the specifier is a prefix of the\n            # prospective version or not.\n            shortened_prospective = padded_prospective[: len(split_spec)]\n\n            return shortened_prospective == split_spec\n        else:\n            # Convert our spec string into a Version\n            spec_version = Version(spec)\n\n            # If the specifier does not have a local segment, then we want to\n            # act as if the prospective version also does not have a local\n            # segment.\n            if not spec_version.local:\n                prospective = Version(prospective.public)\n\n            return prospective == spec_version\n\n    def _compare_not_equal(self, prospective: Version, spec: str) -> bool:\n        return not self._compare_equal(prospective, spec)\n\n    def _compare_less_than_equal(self, prospective: Version, spec: str) -> bool:\n\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) <= Version(spec)\n\n    def _compare_greater_than_equal(self, prospective: Version, spec: str) -> bool:\n\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) >= Version(spec)\n\n    def _compare_less_than(self, prospective: Version, spec_str: str) -> bool:\n\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is less than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective < spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a pre-release version, that we do not accept pre-release\n        # versions for the version mentioned in the specifier (e.g. <3.1 should\n        # not match 3.1.dev0, but should match 3.0.dev0).\n        if not spec.is_prerelease and prospective.is_prerelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # less than the spec version *and* it's not a pre-release of the same\n        # version in the spec.\n        return True\n\n    def _compare_greater_than(self, prospective: Version, spec_str: str) -> bool:\n\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is greater than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective > spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a post-release version, that we do not accept\n        # post-release versions for the version mentioned in the specifier\n        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0).\n        if not spec.is_postrelease and prospective.is_postrelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # Ensure that we do not allow a local version of the version mentioned\n        # in the specifier, which is technically greater than, to match.\n        if prospective.local is not None:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # greater than the spec version *and* it's not a pre-release of the\n        # same version in the spec.\n        return True\n\n    def _compare_arbitrary(self, prospective: Version, spec: str) -> bool:\n        return str(prospective).lower() == str(spec).lower()\n\n    def __contains__(self, item: Union[str, Version]) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in Specifier(\">=1.2.3\")\n        True\n        >>> Version(\"1.2.3\") in Specifier(\">=1.2.3\")\n        True\n        >>> \"1.0.0\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(\n        self, item: UnparsedVersion, prereleases: Optional[bool] = None\n    ) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this Specifier. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> Specifier(\">=1.2.3\").contains(\"1.2.3\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(Version(\"1.2.3\"))\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.0.0\")\n        False\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\")\n        False\n        >>> Specifier(\">=1.2.3\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n\n        # Determine if prereleases are to be allowed or not.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # Normalize item to a Version, this allows us to have a shortcut for\n        # \"2.0\" in Specifier(\">=2\")\n        normalized_item = _coerce_version(item)\n\n        # Determine if we should be supporting prereleases in this specifier\n        # or not, if we do not support prereleases than we can short circuit\n        # logic if this version is a prereleases.\n        if normalized_item.is_prerelease and not prereleases:\n            return False\n\n        # Actually do the comparison to determine if this item is contained\n        # within this Specifier or not.\n        operator_callable: CallableOperator = self._get_operator(self.operator)\n        return operator_callable(normalized_item, self.version)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifier.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(Specifier().contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.2.3\", \"1.3\", Version(\"1.4\")]))\n        ['1.2.3', '1.3', <Version('1.4')>]\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        ['1.5a1']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(Specifier(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        \"\"\"\n\n        yielded = False\n        found_prereleases = []\n\n        kw = {\"prereleases\": prereleases if prereleases is not None else True}\n\n        # Attempt to iterate over all the values in the iterable and if any of\n        # them match, yield them.\n        for version in iterable:\n            parsed_version = _coerce_version(version)\n\n            if self.contains(parsed_version, **kw):\n                # If our version is a prerelease, and we were not set to allow\n                # prereleases, then we'll store it for later in case nothing\n                # else matches this specifier.\n                if parsed_version.is_prerelease and not (\n                    prereleases or self.prereleases\n                ):\n                    found_prereleases.append(version)\n                # Either this is not a prerelease, or we should have been\n                # accepting prereleases from the beginning.\n                else:\n                    yielded = True\n                    yield version\n\n        # Now that we've iterated over everything, determine if we've yielded\n        # any values, and if we have not and we have any prereleases stored up\n        # then we will go ahead and yield the prereleases.\n        if not yielded and found_prereleases:\n            for version in found_prereleases:\n                yield version\n\n\n_prefix_regex = re.compile(r\"^([0-9]+)((?:a|b|c|rc)[0-9]+)$\")\n\n\ndef _version_split(version: str) -> List[str]:\n    \"\"\"Split version into components.\n\n    The split components are intended for version comparison. The logic does\n    not attempt to retain the original version string, so joining the\n    components back with :func:`_version_join` may not produce the original\n    version string.\n    \"\"\"\n    result: List[str] = []\n\n    epoch, _, rest = version.rpartition(\"!\")\n    result.append(epoch or \"0\")\n\n    for item in rest.split(\".\"):\n        match = _prefix_regex.search(item)\n        if match:\n            result.extend(match.groups())\n        else:\n            result.append(item)\n    return result\n\n\ndef _version_join(components: List[str]) -> str:\n    \"\"\"Join split version components into a version string.\n\n    This function assumes the input came from :func:`_version_split`, where the\n    first component must be the epoch (either empty or numeric), and all other\n    components numeric.\n    \"\"\"\n    epoch, *rest = components\n    return f\"{epoch}!{'.'.join(rest)}\"\n\n\ndef _is_not_suffix(segment: str) -> bool:\n    return not any(\n        segment.startswith(prefix) for prefix in (\"dev\", \"a\", \"b\", \"rc\", \"post\")\n    )\n\n\ndef _pad_version(left: List[str], right: List[str]) -> Tuple[List[str], List[str]]:\n    left_split, right_split = [], []\n\n    # Get the release segment of our versions\n    left_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))\n    right_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))\n\n    # Get the rest of our versions\n    left_split.append(left[len(left_split[0]) :])\n    right_split.append(right[len(right_split[0]) :])\n\n    # Insert our padding\n    left_split.insert(1, [\"0\"] * max(0, len(right_split[0]) - len(left_split[0])))\n    right_split.insert(1, [\"0\"] * max(0, len(left_split[0]) - len(right_split[0])))\n\n    return (\n        list(itertools.chain.from_iterable(left_split)),\n        list(itertools.chain.from_iterable(right_split)),\n    )\n\n\nclass SpecifierSet(BaseSpecifier):\n    \"\"\"This class abstracts handling of a set of version specifiers.\n\n    It can be passed a single specifier (``>=3.0``), a comma-separated list of\n    specifiers (``>=3.0,!=3.1``), or no specifier at all.\n    \"\"\"\n\n    def __init__(\n        self, specifiers: str = \"\", prereleases: Optional[bool] = None\n    ) -> None:\n        \"\"\"Initialize a SpecifierSet instance.\n\n        :param specifiers:\n            The string representation of a specifier or a comma-separated list of\n            specifiers which will be parsed and normalized before use.\n        :param prereleases:\n            This tells the SpecifierSet if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n\n        :raises InvalidSpecifier:\n            If the given ``specifiers`` are not parseable than this exception will be\n            raised.\n        \"\"\"\n\n        # Split on `,` to break each individual specifier into it's own item, and\n        # strip each item to remove leading/trailing whitespace.\n        split_specifiers = [s.strip() for s in specifiers.split(\",\") if s.strip()]\n\n        # Make each individual specifier a Specifier and save in a frozen set for later.\n        self._specs = frozenset(map(Specifier, split_specifiers))\n\n        # Store our prereleases value so we can use it later to determine if\n        # we accept prereleases or not.\n        self._prereleases = prereleases\n\n    @property\n    def prereleases(self) -> Optional[bool]:\n        # If we have been given an explicit prerelease modifier, then we'll\n        # pass that through here.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # If we don't have any specifiers, and we don't have a forced value,\n        # then we'll just return None since we don't know if this should have\n        # pre-releases or not.\n        if not self._specs:\n            return None\n\n        # Otherwise we'll see if any of the given specifiers accept\n        # prereleases, if any of them do we'll return True, otherwise False.\n        return any(s.prereleases for s in self._specs)\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the specifier set that shows all internal state.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> SpecifierSet('>=1.0.0,!=2.0.0')\n        <SpecifierSet('!=2.0.0,>=1.0.0')>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=False)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=False)>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=True)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<SpecifierSet({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the specifier set that can be round-tripped.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\"))\n        '!=1.0.1,>=1.0.0'\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False))\n        '!=1.0.1,>=1.0.0'\n        \"\"\"\n        return \",\".join(sorted(str(s) for s in self._specs))\n\n    def __hash__(self) -> int:\n        return hash(self._specs)\n\n    def __and__(self, other: Union[\"SpecifierSet\", str]) -> \"SpecifierSet\":\n        \"\"\"Return a SpecifierSet which is a combination of the two sets.\n\n        :param other: The other object to combine with.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & '<=2.0.0,!=2.0.1'\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & SpecifierSet('<=2.0.0,!=2.0.1')\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        \"\"\"\n        if isinstance(other, str):\n            other = SpecifierSet(other)\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        specifier = SpecifierSet()\n        specifier._specs = frozenset(self._specs | other._specs)\n\n        if self._prereleases is None and other._prereleases is not None:\n            specifier._prereleases = other._prereleases\n        elif self._prereleases is not None and other._prereleases is None:\n            specifier._prereleases = self._prereleases\n        elif self._prereleases == other._prereleases:\n            specifier._prereleases = self._prereleases\n        else:\n            raise ValueError(\n                \"Cannot combine SpecifierSets with True and False prerelease \"\n                \"overrides.\"\n            )\n\n        return specifier\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two SpecifierSet-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> (SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False) ==\n        ...  SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == \">=1.0.0,!=1.0.1\"\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.2\")\n        False\n        \"\"\"\n        if isinstance(other, (str, Specifier)):\n            other = SpecifierSet(str(other))\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        return self._specs == other._specs\n\n    def __len__(self) -> int:\n        \"\"\"Returns the number of specifiers in this specifier set.\"\"\"\n        return len(self._specs)\n\n    def __iter__(self) -> Iterator[Specifier]:\n        \"\"\"\n        Returns an iterator over all the underlying :class:`Specifier` instances\n        in this specifier set.\n\n        >>> sorted(SpecifierSet(\">=1.0.0,!=1.0.1\"), key=str)\n        [<Specifier('!=1.0.1')>, <Specifier('>=1.0.0')>]\n        \"\"\"\n        return iter(self._specs)\n\n    def __contains__(self, item: UnparsedVersion) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> Version(\"1.2.3\") in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> \"1.0.1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(\n        self,\n        item: UnparsedVersion,\n        prereleases: Optional[bool] = None,\n        installed: Optional[bool] = None,\n    ) -> bool:\n        \"\"\"Return whether or not the item is contained in this SpecifierSet.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this SpecifierSet. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.2.3\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(Version(\"1.2.3\"))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.0.1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n        # Ensure that our item is a Version instance.\n        if not isinstance(item, Version):\n            item = Version(item)\n\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # We can determine if we're going to allow pre-releases by looking to\n        # see if any of the underlying items supports them. If none of them do\n        # and this item is a pre-release then we do not allow it and we can\n        # short circuit that here.\n        # Note: This means that 1.0.dev1 would not be contained in something\n        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0\n        if not prereleases and item.is_prerelease:\n            return False\n\n        if installed and item.is_prerelease:\n            item = Version(item.base_version)\n\n        # We simply dispatch to the underlying specs here to make sure that the\n        # given version is contained within all of them.\n        # Note: This use of all() here means that an empty set of specifiers\n        #       will always return True, this is an explicit design decision.\n        return all(s.contains(item, prereleases=prereleases) for s in self._specs)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifiers in this set.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(SpecifierSet(...).contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", Version(\"1.4\")]))\n        ['1.3', <Version('1.4')>]\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        []\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n\n        An \"empty\" SpecifierSet will filter items based on the presence of prerelease\n        versions in the set.\n\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\"\").filter([\"1.5a1\"]))\n        ['1.5a1']\n        >>> list(SpecifierSet(\"\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        \"\"\"\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # If we have any specifiers, then we want to wrap our iterable in the\n        # filter method for each one, this will act as a logical AND amongst\n        # each specifier.\n        if self._specs:\n            for spec in self._specs:\n                iterable = spec.filter(iterable, prereleases=bool(prereleases))\n            return iter(iterable)\n        # If we do not have any specifiers, then we need to have a rough filter\n        # which will filter out any pre-releases, unless there are no final\n        # releases.\n        else:\n            filtered: List[UnparsedVersionVar] = []\n            found_prereleases: List[UnparsedVersionVar] = []\n\n            for item in iterable:\n                parsed_version = _coerce_version(item)\n\n                # Store any item which is a pre-release for later unless we've\n                # already found a final version or we are accepting prereleases\n                if parsed_version.is_prerelease and not prereleases:\n                    if not filtered:\n                        found_prereleases.append(item)\n                else:\n                    filtered.append(item)\n\n            # If we've found no items except for pre-releases, then we'll go\n            # ahead and use the pre-releases\n            if not filtered and found_prereleases and prereleases is None:\n                return iter(found_prereleases)\n\n            return iter(filtered)\n", "setuptools/_vendor/packaging/markers.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport operator\nimport os\nimport platform\nimport sys\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\n\nfrom ._parser import (\n    MarkerAtom,\n    MarkerList,\n    Op,\n    Value,\n    Variable,\n    parse_marker as _parse_marker,\n)\nfrom ._tokenizer import ParserSyntaxError\nfrom .specifiers import InvalidSpecifier, Specifier\nfrom .utils import canonicalize_name\n\n__all__ = [\n    \"InvalidMarker\",\n    \"UndefinedComparison\",\n    \"UndefinedEnvironmentName\",\n    \"Marker\",\n    \"default_environment\",\n]\n\nOperator = Callable[[str, str], bool]\n\n\nclass InvalidMarker(ValueError):\n    \"\"\"\n    An invalid marker was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\n\n\nclass UndefinedEnvironmentName(ValueError):\n    \"\"\"\n    A name was attempted to be used that does not exist inside of the\n    environment.\n    \"\"\"\n\n\ndef _normalize_extra_values(results: Any) -> Any:\n    \"\"\"\n    Normalize extra values.\n    \"\"\"\n    if isinstance(results[0], tuple):\n        lhs, op, rhs = results[0]\n        if isinstance(lhs, Variable) and lhs.value == \"extra\":\n            normalized_extra = canonicalize_name(rhs.value)\n            rhs = Value(normalized_extra)\n        elif isinstance(rhs, Variable) and rhs.value == \"extra\":\n            normalized_extra = canonicalize_name(lhs.value)\n            lhs = Value(normalized_extra)\n        results[0] = lhs, op, rhs\n    return results\n\n\ndef _format_marker(\n    marker: Union[List[str], MarkerAtom, str], first: Optional[bool] = True\n) -> str:\n\n    assert isinstance(marker, (list, tuple, str))\n\n    # Sometimes we have a structure like [[...]] which is a single item list\n    # where the single item is itself it's own list. In that case we want skip\n    # the rest of this function so that we don't get extraneous () on the\n    # outside.\n    if (\n        isinstance(marker, list)\n        and len(marker) == 1\n        and isinstance(marker[0], (list, tuple))\n    ):\n        return _format_marker(marker[0])\n\n    if isinstance(marker, list):\n        inner = (_format_marker(m, first=False) for m in marker)\n        if first:\n            return \" \".join(inner)\n        else:\n            return \"(\" + \" \".join(inner) + \")\"\n    elif isinstance(marker, tuple):\n        return \" \".join([m.serialize() for m in marker])\n    else:\n        return marker\n\n\n_operators: Dict[str, Operator] = {\n    \"in\": lambda lhs, rhs: lhs in rhs,\n    \"not in\": lambda lhs, rhs: lhs not in rhs,\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \"==\": operator.eq,\n    \"!=\": operator.ne,\n    \">=\": operator.ge,\n    \">\": operator.gt,\n}\n\n\ndef _eval_op(lhs: str, op: Op, rhs: str) -> bool:\n    try:\n        spec = Specifier(\"\".join([op.serialize(), rhs]))\n    except InvalidSpecifier:\n        pass\n    else:\n        return spec.contains(lhs, prereleases=True)\n\n    oper: Optional[Operator] = _operators.get(op.serialize())\n    if oper is None:\n        raise UndefinedComparison(f\"Undefined {op!r} on {lhs!r} and {rhs!r}.\")\n\n    return oper(lhs, rhs)\n\n\ndef _normalize(*values: str, key: str) -> Tuple[str, ...]:\n    # PEP 685 \u2013 Comparison of extra names for optional distribution dependencies\n    # https://peps.python.org/pep-0685/\n    # > When comparing extra names, tools MUST normalize the names being\n    # > compared using the semantics outlined in PEP 503 for names\n    if key == \"extra\":\n        return tuple(canonicalize_name(v) for v in values)\n\n    # other environment markers don't have such standards\n    return values\n\n\ndef _evaluate_markers(markers: MarkerList, environment: Dict[str, str]) -> bool:\n    groups: List[List[bool]] = [[]]\n\n    for marker in markers:\n        assert isinstance(marker, (list, tuple, str))\n\n        if isinstance(marker, list):\n            groups[-1].append(_evaluate_markers(marker, environment))\n        elif isinstance(marker, tuple):\n            lhs, op, rhs = marker\n\n            if isinstance(lhs, Variable):\n                environment_key = lhs.value\n                lhs_value = environment[environment_key]\n                rhs_value = rhs.value\n            else:\n                lhs_value = lhs.value\n                environment_key = rhs.value\n                rhs_value = environment[environment_key]\n\n            lhs_value, rhs_value = _normalize(lhs_value, rhs_value, key=environment_key)\n            groups[-1].append(_eval_op(lhs_value, op, rhs_value))\n        else:\n            assert marker in [\"and\", \"or\"]\n            if marker == \"or\":\n                groups.append([])\n\n    return any(all(item) for item in groups)\n\n\ndef format_full_version(info: \"sys._version_info\") -> str:\n    version = \"{0.major}.{0.minor}.{0.micro}\".format(info)\n    kind = info.releaselevel\n    if kind != \"final\":\n        version += kind[0] + str(info.serial)\n    return version\n\n\ndef default_environment() -> Dict[str, str]:\n    iver = format_full_version(sys.implementation.version)\n    implementation_name = sys.implementation.name\n    return {\n        \"implementation_name\": implementation_name,\n        \"implementation_version\": iver,\n        \"os_name\": os.name,\n        \"platform_machine\": platform.machine(),\n        \"platform_release\": platform.release(),\n        \"platform_system\": platform.system(),\n        \"platform_version\": platform.version(),\n        \"python_full_version\": platform.python_version(),\n        \"platform_python_implementation\": platform.python_implementation(),\n        \"python_version\": \".\".join(platform.python_version_tuple()[:2]),\n        \"sys_platform\": sys.platform,\n    }\n\n\nclass Marker:\n    def __init__(self, marker: str) -> None:\n        # Note: We create a Marker object without calling this constructor in\n        #       packaging.requirements.Requirement. If any additional logic is\n        #       added here, make sure to mirror/adapt Requirement.\n        try:\n            self._markers = _normalize_extra_values(_parse_marker(marker))\n            # The attribute `_markers` can be described in terms of a recursive type:\n            # MarkerList = List[Union[Tuple[Node, ...], str, MarkerList]]\n            #\n            # For example, the following expression:\n            # python_version > \"3.6\" or (python_version == \"3.6\" and os_name == \"unix\")\n            #\n            # is parsed into:\n            # [\n            #     (<Variable('python_version')>, <Op('>')>, <Value('3.6')>),\n            #     'and',\n            #     [\n            #         (<Variable('python_version')>, <Op('==')>, <Value('3.6')>),\n            #         'or',\n            #         (<Variable('os_name')>, <Op('==')>, <Value('unix')>)\n            #     ]\n            # ]\n        except ParserSyntaxError as e:\n            raise InvalidMarker(str(e)) from e\n\n    def __str__(self) -> str:\n        return _format_marker(self._markers)\n\n    def __repr__(self) -> str:\n        return f\"<Marker('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash((self.__class__.__name__, str(self)))\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Marker):\n            return NotImplemented\n\n        return str(self) == str(other)\n\n    def evaluate(self, environment: Optional[Dict[str, str]] = None) -> bool:\n        \"\"\"Evaluate a marker.\n\n        Return the boolean from evaluating the given marker against the\n        environment. environment is an optional argument to override all or\n        part of the determined environment.\n\n        The environment is determined from the current Python process.\n        \"\"\"\n        current_environment = default_environment()\n        current_environment[\"extra\"] = \"\"\n        if environment is not None:\n            current_environment.update(environment)\n            # The API used to allow setting extra to None. We need to handle this\n            # case for backwards compatibility.\n            if current_environment[\"extra\"] is None:\n                current_environment[\"extra\"] = \"\"\n\n        return _evaluate_markers(self._markers, current_environment)\n", "setuptools/_vendor/backports/tarfile.py": "#!/usr/bin/env python3\n#-------------------------------------------------------------------\n# tarfile.py\n#-------------------------------------------------------------------\n# Copyright (C) 2002 Lars Gustaebel <lars@gustaebel.de>\n# All rights reserved.\n#\n# Permission  is  hereby granted,  free  of charge,  to  any person\n# obtaining a  copy of  this software  and associated documentation\n# files  (the  \"Software\"),  to   deal  in  the  Software   without\n# restriction,  including  without limitation  the  rights to  use,\n# copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies  of  the  Software,  and to  permit  persons  to  whom the\n# Software  is  furnished  to  do  so,  subject  to  the  following\n# conditions:\n#\n# The above copyright  notice and this  permission notice shall  be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS  IS\", WITHOUT WARRANTY OF ANY  KIND,\n# EXPRESS OR IMPLIED, INCLUDING  BUT NOT LIMITED TO  THE WARRANTIES\n# OF  MERCHANTABILITY,  FITNESS   FOR  A  PARTICULAR   PURPOSE  AND\n# NONINFRINGEMENT.  IN  NO  EVENT SHALL  THE  AUTHORS  OR COPYRIGHT\n# HOLDERS  BE LIABLE  FOR ANY  CLAIM, DAMAGES  OR OTHER  LIABILITY,\n# WHETHER  IN AN  ACTION OF  CONTRACT, TORT  OR OTHERWISE,  ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n# OTHER DEALINGS IN THE SOFTWARE.\n#\n\"\"\"Read from and write to tar format archives.\n\"\"\"\n\nversion     = \"0.9.0\"\n__author__  = \"Lars Gust\\u00e4bel (lars@gustaebel.de)\"\n__credits__ = \"Gustavo Niemeyer, Niels Gust\\u00e4bel, Richard Townsend.\"\n\n#---------\n# Imports\n#---------\nfrom builtins import open as bltn_open\nimport sys\nimport os\nimport io\nimport shutil\nimport stat\nimport time\nimport struct\nimport copy\nimport re\nimport warnings\n\ntry:\n    import pwd\nexcept ImportError:\n    pwd = None\ntry:\n    import grp\nexcept ImportError:\n    grp = None\n\n# os.symlink on Windows prior to 6.0 raises NotImplementedError\n# OSError (winerror=1314) will be raised if the caller does not hold the\n# SeCreateSymbolicLinkPrivilege privilege\nsymlink_exception = (AttributeError, NotImplementedError, OSError)\n\n# from tarfile import *\n__all__ = [\"TarFile\", \"TarInfo\", \"is_tarfile\", \"TarError\", \"ReadError\",\n           \"CompressionError\", \"StreamError\", \"ExtractError\", \"HeaderError\",\n           \"ENCODING\", \"USTAR_FORMAT\", \"GNU_FORMAT\", \"PAX_FORMAT\",\n           \"DEFAULT_FORMAT\", \"open\",\"fully_trusted_filter\", \"data_filter\",\n           \"tar_filter\", \"FilterError\", \"AbsoluteLinkError\",\n           \"OutsideDestinationError\", \"SpecialFileError\", \"AbsolutePathError\",\n           \"LinkOutsideDestinationError\"]\n\n\n#---------------------------------------------------------\n# tar constants\n#---------------------------------------------------------\nNUL = b\"\\0\"                     # the null character\nBLOCKSIZE = 512                 # length of processing blocks\nRECORDSIZE = BLOCKSIZE * 20     # length of records\nGNU_MAGIC = b\"ustar  \\0\"        # magic gnu tar string\nPOSIX_MAGIC = b\"ustar\\x0000\"    # magic posix tar string\n\nLENGTH_NAME = 100               # maximum length of a filename\nLENGTH_LINK = 100               # maximum length of a linkname\nLENGTH_PREFIX = 155             # maximum length of the prefix field\n\nREGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file\n\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\n\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\n\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT\n\n#---------------------------------------------------------\n# tarfile constants\n#---------------------------------------------------------\n# File types that tarfile supports:\nSUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,\n                   SYMTYPE, DIRTYPE, FIFOTYPE,\n                   CONTTYPE, CHRTYPE, BLKTYPE,\n                   GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\n                   GNUTYPE_SPARSE)\n\n# File types that will be treated as a regular file.\nREGULAR_TYPES = (REGTYPE, AREGTYPE,\n                 CONTTYPE, GNUTYPE_SPARSE)\n\n# File types that are part of the GNU tar format.\nGNU_TYPES = (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\n             GNUTYPE_SPARSE)\n\n# Fields from a pax header that override a TarInfo attribute.\nPAX_FIELDS = (\"path\", \"linkpath\", \"size\", \"mtime\",\n              \"uid\", \"gid\", \"uname\", \"gname\")\n\n# Fields from a pax header that are affected by hdrcharset.\nPAX_NAME_FIELDS = {\"path\", \"linkpath\", \"uname\", \"gname\"}\n\n# Fields in a pax header that are numbers, all other fields\n# are treated as strings.\nPAX_NUMBER_FIELDS = {\n    \"atime\": float,\n    \"ctime\": float,\n    \"mtime\": float,\n    \"uid\": int,\n    \"gid\": int,\n    \"size\": int\n}\n\n#---------------------------------------------------------\n# initialization\n#---------------------------------------------------------\nif os.name == \"nt\":\n    ENCODING = \"utf-8\"\nelse:\n    ENCODING = sys.getfilesystemencoding()\n\n#---------------------------------------------------------\n# Some useful functions\n#---------------------------------------------------------\n\ndef stn(s, length, encoding, errors):\n    \"\"\"Convert a string to a null-terminated bytes object.\n    \"\"\"\n    if s is None:\n        raise ValueError(\"metadata cannot contain None\")\n    s = s.encode(encoding, errors)\n    return s[:length] + (length - len(s)) * NUL\n\ndef nts(s, encoding, errors):\n    \"\"\"Convert a null-terminated bytes object to a string.\n    \"\"\"\n    p = s.find(b\"\\0\")\n    if p != -1:\n        s = s[:p]\n    return s.decode(encoding, errors)\n\ndef nti(s):\n    \"\"\"Convert a number field to a python number.\n    \"\"\"\n    # There are two possible encodings for a number field, see\n    # itn() below.\n    if s[0] in (0o200, 0o377):\n        n = 0\n        for i in range(len(s) - 1):\n            n <<= 8\n            n += s[i + 1]\n        if s[0] == 0o377:\n            n = -(256 ** (len(s) - 1) - n)\n    else:\n        try:\n            s = nts(s, \"ascii\", \"strict\")\n            n = int(s.strip() or \"0\", 8)\n        except ValueError:\n            raise InvalidHeaderError(\"invalid header\")\n    return n\n\ndef itn(n, digits=8, format=DEFAULT_FORMAT):\n    \"\"\"Convert a python number to a number field.\n    \"\"\"\n    # POSIX 1003.1-1988 requires numbers to be encoded as a string of\n    # octal digits followed by a null-byte, this allows values up to\n    # (8**(digits-1))-1. GNU tar allows storing numbers greater than\n    # that if necessary. A leading 0o200 or 0o377 byte indicate this\n    # particular encoding, the following digits-1 bytes are a big-endian\n    # base-256 representation. This allows values up to (256**(digits-1))-1.\n    # A 0o200 byte indicates a positive number, a 0o377 byte a negative\n    # number.\n    original_n = n\n    n = int(n)\n    if 0 <= n < 8 ** (digits - 1):\n        s = bytes(\"%0*o\" % (digits - 1, n), \"ascii\") + NUL\n    elif format == GNU_FORMAT and -256 ** (digits - 1) <= n < 256 ** (digits - 1):\n        if n >= 0:\n            s = bytearray([0o200])\n        else:\n            s = bytearray([0o377])\n            n = 256 ** digits + n\n\n        for i in range(digits - 1):\n            s.insert(1, n & 0o377)\n            n >>= 8\n    else:\n        raise ValueError(\"overflow in number field\")\n\n    return s\n\ndef calc_chksums(buf):\n    \"\"\"Calculate the checksum for a member's header by summing up all\n       characters except for the chksum field which is treated as if\n       it was filled with spaces. According to the GNU tar sources,\n       some tars (Sun and NeXT) calculate chksum with signed char,\n       which will be different if there are chars in the buffer with\n       the high bit set. So we calculate two checksums, unsigned and\n       signed.\n    \"\"\"\n    unsigned_chksum = 256 + sum(struct.unpack_from(\"148B8x356B\", buf))\n    signed_chksum = 256 + sum(struct.unpack_from(\"148b8x356b\", buf))\n    return unsigned_chksum, signed_chksum\n\ndef copyfileobj(src, dst, length=None, exception=OSError, bufsize=None):\n    \"\"\"Copy length bytes from fileobj src to fileobj dst.\n       If length is None, copy the entire content.\n    \"\"\"\n    bufsize = bufsize or 16 * 1024\n    if length == 0:\n        return\n    if length is None:\n        shutil.copyfileobj(src, dst, bufsize)\n        return\n\n    blocks, remainder = divmod(length, bufsize)\n    for b in range(blocks):\n        buf = src.read(bufsize)\n        if len(buf) < bufsize:\n            raise exception(\"unexpected end of data\")\n        dst.write(buf)\n\n    if remainder != 0:\n        buf = src.read(remainder)\n        if len(buf) < remainder:\n            raise exception(\"unexpected end of data\")\n        dst.write(buf)\n    return\n\ndef _safe_print(s):\n    encoding = getattr(sys.stdout, 'encoding', None)\n    if encoding is not None:\n        s = s.encode(encoding, 'backslashreplace').decode(encoding)\n    print(s, end=' ')\n\n\nclass TarError(Exception):\n    \"\"\"Base exception.\"\"\"\n    pass\nclass ExtractError(TarError):\n    \"\"\"General exception for extract errors.\"\"\"\n    pass\nclass ReadError(TarError):\n    \"\"\"Exception for unreadable tar archives.\"\"\"\n    pass\nclass CompressionError(TarError):\n    \"\"\"Exception for unavailable compression methods.\"\"\"\n    pass\nclass StreamError(TarError):\n    \"\"\"Exception for unsupported operations on stream-like TarFiles.\"\"\"\n    pass\nclass HeaderError(TarError):\n    \"\"\"Base exception for header errors.\"\"\"\n    pass\nclass EmptyHeaderError(HeaderError):\n    \"\"\"Exception for empty headers.\"\"\"\n    pass\nclass TruncatedHeaderError(HeaderError):\n    \"\"\"Exception for truncated headers.\"\"\"\n    pass\nclass EOFHeaderError(HeaderError):\n    \"\"\"Exception for end of file headers.\"\"\"\n    pass\nclass InvalidHeaderError(HeaderError):\n    \"\"\"Exception for invalid headers.\"\"\"\n    pass\nclass SubsequentHeaderError(HeaderError):\n    \"\"\"Exception for missing and invalid extended headers.\"\"\"\n    pass\n\n#---------------------------\n# internal stream interface\n#---------------------------\nclass _LowLevelFile:\n    \"\"\"Low-level file object. Supports reading and writing.\n       It is used instead of a regular file object for streaming\n       access.\n    \"\"\"\n\n    def __init__(self, name, mode):\n        mode = {\n            \"r\": os.O_RDONLY,\n            \"w\": os.O_WRONLY | os.O_CREAT | os.O_TRUNC,\n        }[mode]\n        if hasattr(os, \"O_BINARY\"):\n            mode |= os.O_BINARY\n        self.fd = os.open(name, mode, 0o666)\n\n    def close(self):\n        os.close(self.fd)\n\n    def read(self, size):\n        return os.read(self.fd, size)\n\n    def write(self, s):\n        os.write(self.fd, s)\n\nclass _Stream:\n    \"\"\"Class that serves as an adapter between TarFile and\n       a stream-like object.  The stream-like object only\n       needs to have a read() or write() method that works with bytes,\n       and the method is accessed blockwise.\n       Use of gzip or bzip2 compression is possible.\n       A stream-like object could be for example: sys.stdin.buffer,\n       sys.stdout.buffer, a socket, a tape device etc.\n\n       _Stream is intended to be used only internally.\n    \"\"\"\n\n    def __init__(self, name, mode, comptype, fileobj, bufsize,\n                 compresslevel):\n        \"\"\"Construct a _Stream object.\n        \"\"\"\n        self._extfileobj = True\n        if fileobj is None:\n            fileobj = _LowLevelFile(name, mode)\n            self._extfileobj = False\n\n        if comptype == '*':\n            # Enable transparent compression detection for the\n            # stream interface\n            fileobj = _StreamProxy(fileobj)\n            comptype = fileobj.getcomptype()\n\n        self.name     = name or \"\"\n        self.mode     = mode\n        self.comptype = comptype\n        self.fileobj  = fileobj\n        self.bufsize  = bufsize\n        self.buf      = b\"\"\n        self.pos      = 0\n        self.closed   = False\n\n        try:\n            if comptype == \"gz\":\n                try:\n                    import zlib\n                except ImportError:\n                    raise CompressionError(\"zlib module is not available\") from None\n                self.zlib = zlib\n                self.crc = zlib.crc32(b\"\")\n                if mode == \"r\":\n                    self.exception = zlib.error\n                    self._init_read_gz()\n                else:\n                    self._init_write_gz(compresslevel)\n\n            elif comptype == \"bz2\":\n                try:\n                    import bz2\n                except ImportError:\n                    raise CompressionError(\"bz2 module is not available\") from None\n                if mode == \"r\":\n                    self.dbuf = b\"\"\n                    self.cmp = bz2.BZ2Decompressor()\n                    self.exception = OSError\n                else:\n                    self.cmp = bz2.BZ2Compressor(compresslevel)\n\n            elif comptype == \"xz\":\n                try:\n                    import lzma\n                except ImportError:\n                    raise CompressionError(\"lzma module is not available\") from None\n                if mode == \"r\":\n                    self.dbuf = b\"\"\n                    self.cmp = lzma.LZMADecompressor()\n                    self.exception = lzma.LZMAError\n                else:\n                    self.cmp = lzma.LZMACompressor()\n\n            elif comptype != \"tar\":\n                raise CompressionError(\"unknown compression type %r\" % comptype)\n\n        except:\n            if not self._extfileobj:\n                self.fileobj.close()\n            self.closed = True\n            raise\n\n    def __del__(self):\n        if hasattr(self, \"closed\") and not self.closed:\n            self.close()\n\n    def _init_write_gz(self, compresslevel):\n        \"\"\"Initialize for writing with gzip compression.\n        \"\"\"\n        self.cmp = self.zlib.compressobj(compresslevel,\n                                         self.zlib.DEFLATED,\n                                         -self.zlib.MAX_WBITS,\n                                         self.zlib.DEF_MEM_LEVEL,\n                                         0)\n        timestamp = struct.pack(\"<L\", int(time.time()))\n        self.__write(b\"\\037\\213\\010\\010\" + timestamp + b\"\\002\\377\")\n        if self.name.endswith(\".gz\"):\n            self.name = self.name[:-3]\n        # Honor \"directory components removed\" from RFC1952\n        self.name = os.path.basename(self.name)\n        # RFC1952 says we must use ISO-8859-1 for the FNAME field.\n        self.__write(self.name.encode(\"iso-8859-1\", \"replace\") + NUL)\n\n    def write(self, s):\n        \"\"\"Write string s to the stream.\n        \"\"\"\n        if self.comptype == \"gz\":\n            self.crc = self.zlib.crc32(s, self.crc)\n        self.pos += len(s)\n        if self.comptype != \"tar\":\n            s = self.cmp.compress(s)\n        self.__write(s)\n\n    def __write(self, s):\n        \"\"\"Write string s to the stream if a whole new block\n           is ready to be written.\n        \"\"\"\n        self.buf += s\n        while len(self.buf) > self.bufsize:\n            self.fileobj.write(self.buf[:self.bufsize])\n            self.buf = self.buf[self.bufsize:]\n\n    def close(self):\n        \"\"\"Close the _Stream object. No operation should be\n           done on it afterwards.\n        \"\"\"\n        if self.closed:\n            return\n\n        self.closed = True\n        try:\n            if self.mode == \"w\" and self.comptype != \"tar\":\n                self.buf += self.cmp.flush()\n\n            if self.mode == \"w\" and self.buf:\n                self.fileobj.write(self.buf)\n                self.buf = b\"\"\n                if self.comptype == \"gz\":\n                    self.fileobj.write(struct.pack(\"<L\", self.crc))\n                    self.fileobj.write(struct.pack(\"<L\", self.pos & 0xffffFFFF))\n        finally:\n            if not self._extfileobj:\n                self.fileobj.close()\n\n    def _init_read_gz(self):\n        \"\"\"Initialize for reading a gzip compressed fileobj.\n        \"\"\"\n        self.cmp = self.zlib.decompressobj(-self.zlib.MAX_WBITS)\n        self.dbuf = b\"\"\n\n        # taken from gzip.GzipFile with some alterations\n        if self.__read(2) != b\"\\037\\213\":\n            raise ReadError(\"not a gzip file\")\n        if self.__read(1) != b\"\\010\":\n            raise CompressionError(\"unsupported compression method\")\n\n        flag = ord(self.__read(1))\n        self.__read(6)\n\n        if flag & 4:\n            xlen = ord(self.__read(1)) + 256 * ord(self.__read(1))\n            self.read(xlen)\n        if flag & 8:\n            while True:\n                s = self.__read(1)\n                if not s or s == NUL:\n                    break\n        if flag & 16:\n            while True:\n                s = self.__read(1)\n                if not s or s == NUL:\n                    break\n        if flag & 2:\n            self.__read(2)\n\n    def tell(self):\n        \"\"\"Return the stream's file pointer position.\n        \"\"\"\n        return self.pos\n\n    def seek(self, pos=0):\n        \"\"\"Set the stream's file pointer to pos. Negative seeking\n           is forbidden.\n        \"\"\"\n        if pos - self.pos >= 0:\n            blocks, remainder = divmod(pos - self.pos, self.bufsize)\n            for i in range(blocks):\n                self.read(self.bufsize)\n            self.read(remainder)\n        else:\n            raise StreamError(\"seeking backwards is not allowed\")\n        return self.pos\n\n    def read(self, size):\n        \"\"\"Return the next size number of bytes from the stream.\"\"\"\n        assert size is not None\n        buf = self._read(size)\n        self.pos += len(buf)\n        return buf\n\n    def _read(self, size):\n        \"\"\"Return size bytes from the stream.\n        \"\"\"\n        if self.comptype == \"tar\":\n            return self.__read(size)\n\n        c = len(self.dbuf)\n        t = [self.dbuf]\n        while c < size:\n            # Skip underlying buffer to avoid unaligned double buffering.\n            if self.buf:\n                buf = self.buf\n                self.buf = b\"\"\n            else:\n                buf = self.fileobj.read(self.bufsize)\n                if not buf:\n                    break\n            try:\n                buf = self.cmp.decompress(buf)\n            except self.exception as e:\n                raise ReadError(\"invalid compressed data\") from e\n            t.append(buf)\n            c += len(buf)\n        t = b\"\".join(t)\n        self.dbuf = t[size:]\n        return t[:size]\n\n    def __read(self, size):\n        \"\"\"Return size bytes from stream. If internal buffer is empty,\n           read another block from the stream.\n        \"\"\"\n        c = len(self.buf)\n        t = [self.buf]\n        while c < size:\n            buf = self.fileobj.read(self.bufsize)\n            if not buf:\n                break\n            t.append(buf)\n            c += len(buf)\n        t = b\"\".join(t)\n        self.buf = t[size:]\n        return t[:size]\n# class _Stream\n\nclass _StreamProxy(object):\n    \"\"\"Small proxy class that enables transparent compression\n       detection for the Stream interface (mode 'r|*').\n    \"\"\"\n\n    def __init__(self, fileobj):\n        self.fileobj = fileobj\n        self.buf = self.fileobj.read(BLOCKSIZE)\n\n    def read(self, size):\n        self.read = self.fileobj.read\n        return self.buf\n\n    def getcomptype(self):\n        if self.buf.startswith(b\"\\x1f\\x8b\\x08\"):\n            return \"gz\"\n        elif self.buf[0:3] == b\"BZh\" and self.buf[4:10] == b\"1AY&SY\":\n            return \"bz2\"\n        elif self.buf.startswith((b\"\\x5d\\x00\\x00\\x80\", b\"\\xfd7zXZ\")):\n            return \"xz\"\n        else:\n            return \"tar\"\n\n    def close(self):\n        self.fileobj.close()\n# class StreamProxy\n\n#------------------------\n# Extraction file object\n#------------------------\nclass _FileInFile(object):\n    \"\"\"A thin wrapper around an existing file object that\n       provides a part of its data as an individual file\n       object.\n    \"\"\"\n\n    def __init__(self, fileobj, offset, size, name, blockinfo=None):\n        self.fileobj = fileobj\n        self.offset = offset\n        self.size = size\n        self.position = 0\n        self.name = name\n        self.closed = False\n\n        if blockinfo is None:\n            blockinfo = [(0, size)]\n\n        # Construct a map with data and zero blocks.\n        self.map_index = 0\n        self.map = []\n        lastpos = 0\n        realpos = self.offset\n        for offset, size in blockinfo:\n            if offset > lastpos:\n                self.map.append((False, lastpos, offset, None))\n            self.map.append((True, offset, offset + size, realpos))\n            realpos += size\n            lastpos = offset + size\n        if lastpos < self.size:\n            self.map.append((False, lastpos, self.size, None))\n\n    def flush(self):\n        pass\n\n    def readable(self):\n        return True\n\n    def writable(self):\n        return False\n\n    def seekable(self):\n        return self.fileobj.seekable()\n\n    def tell(self):\n        \"\"\"Return the current file position.\n        \"\"\"\n        return self.position\n\n    def seek(self, position, whence=io.SEEK_SET):\n        \"\"\"Seek to a position in the file.\n        \"\"\"\n        if whence == io.SEEK_SET:\n            self.position = min(max(position, 0), self.size)\n        elif whence == io.SEEK_CUR:\n            if position < 0:\n                self.position = max(self.position + position, 0)\n            else:\n                self.position = min(self.position + position, self.size)\n        elif whence == io.SEEK_END:\n            self.position = max(min(self.size + position, self.size), 0)\n        else:\n            raise ValueError(\"Invalid argument\")\n        return self.position\n\n    def read(self, size=None):\n        \"\"\"Read data from the file.\n        \"\"\"\n        if size is None:\n            size = self.size - self.position\n        else:\n            size = min(size, self.size - self.position)\n\n        buf = b\"\"\n        while size > 0:\n            while True:\n                data, start, stop, offset = self.map[self.map_index]\n                if start <= self.position < stop:\n                    break\n                else:\n                    self.map_index += 1\n                    if self.map_index == len(self.map):\n                        self.map_index = 0\n            length = min(size, stop - self.position)\n            if data:\n                self.fileobj.seek(offset + (self.position - start))\n                b = self.fileobj.read(length)\n                if len(b) != length:\n                    raise ReadError(\"unexpected end of data\")\n                buf += b\n            else:\n                buf += NUL * length\n            size -= length\n            self.position += length\n        return buf\n\n    def readinto(self, b):\n        buf = self.read(len(b))\n        b[:len(buf)] = buf\n        return len(buf)\n\n    def close(self):\n        self.closed = True\n#class _FileInFile\n\nclass ExFileObject(io.BufferedReader):\n\n    def __init__(self, tarfile, tarinfo):\n        fileobj = _FileInFile(tarfile.fileobj, tarinfo.offset_data,\n                tarinfo.size, tarinfo.name, tarinfo.sparse)\n        super().__init__(fileobj)\n#class ExFileObject\n\n\n#-----------------------------\n# extraction filters (PEP 706)\n#-----------------------------\n\nclass FilterError(TarError):\n    pass\n\nclass AbsolutePathError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'member {tarinfo.name!r} has an absolute path')\n\nclass OutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):\n        self.tarinfo = tarinfo\n        self._path = path\n        super().__init__(f'{tarinfo.name!r} would be extracted to {path!r}, '\n                         + 'which is outside the destination')\n\nclass SpecialFileError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'{tarinfo.name!r} is a special file')\n\nclass AbsoluteLinkError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'{tarinfo.name!r} is a link to an absolute path')\n\nclass LinkOutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):\n        self.tarinfo = tarinfo\n        self._path = path\n        super().__init__(f'{tarinfo.name!r} would link to {path!r}, '\n                         + 'which is outside the destination')\n\ndef _get_filtered_attrs(member, dest_path, for_data=True):\n    new_attrs = {}\n    name = member.name\n    dest_path = os.path.realpath(dest_path)\n    # Strip leading / (tar's directory separator) from filenames.\n    # Include os.sep (target OS directory separator) as well.\n    if name.startswith(('/', os.sep)):\n        name = new_attrs['name'] = member.path.lstrip('/' + os.sep)\n    if os.path.isabs(name):\n        # Path is absolute even after stripping.\n        # For example, 'C:/foo' on Windows.\n        raise AbsolutePathError(member)\n    # Ensure we stay in the destination\n    target_path = os.path.realpath(os.path.join(dest_path, name))\n    if os.path.commonpath([target_path, dest_path]) != dest_path:\n        raise OutsideDestinationError(member, target_path)\n    # Limit permissions (no high bits, and go-w)\n    mode = member.mode\n    if mode is not None:\n        # Strip high bits & group/other write bits\n        mode = mode & 0o755\n        if for_data:\n            # For data, handle permissions & file types\n            if member.isreg() or member.islnk():\n                if not mode & 0o100:\n                    # Clear executable bits if not executable by user\n                    mode &= ~0o111\n                # Ensure owner can read & write\n                mode |= 0o600\n            elif member.isdir() or member.issym():\n                # Ignore mode for directories & symlinks\n                mode = None\n            else:\n                # Reject special files\n                raise SpecialFileError(member)\n        if mode != member.mode:\n            new_attrs['mode'] = mode\n    if for_data:\n        # Ignore ownership for 'data'\n        if member.uid is not None:\n            new_attrs['uid'] = None\n        if member.gid is not None:\n            new_attrs['gid'] = None\n        if member.uname is not None:\n            new_attrs['uname'] = None\n        if member.gname is not None:\n            new_attrs['gname'] = None\n        # Check link destination for 'data'\n        if member.islnk() or member.issym():\n            if os.path.isabs(member.linkname):\n                raise AbsoluteLinkError(member)\n            if member.issym():\n                target_path = os.path.join(dest_path,\n                                           os.path.dirname(name),\n                                           member.linkname)\n            else:\n                target_path = os.path.join(dest_path,\n                                           member.linkname)\n            target_path = os.path.realpath(target_path)\n            if os.path.commonpath([target_path, dest_path]) != dest_path:\n                raise LinkOutsideDestinationError(member, target_path)\n    return new_attrs\n\ndef fully_trusted_filter(member, dest_path):\n    return member\n\ndef tar_filter(member, dest_path):\n    new_attrs = _get_filtered_attrs(member, dest_path, False)\n    if new_attrs:\n        return member.replace(**new_attrs, deep=False)\n    return member\n\ndef data_filter(member, dest_path):\n    new_attrs = _get_filtered_attrs(member, dest_path, True)\n    if new_attrs:\n        return member.replace(**new_attrs, deep=False)\n    return member\n\n_NAMED_FILTERS = {\n    \"fully_trusted\": fully_trusted_filter,\n    \"tar\": tar_filter,\n    \"data\": data_filter,\n}\n\n#------------------\n# Exported Classes\n#------------------\n\n# Sentinel for replace() defaults, meaning \"don't change the attribute\"\n_KEEP = object()\n\nclass TarInfo(object):\n    \"\"\"Informational class which holds the details about an\n       archive member given by a tar header block.\n       TarInfo objects are returned by TarFile.getmember(),\n       TarFile.getmembers() and TarFile.gettarinfo() and are\n       usually created internally.\n    \"\"\"\n\n    __slots__ = dict(\n        name = 'Name of the archive member.',\n        mode = 'Permission bits.',\n        uid = 'User ID of the user who originally stored this member.',\n        gid = 'Group ID of the user who originally stored this member.',\n        size = 'Size in bytes.',\n        mtime = 'Time of last modification.',\n        chksum = 'Header checksum.',\n        type = ('File type. type is usually one of these constants: '\n                'REGTYPE, AREGTYPE, LNKTYPE, SYMTYPE, DIRTYPE, FIFOTYPE, '\n                'CONTTYPE, CHRTYPE, BLKTYPE, GNUTYPE_SPARSE.'),\n        linkname = ('Name of the target file name, which is only present '\n                    'in TarInfo objects of type LNKTYPE and SYMTYPE.'),\n        uname = 'User name.',\n        gname = 'Group name.',\n        devmajor = 'Device major number.',\n        devminor = 'Device minor number.',\n        offset = 'The tar header starts here.',\n        offset_data = \"The file's data starts here.\",\n        pax_headers = ('A dictionary containing key-value pairs of an '\n                       'associated pax extended header.'),\n        sparse = 'Sparse member information.',\n        tarfile = None,\n        _sparse_structs = None,\n        _link_target = None,\n        )\n\n    def __init__(self, name=\"\"):\n        \"\"\"Construct a TarInfo object. name is the optional name\n           of the member.\n        \"\"\"\n        self.name = name        # member name\n        self.mode = 0o644       # file permissions\n        self.uid = 0            # user id\n        self.gid = 0            # group id\n        self.size = 0           # file size\n        self.mtime = 0          # modification time\n        self.chksum = 0         # header checksum\n        self.type = REGTYPE     # member type\n        self.linkname = \"\"      # link name\n        self.uname = \"\"         # user name\n        self.gname = \"\"         # group name\n        self.devmajor = 0       # device major number\n        self.devminor = 0       # device minor number\n\n        self.offset = 0         # the tar header starts here\n        self.offset_data = 0    # the file's data starts here\n\n        self.sparse = None      # sparse member information\n        self.pax_headers = {}   # pax header information\n\n    @property\n    def path(self):\n        'In pax headers, \"name\" is called \"path\".'\n        return self.name\n\n    @path.setter\n    def path(self, name):\n        self.name = name\n\n    @property\n    def linkpath(self):\n        'In pax headers, \"linkname\" is called \"linkpath\".'\n        return self.linkname\n\n    @linkpath.setter\n    def linkpath(self, linkname):\n        self.linkname = linkname\n\n    def __repr__(self):\n        return \"<%s %r at %#x>\" % (self.__class__.__name__,self.name,id(self))\n\n    def replace(self, *,\n                name=_KEEP, mtime=_KEEP, mode=_KEEP, linkname=_KEEP,\n                uid=_KEEP, gid=_KEEP, uname=_KEEP, gname=_KEEP,\n                deep=True, _KEEP=_KEEP):\n        \"\"\"Return a deep copy of self with the given attributes replaced.\n        \"\"\"\n        if deep:\n            result = copy.deepcopy(self)\n        else:\n            result = copy.copy(self)\n        if name is not _KEEP:\n            result.name = name\n        if mtime is not _KEEP:\n            result.mtime = mtime\n        if mode is not _KEEP:\n            result.mode = mode\n        if linkname is not _KEEP:\n            result.linkname = linkname\n        if uid is not _KEEP:\n            result.uid = uid\n        if gid is not _KEEP:\n            result.gid = gid\n        if uname is not _KEEP:\n            result.uname = uname\n        if gname is not _KEEP:\n            result.gname = gname\n        return result\n\n    def get_info(self):\n        \"\"\"Return the TarInfo's attributes as a dictionary.\n        \"\"\"\n        if self.mode is None:\n            mode = None\n        else:\n            mode = self.mode & 0o7777\n        info = {\n            \"name\":     self.name,\n            \"mode\":     mode,\n            \"uid\":      self.uid,\n            \"gid\":      self.gid,\n            \"size\":     self.size,\n            \"mtime\":    self.mtime,\n            \"chksum\":   self.chksum,\n            \"type\":     self.type,\n            \"linkname\": self.linkname,\n            \"uname\":    self.uname,\n            \"gname\":    self.gname,\n            \"devmajor\": self.devmajor,\n            \"devminor\": self.devminor\n        }\n\n        if info[\"type\"] == DIRTYPE and not info[\"name\"].endswith(\"/\"):\n            info[\"name\"] += \"/\"\n\n        return info\n\n    def tobuf(self, format=DEFAULT_FORMAT, encoding=ENCODING, errors=\"surrogateescape\"):\n        \"\"\"Return a tar header as a string of 512 byte blocks.\n        \"\"\"\n        info = self.get_info()\n        for name, value in info.items():\n            if value is None:\n                raise ValueError(\"%s may not be None\" % name)\n\n        if format == USTAR_FORMAT:\n            return self.create_ustar_header(info, encoding, errors)\n        elif format == GNU_FORMAT:\n            return self.create_gnu_header(info, encoding, errors)\n        elif format == PAX_FORMAT:\n            return self.create_pax_header(info, encoding)\n        else:\n            raise ValueError(\"invalid format\")\n\n    def create_ustar_header(self, info, encoding, errors):\n        \"\"\"Return the object as a ustar header block.\n        \"\"\"\n        info[\"magic\"] = POSIX_MAGIC\n\n        if len(info[\"linkname\"].encode(encoding, errors)) > LENGTH_LINK:\n            raise ValueError(\"linkname is too long\")\n\n        if len(info[\"name\"].encode(encoding, errors)) > LENGTH_NAME:\n            info[\"prefix\"], info[\"name\"] = self._posix_split_name(info[\"name\"], encoding, errors)\n\n        return self._create_header(info, USTAR_FORMAT, encoding, errors)\n\n    def create_gnu_header(self, info, encoding, errors):\n        \"\"\"Return the object as a GNU header block sequence.\n        \"\"\"\n        info[\"magic\"] = GNU_MAGIC\n\n        buf = b\"\"\n        if len(info[\"linkname\"].encode(encoding, errors)) > LENGTH_LINK:\n            buf += self._create_gnu_long_header(info[\"linkname\"], GNUTYPE_LONGLINK, encoding, errors)\n\n        if len(info[\"name\"].encode(encoding, errors)) > LENGTH_NAME:\n            buf += self._create_gnu_long_header(info[\"name\"], GNUTYPE_LONGNAME, encoding, errors)\n\n        return buf + self._create_header(info, GNU_FORMAT, encoding, errors)\n\n    def create_pax_header(self, info, encoding):\n        \"\"\"Return the object as a ustar header block. If it cannot be\n           represented this way, prepend a pax extended header sequence\n           with supplement information.\n        \"\"\"\n        info[\"magic\"] = POSIX_MAGIC\n        pax_headers = self.pax_headers.copy()\n\n        # Test string fields for values that exceed the field length or cannot\n        # be represented in ASCII encoding.\n        for name, hname, length in (\n                (\"name\", \"path\", LENGTH_NAME), (\"linkname\", \"linkpath\", LENGTH_LINK),\n                (\"uname\", \"uname\", 32), (\"gname\", \"gname\", 32)):\n\n            if hname in pax_headers:\n                # The pax header has priority.\n                continue\n\n            # Try to encode the string as ASCII.\n            try:\n                info[name].encode(\"ascii\", \"strict\")\n            except UnicodeEncodeError:\n                pax_headers[hname] = info[name]\n                continue\n\n            if len(info[name]) > length:\n                pax_headers[hname] = info[name]\n\n        # Test number fields for values that exceed the field limit or values\n        # that like to be stored as float.\n        for name, digits in ((\"uid\", 8), (\"gid\", 8), (\"size\", 12), (\"mtime\", 12)):\n            needs_pax = False\n\n            val = info[name]\n            val_is_float = isinstance(val, float)\n            val_int = round(val) if val_is_float else val\n            if not 0 <= val_int < 8 ** (digits - 1):\n                # Avoid overflow.\n                info[name] = 0\n                needs_pax = True\n            elif val_is_float:\n                # Put rounded value in ustar header, and full\n                # precision value in pax header.\n                info[name] = val_int\n                needs_pax = True\n\n            # The existing pax header has priority.\n            if needs_pax and name not in pax_headers:\n                pax_headers[name] = str(val)\n\n        # Create a pax extended header if necessary.\n        if pax_headers:\n            buf = self._create_pax_generic_header(pax_headers, XHDTYPE, encoding)\n        else:\n            buf = b\"\"\n\n        return buf + self._create_header(info, USTAR_FORMAT, \"ascii\", \"replace\")\n\n    @classmethod\n    def create_pax_global_header(cls, pax_headers):\n        \"\"\"Return the object as a pax global header block sequence.\n        \"\"\"\n        return cls._create_pax_generic_header(pax_headers, XGLTYPE, \"utf-8\")\n\n    def _posix_split_name(self, name, encoding, errors):\n        \"\"\"Split a name longer than 100 chars into a prefix\n           and a name part.\n        \"\"\"\n        components = name.split(\"/\")\n        for i in range(1, len(components)):\n            prefix = \"/\".join(components[:i])\n            name = \"/\".join(components[i:])\n            if len(prefix.encode(encoding, errors)) <= LENGTH_PREFIX and \\\n                    len(name.encode(encoding, errors)) <= LENGTH_NAME:\n                break\n        else:\n            raise ValueError(\"name is too long\")\n\n        return prefix, name\n\n    @staticmethod\n    def _create_header(info, format, encoding, errors):\n        \"\"\"Return a header block. info is a dictionary with file\n           information, format must be one of the *_FORMAT constants.\n        \"\"\"\n        has_device_fields = info.get(\"type\") in (CHRTYPE, BLKTYPE)\n        if has_device_fields:\n            devmajor = itn(info.get(\"devmajor\", 0), 8, format)\n            devminor = itn(info.get(\"devminor\", 0), 8, format)\n        else:\n            devmajor = stn(\"\", 8, encoding, errors)\n            devminor = stn(\"\", 8, encoding, errors)\n\n        # None values in metadata should cause ValueError.\n        # itn()/stn() do this for all fields except type.\n        filetype = info.get(\"type\", REGTYPE)\n        if filetype is None:\n            raise ValueError(\"TarInfo.type must not be None\")\n\n        parts = [\n            stn(info.get(\"name\", \"\"), 100, encoding, errors),\n            itn(info.get(\"mode\", 0) & 0o7777, 8, format),\n            itn(info.get(\"uid\", 0), 8, format),\n            itn(info.get(\"gid\", 0), 8, format),\n            itn(info.get(\"size\", 0), 12, format),\n            itn(info.get(\"mtime\", 0), 12, format),\n            b\"        \", # checksum field\n            filetype,\n            stn(info.get(\"linkname\", \"\"), 100, encoding, errors),\n            info.get(\"magic\", POSIX_MAGIC),\n            stn(info.get(\"uname\", \"\"), 32, encoding, errors),\n            stn(info.get(\"gname\", \"\"), 32, encoding, errors),\n            devmajor,\n            devminor,\n            stn(info.get(\"prefix\", \"\"), 155, encoding, errors)\n        ]\n\n        buf = struct.pack(\"%ds\" % BLOCKSIZE, b\"\".join(parts))\n        chksum = calc_chksums(buf[-BLOCKSIZE:])[0]\n        buf = buf[:-364] + bytes(\"%06o\\0\" % chksum, \"ascii\") + buf[-357:]\n        return buf\n\n    @staticmethod\n    def _create_payload(payload):\n        \"\"\"Return the string payload filled with zero bytes\n           up to the next 512 byte border.\n        \"\"\"\n        blocks, remainder = divmod(len(payload), BLOCKSIZE)\n        if remainder > 0:\n            payload += (BLOCKSIZE - remainder) * NUL\n        return payload\n\n    @classmethod\n    def _create_gnu_long_header(cls, name, type, encoding, errors):\n        \"\"\"Return a GNUTYPE_LONGNAME or GNUTYPE_LONGLINK sequence\n           for name.\n        \"\"\"\n        name = name.encode(encoding, errors) + NUL\n\n        info = {}\n        info[\"name\"] = \"././@LongLink\"\n        info[\"type\"] = type\n        info[\"size\"] = len(name)\n        info[\"magic\"] = GNU_MAGIC\n\n        # create extended header + name blocks.\n        return cls._create_header(info, USTAR_FORMAT, encoding, errors) + \\\n                cls._create_payload(name)\n\n    @classmethod\n    def _create_pax_generic_header(cls, pax_headers, type, encoding):\n        \"\"\"Return a POSIX.1-2008 extended or global header sequence\n           that contains a list of keyword, value pairs. The values\n           must be strings.\n        \"\"\"\n        # Check if one of the fields contains surrogate characters and thereby\n        # forces hdrcharset=BINARY, see _proc_pax() for more information.\n        binary = False\n        for keyword, value in pax_headers.items():\n            try:\n                value.encode(\"utf-8\", \"strict\")\n            except UnicodeEncodeError:\n                binary = True\n                break\n\n        records = b\"\"\n        if binary:\n            # Put the hdrcharset field at the beginning of the header.\n            records += b\"21 hdrcharset=BINARY\\n\"\n\n        for keyword, value in pax_headers.items():\n            keyword = keyword.encode(\"utf-8\")\n            if binary:\n                # Try to restore the original byte representation of `value'.\n                # Needless to say, that the encoding must match the string.\n                value = value.encode(encoding, \"surrogateescape\")\n            else:\n                value = value.encode(\"utf-8\")\n\n            l = len(keyword) + len(value) + 3   # ' ' + '=' + '\\n'\n            n = p = 0\n            while True:\n                n = l + len(str(p))\n                if n == p:\n                    break\n                p = n\n            records += bytes(str(p), \"ascii\") + b\" \" + keyword + b\"=\" + value + b\"\\n\"\n\n        # We use a hardcoded \"././@PaxHeader\" name like star does\n        # instead of the one that POSIX recommends.\n        info = {}\n        info[\"name\"] = \"././@PaxHeader\"\n        info[\"type\"] = type\n        info[\"size\"] = len(records)\n        info[\"magic\"] = POSIX_MAGIC\n\n        # Create pax header + record blocks.\n        return cls._create_header(info, USTAR_FORMAT, \"ascii\", \"replace\") + \\\n                cls._create_payload(records)\n\n    @classmethod\n    def frombuf(cls, buf, encoding, errors):\n        \"\"\"Construct a TarInfo object from a 512 byte bytes object.\n        \"\"\"\n        if len(buf) == 0:\n            raise EmptyHeaderError(\"empty header\")\n        if len(buf) != BLOCKSIZE:\n            raise TruncatedHeaderError(\"truncated header\")\n        if buf.count(NUL) == BLOCKSIZE:\n            raise EOFHeaderError(\"end of file header\")\n\n        chksum = nti(buf[148:156])\n        if chksum not in calc_chksums(buf):\n            raise InvalidHeaderError(\"bad checksum\")\n\n        obj = cls()\n        obj.name = nts(buf[0:100], encoding, errors)\n        obj.mode = nti(buf[100:108])\n        obj.uid = nti(buf[108:116])\n        obj.gid = nti(buf[116:124])\n        obj.size = nti(buf[124:136])\n        obj.mtime = nti(buf[136:148])\n        obj.chksum = chksum\n        obj.type = buf[156:157]\n        obj.linkname = nts(buf[157:257], encoding, errors)\n        obj.uname = nts(buf[265:297], encoding, errors)\n        obj.gname = nts(buf[297:329], encoding, errors)\n        obj.devmajor = nti(buf[329:337])\n        obj.devminor = nti(buf[337:345])\n        prefix = nts(buf[345:500], encoding, errors)\n\n        # Old V7 tar format represents a directory as a regular\n        # file with a trailing slash.\n        if obj.type == AREGTYPE and obj.name.endswith(\"/\"):\n            obj.type = DIRTYPE\n\n        # The old GNU sparse format occupies some of the unused\n        # space in the buffer for up to 4 sparse structures.\n        # Save them for later processing in _proc_sparse().\n        if obj.type == GNUTYPE_SPARSE:\n            pos = 386\n            structs = []\n            for i in range(4):\n                try:\n                    offset = nti(buf[pos:pos + 12])\n                    numbytes = nti(buf[pos + 12:pos + 24])\n                except ValueError:\n                    break\n                structs.append((offset, numbytes))\n                pos += 24\n            isextended = bool(buf[482])\n            origsize = nti(buf[483:495])\n            obj._sparse_structs = (structs, isextended, origsize)\n\n        # Remove redundant slashes from directories.\n        if obj.isdir():\n            obj.name = obj.name.rstrip(\"/\")\n\n        # Reconstruct a ustar longname.\n        if prefix and obj.type not in GNU_TYPES:\n            obj.name = prefix + \"/\" + obj.name\n        return obj\n\n    @classmethod\n    def fromtarfile(cls, tarfile):\n        \"\"\"Return the next TarInfo object from TarFile object\n           tarfile.\n        \"\"\"\n        buf = tarfile.fileobj.read(BLOCKSIZE)\n        obj = cls.frombuf(buf, tarfile.encoding, tarfile.errors)\n        obj.offset = tarfile.fileobj.tell() - BLOCKSIZE\n        return obj._proc_member(tarfile)\n\n    #--------------------------------------------------------------------------\n    # The following are methods that are called depending on the type of a\n    # member. The entry point is _proc_member() which can be overridden in a\n    # subclass to add custom _proc_*() methods. A _proc_*() method MUST\n    # implement the following\n    # operations:\n    # 1. Set self.offset_data to the position where the data blocks begin,\n    #    if there is data that follows.\n    # 2. Set tarfile.offset to the position where the next member's header will\n    #    begin.\n    # 3. Return self or another valid TarInfo object.\n    def _proc_member(self, tarfile):\n        \"\"\"Choose the right processing method depending on\n           the type and call it.\n        \"\"\"\n        if self.type in (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK):\n            return self._proc_gnulong(tarfile)\n        elif self.type == GNUTYPE_SPARSE:\n            return self._proc_sparse(tarfile)\n        elif self.type in (XHDTYPE, XGLTYPE, SOLARIS_XHDTYPE):\n            return self._proc_pax(tarfile)\n        else:\n            return self._proc_builtin(tarfile)\n\n    def _proc_builtin(self, tarfile):\n        \"\"\"Process a builtin type or an unknown type which\n           will be treated as a regular file.\n        \"\"\"\n        self.offset_data = tarfile.fileobj.tell()\n        offset = self.offset_data\n        if self.isreg() or self.type not in SUPPORTED_TYPES:\n            # Skip the following data blocks.\n            offset += self._block(self.size)\n        tarfile.offset = offset\n\n        # Patch the TarInfo object with saved global\n        # header information.\n        self._apply_pax_info(tarfile.pax_headers, tarfile.encoding, tarfile.errors)\n\n        # Remove redundant slashes from directories. This is to be consistent\n        # with frombuf().\n        if self.isdir():\n            self.name = self.name.rstrip(\"/\")\n\n        return self\n\n    def _proc_gnulong(self, tarfile):\n        \"\"\"Process the blocks that hold a GNU longname\n           or longlink member.\n        \"\"\"\n        buf = tarfile.fileobj.read(self._block(self.size))\n\n        # Fetch the next header and process it.\n        try:\n            next = self.fromtarfile(tarfile)\n        except HeaderError as e:\n            raise SubsequentHeaderError(str(e)) from None\n\n        # Patch the TarInfo object from the next header with\n        # the longname information.\n        next.offset = self.offset\n        if self.type == GNUTYPE_LONGNAME:\n            next.name = nts(buf, tarfile.encoding, tarfile.errors)\n        elif self.type == GNUTYPE_LONGLINK:\n            next.linkname = nts(buf, tarfile.encoding, tarfile.errors)\n\n        # Remove redundant slashes from directories. This is to be consistent\n        # with frombuf().\n        if next.isdir():\n            next.name = next.name.removesuffix(\"/\")\n\n        return next\n\n    def _proc_sparse(self, tarfile):\n        \"\"\"Process a GNU sparse header plus extra headers.\n        \"\"\"\n        # We already collected some sparse structures in frombuf().\n        structs, isextended, origsize = self._sparse_structs\n        del self._sparse_structs\n\n        # Collect sparse structures from extended header blocks.\n        while isextended:\n            buf = tarfile.fileobj.read(BLOCKSIZE)\n            pos = 0\n            for i in range(21):\n                try:\n                    offset = nti(buf[pos:pos + 12])\n                    numbytes = nti(buf[pos + 12:pos + 24])\n                except ValueError:\n                    break\n                if offset and numbytes:\n                    structs.append((offset, numbytes))\n                pos += 24\n            isextended = bool(buf[504])\n        self.sparse = structs\n\n        self.offset_data = tarfile.fileobj.tell()\n        tarfile.offset = self.offset_data + self._block(self.size)\n        self.size = origsize\n        return self\n\n    def _proc_pax(self, tarfile):\n        \"\"\"Process an extended or global header as described in\n           POSIX.1-2008.\n        \"\"\"\n        # Read the header information.\n        buf = tarfile.fileobj.read(self._block(self.size))\n\n        # A pax header stores supplemental information for either\n        # the following file (extended) or all following files\n        # (global).\n        if self.type == XGLTYPE:\n            pax_headers = tarfile.pax_headers\n        else:\n            pax_headers = tarfile.pax_headers.copy()\n\n        # Check if the pax header contains a hdrcharset field. This tells us\n        # the encoding of the path, linkpath, uname and gname fields. Normally,\n        # these fields are UTF-8 encoded but since POSIX.1-2008 tar\n        # implementations are allowed to store them as raw binary strings if\n        # the translation to UTF-8 fails.\n        match = re.search(br\"\\d+ hdrcharset=([^\\n]+)\\n\", buf)\n        if match is not None:\n            pax_headers[\"hdrcharset\"] = match.group(1).decode(\"utf-8\")\n\n        # For the time being, we don't care about anything other than \"BINARY\".\n        # The only other value that is currently allowed by the standard is\n        # \"ISO-IR 10646 2000 UTF-8\" in other words UTF-8.\n        hdrcharset = pax_headers.get(\"hdrcharset\")\n        if hdrcharset == \"BINARY\":\n            encoding = tarfile.encoding\n        else:\n            encoding = \"utf-8\"\n\n        # Parse pax header information. A record looks like that:\n        # \"%d %s=%s\\n\" % (length, keyword, value). length is the size\n        # of the complete record including the length field itself and\n        # the newline. keyword and value are both UTF-8 encoded strings.\n        regex = re.compile(br\"(\\d+) ([^=]+)=\")\n        pos = 0\n        while match := regex.match(buf, pos):\n            length, keyword = match.groups()\n            length = int(length)\n            if length == 0:\n                raise InvalidHeaderError(\"invalid header\")\n            value = buf[match.end(2) + 1:match.start(1) + length - 1]\n\n            # Normally, we could just use \"utf-8\" as the encoding and \"strict\"\n            # as the error handler, but we better not take the risk. For\n            # example, GNU tar <= 1.23 is known to store filenames it cannot\n            # translate to UTF-8 as raw strings (unfortunately without a\n            # hdrcharset=BINARY header).\n            # We first try the strict standard encoding, and if that fails we\n            # fall back on the user's encoding and error handler.\n            keyword = self._decode_pax_field(keyword, \"utf-8\", \"utf-8\",\n                    tarfile.errors)\n            if keyword in PAX_NAME_FIELDS:\n                value = self._decode_pax_field(value, encoding, tarfile.encoding,\n                        tarfile.errors)\n            else:\n                value = self._decode_pax_field(value, \"utf-8\", \"utf-8\",\n                        tarfile.errors)\n\n            pax_headers[keyword] = value\n            pos += length\n\n        # Fetch the next header.\n        try:\n            next = self.fromtarfile(tarfile)\n        except HeaderError as e:\n            raise SubsequentHeaderError(str(e)) from None\n\n        # Process GNU sparse information.\n        if \"GNU.sparse.map\" in pax_headers:\n            # GNU extended sparse format version 0.1.\n            self._proc_gnusparse_01(next, pax_headers)\n\n        elif \"GNU.sparse.size\" in pax_headers:\n            # GNU extended sparse format version 0.0.\n            self._proc_gnusparse_00(next, pax_headers, buf)\n\n        elif pax_headers.get(\"GNU.sparse.major\") == \"1\" and pax_headers.get(\"GNU.sparse.minor\") == \"0\":\n            # GNU extended sparse format version 1.0.\n            self._proc_gnusparse_10(next, pax_headers, tarfile)\n\n        if self.type in (XHDTYPE, SOLARIS_XHDTYPE):\n            # Patch the TarInfo object with the extended header info.\n            next._apply_pax_info(pax_headers, tarfile.encoding, tarfile.errors)\n            next.offset = self.offset\n\n            if \"size\" in pax_headers:\n                # If the extended header replaces the size field,\n                # we need to recalculate the offset where the next\n                # header starts.\n                offset = next.offset_data\n                if next.isreg() or next.type not in SUPPORTED_TYPES:\n                    offset += next._block(next.size)\n                tarfile.offset = offset\n\n        return next\n\n    def _proc_gnusparse_00(self, next, pax_headers, buf):\n        \"\"\"Process a GNU tar extended sparse header, version 0.0.\n        \"\"\"\n        offsets = []\n        for match in re.finditer(br\"\\d+ GNU.sparse.offset=(\\d+)\\n\", buf):\n            offsets.append(int(match.group(1)))\n        numbytes = []\n        for match in re.finditer(br\"\\d+ GNU.sparse.numbytes=(\\d+)\\n\", buf):\n            numbytes.append(int(match.group(1)))\n        next.sparse = list(zip(offsets, numbytes))\n\n    def _proc_gnusparse_01(self, next, pax_headers):\n        \"\"\"Process a GNU tar extended sparse header, version 0.1.\n        \"\"\"\n        sparse = [int(x) for x in pax_headers[\"GNU.sparse.map\"].split(\",\")]\n        next.sparse = list(zip(sparse[::2], sparse[1::2]))\n\n    def _proc_gnusparse_10(self, next, pax_headers, tarfile):\n        \"\"\"Process a GNU tar extended sparse header, version 1.0.\n        \"\"\"\n        fields = None\n        sparse = []\n        buf = tarfile.fileobj.read(BLOCKSIZE)\n        fields, buf = buf.split(b\"\\n\", 1)\n        fields = int(fields)\n        while len(sparse) < fields * 2:\n            if b\"\\n\" not in buf:\n                buf += tarfile.fileobj.read(BLOCKSIZE)\n            number, buf = buf.split(b\"\\n\", 1)\n            sparse.append(int(number))\n        next.offset_data = tarfile.fileobj.tell()\n        next.sparse = list(zip(sparse[::2], sparse[1::2]))\n\n    def _apply_pax_info(self, pax_headers, encoding, errors):\n        \"\"\"Replace fields with supplemental information from a previous\n           pax extended or global header.\n        \"\"\"\n        for keyword, value in pax_headers.items():\n            if keyword == \"GNU.sparse.name\":\n                setattr(self, \"path\", value)\n            elif keyword == \"GNU.sparse.size\":\n                setattr(self, \"size\", int(value))\n            elif keyword == \"GNU.sparse.realsize\":\n                setattr(self, \"size\", int(value))\n            elif keyword in PAX_FIELDS:\n                if keyword in PAX_NUMBER_FIELDS:\n                    try:\n                        value = PAX_NUMBER_FIELDS[keyword](value)\n                    except ValueError:\n                        value = 0\n                if keyword == \"path\":\n                    value = value.rstrip(\"/\")\n                setattr(self, keyword, value)\n\n        self.pax_headers = pax_headers.copy()\n\n    def _decode_pax_field(self, value, encoding, fallback_encoding, fallback_errors):\n        \"\"\"Decode a single field from a pax record.\n        \"\"\"\n        try:\n            return value.decode(encoding, \"strict\")\n        except UnicodeDecodeError:\n            return value.decode(fallback_encoding, fallback_errors)\n\n    def _block(self, count):\n        \"\"\"Round up a byte count by BLOCKSIZE and return it,\n           e.g. _block(834) => 1024.\n        \"\"\"\n        blocks, remainder = divmod(count, BLOCKSIZE)\n        if remainder:\n            blocks += 1\n        return blocks * BLOCKSIZE\n\n    def isreg(self):\n        'Return True if the Tarinfo object is a regular file.'\n        return self.type in REGULAR_TYPES\n\n    def isfile(self):\n        'Return True if the Tarinfo object is a regular file.'\n        return self.isreg()\n\n    def isdir(self):\n        'Return True if it is a directory.'\n        return self.type == DIRTYPE\n\n    def issym(self):\n        'Return True if it is a symbolic link.'\n        return self.type == SYMTYPE\n\n    def islnk(self):\n        'Return True if it is a hard link.'\n        return self.type == LNKTYPE\n\n    def ischr(self):\n        'Return True if it is a character device.'\n        return self.type == CHRTYPE\n\n    def isblk(self):\n        'Return True if it is a block device.'\n        return self.type == BLKTYPE\n\n    def isfifo(self):\n        'Return True if it is a FIFO.'\n        return self.type == FIFOTYPE\n\n    def issparse(self):\n        return self.sparse is not None\n\n    def isdev(self):\n        'Return True if it is one of character device, block device or FIFO.'\n        return self.type in (CHRTYPE, BLKTYPE, FIFOTYPE)\n# class TarInfo\n\nclass TarFile(object):\n    \"\"\"The TarFile Class provides an interface to tar archives.\n    \"\"\"\n\n    debug = 0                   # May be set from 0 (no msgs) to 3 (all msgs)\n\n    dereference = False         # If true, add content of linked file to the\n                                # tar file, else the link.\n\n    ignore_zeros = False        # If true, skips empty or invalid blocks and\n                                # continues processing.\n\n    errorlevel = 1              # If 0, fatal errors only appear in debug\n                                # messages (if debug >= 0). If > 0, errors\n                                # are passed to the caller as exceptions.\n\n    format = DEFAULT_FORMAT     # The format to use when creating an archive.\n\n    encoding = ENCODING         # Encoding for 8-bit character strings.\n\n    errors = None               # Error handler for unicode conversion.\n\n    tarinfo = TarInfo           # The default TarInfo class to use.\n\n    fileobject = ExFileObject   # The file-object for extractfile().\n\n    extraction_filter = None    # The default filter for extraction.\n\n    def __init__(self, name=None, mode=\"r\", fileobj=None, format=None,\n            tarinfo=None, dereference=None, ignore_zeros=None, encoding=None,\n            errors=\"surrogateescape\", pax_headers=None, debug=None,\n            errorlevel=None, copybufsize=None):\n        \"\"\"Open an (uncompressed) tar archive `name'. `mode' is either 'r' to\n           read from an existing archive, 'a' to append data to an existing\n           file or 'w' to create a new file overwriting an existing one. `mode'\n           defaults to 'r'.\n           If `fileobj' is given, it is used for reading or writing data. If it\n           can be determined, `mode' is overridden by `fileobj's mode.\n           `fileobj' is not closed, when TarFile is closed.\n        \"\"\"\n        modes = {\"r\": \"rb\", \"a\": \"r+b\", \"w\": \"wb\", \"x\": \"xb\"}\n        if mode not in modes:\n            raise ValueError(\"mode must be 'r', 'a', 'w' or 'x'\")\n        self.mode = mode\n        self._mode = modes[mode]\n\n        if not fileobj:\n            if self.mode == \"a\" and not os.path.exists(name):\n                # Create nonexistent files in append mode.\n                self.mode = \"w\"\n                self._mode = \"wb\"\n            fileobj = bltn_open(name, self._mode)\n            self._extfileobj = False\n        else:\n            if (name is None and hasattr(fileobj, \"name\") and\n                isinstance(fileobj.name, (str, bytes))):\n                name = fileobj.name\n            if hasattr(fileobj, \"mode\"):\n                self._mode = fileobj.mode\n            self._extfileobj = True\n        self.name = os.path.abspath(name) if name else None\n        self.fileobj = fileobj\n\n        # Init attributes.\n        if format is not None:\n            self.format = format\n        if tarinfo is not None:\n            self.tarinfo = tarinfo\n        if dereference is not None:\n            self.dereference = dereference\n        if ignore_zeros is not None:\n            self.ignore_zeros = ignore_zeros\n        if encoding is not None:\n            self.encoding = encoding\n        self.errors = errors\n\n        if pax_headers is not None and self.format == PAX_FORMAT:\n            self.pax_headers = pax_headers\n        else:\n            self.pax_headers = {}\n\n        if debug is not None:\n            self.debug = debug\n        if errorlevel is not None:\n            self.errorlevel = errorlevel\n\n        # Init datastructures.\n        self.copybufsize = copybufsize\n        self.closed = False\n        self.members = []       # list of members as TarInfo objects\n        self._loaded = False    # flag if all members have been read\n        self.offset = self.fileobj.tell()\n                                # current position in the archive file\n        self.inodes = {}        # dictionary caching the inodes of\n                                # archive members already added\n\n        try:\n            if self.mode == \"r\":\n                self.firstmember = None\n                self.firstmember = self.next()\n\n            if self.mode == \"a\":\n                # Move to the end of the archive,\n                # before the first empty block.\n                while True:\n                    self.fileobj.seek(self.offset)\n                    try:\n                        tarinfo = self.tarinfo.fromtarfile(self)\n                        self.members.append(tarinfo)\n                    except EOFHeaderError:\n                        self.fileobj.seek(self.offset)\n                        break\n                    except HeaderError as e:\n                        raise ReadError(str(e)) from None\n\n            if self.mode in (\"a\", \"w\", \"x\"):\n                self._loaded = True\n\n                if self.pax_headers:\n                    buf = self.tarinfo.create_pax_global_header(self.pax_headers.copy())\n                    self.fileobj.write(buf)\n                    self.offset += len(buf)\n        except:\n            if not self._extfileobj:\n                self.fileobj.close()\n            self.closed = True\n            raise\n\n    #--------------------------------------------------------------------------\n    # Below are the classmethods which act as alternate constructors to the\n    # TarFile class. The open() method is the only one that is needed for\n    # public use; it is the \"super\"-constructor and is able to select an\n    # adequate \"sub\"-constructor for a particular compression using the mapping\n    # from OPEN_METH.\n    #\n    # This concept allows one to subclass TarFile without losing the comfort of\n    # the super-constructor. A sub-constructor is registered and made available\n    # by adding it to the mapping in OPEN_METH.\n\n    @classmethod\n    def open(cls, name=None, mode=\"r\", fileobj=None, bufsize=RECORDSIZE, **kwargs):\n        r\"\"\"Open a tar archive for reading, writing or appending. Return\n           an appropriate TarFile class.\n\n           mode:\n           'r' or 'r:\\*' open for reading with transparent compression\n           'r:'         open for reading exclusively uncompressed\n           'r:gz'       open for reading with gzip compression\n           'r:bz2'      open for reading with bzip2 compression\n           'r:xz'       open for reading with lzma compression\n           'a' or 'a:'  open for appending, creating the file if necessary\n           'w' or 'w:'  open for writing without compression\n           'w:gz'       open for writing with gzip compression\n           'w:bz2'      open for writing with bzip2 compression\n           'w:xz'       open for writing with lzma compression\n\n           'x' or 'x:'  create a tarfile exclusively without compression, raise\n                        an exception if the file is already created\n           'x:gz'       create a gzip compressed tarfile, raise an exception\n                        if the file is already created\n           'x:bz2'      create a bzip2 compressed tarfile, raise an exception\n                        if the file is already created\n           'x:xz'       create an lzma compressed tarfile, raise an exception\n                        if the file is already created\n\n           'r|\\*'        open a stream of tar blocks with transparent compression\n           'r|'         open an uncompressed stream of tar blocks for reading\n           'r|gz'       open a gzip compressed stream of tar blocks\n           'r|bz2'      open a bzip2 compressed stream of tar blocks\n           'r|xz'       open an lzma compressed stream of tar blocks\n           'w|'         open an uncompressed stream for writing\n           'w|gz'       open a gzip compressed stream for writing\n           'w|bz2'      open a bzip2 compressed stream for writing\n           'w|xz'       open an lzma compressed stream for writing\n        \"\"\"\n\n        if not name and not fileobj:\n            raise ValueError(\"nothing to open\")\n\n        if mode in (\"r\", \"r:*\"):\n            # Find out which *open() is appropriate for opening the file.\n            def not_compressed(comptype):\n                return cls.OPEN_METH[comptype] == 'taropen'\n            error_msgs = []\n            for comptype in sorted(cls.OPEN_METH, key=not_compressed):\n                func = getattr(cls, cls.OPEN_METH[comptype])\n                if fileobj is not None:\n                    saved_pos = fileobj.tell()\n                try:\n                    return func(name, \"r\", fileobj, **kwargs)\n                except (ReadError, CompressionError) as e:\n                    error_msgs.append(f'- method {comptype}: {e!r}')\n                    if fileobj is not None:\n                        fileobj.seek(saved_pos)\n                    continue\n            error_msgs_summary = '\\n'.join(error_msgs)\n            raise ReadError(f\"file could not be opened successfully:\\n{error_msgs_summary}\")\n\n        elif \":\" in mode:\n            filemode, comptype = mode.split(\":\", 1)\n            filemode = filemode or \"r\"\n            comptype = comptype or \"tar\"\n\n            # Select the *open() function according to\n            # given compression.\n            if comptype in cls.OPEN_METH:\n                func = getattr(cls, cls.OPEN_METH[comptype])\n            else:\n                raise CompressionError(\"unknown compression type %r\" % comptype)\n            return func(name, filemode, fileobj, **kwargs)\n\n        elif \"|\" in mode:\n            filemode, comptype = mode.split(\"|\", 1)\n            filemode = filemode or \"r\"\n            comptype = comptype or \"tar\"\n\n            if filemode not in (\"r\", \"w\"):\n                raise ValueError(\"mode must be 'r' or 'w'\")\n\n            compresslevel = kwargs.pop(\"compresslevel\", 9)\n            stream = _Stream(name, filemode, comptype, fileobj, bufsize,\n                             compresslevel)\n            try:\n                t = cls(name, filemode, stream, **kwargs)\n            except:\n                stream.close()\n                raise\n            t._extfileobj = False\n            return t\n\n        elif mode in (\"a\", \"w\", \"x\"):\n            return cls.taropen(name, mode, fileobj, **kwargs)\n\n        raise ValueError(\"undiscernible mode\")\n\n    @classmethod\n    def taropen(cls, name, mode=\"r\", fileobj=None, **kwargs):\n        \"\"\"Open uncompressed tar archive name for reading or writing.\n        \"\"\"\n        if mode not in (\"r\", \"a\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'a', 'w' or 'x'\")\n        return cls(name, mode, fileobj, **kwargs)\n\n    @classmethod\n    def gzopen(cls, name, mode=\"r\", fileobj=None, compresslevel=9, **kwargs):\n        \"\"\"Open gzip compressed tar archive name for reading or writing.\n           Appending is not allowed.\n        \"\"\"\n        if mode not in (\"r\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'w' or 'x'\")\n\n        try:\n            from gzip import GzipFile\n        except ImportError:\n            raise CompressionError(\"gzip module is not available\") from None\n\n        try:\n            fileobj = GzipFile(name, mode + \"b\", compresslevel, fileobj)\n        except OSError as e:\n            if fileobj is not None and mode == 'r':\n                raise ReadError(\"not a gzip file\") from e\n            raise\n\n        try:\n            t = cls.taropen(name, mode, fileobj, **kwargs)\n        except OSError as e:\n            fileobj.close()\n            if mode == 'r':\n                raise ReadError(\"not a gzip file\") from e\n            raise\n        except:\n            fileobj.close()\n            raise\n        t._extfileobj = False\n        return t\n\n    @classmethod\n    def bz2open(cls, name, mode=\"r\", fileobj=None, compresslevel=9, **kwargs):\n        \"\"\"Open bzip2 compressed tar archive name for reading or writing.\n           Appending is not allowed.\n        \"\"\"\n        if mode not in (\"r\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'w' or 'x'\")\n\n        try:\n            from bz2 import BZ2File\n        except ImportError:\n            raise CompressionError(\"bz2 module is not available\") from None\n\n        fileobj = BZ2File(fileobj or name, mode, compresslevel=compresslevel)\n\n        try:\n            t = cls.taropen(name, mode, fileobj, **kwargs)\n        except (OSError, EOFError) as e:\n            fileobj.close()\n            if mode == 'r':\n                raise ReadError(\"not a bzip2 file\") from e\n            raise\n        except:\n            fileobj.close()\n            raise\n        t._extfileobj = False\n        return t\n\n    @classmethod\n    def xzopen(cls, name, mode=\"r\", fileobj=None, preset=None, **kwargs):\n        \"\"\"Open lzma compressed tar archive name for reading or writing.\n           Appending is not allowed.\n        \"\"\"\n        if mode not in (\"r\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'w' or 'x'\")\n\n        try:\n            from lzma import LZMAFile, LZMAError\n        except ImportError:\n            raise CompressionError(\"lzma module is not available\") from None\n\n        fileobj = LZMAFile(fileobj or name, mode, preset=preset)\n\n        try:\n            t = cls.taropen(name, mode, fileobj, **kwargs)\n        except (LZMAError, EOFError) as e:\n            fileobj.close()\n            if mode == 'r':\n                raise ReadError(\"not an lzma file\") from e\n            raise\n        except:\n            fileobj.close()\n            raise\n        t._extfileobj = False\n        return t\n\n    # All *open() methods are registered here.\n    OPEN_METH = {\n        \"tar\": \"taropen\",   # uncompressed tar\n        \"gz\":  \"gzopen\",    # gzip compressed tar\n        \"bz2\": \"bz2open\",   # bzip2 compressed tar\n        \"xz\":  \"xzopen\"     # lzma compressed tar\n    }\n\n    #--------------------------------------------------------------------------\n    # The public methods which TarFile provides:\n\n    def close(self):\n        \"\"\"Close the TarFile. In write-mode, two finishing zero blocks are\n           appended to the archive.\n        \"\"\"\n        if self.closed:\n            return\n\n        self.closed = True\n        try:\n            if self.mode in (\"a\", \"w\", \"x\"):\n                self.fileobj.write(NUL * (BLOCKSIZE * 2))\n                self.offset += (BLOCKSIZE * 2)\n                # fill up the end with zero-blocks\n                # (like option -b20 for tar does)\n                blocks, remainder = divmod(self.offset, RECORDSIZE)\n                if remainder > 0:\n                    self.fileobj.write(NUL * (RECORDSIZE - remainder))\n        finally:\n            if not self._extfileobj:\n                self.fileobj.close()\n\n    def getmember(self, name):\n        \"\"\"Return a TarInfo object for member ``name``. If ``name`` can not be\n           found in the archive, KeyError is raised. If a member occurs more\n           than once in the archive, its last occurrence is assumed to be the\n           most up-to-date version.\n        \"\"\"\n        tarinfo = self._getmember(name.rstrip('/'))\n        if tarinfo is None:\n            raise KeyError(\"filename %r not found\" % name)\n        return tarinfo\n\n    def getmembers(self):\n        \"\"\"Return the members of the archive as a list of TarInfo objects. The\n           list has the same order as the members in the archive.\n        \"\"\"\n        self._check()\n        if not self._loaded:    # if we want to obtain a list of\n            self._load()        # all members, we first have to\n                                # scan the whole archive.\n        return self.members\n\n    def getnames(self):\n        \"\"\"Return the members of the archive as a list of their names. It has\n           the same order as the list returned by getmembers().\n        \"\"\"\n        return [tarinfo.name for tarinfo in self.getmembers()]\n\n    def gettarinfo(self, name=None, arcname=None, fileobj=None):\n        \"\"\"Create a TarInfo object from the result of os.stat or equivalent\n           on an existing file. The file is either named by ``name``, or\n           specified as a file object ``fileobj`` with a file descriptor. If\n           given, ``arcname`` specifies an alternative name for the file in the\n           archive, otherwise, the name is taken from the 'name' attribute of\n           'fileobj', or the 'name' argument. The name should be a text\n           string.\n        \"\"\"\n        self._check(\"awx\")\n\n        # When fileobj is given, replace name by\n        # fileobj's real name.\n        if fileobj is not None:\n            name = fileobj.name\n\n        # Building the name of the member in the archive.\n        # Backward slashes are converted to forward slashes,\n        # Absolute paths are turned to relative paths.\n        if arcname is None:\n            arcname = name\n        drv, arcname = os.path.splitdrive(arcname)\n        arcname = arcname.replace(os.sep, \"/\")\n        arcname = arcname.lstrip(\"/\")\n\n        # Now, fill the TarInfo object with\n        # information specific for the file.\n        tarinfo = self.tarinfo()\n        tarinfo.tarfile = self  # Not needed\n\n        # Use os.stat or os.lstat, depending on if symlinks shall be resolved.\n        if fileobj is None:\n            if not self.dereference:\n                statres = os.lstat(name)\n            else:\n                statres = os.stat(name)\n        else:\n            statres = os.fstat(fileobj.fileno())\n        linkname = \"\"\n\n        stmd = statres.st_mode\n        if stat.S_ISREG(stmd):\n            inode = (statres.st_ino, statres.st_dev)\n            if not self.dereference and statres.st_nlink > 1 and \\\n                    inode in self.inodes and arcname != self.inodes[inode]:\n                # Is it a hardlink to an already\n                # archived file?\n                type = LNKTYPE\n                linkname = self.inodes[inode]\n            else:\n                # The inode is added only if its valid.\n                # For win32 it is always 0.\n                type = REGTYPE\n                if inode[0]:\n                    self.inodes[inode] = arcname\n        elif stat.S_ISDIR(stmd):\n            type = DIRTYPE\n        elif stat.S_ISFIFO(stmd):\n            type = FIFOTYPE\n        elif stat.S_ISLNK(stmd):\n            type = SYMTYPE\n            linkname = os.readlink(name)\n        elif stat.S_ISCHR(stmd):\n            type = CHRTYPE\n        elif stat.S_ISBLK(stmd):\n            type = BLKTYPE\n        else:\n            return None\n\n        # Fill the TarInfo object with all\n        # information we can get.\n        tarinfo.name = arcname\n        tarinfo.mode = stmd\n        tarinfo.uid = statres.st_uid\n        tarinfo.gid = statres.st_gid\n        if type == REGTYPE:\n            tarinfo.size = statres.st_size\n        else:\n            tarinfo.size = 0\n        tarinfo.mtime = statres.st_mtime\n        tarinfo.type = type\n        tarinfo.linkname = linkname\n        if pwd:\n            try:\n                tarinfo.uname = pwd.getpwuid(tarinfo.uid)[0]\n            except KeyError:\n                pass\n        if grp:\n            try:\n                tarinfo.gname = grp.getgrgid(tarinfo.gid)[0]\n            except KeyError:\n                pass\n\n        if type in (CHRTYPE, BLKTYPE):\n            if hasattr(os, \"major\") and hasattr(os, \"minor\"):\n                tarinfo.devmajor = os.major(statres.st_rdev)\n                tarinfo.devminor = os.minor(statres.st_rdev)\n        return tarinfo\n\n    def list(self, verbose=True, *, members=None):\n        \"\"\"Print a table of contents to sys.stdout. If ``verbose`` is False, only\n           the names of the members are printed. If it is True, an `ls -l'-like\n           output is produced. ``members`` is optional and must be a subset of the\n           list returned by getmembers().\n        \"\"\"\n        self._check()\n\n        if members is None:\n            members = self\n        for tarinfo in members:\n            if verbose:\n                if tarinfo.mode is None:\n                    _safe_print(\"??????????\")\n                else:\n                    _safe_print(stat.filemode(tarinfo.mode))\n                _safe_print(\"%s/%s\" % (tarinfo.uname or tarinfo.uid,\n                                       tarinfo.gname or tarinfo.gid))\n                if tarinfo.ischr() or tarinfo.isblk():\n                    _safe_print(\"%10s\" %\n                            (\"%d,%d\" % (tarinfo.devmajor, tarinfo.devminor)))\n                else:\n                    _safe_print(\"%10d\" % tarinfo.size)\n                if tarinfo.mtime is None:\n                    _safe_print(\"????-??-?? ??:??:??\")\n                else:\n                    _safe_print(\"%d-%02d-%02d %02d:%02d:%02d\" \\\n                                % time.localtime(tarinfo.mtime)[:6])\n\n            _safe_print(tarinfo.name + (\"/\" if tarinfo.isdir() else \"\"))\n\n            if verbose:\n                if tarinfo.issym():\n                    _safe_print(\"-> \" + tarinfo.linkname)\n                if tarinfo.islnk():\n                    _safe_print(\"link to \" + tarinfo.linkname)\n            print()\n\n    def add(self, name, arcname=None, recursive=True, *, filter=None):\n        \"\"\"Add the file ``name`` to the archive. ``name`` may be any type of file\n           (directory, fifo, symbolic link, etc.). If given, ``arcname``\n           specifies an alternative name for the file in the archive.\n           Directories are added recursively by default. This can be avoided by\n           setting ``recursive`` to False. ``filter`` is a function\n           that expects a TarInfo object argument and returns the changed\n           TarInfo object, if it returns None the TarInfo object will be\n           excluded from the archive.\n        \"\"\"\n        self._check(\"awx\")\n\n        if arcname is None:\n            arcname = name\n\n        # Skip if somebody tries to archive the archive...\n        if self.name is not None and os.path.abspath(name) == self.name:\n            self._dbg(2, \"tarfile: Skipped %r\" % name)\n            return\n\n        self._dbg(1, name)\n\n        # Create a TarInfo object from the file.\n        tarinfo = self.gettarinfo(name, arcname)\n\n        if tarinfo is None:\n            self._dbg(1, \"tarfile: Unsupported type %r\" % name)\n            return\n\n        # Change or exclude the TarInfo object.\n        if filter is not None:\n            tarinfo = filter(tarinfo)\n            if tarinfo is None:\n                self._dbg(2, \"tarfile: Excluded %r\" % name)\n                return\n\n        # Append the tar header and data to the archive.\n        if tarinfo.isreg():\n            with bltn_open(name, \"rb\") as f:\n                self.addfile(tarinfo, f)\n\n        elif tarinfo.isdir():\n            self.addfile(tarinfo)\n            if recursive:\n                for f in sorted(os.listdir(name)):\n                    self.add(os.path.join(name, f), os.path.join(arcname, f),\n                            recursive, filter=filter)\n\n        else:\n            self.addfile(tarinfo)\n\n    def addfile(self, tarinfo, fileobj=None):\n        \"\"\"Add the TarInfo object ``tarinfo`` to the archive. If ``fileobj`` is\n           given, it should be a binary file, and tarinfo.size bytes are read\n           from it and added to the archive. You can create TarInfo objects\n           directly, or by using gettarinfo().\n        \"\"\"\n        self._check(\"awx\")\n\n        tarinfo = copy.copy(tarinfo)\n\n        buf = tarinfo.tobuf(self.format, self.encoding, self.errors)\n        self.fileobj.write(buf)\n        self.offset += len(buf)\n        bufsize=self.copybufsize\n        # If there's data to follow, append it.\n        if fileobj is not None:\n            copyfileobj(fileobj, self.fileobj, tarinfo.size, bufsize=bufsize)\n            blocks, remainder = divmod(tarinfo.size, BLOCKSIZE)\n            if remainder > 0:\n                self.fileobj.write(NUL * (BLOCKSIZE - remainder))\n                blocks += 1\n            self.offset += blocks * BLOCKSIZE\n\n        self.members.append(tarinfo)\n\n    def _get_filter_function(self, filter):\n        if filter is None:\n            filter = self.extraction_filter\n            if filter is None:\n                warnings.warn(\n                    'Python 3.14 will, by default, filter extracted tar '\n                    + 'archives and reject files or modify their metadata. '\n                    + 'Use the filter argument to control this behavior.',\n                    DeprecationWarning)\n                return fully_trusted_filter\n            if isinstance(filter, str):\n                raise TypeError(\n                    'String names are not supported for '\n                    + 'TarFile.extraction_filter. Use a function such as '\n                    + 'tarfile.data_filter directly.')\n            return filter\n        if callable(filter):\n            return filter\n        try:\n            return _NAMED_FILTERS[filter]\n        except KeyError:\n            raise ValueError(f\"filter {filter!r} not found\") from None\n\n    def extractall(self, path=\".\", members=None, *, numeric_owner=False,\n                   filter=None):\n        \"\"\"Extract all members from the archive to the current working\n           directory and set owner, modification time and permissions on\n           directories afterwards. `path' specifies a different directory\n           to extract to. `members' is optional and must be a subset of the\n           list returned by getmembers(). If `numeric_owner` is True, only\n           the numbers for user/group names are used and not the names.\n\n           The `filter` function will be called on each member just\n           before extraction.\n           It can return a changed TarInfo or None to skip the member.\n           String names of common filters are accepted.\n        \"\"\"\n        directories = []\n\n        filter_function = self._get_filter_function(filter)\n        if members is None:\n            members = self\n\n        for member in members:\n            tarinfo = self._get_extract_tarinfo(member, filter_function, path)\n            if tarinfo is None:\n                continue\n            if tarinfo.isdir():\n                # For directories, delay setting attributes until later,\n                # since permissions can interfere with extraction and\n                # extracting contents can reset mtime.\n                directories.append(tarinfo)\n            self._extract_one(tarinfo, path, set_attrs=not tarinfo.isdir(),\n                              numeric_owner=numeric_owner)\n\n        # Reverse sort directories.\n        directories.sort(key=lambda a: a.name, reverse=True)\n\n        # Set correct owner, mtime and filemode on directories.\n        for tarinfo in directories:\n            dirpath = os.path.join(path, tarinfo.name)\n            try:\n                self.chown(tarinfo, dirpath, numeric_owner=numeric_owner)\n                self.utime(tarinfo, dirpath)\n                self.chmod(tarinfo, dirpath)\n            except ExtractError as e:\n                self._handle_nonfatal_error(e)\n\n    def extract(self, member, path=\"\", set_attrs=True, *, numeric_owner=False,\n                filter=None):\n        \"\"\"Extract a member from the archive to the current working directory,\n           using its full name. Its file information is extracted as accurately\n           as possible. `member' may be a filename or a TarInfo object. You can\n           specify a different directory using `path'. File attributes (owner,\n           mtime, mode) are set unless `set_attrs' is False. If `numeric_owner`\n           is True, only the numbers for user/group names are used and not\n           the names.\n\n           The `filter` function will be called before extraction.\n           It can return a changed TarInfo or None to skip the member.\n           String names of common filters are accepted.\n        \"\"\"\n        filter_function = self._get_filter_function(filter)\n        tarinfo = self._get_extract_tarinfo(member, filter_function, path)\n        if tarinfo is not None:\n            self._extract_one(tarinfo, path, set_attrs, numeric_owner)\n\n    def _get_extract_tarinfo(self, member, filter_function, path):\n        \"\"\"Get filtered TarInfo (or None) from member, which might be a str\"\"\"\n        if isinstance(member, str):\n            tarinfo = self.getmember(member)\n        else:\n            tarinfo = member\n\n        unfiltered = tarinfo\n        try:\n            tarinfo = filter_function(tarinfo, path)\n        except (OSError, FilterError) as e:\n            self._handle_fatal_error(e)\n        except ExtractError as e:\n            self._handle_nonfatal_error(e)\n        if tarinfo is None:\n            self._dbg(2, \"tarfile: Excluded %r\" % unfiltered.name)\n            return None\n        # Prepare the link target for makelink().\n        if tarinfo.islnk():\n            tarinfo = copy.copy(tarinfo)\n            tarinfo._link_target = os.path.join(path, tarinfo.linkname)\n        return tarinfo\n\n    def _extract_one(self, tarinfo, path, set_attrs, numeric_owner):\n        \"\"\"Extract from filtered tarinfo to disk\"\"\"\n        self._check(\"r\")\n\n        try:\n            self._extract_member(tarinfo, os.path.join(path, tarinfo.name),\n                                 set_attrs=set_attrs,\n                                 numeric_owner=numeric_owner)\n        except OSError as e:\n            self._handle_fatal_error(e)\n        except ExtractError as e:\n            self._handle_nonfatal_error(e)\n\n    def _handle_nonfatal_error(self, e):\n        \"\"\"Handle non-fatal error (ExtractError) according to errorlevel\"\"\"\n        if self.errorlevel > 1:\n            raise\n        else:\n            self._dbg(1, \"tarfile: %s\" % e)\n\n    def _handle_fatal_error(self, e):\n        \"\"\"Handle \"fatal\" error according to self.errorlevel\"\"\"\n        if self.errorlevel > 0:\n            raise\n        elif isinstance(e, OSError):\n            if e.filename is None:\n                self._dbg(1, \"tarfile: %s\" % e.strerror)\n            else:\n                self._dbg(1, \"tarfile: %s %r\" % (e.strerror, e.filename))\n        else:\n            self._dbg(1, \"tarfile: %s %s\" % (type(e).__name__, e))\n\n    def extractfile(self, member):\n        \"\"\"Extract a member from the archive as a file object. ``member`` may be\n           a filename or a TarInfo object. If ``member`` is a regular file or\n           a link, an io.BufferedReader object is returned. For all other\n           existing members, None is returned. If ``member`` does not appear\n           in the archive, KeyError is raised.\n        \"\"\"\n        self._check(\"r\")\n\n        if isinstance(member, str):\n            tarinfo = self.getmember(member)\n        else:\n            tarinfo = member\n\n        if tarinfo.isreg() or tarinfo.type not in SUPPORTED_TYPES:\n            # Members with unknown types are treated as regular files.\n            return self.fileobject(self, tarinfo)\n\n        elif tarinfo.islnk() or tarinfo.issym():\n            if isinstance(self.fileobj, _Stream):\n                # A small but ugly workaround for the case that someone tries\n                # to extract a (sym)link as a file-object from a non-seekable\n                # stream of tar blocks.\n                raise StreamError(\"cannot extract (sym)link as file object\")\n            else:\n                # A (sym)link's file object is its target's file object.\n                return self.extractfile(self._find_link_target(tarinfo))\n        else:\n            # If there's no data associated with the member (directory, chrdev,\n            # blkdev, etc.), return None instead of a file object.\n            return None\n\n    def _extract_member(self, tarinfo, targetpath, set_attrs=True,\n                        numeric_owner=False):\n        \"\"\"Extract the TarInfo object tarinfo to a physical\n           file called targetpath.\n        \"\"\"\n        # Fetch the TarInfo object for the given name\n        # and build the destination pathname, replacing\n        # forward slashes to platform specific separators.\n        targetpath = targetpath.rstrip(\"/\")\n        targetpath = targetpath.replace(\"/\", os.sep)\n\n        # Create all upper directories.\n        upperdirs = os.path.dirname(targetpath)\n        if upperdirs and not os.path.exists(upperdirs):\n            # Create directories that are not part of the archive with\n            # default permissions.\n            os.makedirs(upperdirs)\n\n        if tarinfo.islnk() or tarinfo.issym():\n            self._dbg(1, \"%s -> %s\" % (tarinfo.name, tarinfo.linkname))\n        else:\n            self._dbg(1, tarinfo.name)\n\n        if tarinfo.isreg():\n            self.makefile(tarinfo, targetpath)\n        elif tarinfo.isdir():\n            self.makedir(tarinfo, targetpath)\n        elif tarinfo.isfifo():\n            self.makefifo(tarinfo, targetpath)\n        elif tarinfo.ischr() or tarinfo.isblk():\n            self.makedev(tarinfo, targetpath)\n        elif tarinfo.islnk() or tarinfo.issym():\n            self.makelink(tarinfo, targetpath)\n        elif tarinfo.type not in SUPPORTED_TYPES:\n            self.makeunknown(tarinfo, targetpath)\n        else:\n            self.makefile(tarinfo, targetpath)\n\n        if set_attrs:\n            self.chown(tarinfo, targetpath, numeric_owner)\n            if not tarinfo.issym():\n                self.chmod(tarinfo, targetpath)\n                self.utime(tarinfo, targetpath)\n\n    #--------------------------------------------------------------------------\n    # Below are the different file methods. They are called via\n    # _extract_member() when extract() is called. They can be replaced in a\n    # subclass to implement other functionality.\n\n    def makedir(self, tarinfo, targetpath):\n        \"\"\"Make a directory called targetpath.\n        \"\"\"\n        try:\n            if tarinfo.mode is None:\n                # Use the system's default mode\n                os.mkdir(targetpath)\n            else:\n                # Use a safe mode for the directory, the real mode is set\n                # later in _extract_member().\n                os.mkdir(targetpath, 0o700)\n        except FileExistsError:\n            if not os.path.isdir(targetpath):\n                raise\n\n    def makefile(self, tarinfo, targetpath):\n        \"\"\"Make a file called targetpath.\n        \"\"\"\n        source = self.fileobj\n        source.seek(tarinfo.offset_data)\n        bufsize = self.copybufsize\n        with bltn_open(targetpath, \"wb\") as target:\n            if tarinfo.sparse is not None:\n                for offset, size in tarinfo.sparse:\n                    target.seek(offset)\n                    copyfileobj(source, target, size, ReadError, bufsize)\n                target.seek(tarinfo.size)\n                target.truncate()\n            else:\n                copyfileobj(source, target, tarinfo.size, ReadError, bufsize)\n\n    def makeunknown(self, tarinfo, targetpath):\n        \"\"\"Make a file from a TarInfo object with an unknown type\n           at targetpath.\n        \"\"\"\n        self.makefile(tarinfo, targetpath)\n        self._dbg(1, \"tarfile: Unknown file type %r, \" \\\n                     \"extracted as regular file.\" % tarinfo.type)\n\n    def makefifo(self, tarinfo, targetpath):\n        \"\"\"Make a fifo called targetpath.\n        \"\"\"\n        if hasattr(os, \"mkfifo\"):\n            os.mkfifo(targetpath)\n        else:\n            raise ExtractError(\"fifo not supported by system\")\n\n    def makedev(self, tarinfo, targetpath):\n        \"\"\"Make a character or block device called targetpath.\n        \"\"\"\n        if not hasattr(os, \"mknod\") or not hasattr(os, \"makedev\"):\n            raise ExtractError(\"special devices not supported by system\")\n\n        mode = tarinfo.mode\n        if mode is None:\n            # Use mknod's default\n            mode = 0o600\n        if tarinfo.isblk():\n            mode |= stat.S_IFBLK\n        else:\n            mode |= stat.S_IFCHR\n\n        os.mknod(targetpath, mode,\n                 os.makedev(tarinfo.devmajor, tarinfo.devminor))\n\n    def makelink(self, tarinfo, targetpath):\n        \"\"\"Make a (symbolic) link called targetpath. If it cannot be created\n          (platform limitation), we try to make a copy of the referenced file\n          instead of a link.\n        \"\"\"\n        try:\n            # For systems that support symbolic and hard links.\n            if tarinfo.issym():\n                if os.path.lexists(targetpath):\n                    # Avoid FileExistsError on following os.symlink.\n                    os.unlink(targetpath)\n                os.symlink(tarinfo.linkname, targetpath)\n            else:\n                if os.path.exists(tarinfo._link_target):\n                    os.link(tarinfo._link_target, targetpath)\n                else:\n                    self._extract_member(self._find_link_target(tarinfo),\n                                         targetpath)\n        except symlink_exception:\n            try:\n                self._extract_member(self._find_link_target(tarinfo),\n                                     targetpath)\n            except KeyError:\n                raise ExtractError(\"unable to resolve link inside archive\") from None\n\n    def chown(self, tarinfo, targetpath, numeric_owner):\n        \"\"\"Set owner of targetpath according to tarinfo. If numeric_owner\n           is True, use .gid/.uid instead of .gname/.uname. If numeric_owner\n           is False, fall back to .gid/.uid when the search based on name\n           fails.\n        \"\"\"\n        if hasattr(os, \"geteuid\") and os.geteuid() == 0:\n            # We have to be root to do so.\n            g = tarinfo.gid\n            u = tarinfo.uid\n            if not numeric_owner:\n                try:\n                    if grp and tarinfo.gname:\n                        g = grp.getgrnam(tarinfo.gname)[2]\n                except KeyError:\n                    pass\n                try:\n                    if pwd and tarinfo.uname:\n                        u = pwd.getpwnam(tarinfo.uname)[2]\n                except KeyError:\n                    pass\n            if g is None:\n                g = -1\n            if u is None:\n                u = -1\n            try:\n                if tarinfo.issym() and hasattr(os, \"lchown\"):\n                    os.lchown(targetpath, u, g)\n                else:\n                    os.chown(targetpath, u, g)\n            except OSError as e:\n                raise ExtractError(\"could not change owner\") from e\n\n    def chmod(self, tarinfo, targetpath):\n        \"\"\"Set file permissions of targetpath according to tarinfo.\n        \"\"\"\n        if tarinfo.mode is None:\n            return\n        try:\n            os.chmod(targetpath, tarinfo.mode)\n        except OSError as e:\n            raise ExtractError(\"could not change mode\") from e\n\n    def utime(self, tarinfo, targetpath):\n        \"\"\"Set modification time of targetpath according to tarinfo.\n        \"\"\"\n        mtime = tarinfo.mtime\n        if mtime is None:\n            return\n        if not hasattr(os, 'utime'):\n            return\n        try:\n            os.utime(targetpath, (mtime, mtime))\n        except OSError as e:\n            raise ExtractError(\"could not change modification time\") from e\n\n    #--------------------------------------------------------------------------\n    def next(self):\n        \"\"\"Return the next member of the archive as a TarInfo object, when\n           TarFile is opened for reading. Return None if there is no more\n           available.\n        \"\"\"\n        self._check(\"ra\")\n        if self.firstmember is not None:\n            m = self.firstmember\n            self.firstmember = None\n            return m\n\n        # Advance the file pointer.\n        if self.offset != self.fileobj.tell():\n            if self.offset == 0:\n                return None\n            self.fileobj.seek(self.offset - 1)\n            if not self.fileobj.read(1):\n                raise ReadError(\"unexpected end of data\")\n\n        # Read the next block.\n        tarinfo = None\n        while True:\n            try:\n                tarinfo = self.tarinfo.fromtarfile(self)\n            except EOFHeaderError as e:\n                if self.ignore_zeros:\n                    self._dbg(2, \"0x%X: %s\" % (self.offset, e))\n                    self.offset += BLOCKSIZE\n                    continue\n            except InvalidHeaderError as e:\n                if self.ignore_zeros:\n                    self._dbg(2, \"0x%X: %s\" % (self.offset, e))\n                    self.offset += BLOCKSIZE\n                    continue\n                elif self.offset == 0:\n                    raise ReadError(str(e)) from None\n            except EmptyHeaderError:\n                if self.offset == 0:\n                    raise ReadError(\"empty file\") from None\n            except TruncatedHeaderError as e:\n                if self.offset == 0:\n                    raise ReadError(str(e)) from None\n            except SubsequentHeaderError as e:\n                raise ReadError(str(e)) from None\n            except Exception as e:\n                try:\n                    import zlib\n                    if isinstance(e, zlib.error):\n                        raise ReadError(f'zlib error: {e}') from None\n                    else:\n                        raise e\n                except ImportError:\n                    raise e\n            break\n\n        if tarinfo is not None:\n            self.members.append(tarinfo)\n        else:\n            self._loaded = True\n\n        return tarinfo\n\n    #--------------------------------------------------------------------------\n    # Little helper methods:\n\n    def _getmember(self, name, tarinfo=None, normalize=False):\n        \"\"\"Find an archive member by name from bottom to top.\n           If tarinfo is given, it is used as the starting point.\n        \"\"\"\n        # Ensure that all members have been loaded.\n        members = self.getmembers()\n\n        # Limit the member search list up to tarinfo.\n        skipping = False\n        if tarinfo is not None:\n            try:\n                index = members.index(tarinfo)\n            except ValueError:\n                # The given starting point might be a (modified) copy.\n                # We'll later skip members until we find an equivalent.\n                skipping = True\n            else:\n                # Happy fast path\n                members = members[:index]\n\n        if normalize:\n            name = os.path.normpath(name)\n\n        for member in reversed(members):\n            if skipping:\n                if tarinfo.offset == member.offset:\n                    skipping = False\n                continue\n            if normalize:\n                member_name = os.path.normpath(member.name)\n            else:\n                member_name = member.name\n\n            if name == member_name:\n                return member\n\n        if skipping:\n            # Starting point was not found\n            raise ValueError(tarinfo)\n\n    def _load(self):\n        \"\"\"Read through the entire archive file and look for readable\n           members.\n        \"\"\"\n        while self.next() is not None:\n            pass\n        self._loaded = True\n\n    def _check(self, mode=None):\n        \"\"\"Check if TarFile is still open, and if the operation's mode\n           corresponds to TarFile's mode.\n        \"\"\"\n        if self.closed:\n            raise OSError(\"%s is closed\" % self.__class__.__name__)\n        if mode is not None and self.mode not in mode:\n            raise OSError(\"bad operation for mode %r\" % self.mode)\n\n    def _find_link_target(self, tarinfo):\n        \"\"\"Find the target member of a symlink or hardlink member in the\n           archive.\n        \"\"\"\n        if tarinfo.issym():\n            # Always search the entire archive.\n            linkname = \"/\".join(filter(None, (os.path.dirname(tarinfo.name), tarinfo.linkname)))\n            limit = None\n        else:\n            # Search the archive before the link, because a hard link is\n            # just a reference to an already archived file.\n            linkname = tarinfo.linkname\n            limit = tarinfo\n\n        member = self._getmember(linkname, tarinfo=limit, normalize=True)\n        if member is None:\n            raise KeyError(\"linkname %r not found\" % linkname)\n        return member\n\n    def __iter__(self):\n        \"\"\"Provide an iterator object.\n        \"\"\"\n        if self._loaded:\n            yield from self.members\n            return\n\n        # Yield items using TarFile's next() method.\n        # When all members have been read, set TarFile as _loaded.\n        index = 0\n        # Fix for SF #1100429: Under rare circumstances it can\n        # happen that getmembers() is called during iteration,\n        # which will have already exhausted the next() method.\n        if self.firstmember is not None:\n            tarinfo = self.next()\n            index += 1\n            yield tarinfo\n\n        while True:\n            if index < len(self.members):\n                tarinfo = self.members[index]\n            elif not self._loaded:\n                tarinfo = self.next()\n                if not tarinfo:\n                    self._loaded = True\n                    return\n            else:\n                return\n            index += 1\n            yield tarinfo\n\n    def _dbg(self, level, msg):\n        \"\"\"Write debugging output to sys.stderr.\n        \"\"\"\n        if level <= self.debug:\n            print(msg, file=sys.stderr)\n\n    def __enter__(self):\n        self._check()\n        return self\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            self.close()\n        else:\n            # An exception occurred. We must not call close() because\n            # it would try to write end-of-archive blocks and padding.\n            if not self._extfileobj:\n                self.fileobj.close()\n            self.closed = True\n\n#--------------------\n# exported functions\n#--------------------\n\ndef is_tarfile(name):\n    \"\"\"Return True if name points to a tar archive that we\n       are able to handle, else return False.\n\n       'name' should be a string, file, or file-like object.\n    \"\"\"\n    try:\n        if hasattr(name, \"read\"):\n            pos = name.tell()\n            t = open(fileobj=name)\n            name.seek(pos)\n        else:\n            t = open(name)\n        t.close()\n        return True\n    except TarError:\n        return False\n\nopen = TarFile.open\n\n\ndef main():\n    import argparse\n\n    description = 'A simple command-line interface for tarfile module.'\n    parser = argparse.ArgumentParser(description=description)\n    parser.add_argument('-v', '--verbose', action='store_true', default=False,\n                        help='Verbose output')\n    parser.add_argument('--filter', metavar='<filtername>',\n                        choices=_NAMED_FILTERS,\n                        help='Filter for extraction')\n\n    group = parser.add_mutually_exclusive_group(required=True)\n    group.add_argument('-l', '--list', metavar='<tarfile>',\n                       help='Show listing of a tarfile')\n    group.add_argument('-e', '--extract', nargs='+',\n                       metavar=('<tarfile>', '<output_dir>'),\n                       help='Extract tarfile into target dir')\n    group.add_argument('-c', '--create', nargs='+',\n                       metavar=('<name>', '<file>'),\n                       help='Create tarfile from sources')\n    group.add_argument('-t', '--test', metavar='<tarfile>',\n                       help='Test if a tarfile is valid')\n\n    args = parser.parse_args()\n\n    if args.filter and args.extract is None:\n        parser.exit(1, '--filter is only valid for extraction\\n')\n\n    if args.test is not None:\n        src = args.test\n        if is_tarfile(src):\n            with open(src, 'r') as tar:\n                tar.getmembers()\n                print(tar.getmembers(), file=sys.stderr)\n            if args.verbose:\n                print('{!r} is a tar archive.'.format(src))\n        else:\n            parser.exit(1, '{!r} is not a tar archive.\\n'.format(src))\n\n    elif args.list is not None:\n        src = args.list\n        if is_tarfile(src):\n            with TarFile.open(src, 'r:*') as tf:\n                tf.list(verbose=args.verbose)\n        else:\n            parser.exit(1, '{!r} is not a tar archive.\\n'.format(src))\n\n    elif args.extract is not None:\n        if len(args.extract) == 1:\n            src = args.extract[0]\n            curdir = os.curdir\n        elif len(args.extract) == 2:\n            src, curdir = args.extract\n        else:\n            parser.exit(1, parser.format_help())\n\n        if is_tarfile(src):\n            with TarFile.open(src, 'r:*') as tf:\n                tf.extractall(path=curdir, filter=args.filter)\n            if args.verbose:\n                if curdir == '.':\n                    msg = '{!r} file is extracted.'.format(src)\n                else:\n                    msg = ('{!r} file is extracted '\n                           'into {!r} directory.').format(src, curdir)\n                print(msg)\n        else:\n            parser.exit(1, '{!r} is not a tar archive.\\n'.format(src))\n\n    elif args.create is not None:\n        tar_name = args.create.pop(0)\n        _, ext = os.path.splitext(tar_name)\n        compressions = {\n            # gz\n            '.gz': 'gz',\n            '.tgz': 'gz',\n            # xz\n            '.xz': 'xz',\n            '.txz': 'xz',\n            # bz2\n            '.bz2': 'bz2',\n            '.tbz': 'bz2',\n            '.tbz2': 'bz2',\n            '.tb2': 'bz2',\n        }\n        tar_mode = 'w:' + compressions[ext] if ext in compressions else 'w'\n        tar_files = args.create\n\n        with TarFile.open(tar_name, tar_mode) as tf:\n            for file_name in tar_files:\n                tf.add(file_name)\n\n        if args.verbose:\n            print('{!r} file created.'.format(tar_name))\n\nif __name__ == '__main__':\n    main()\n", "setuptools/_vendor/backports/__init__.py": "", "setuptools/_vendor/more_itertools/more.py": "import warnings\n\nfrom collections import Counter, defaultdict, deque, abc\nfrom collections.abc import Sequence\nfrom functools import partial, reduce, wraps\nfrom heapq import merge, heapify, heapreplace, heappop\nfrom itertools import (\n    chain,\n    compress,\n    count,\n    cycle,\n    dropwhile,\n    groupby,\n    islice,\n    repeat,\n    starmap,\n    takewhile,\n    tee,\n    zip_longest,\n)\nfrom math import exp, factorial, floor, log\nfrom queue import Empty, Queue\nfrom random import random, randrange, uniform\nfrom operator import itemgetter, mul, sub, gt, lt\nfrom sys import hexversion, maxsize\nfrom time import monotonic\n\nfrom .recipes import (\n    consume,\n    flatten,\n    pairwise,\n    powerset,\n    take,\n    unique_everseen,\n)\n\n__all__ = [\n    'AbortThread',\n    'adjacent',\n    'always_iterable',\n    'always_reversible',\n    'bucket',\n    'callback_iter',\n    'chunked',\n    'circular_shifts',\n    'collapse',\n    'collate',\n    'consecutive_groups',\n    'consumer',\n    'countable',\n    'count_cycle',\n    'mark_ends',\n    'difference',\n    'distinct_combinations',\n    'distinct_permutations',\n    'distribute',\n    'divide',\n    'exactly_n',\n    'filter_except',\n    'first',\n    'groupby_transform',\n    'ilen',\n    'interleave_longest',\n    'interleave',\n    'intersperse',\n    'islice_extended',\n    'iterate',\n    'ichunked',\n    'is_sorted',\n    'last',\n    'locate',\n    'lstrip',\n    'make_decorator',\n    'map_except',\n    'map_reduce',\n    'nth_or_last',\n    'nth_permutation',\n    'nth_product',\n    'numeric_range',\n    'one',\n    'only',\n    'padded',\n    'partitions',\n    'set_partitions',\n    'peekable',\n    'repeat_last',\n    'replace',\n    'rlocate',\n    'rstrip',\n    'run_length',\n    'sample',\n    'seekable',\n    'SequenceView',\n    'side_effect',\n    'sliced',\n    'sort_together',\n    'split_at',\n    'split_after',\n    'split_before',\n    'split_when',\n    'split_into',\n    'spy',\n    'stagger',\n    'strip',\n    'substrings',\n    'substrings_indexes',\n    'time_limited',\n    'unique_to_each',\n    'unzip',\n    'windowed',\n    'with_iter',\n    'UnequalIterablesError',\n    'zip_equal',\n    'zip_offset',\n    'windowed_complete',\n    'all_unique',\n    'value_chain',\n    'product_index',\n    'combination_index',\n    'permutation_index',\n]\n\n_marker = object()\n\n\ndef chunked(iterable, n, strict=False):\n    \"\"\"Break *iterable* into lists of length *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6], 3))\n        [[1, 2, 3], [4, 5, 6]]\n\n    By the default, the last yielded list will have fewer than *n* elements\n    if the length of *iterable* is not divisible by *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))\n        [[1, 2, 3], [4, 5, 6], [7, 8]]\n\n    To use a fill-in value instead, see the :func:`grouper` recipe.\n\n    If the length of *iterable* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    list is yielded.\n\n    \"\"\"\n    iterator = iter(partial(take, n, iter(iterable)), [])\n    if strict:\n\n        def ret():\n            for chunk in iterator:\n                if len(chunk) != n:\n                    raise ValueError('iterable is not divisible by n.')\n                yield chunk\n\n        return iter(ret())\n    else:\n        return iterator\n\n\ndef first(iterable, default=_marker):\n    \"\"\"Return the first item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> first([0, 1, 2, 3])\n        0\n        >>> first([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n\n    :func:`first` is useful when you have a generator of expensive-to-retrieve\n    values and want any arbitrary one. It is marginally shorter than\n    ``next(iter(iterable), default)``.\n\n    \"\"\"\n    try:\n        return next(iter(iterable))\n    except StopIteration as e:\n        if default is _marker:\n            raise ValueError(\n                'first() was called on an empty iterable, and no '\n                'default value was provided.'\n            ) from e\n        return default\n\n\ndef last(iterable, default=_marker):\n    \"\"\"Return the last item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> last([0, 1, 2, 3])\n        3\n        >>> last([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    \"\"\"\n    try:\n        if isinstance(iterable, Sequence):\n            return iterable[-1]\n        # Work around https://bugs.python.org/issue38525\n        elif hasattr(iterable, '__reversed__') and (hexversion != 0x030800F0):\n            return next(reversed(iterable))\n        else:\n            return deque(iterable, maxlen=1)[-1]\n    except (IndexError, TypeError, StopIteration):\n        if default is _marker:\n            raise ValueError(\n                'last() was called on an empty iterable, and no default was '\n                'provided.'\n            )\n        return default\n\n\ndef nth_or_last(iterable, n, default=_marker):\n    \"\"\"Return the nth or the last item of *iterable*,\n    or *default* if *iterable* is empty.\n\n        >>> nth_or_last([0, 1, 2, 3], 2)\n        2\n        >>> nth_or_last([0, 1], 2)\n        1\n        >>> nth_or_last([], 0, 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    \"\"\"\n    return last(islice(iterable, n + 1), default=default)\n\n\nclass peekable:\n    \"\"\"Wrap an iterator to allow lookahead and prepending elements.\n\n    Call :meth:`peek` on the result to get the value that will be returned\n    by :func:`next`. This won't advance the iterator:\n\n        >>> p = peekable(['a', 'b'])\n        >>> p.peek()\n        'a'\n        >>> next(p)\n        'a'\n\n    Pass :meth:`peek` a default value to return that instead of raising\n    ``StopIteration`` when the iterator is exhausted.\n\n        >>> p = peekable([])\n        >>> p.peek('hi')\n        'hi'\n\n    peekables also offer a :meth:`prepend` method, which \"inserts\" items\n    at the head of the iterable:\n\n        >>> p = peekable([1, 2, 3])\n        >>> p.prepend(10, 11, 12)\n        >>> next(p)\n        10\n        >>> p.peek()\n        11\n        >>> list(p)\n        [11, 12, 1, 2, 3]\n\n    peekables can be indexed. Index 0 is the item that will be returned by\n    :func:`next`, index 1 is the item after that, and so on:\n    The values up to the given index will be cached.\n\n        >>> p = peekable(['a', 'b', 'c', 'd'])\n        >>> p[0]\n        'a'\n        >>> p[1]\n        'b'\n        >>> next(p)\n        'a'\n\n    Negative indexes are supported, but be aware that they will cache the\n    remaining items in the source iterator, which may require significant\n    storage.\n\n    To check whether a peekable is exhausted, check its truth value:\n\n        >>> p = peekable(['a', 'b'])\n        >>> if p:  # peekable has items\n        ...     list(p)\n        ['a', 'b']\n        >>> if not p:  # peekable is exhausted\n        ...     list(p)\n        []\n\n    \"\"\"\n\n    def __init__(self, iterable):\n        self._it = iter(iterable)\n        self._cache = deque()\n\n    def __iter__(self):\n        return self\n\n    def __bool__(self):\n        try:\n            self.peek()\n        except StopIteration:\n            return False\n        return True\n\n    def peek(self, default=_marker):\n        \"\"\"Return the item that will be next returned from ``next()``.\n\n        Return ``default`` if there are no items left. If ``default`` is not\n        provided, raise ``StopIteration``.\n\n        \"\"\"\n        if not self._cache:\n            try:\n                self._cache.append(next(self._it))\n            except StopIteration:\n                if default is _marker:\n                    raise\n                return default\n        return self._cache[0]\n\n    def prepend(self, *items):\n        \"\"\"Stack up items to be the next ones returned from ``next()`` or\n        ``self.peek()``. The items will be returned in\n        first in, first out order::\n\n            >>> p = peekable([1, 2, 3])\n            >>> p.prepend(10, 11, 12)\n            >>> next(p)\n            10\n            >>> list(p)\n            [11, 12, 1, 2, 3]\n\n        It is possible, by prepending items, to \"resurrect\" a peekable that\n        previously raised ``StopIteration``.\n\n            >>> p = peekable([])\n            >>> next(p)\n            Traceback (most recent call last):\n              ...\n            StopIteration\n            >>> p.prepend(1)\n            >>> next(p)\n            1\n            >>> next(p)\n            Traceback (most recent call last):\n              ...\n            StopIteration\n\n        \"\"\"\n        self._cache.extendleft(reversed(items))\n\n    def __next__(self):\n        if self._cache:\n            return self._cache.popleft()\n\n        return next(self._it)\n\n    def _get_slice(self, index):\n        # Normalize the slice's arguments\n        step = 1 if (index.step is None) else index.step\n        if step > 0:\n            start = 0 if (index.start is None) else index.start\n            stop = maxsize if (index.stop is None) else index.stop\n        elif step < 0:\n            start = -1 if (index.start is None) else index.start\n            stop = (-maxsize - 1) if (index.stop is None) else index.stop\n        else:\n            raise ValueError('slice step cannot be zero')\n\n        # If either the start or stop index is negative, we'll need to cache\n        # the rest of the iterable in order to slice from the right side.\n        if (start < 0) or (stop < 0):\n            self._cache.extend(self._it)\n        # Otherwise we'll need to find the rightmost index and cache to that\n        # point.\n        else:\n            n = min(max(start, stop) + 1, maxsize)\n            cache_len = len(self._cache)\n            if n >= cache_len:\n                self._cache.extend(islice(self._it, n - cache_len))\n\n        return list(self._cache)[index]\n\n    def __getitem__(self, index):\n        if isinstance(index, slice):\n            return self._get_slice(index)\n\n        cache_len = len(self._cache)\n        if index < 0:\n            self._cache.extend(self._it)\n        elif index >= cache_len:\n            self._cache.extend(islice(self._it, index + 1 - cache_len))\n\n        return self._cache[index]\n\n\ndef collate(*iterables, **kwargs):\n    \"\"\"Return a sorted merge of the items from each of several already-sorted\n    *iterables*.\n\n        >>> list(collate('ACDZ', 'AZ', 'JKL'))\n        ['A', 'A', 'C', 'D', 'J', 'K', 'L', 'Z', 'Z']\n\n    Works lazily, keeping only the next value from each iterable in memory. Use\n    :func:`collate` to, for example, perform a n-way mergesort of items that\n    don't fit in memory.\n\n    If a *key* function is specified, the iterables will be sorted according\n    to its result:\n\n        >>> key = lambda s: int(s)  # Sort by numeric value, not by string\n        >>> list(collate(['1', '10'], ['2', '11'], key=key))\n        ['1', '2', '10', '11']\n\n\n    If the *iterables* are sorted in descending order, set *reverse* to\n    ``True``:\n\n        >>> list(collate([5, 3, 1], [4, 2, 0], reverse=True))\n        [5, 4, 3, 2, 1, 0]\n\n    If the elements of the passed-in iterables are out of order, you might get\n    unexpected results.\n\n    On Python 3.5+, this function is an alias for :func:`heapq.merge`.\n\n    \"\"\"\n    warnings.warn(\n        \"collate is no longer part of more_itertools, use heapq.merge\",\n        DeprecationWarning,\n    )\n    return merge(*iterables, **kwargs)\n\n\ndef consumer(func):\n    \"\"\"Decorator that automatically advances a PEP-342-style \"reverse iterator\"\n    to its first yield point so you don't have to call ``next()`` on it\n    manually.\n\n        >>> @consumer\n        ... def tally():\n        ...     i = 0\n        ...     while True:\n        ...         print('Thing number %s is %s.' % (i, (yield)))\n        ...         i += 1\n        ...\n        >>> t = tally()\n        >>> t.send('red')\n        Thing number 0 is red.\n        >>> t.send('fish')\n        Thing number 1 is fish.\n\n    Without the decorator, you would have to call ``next(t)`` before\n    ``t.send()`` could be used.\n\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        gen = func(*args, **kwargs)\n        next(gen)\n        return gen\n\n    return wrapper\n\n\ndef ilen(iterable):\n    \"\"\"Return the number of items in *iterable*.\n\n        >>> ilen(x for x in range(1000000) if x % 3 == 0)\n        333334\n\n    This consumes the iterable, so handle with care.\n\n    \"\"\"\n    # This approach was selected because benchmarks showed it's likely the\n    # fastest of the known implementations at the time of writing.\n    # See GitHub tracker: #236, #230.\n    counter = count()\n    deque(zip(iterable, counter), maxlen=0)\n    return next(counter)\n\n\ndef iterate(func, start):\n    \"\"\"Return ``start``, ``func(start)``, ``func(func(start))``, ...\n\n    >>> from itertools import islice\n    >>> list(islice(iterate(lambda x: 2*x, 1), 10))\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n\n    \"\"\"\n    while True:\n        yield start\n        start = func(start)\n\n\ndef with_iter(context_manager):\n    \"\"\"Wrap an iterable in a ``with`` statement, so it closes once exhausted.\n\n    For example, this will close the file when the iterator is exhausted::\n\n        upper_lines = (line.upper() for line in with_iter(open('foo')))\n\n    Any context manager which returns an iterable is a candidate for\n    ``with_iter``.\n\n    \"\"\"\n    with context_manager as iterable:\n        yield from iterable\n\n\ndef one(iterable, too_short=None, too_long=None):\n    \"\"\"Return the first item from *iterable*, which is expected to contain only\n    that item. Raise an exception if *iterable* is empty or has more than one\n    item.\n\n    :func:`one` is useful for ensuring that an iterable contains only one item.\n    For example, it can be used to retrieve the result of a database query\n    that is expected to return a single row.\n\n    If *iterable* is empty, ``ValueError`` will be raised. You may specify a\n    different exception with the *too_short* keyword:\n\n        >>> it = []\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too many items in iterable (expected 1)'\n        >>> too_short = IndexError('too few items')\n        >>> one(it, too_short=too_short)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        IndexError: too few items\n\n    Similarly, if *iterable* contains more than one item, ``ValueError`` will\n    be raised. You may specify a different exception with the *too_long*\n    keyword:\n\n        >>> it = ['too', 'many']\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: Expected exactly one item in iterable, but got 'too',\n        'many', and perhaps more.\n        >>> too_long = RuntimeError\n        >>> one(it, too_long=too_long)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        RuntimeError\n\n    Note that :func:`one` attempts to advance *iterable* twice to ensure there\n    is only one item. See :func:`spy` or :func:`peekable` to check iterable\n    contents less destructively.\n\n    \"\"\"\n    it = iter(iterable)\n\n    try:\n        first_value = next(it)\n    except StopIteration as e:\n        raise (\n            too_short or ValueError('too few items in iterable (expected 1)')\n        ) from e\n\n    try:\n        second_value = next(it)\n    except StopIteration:\n        pass\n    else:\n        msg = (\n            'Expected exactly one item in iterable, but got {!r}, {!r}, '\n            'and perhaps more.'.format(first_value, second_value)\n        )\n        raise too_long or ValueError(msg)\n\n    return first_value\n\n\ndef distinct_permutations(iterable, r=None):\n    \"\"\"Yield successive distinct permutations of the elements in *iterable*.\n\n        >>> sorted(distinct_permutations([1, 0, 1]))\n        [(0, 1, 1), (1, 0, 1), (1, 1, 0)]\n\n    Equivalent to ``set(permutations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    Duplicate permutations arise when there are duplicated elements in the\n    input iterable. The number of items returned is\n    `n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of\n    items input, and each `x_i` is the count of a distinct item in the input\n    sequence.\n\n    If *r* is given, only the *r*-length permutations are yielded.\n\n        >>> sorted(distinct_permutations([1, 0, 1], r=2))\n        [(0, 1), (1, 0), (1, 1)]\n        >>> sorted(distinct_permutations(range(3), r=2))\n        [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]\n\n    \"\"\"\n    # Algorithm: https://w.wiki/Qai\n    def _full(A):\n        while True:\n            # Yield the permutation we have\n            yield tuple(A)\n\n            # Find the largest index i such that A[i] < A[i + 1]\n            for i in range(size - 2, -1, -1):\n                if A[i] < A[i + 1]:\n                    break\n            #  If no such index exists, this permutation is the last one\n            else:\n                return\n\n            # Find the largest index j greater than j such that A[i] < A[j]\n            for j in range(size - 1, i, -1):\n                if A[i] < A[j]:\n                    break\n\n            # Swap the value of A[i] with that of A[j], then reverse the\n            # sequence from A[i + 1] to form the new permutation\n            A[i], A[j] = A[j], A[i]\n            A[i + 1 :] = A[: i - size : -1]  # A[i + 1:][::-1]\n\n    # Algorithm: modified from the above\n    def _partial(A, r):\n        # Split A into the first r items and the last r items\n        head, tail = A[:r], A[r:]\n        right_head_indexes = range(r - 1, -1, -1)\n        left_tail_indexes = range(len(tail))\n\n        while True:\n            # Yield the permutation we have\n            yield tuple(head)\n\n            # Starting from the right, find the first index of the head with\n            # value smaller than the maximum value of the tail - call it i.\n            pivot = tail[-1]\n            for i in right_head_indexes:\n                if head[i] < pivot:\n                    break\n                pivot = head[i]\n            else:\n                return\n\n            # Starting from the left, find the first value of the tail\n            # with a value greater than head[i] and swap.\n            for j in left_tail_indexes:\n                if tail[j] > head[i]:\n                    head[i], tail[j] = tail[j], head[i]\n                    break\n            # If we didn't find one, start from the right and find the first\n            # index of the head with a value greater than head[i] and swap.\n            else:\n                for j in right_head_indexes:\n                    if head[j] > head[i]:\n                        head[i], head[j] = head[j], head[i]\n                        break\n\n            # Reverse head[i + 1:] and swap it with tail[:r - (i + 1)]\n            tail += head[: i - r : -1]  # head[i + 1:][::-1]\n            i += 1\n            head[i:], tail[:] = tail[: r - i], tail[r - i :]\n\n    items = sorted(iterable)\n\n    size = len(items)\n    if r is None:\n        r = size\n\n    if 0 < r <= size:\n        return _full(items) if (r == size) else _partial(items, r)\n\n    return iter(() if r else ((),))\n\n\ndef intersperse(e, iterable, n=1):\n    \"\"\"Intersperse filler element *e* among the items in *iterable*, leaving\n    *n* items between each filler element.\n\n        >>> list(intersperse('!', [1, 2, 3, 4, 5]))\n        [1, '!', 2, '!', 3, '!', 4, '!', 5]\n\n        >>> list(intersperse(None, [1, 2, 3, 4, 5], n=2))\n        [1, 2, None, 3, 4, None, 5]\n\n    \"\"\"\n    if n == 0:\n        raise ValueError('n must be > 0')\n    elif n == 1:\n        # interleave(repeat(e), iterable) -> e, x_0, e, e, x_1, e, x_2...\n        # islice(..., 1, None) -> x_0, e, e, x_1, e, x_2...\n        return islice(interleave(repeat(e), iterable), 1, None)\n    else:\n        # interleave(filler, chunks) -> [e], [x_0, x_1], [e], [x_2, x_3]...\n        # islice(..., 1, None) -> [x_0, x_1], [e], [x_2, x_3]...\n        # flatten(...) -> x_0, x_1, e, x_2, x_3...\n        filler = repeat([e])\n        chunks = chunked(iterable, n)\n        return flatten(islice(interleave(filler, chunks), 1, None))\n\n\ndef unique_to_each(*iterables):\n    \"\"\"Return the elements from each of the input iterables that aren't in the\n    other input iterables.\n\n    For example, suppose you have a set of packages, each with a set of\n    dependencies::\n\n        {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}\n\n    If you remove one package, which dependencies can also be removed?\n\n    If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not\n    associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for\n    ``pkg_2``, and ``D`` is only needed for ``pkg_3``::\n\n        >>> unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})\n        [['A'], ['C'], ['D']]\n\n    If there are duplicates in one input iterable that aren't in the others\n    they will be duplicated in the output. Input order is preserved::\n\n        >>> unique_to_each(\"mississippi\", \"missouri\")\n        [['p', 'p'], ['o', 'u', 'r']]\n\n    It is assumed that the elements of each iterable are hashable.\n\n    \"\"\"\n    pool = [list(it) for it in iterables]\n    counts = Counter(chain.from_iterable(map(set, pool)))\n    uniques = {element for element in counts if counts[element] == 1}\n    return [list(filter(uniques.__contains__, it)) for it in pool]\n\n\ndef windowed(seq, n, fillvalue=None, step=1):\n    \"\"\"Return a sliding window of width *n* over the given iterable.\n\n        >>> all_windows = windowed([1, 2, 3, 4, 5], 3)\n        >>> list(all_windows)\n        [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n\n    When the window is larger than the iterable, *fillvalue* is used in place\n    of missing values:\n\n        >>> list(windowed([1, 2, 3], 4))\n        [(1, 2, 3, None)]\n\n    Each window will advance in increments of *step*:\n\n        >>> list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue='!', step=2))\n        [(1, 2, 3), (3, 4, 5), (5, 6, '!')]\n\n    To slide into the iterable's items, use :func:`chain` to add filler items\n    to the left:\n\n        >>> iterable = [1, 2, 3, 4]\n        >>> n = 3\n        >>> padding = [None] * (n - 1)\n        >>> list(windowed(chain(padding, iterable), 3))\n        [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        yield tuple()\n        return\n    if step < 1:\n        raise ValueError('step must be >= 1')\n\n    window = deque(maxlen=n)\n    i = n\n    for _ in map(window.append, seq):\n        i -= 1\n        if not i:\n            i = step\n            yield tuple(window)\n\n    size = len(window)\n    if size < n:\n        yield tuple(chain(window, repeat(fillvalue, n - size)))\n    elif 0 < i < min(step, n):\n        window += (fillvalue,) * i\n        yield tuple(window)\n\n\ndef substrings(iterable):\n    \"\"\"Yield all of the substrings of *iterable*.\n\n        >>> [''.join(s) for s in substrings('more')]\n        ['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more']\n\n    Note that non-string iterables can also be subdivided.\n\n        >>> list(substrings([0, 1, 2]))\n        [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]\n\n    \"\"\"\n    # The length-1 substrings\n    seq = []\n    for item in iter(iterable):\n        seq.append(item)\n        yield (item,)\n    seq = tuple(seq)\n    item_count = len(seq)\n\n    # And the rest\n    for n in range(2, item_count + 1):\n        for i in range(item_count - n + 1):\n            yield seq[i : i + n]\n\n\ndef substrings_indexes(seq, reverse=False):\n    \"\"\"Yield all substrings and their positions in *seq*\n\n    The items yielded will be a tuple of the form ``(substr, i, j)``, where\n    ``substr == seq[i:j]``.\n\n    This function only works for iterables that support slicing, such as\n    ``str`` objects.\n\n    >>> for item in substrings_indexes('more'):\n    ...    print(item)\n    ('m', 0, 1)\n    ('o', 1, 2)\n    ('r', 2, 3)\n    ('e', 3, 4)\n    ('mo', 0, 2)\n    ('or', 1, 3)\n    ('re', 2, 4)\n    ('mor', 0, 3)\n    ('ore', 1, 4)\n    ('more', 0, 4)\n\n    Set *reverse* to ``True`` to yield the same items in the opposite order.\n\n\n    \"\"\"\n    r = range(1, len(seq) + 1)\n    if reverse:\n        r = reversed(r)\n    return (\n        (seq[i : i + L], i, i + L) for L in r for i in range(len(seq) - L + 1)\n    )\n\n\nclass bucket:\n    \"\"\"Wrap *iterable* and return an object that buckets it iterable into\n    child iterables based on a *key* function.\n\n        >>> iterable = ['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'b3']\n        >>> s = bucket(iterable, key=lambda x: x[0])  # Bucket by 1st character\n        >>> sorted(list(s))  # Get the keys\n        ['a', 'b', 'c']\n        >>> a_iterable = s['a']\n        >>> next(a_iterable)\n        'a1'\n        >>> next(a_iterable)\n        'a2'\n        >>> list(s['b'])\n        ['b1', 'b2', 'b3']\n\n    The original iterable will be advanced and its items will be cached until\n    they are used by the child iterables. This may require significant storage.\n\n    By default, attempting to select a bucket to which no items belong  will\n    exhaust the iterable and cache all values.\n    If you specify a *validator* function, selected buckets will instead be\n    checked against it.\n\n        >>> from itertools import count\n        >>> it = count(1, 2)  # Infinite sequence of odd numbers\n        >>> key = lambda x: x % 10  # Bucket by last digit\n        >>> validator = lambda x: x in {1, 3, 5, 7, 9}  # Odd digits only\n        >>> s = bucket(it, key=key, validator=validator)\n        >>> 2 in s\n        False\n        >>> list(s[2])\n        []\n\n    \"\"\"\n\n    def __init__(self, iterable, key, validator=None):\n        self._it = iter(iterable)\n        self._key = key\n        self._cache = defaultdict(deque)\n        self._validator = validator or (lambda x: True)\n\n    def __contains__(self, value):\n        if not self._validator(value):\n            return False\n\n        try:\n            item = next(self[value])\n        except StopIteration:\n            return False\n        else:\n            self._cache[value].appendleft(item)\n\n        return True\n\n    def _get_values(self, value):\n        \"\"\"\n        Helper to yield items from the parent iterator that match *value*.\n        Items that don't match are stored in the local cache as they\n        are encountered.\n        \"\"\"\n        while True:\n            # If we've cached some items that match the target value, emit\n            # the first one and evict it from the cache.\n            if self._cache[value]:\n                yield self._cache[value].popleft()\n            # Otherwise we need to advance the parent iterator to search for\n            # a matching item, caching the rest.\n            else:\n                while True:\n                    try:\n                        item = next(self._it)\n                    except StopIteration:\n                        return\n                    item_value = self._key(item)\n                    if item_value == value:\n                        yield item\n                        break\n                    elif self._validator(item_value):\n                        self._cache[item_value].append(item)\n\n    def __iter__(self):\n        for item in self._it:\n            item_value = self._key(item)\n            if self._validator(item_value):\n                self._cache[item_value].append(item)\n\n        yield from self._cache.keys()\n\n    def __getitem__(self, value):\n        if not self._validator(value):\n            return iter(())\n\n        return self._get_values(value)\n\n\ndef spy(iterable, n=1):\n    \"\"\"Return a 2-tuple with a list containing the first *n* elements of\n    *iterable*, and an iterator with the same items as *iterable*.\n    This allows you to \"look ahead\" at the items in the iterable without\n    advancing it.\n\n    There is one item in the list by default:\n\n        >>> iterable = 'abcdefg'\n        >>> head, iterable = spy(iterable)\n        >>> head\n        ['a']\n        >>> list(iterable)\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\n    You may use unpacking to retrieve items instead of lists:\n\n        >>> (head,), iterable = spy('abcdefg')\n        >>> head\n        'a'\n        >>> (first, second), iterable = spy('abcdefg', 2)\n        >>> first\n        'a'\n        >>> second\n        'b'\n\n    The number of items requested can be larger than the number of items in\n    the iterable:\n\n        >>> iterable = [1, 2, 3, 4, 5]\n        >>> head, iterable = spy(iterable, 10)\n        >>> head\n        [1, 2, 3, 4, 5]\n        >>> list(iterable)\n        [1, 2, 3, 4, 5]\n\n    \"\"\"\n    it = iter(iterable)\n    head = take(n, it)\n\n    return head.copy(), chain(head, it)\n\n\ndef interleave(*iterables):\n    \"\"\"Return a new iterable yielding from each iterable in turn,\n    until the shortest is exhausted.\n\n        >>> list(interleave([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7]\n\n    For a version that doesn't terminate after the shortest iterable is\n    exhausted, see :func:`interleave_longest`.\n\n    \"\"\"\n    return chain.from_iterable(zip(*iterables))\n\n\ndef interleave_longest(*iterables):\n    \"\"\"Return a new iterable yielding from each iterable in turn,\n    skipping any that are exhausted.\n\n        >>> list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7, 3, 8]\n\n    This function produces the same output as :func:`roundrobin`, but may\n    perform better for some inputs (in particular when the number of iterables\n    is large).\n\n    \"\"\"\n    i = chain.from_iterable(zip_longest(*iterables, fillvalue=_marker))\n    return (x for x in i if x is not _marker)\n\n\ndef collapse(iterable, base_type=None, levels=None):\n    \"\"\"Flatten an iterable with multiple levels of nesting (e.g., a list of\n    lists of tuples) into non-iterable types.\n\n        >>> iterable = [(1, 2), ([3, 4], [[5], [6]])]\n        >>> list(collapse(iterable))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and\n    will not be collapsed.\n\n    To avoid collapsing other types, specify *base_type*:\n\n        >>> iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]\n        >>> list(collapse(iterable, base_type=tuple))\n        ['ab', ('cd', 'ef'), 'gh', 'ij']\n\n    Specify *levels* to stop flattening after a certain level:\n\n    >>> iterable = [('a', ['b']), ('c', ['d'])]\n    >>> list(collapse(iterable))  # Fully flattened\n    ['a', 'b', 'c', 'd']\n    >>> list(collapse(iterable, levels=1))  # Only one level flattened\n    ['a', ['b'], 'c', ['d']]\n\n    \"\"\"\n\n    def walk(node, level):\n        if (\n            ((levels is not None) and (level > levels))\n            or isinstance(node, (str, bytes))\n            or ((base_type is not None) and isinstance(node, base_type))\n        ):\n            yield node\n            return\n\n        try:\n            tree = iter(node)\n        except TypeError:\n            yield node\n            return\n        else:\n            for child in tree:\n                yield from walk(child, level + 1)\n\n    yield from walk(iterable, 0)\n\n\ndef side_effect(func, iterable, chunk_size=None, before=None, after=None):\n    \"\"\"Invoke *func* on each item in *iterable* (or on each *chunk_size* group\n    of items) before yielding the item.\n\n    `func` must be a function that takes a single argument. Its return value\n    will be discarded.\n\n    *before* and *after* are optional functions that take no arguments. They\n    will be executed before iteration starts and after it ends, respectively.\n\n    `side_effect` can be used for logging, updating progress bars, or anything\n    that is not functionally \"pure.\"\n\n    Emitting a status message:\n\n        >>> from more_itertools import consume\n        >>> func = lambda item: print('Received {}'.format(item))\n        >>> consume(side_effect(func, range(2)))\n        Received 0\n        Received 1\n\n    Operating on chunks of items:\n\n        >>> pair_sums = []\n        >>> func = lambda chunk: pair_sums.append(sum(chunk))\n        >>> list(side_effect(func, [0, 1, 2, 3, 4, 5], 2))\n        [0, 1, 2, 3, 4, 5]\n        >>> list(pair_sums)\n        [1, 5, 9]\n\n    Writing to a file-like object:\n\n        >>> from io import StringIO\n        >>> from more_itertools import consume\n        >>> f = StringIO()\n        >>> func = lambda x: print(x, file=f)\n        >>> before = lambda: print(u'HEADER', file=f)\n        >>> after = f.close\n        >>> it = [u'a', u'b', u'c']\n        >>> consume(side_effect(func, it, before=before, after=after))\n        >>> f.closed\n        True\n\n    \"\"\"\n    try:\n        if before is not None:\n            before()\n\n        if chunk_size is None:\n            for item in iterable:\n                func(item)\n                yield item\n        else:\n            for chunk in chunked(iterable, chunk_size):\n                func(chunk)\n                yield from chunk\n    finally:\n        if after is not None:\n            after()\n\n\ndef sliced(seq, n, strict=False):\n    \"\"\"Yield slices of length *n* from the sequence *seq*.\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6), 3))\n    [(1, 2, 3), (4, 5, 6)]\n\n    By the default, the last yielded slice will have fewer than *n* elements\n    if the length of *seq* is not divisible by *n*:\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))\n    [(1, 2, 3), (4, 5, 6), (7, 8)]\n\n    If the length of *seq* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    slice is yielded.\n\n    This function will only work for iterables that support slicing.\n    For non-sliceable iterables, see :func:`chunked`.\n\n    \"\"\"\n    iterator = takewhile(len, (seq[i : i + n] for i in count(0, n)))\n    if strict:\n\n        def ret():\n            for _slice in iterator:\n                if len(_slice) != n:\n                    raise ValueError(\"seq is not divisible by n.\")\n                yield _slice\n\n        return iter(ret())\n    else:\n        return iterator\n\n\ndef split_at(iterable, pred, maxsplit=-1, keep_separator=False):\n    \"\"\"Yield lists of items from *iterable*, where each list is delimited by\n    an item where callable *pred* returns ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b'))\n        [['a'], ['c', 'd', 'c'], ['a']]\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1))\n        [[0], [2], [4], [6], [8], []]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1, maxsplit=2))\n        [[0], [2], [4, 5, 6, 7, 8, 9]]\n\n    By default, the delimiting items are not included in the output.\n    The include them, set *keep_separator* to ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b', keep_separator=True))\n        [['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item):\n            yield buf\n            if keep_separator:\n                yield [item]\n            if maxsplit == 1:\n                yield list(it)\n                return\n            buf = []\n            maxsplit -= 1\n        else:\n            buf.append(item)\n    yield buf\n\n\ndef split_before(iterable, pred, maxsplit=-1):\n    \"\"\"Yield lists of items from *iterable*, where each list ends just before\n    an item for which callable *pred* returns ``True``:\n\n        >>> list(split_before('OneTwo', lambda s: s.isupper()))\n        [['O', 'n', 'e'], ['T', 'w', 'o']]\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                yield [item] + list(it)\n                return\n            buf = []\n            maxsplit -= 1\n        buf.append(item)\n    if buf:\n        yield buf\n\n\ndef split_after(iterable, pred, maxsplit=-1):\n    \"\"\"Yield lists of items from *iterable*, where each list ends with an\n    item where callable *pred* returns ``True``:\n\n        >>> list(split_after('one1two2', lambda s: s.isdigit()))\n        [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0))\n        [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        buf.append(item)\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                yield list(it)\n                return\n            buf = []\n            maxsplit -= 1\n    if buf:\n        yield buf\n\n\ndef split_when(iterable, pred, maxsplit=-1):\n    \"\"\"Split *iterable* into pieces based on the output of *pred*.\n    *pred* should be a function that takes successive pairs of items and\n    returns ``True`` if the iterable should be split in between them.\n\n    For example, to find runs of increasing numbers, split the iterable when\n    element ``i`` is larger than element ``i + 1``:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x > y))\n        [[1, 2, 3, 3], [2, 5], [2, 4], [2]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],\n        ...                 lambda x, y: x > y, maxsplit=2))\n        [[1, 2, 3, 3], [2, 5], [2, 4, 2]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    it = iter(iterable)\n    try:\n        cur_item = next(it)\n    except StopIteration:\n        return\n\n    buf = [cur_item]\n    for next_item in it:\n        if pred(cur_item, next_item):\n            yield buf\n            if maxsplit == 1:\n                yield [next_item] + list(it)\n                return\n            buf = []\n            maxsplit -= 1\n\n        buf.append(next_item)\n        cur_item = next_item\n\n    yield buf\n\n\ndef split_into(iterable, sizes):\n    \"\"\"Yield a list of sequential items from *iterable* of length 'n' for each\n    integer 'n' in *sizes*.\n\n        >>> list(split_into([1,2,3,4,5,6], [1,2,3]))\n        [[1], [2, 3], [4, 5, 6]]\n\n    If the sum of *sizes* is smaller than the length of *iterable*, then the\n    remaining items of *iterable* will not be returned.\n\n        >>> list(split_into([1,2,3,4,5,6], [2,3]))\n        [[1, 2], [3, 4, 5]]\n\n    If the sum of *sizes* is larger than the length of *iterable*, fewer items\n    will be returned in the iteration that overruns *iterable* and further\n    lists will be empty:\n\n        >>> list(split_into([1,2,3,4], [1,2,3,4]))\n        [[1], [2, 3], [4], []]\n\n    When a ``None`` object is encountered in *sizes*, the returned list will\n    contain items up to the end of *iterable* the same way that itertools.slice\n    does:\n\n        >>> list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))\n        [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]\n\n    :func:`split_into` can be useful for grouping a series of items where the\n    sizes of the groups are not uniform. An example would be where in a row\n    from a table, multiple columns represent elements of the same feature\n    (e.g. a point represented by x,y,z) but, the format is not the same for\n    all columns.\n    \"\"\"\n    # convert the iterable argument into an iterator so its contents can\n    # be consumed by islice in case it is a generator\n    it = iter(iterable)\n\n    for size in sizes:\n        if size is None:\n            yield list(it)\n            return\n        else:\n            yield list(islice(it, size))\n\n\ndef padded(iterable, fillvalue=None, n=None, next_multiple=False):\n    \"\"\"Yield the elements from *iterable*, followed by *fillvalue*, such that\n    at least *n* items are emitted.\n\n        >>> list(padded([1, 2, 3], '?', 5))\n        [1, 2, 3, '?', '?']\n\n    If *next_multiple* is ``True``, *fillvalue* will be emitted until the\n    number of items emitted is a multiple of *n*::\n\n        >>> list(padded([1, 2, 3, 4], n=3, next_multiple=True))\n        [1, 2, 3, 4, None, None]\n\n    If *n* is ``None``, *fillvalue* will be emitted indefinitely.\n\n    \"\"\"\n    it = iter(iterable)\n    if n is None:\n        yield from chain(it, repeat(fillvalue))\n    elif n < 1:\n        raise ValueError('n must be at least 1')\n    else:\n        item_count = 0\n        for item in it:\n            yield item\n            item_count += 1\n\n        remaining = (n - item_count) % n if next_multiple else n - item_count\n        for _ in range(remaining):\n            yield fillvalue\n\n\ndef repeat_last(iterable, default=None):\n    \"\"\"After the *iterable* is exhausted, keep yielding its last element.\n\n        >>> list(islice(repeat_last(range(3)), 5))\n        [0, 1, 2, 2, 2]\n\n    If the iterable is empty, yield *default* forever::\n\n        >>> list(islice(repeat_last(range(0), 42), 5))\n        [42, 42, 42, 42, 42]\n\n    \"\"\"\n    item = _marker\n    for item in iterable:\n        yield item\n    final = default if item is _marker else item\n    yield from repeat(final)\n\n\ndef distribute(n, iterable):\n    \"\"\"Distribute the items from *iterable* among *n* smaller iterables.\n\n        >>> group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 3, 5]\n        >>> list(group_2)\n        [2, 4, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = distribute(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 4, 7], [2, 5], [3, 6]]\n\n    If the length of *iterable* is smaller than *n*, then the last returned\n    iterables will be empty:\n\n        >>> children = distribute(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function uses :func:`itertools.tee` and may require significant\n    storage. If you need the order items in the smaller iterables to match the\n    original iterable, see :func:`divide`.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    children = tee(iterable, n)\n    return [islice(it, index, None, n) for index, it in enumerate(children)]\n\n\ndef stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):\n    \"\"\"Yield tuples whose elements are offset from *iterable*.\n    The amount by which the `i`-th item in each tuple is offset is given by\n    the `i`-th item in *offsets*.\n\n        >>> list(stagger([0, 1, 2, 3]))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3)]\n        >>> list(stagger(range(8), offsets=(0, 2, 4)))\n        [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]\n\n    By default, the sequence will end when the final element of a tuple is the\n    last item in the iterable. To continue until the first element of a tuple\n    is the last item in the iterable, set *longest* to ``True``::\n\n        >>> list(stagger([0, 1, 2, 3], longest=True))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    \"\"\"\n    children = tee(iterable, len(offsets))\n\n    return zip_offset(\n        *children, offsets=offsets, longest=longest, fillvalue=fillvalue\n    )\n\n\nclass UnequalIterablesError(ValueError):\n    def __init__(self, details=None):\n        msg = 'Iterables have different lengths'\n        if details is not None:\n            msg += (': index 0 has length {}; index {} has length {}').format(\n                *details\n            )\n\n        super().__init__(msg)\n\n\ndef _zip_equal_generator(iterables):\n    for combo in zip_longest(*iterables, fillvalue=_marker):\n        for val in combo:\n            if val is _marker:\n                raise UnequalIterablesError()\n        yield combo\n\n\ndef zip_equal(*iterables):\n    \"\"\"``zip`` the input *iterables* together, but raise\n    ``UnequalIterablesError`` if they aren't all the same length.\n\n        >>> it_1 = range(3)\n        >>> it_2 = iter('abc')\n        >>> list(zip_equal(it_1, it_2))\n        [(0, 'a'), (1, 'b'), (2, 'c')]\n\n        >>> it_1 = range(3)\n        >>> it_2 = iter('abcd')\n        >>> list(zip_equal(it_1, it_2)) # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        more_itertools.more.UnequalIterablesError: Iterables have different\n        lengths\n\n    \"\"\"\n    if hexversion >= 0x30A00A6:\n        warnings.warn(\n            (\n                'zip_equal will be removed in a future version of '\n                'more-itertools. Use the builtin zip function with '\n                'strict=True instead.'\n            ),\n            DeprecationWarning,\n        )\n    # Check whether the iterables are all the same size.\n    try:\n        first_size = len(iterables[0])\n        for i, it in enumerate(iterables[1:], 1):\n            size = len(it)\n            if size != first_size:\n                break\n        else:\n            # If we didn't break out, we can use the built-in zip.\n            return zip(*iterables)\n\n        # If we did break out, there was a mismatch.\n        raise UnequalIterablesError(details=(first_size, i, size))\n    # If any one of the iterables didn't have a length, start reading\n    # them until one runs out.\n    except TypeError:\n        return _zip_equal_generator(iterables)\n\n\ndef zip_offset(*iterables, offsets, longest=False, fillvalue=None):\n    \"\"\"``zip`` the input *iterables* together, but offset the `i`-th iterable\n    by the `i`-th item in *offsets*.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1)))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]\n\n    This can be used as a lightweight alternative to SciPy or pandas to analyze\n    data sets in which some series have a lead or lag relationship.\n\n    By default, the sequence will end when the shortest iterable is exhausted.\n    To continue until the longest iterable is exhausted, set *longest* to\n    ``True``.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    \"\"\"\n    if len(iterables) != len(offsets):\n        raise ValueError(\"Number of iterables and offsets didn't match\")\n\n    staggered = []\n    for it, n in zip(iterables, offsets):\n        if n < 0:\n            staggered.append(chain(repeat(fillvalue, -n), it))\n        elif n > 0:\n            staggered.append(islice(it, n, None))\n        else:\n            staggered.append(it)\n\n    if longest:\n        return zip_longest(*staggered, fillvalue=fillvalue)\n\n    return zip(*staggered)\n\n\ndef sort_together(iterables, key_list=(0,), key=None, reverse=False):\n    \"\"\"Return the input iterables sorted together, with *key_list* as the\n    priority for sorting. All iterables are trimmed to the length of the\n    shortest one.\n\n    This can be used like the sorting function in a spreadsheet. If each\n    iterable represents a column of data, the key list determines which\n    columns are used for sorting.\n\n    By default, all iterables are sorted using the ``0``-th iterable::\n\n        >>> iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]\n        >>> sort_together(iterables)\n        [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]\n\n    Set a different key list to sort according to another iterable.\n    Specifying multiple keys dictates how ties are broken::\n\n        >>> iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]\n        >>> sort_together(iterables, key_list=(1, 2))\n        [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]\n\n    To sort by a function of the elements of the iterable, pass a *key*\n    function. Its arguments are the elements of the iterables corresponding to\n    the key list::\n\n        >>> names = ('a', 'b', 'c')\n        >>> lengths = (1, 2, 3)\n        >>> widths = (5, 2, 1)\n        >>> def area(length, width):\n        ...     return length * width\n        >>> sort_together([names, lengths, widths], key_list=(1, 2), key=area)\n        [('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)]\n\n    Set *reverse* to ``True`` to sort in descending order.\n\n        >>> sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True)\n        [(3, 2, 1), ('a', 'b', 'c')]\n\n    \"\"\"\n    if key is None:\n        # if there is no key function, the key argument to sorted is an\n        # itemgetter\n        key_argument = itemgetter(*key_list)\n    else:\n        # if there is a key function, call it with the items at the offsets\n        # specified by the key function as arguments\n        key_list = list(key_list)\n        if len(key_list) == 1:\n            # if key_list contains a single item, pass the item at that offset\n            # as the only argument to the key function\n            key_offset = key_list[0]\n            key_argument = lambda zipped_items: key(zipped_items[key_offset])\n        else:\n            # if key_list contains multiple items, use itemgetter to return a\n            # tuple of items, which we pass as *args to the key function\n            get_key_items = itemgetter(*key_list)\n            key_argument = lambda zipped_items: key(\n                *get_key_items(zipped_items)\n            )\n\n    return list(\n        zip(*sorted(zip(*iterables), key=key_argument, reverse=reverse))\n    )\n\n\ndef unzip(iterable):\n    \"\"\"The inverse of :func:`zip`, this function disaggregates the elements\n    of the zipped *iterable*.\n\n    The ``i``-th iterable contains the ``i``-th element from each element\n    of the zipped iterable. The first element is used to to determine the\n    length of the remaining elements.\n\n        >>> iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> letters, numbers = unzip(iterable)\n        >>> list(letters)\n        ['a', 'b', 'c', 'd']\n        >>> list(numbers)\n        [1, 2, 3, 4]\n\n    This is similar to using ``zip(*iterable)``, but it avoids reading\n    *iterable* into memory. Note, however, that this function uses\n    :func:`itertools.tee` and thus may require significant storage.\n\n    \"\"\"\n    head, iterable = spy(iter(iterable))\n    if not head:\n        # empty iterable, e.g. zip([], [], [])\n        return ()\n    # spy returns a one-length iterable as head\n    head = head[0]\n    iterables = tee(iterable, len(head))\n\n    def itemgetter(i):\n        def getter(obj):\n            try:\n                return obj[i]\n            except IndexError:\n                # basically if we have an iterable like\n                # iter([(1, 2, 3), (4, 5), (6,)])\n                # the second unzipped iterable would fail at the third tuple\n                # since it would try to access tup[1]\n                # same with the third unzipped iterable and the second tuple\n                # to support these \"improperly zipped\" iterables,\n                # we create a custom itemgetter\n                # which just stops the unzipped iterables\n                # at first length mismatch\n                raise StopIteration\n\n        return getter\n\n    return tuple(map(itemgetter(i), it) for i, it in enumerate(iterables))\n\n\ndef divide(n, iterable):\n    \"\"\"Divide the elements from *iterable* into *n* parts, maintaining\n    order.\n\n        >>> group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 2, 3]\n        >>> list(group_2)\n        [4, 5, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = divide(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 2, 3], [4, 5], [6, 7]]\n\n    If the length of the iterable is smaller than n, then the last returned\n    iterables will be empty:\n\n        >>> children = divide(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function will exhaust the iterable before returning and may require\n    significant storage. If order is not important, see :func:`distribute`,\n    which does not first pull the iterable into memory.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    try:\n        iterable[:0]\n    except TypeError:\n        seq = tuple(iterable)\n    else:\n        seq = iterable\n\n    q, r = divmod(len(seq), n)\n\n    ret = []\n    stop = 0\n    for i in range(1, n + 1):\n        start = stop\n        stop += q + 1 if i <= r else q\n        ret.append(iter(seq[start:stop]))\n\n    return ret\n\n\ndef always_iterable(obj, base_type=(str, bytes)):\n    \"\"\"If *obj* is iterable, return an iterator over its items::\n\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n\n    If *obj* is ``None``, return an empty iterable:\n\n        >>> obj = None\n        >>> list(always_iterable(None))\n        []\n\n    By default, binary and text strings are not considered iterable::\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj))\n        ['foo']\n\n    If *base_type* is set, objects for which ``isinstance(obj, base_type)``\n    returns ``True`` won't be considered iterable.\n\n        >>> obj = {'a': 1}\n        >>> list(always_iterable(obj))  # Iterate over the dict's keys\n        ['a']\n        >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n        [{'a': 1}]\n\n    Set *base_type* to ``None`` to avoid any special handling and treat objects\n    Python considers iterable as iterable:\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj, base_type=None))\n        ['f', 'o', 'o']\n    \"\"\"\n    if obj is None:\n        return iter(())\n\n    if (base_type is not None) and isinstance(obj, base_type):\n        return iter((obj,))\n\n    try:\n        return iter(obj)\n    except TypeError:\n        return iter((obj,))\n\n\ndef adjacent(predicate, iterable, distance=1):\n    \"\"\"Return an iterable over `(bool, item)` tuples where the `item` is\n    drawn from *iterable* and the `bool` indicates whether\n    that item satisfies the *predicate* or is adjacent to an item that does.\n\n    For example, to find whether items are adjacent to a ``3``::\n\n        >>> list(adjacent(lambda x: x == 3, range(6)))\n        [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]\n\n    Set *distance* to change what counts as adjacent. For example, to find\n    whether items are two places away from a ``3``:\n\n        >>> list(adjacent(lambda x: x == 3, range(6), distance=2))\n        [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]\n\n    This is useful for contextualizing the results of a search function.\n    For example, a code comparison tool might want to identify lines that\n    have changed, but also surrounding lines to give the viewer of the diff\n    context.\n\n    The predicate function will only be called once for each item in the\n    iterable.\n\n    See also :func:`groupby_transform`, which can be used with this function\n    to group ranges of items with the same `bool` value.\n\n    \"\"\"\n    # Allow distance=0 mainly for testing that it reproduces results with map()\n    if distance < 0:\n        raise ValueError('distance must be at least 0')\n\n    i1, i2 = tee(iterable)\n    padding = [False] * distance\n    selected = chain(padding, map(predicate, i1), padding)\n    adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))\n    return zip(adjacent_to_selected, i2)\n\n\ndef groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):\n    \"\"\"An extension of :func:`itertools.groupby` that can apply transformations\n    to the grouped data.\n\n    * *keyfunc* is a function computing a key value for each item in *iterable*\n    * *valuefunc* is a function that transforms the individual items from\n      *iterable* after grouping\n    * *reducefunc* is a function that transforms each group of items\n\n    >>> iterable = 'aAAbBBcCC'\n    >>> keyfunc = lambda k: k.upper()\n    >>> valuefunc = lambda v: v.lower()\n    >>> reducefunc = lambda g: ''.join(g)\n    >>> list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))\n    [('A', 'aaa'), ('B', 'bbb'), ('C', 'ccc')]\n\n    Each optional argument defaults to an identity function if not specified.\n\n    :func:`groupby_transform` is useful when grouping elements of an iterable\n    using a separate iterable as the key. To do this, :func:`zip` the iterables\n    and pass a *keyfunc* that extracts the first element and a *valuefunc*\n    that extracts the second element::\n\n        >>> from operator import itemgetter\n        >>> keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]\n        >>> values = 'abcdefghi'\n        >>> iterable = zip(keys, values)\n        >>> grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))\n        >>> [(k, ''.join(g)) for k, g in grouper]\n        [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')]\n\n    Note that the order of items in the iterable is significant.\n    Only adjacent items are grouped together, so if you don't want any\n    duplicate groups, you should sort the iterable by the key function.\n\n    \"\"\"\n    ret = groupby(iterable, keyfunc)\n    if valuefunc:\n        ret = ((k, map(valuefunc, g)) for k, g in ret)\n    if reducefunc:\n        ret = ((k, reducefunc(g)) for k, g in ret)\n\n    return ret\n\n\nclass numeric_range(abc.Sequence, abc.Hashable):\n    \"\"\"An extension of the built-in ``range()`` function whose arguments can\n    be any orderable numeric type.\n\n    With only *stop* specified, *start* defaults to ``0`` and *step*\n    defaults to ``1``. The output items will match the type of *stop*:\n\n        >>> list(numeric_range(3.5))\n        [0.0, 1.0, 2.0, 3.0]\n\n    With only *start* and *stop* specified, *step* defaults to ``1``. The\n    output items will match the type of *start*:\n\n        >>> from decimal import Decimal\n        >>> start = Decimal('2.1')\n        >>> stop = Decimal('5.1')\n        >>> list(numeric_range(start, stop))\n        [Decimal('2.1'), Decimal('3.1'), Decimal('4.1')]\n\n    With *start*, *stop*, and *step*  specified the output items will match\n    the type of ``start + step``:\n\n        >>> from fractions import Fraction\n        >>> start = Fraction(1, 2)  # Start at 1/2\n        >>> stop = Fraction(5, 2)  # End at 5/2\n        >>> step = Fraction(1, 2)  # Count by 1/2\n        >>> list(numeric_range(start, stop, step))\n        [Fraction(1, 2), Fraction(1, 1), Fraction(3, 2), Fraction(2, 1)]\n\n    If *step* is zero, ``ValueError`` is raised. Negative steps are supported:\n\n        >>> list(numeric_range(3, -1, -1.0))\n        [3.0, 2.0, 1.0, 0.0]\n\n    Be aware of the limitations of floating point numbers; the representation\n    of the yielded numbers may be surprising.\n\n    ``datetime.datetime`` objects can be used for *start* and *stop*, if *step*\n    is a ``datetime.timedelta`` object:\n\n        >>> import datetime\n        >>> start = datetime.datetime(2019, 1, 1)\n        >>> stop = datetime.datetime(2019, 1, 3)\n        >>> step = datetime.timedelta(days=1)\n        >>> items = iter(numeric_range(start, stop, step))\n        >>> next(items)\n        datetime.datetime(2019, 1, 1, 0, 0)\n        >>> next(items)\n        datetime.datetime(2019, 1, 2, 0, 0)\n\n    \"\"\"\n\n    _EMPTY_HASH = hash(range(0, 0))\n\n    def __init__(self, *args):\n        argc = len(args)\n        if argc == 1:\n            (self._stop,) = args\n            self._start = type(self._stop)(0)\n            self._step = type(self._stop - self._start)(1)\n        elif argc == 2:\n            self._start, self._stop = args\n            self._step = type(self._stop - self._start)(1)\n        elif argc == 3:\n            self._start, self._stop, self._step = args\n        elif argc == 0:\n            raise TypeError(\n                'numeric_range expected at least '\n                '1 argument, got {}'.format(argc)\n            )\n        else:\n            raise TypeError(\n                'numeric_range expected at most '\n                '3 arguments, got {}'.format(argc)\n            )\n\n        self._zero = type(self._step)(0)\n        if self._step == self._zero:\n            raise ValueError('numeric_range() arg 3 must not be zero')\n        self._growing = self._step > self._zero\n        self._init_len()\n\n    def __bool__(self):\n        if self._growing:\n            return self._start < self._stop\n        else:\n            return self._start > self._stop\n\n    def __contains__(self, elem):\n        if self._growing:\n            if self._start <= elem < self._stop:\n                return (elem - self._start) % self._step == self._zero\n        else:\n            if self._start >= elem > self._stop:\n                return (self._start - elem) % (-self._step) == self._zero\n\n        return False\n\n    def __eq__(self, other):\n        if isinstance(other, numeric_range):\n            empty_self = not bool(self)\n            empty_other = not bool(other)\n            if empty_self or empty_other:\n                return empty_self and empty_other  # True if both empty\n            else:\n                return (\n                    self._start == other._start\n                    and self._step == other._step\n                    and self._get_by_index(-1) == other._get_by_index(-1)\n                )\n        else:\n            return False\n\n    def __getitem__(self, key):\n        if isinstance(key, int):\n            return self._get_by_index(key)\n        elif isinstance(key, slice):\n            step = self._step if key.step is None else key.step * self._step\n\n            if key.start is None or key.start <= -self._len:\n                start = self._start\n            elif key.start >= self._len:\n                start = self._stop\n            else:  # -self._len < key.start < self._len\n                start = self._get_by_index(key.start)\n\n            if key.stop is None or key.stop >= self._len:\n                stop = self._stop\n            elif key.stop <= -self._len:\n                stop = self._start\n            else:  # -self._len < key.stop < self._len\n                stop = self._get_by_index(key.stop)\n\n            return numeric_range(start, stop, step)\n        else:\n            raise TypeError(\n                'numeric range indices must be '\n                'integers or slices, not {}'.format(type(key).__name__)\n            )\n\n    def __hash__(self):\n        if self:\n            return hash((self._start, self._get_by_index(-1), self._step))\n        else:\n            return self._EMPTY_HASH\n\n    def __iter__(self):\n        values = (self._start + (n * self._step) for n in count())\n        if self._growing:\n            return takewhile(partial(gt, self._stop), values)\n        else:\n            return takewhile(partial(lt, self._stop), values)\n\n    def __len__(self):\n        return self._len\n\n    def _init_len(self):\n        if self._growing:\n            start = self._start\n            stop = self._stop\n            step = self._step\n        else:\n            start = self._stop\n            stop = self._start\n            step = -self._step\n        distance = stop - start\n        if distance <= self._zero:\n            self._len = 0\n        else:  # distance > 0 and step > 0: regular euclidean division\n            q, r = divmod(distance, step)\n            self._len = int(q) + int(r != self._zero)\n\n    def __reduce__(self):\n        return numeric_range, (self._start, self._stop, self._step)\n\n    def __repr__(self):\n        if self._step == 1:\n            return \"numeric_range({}, {})\".format(\n                repr(self._start), repr(self._stop)\n            )\n        else:\n            return \"numeric_range({}, {}, {})\".format(\n                repr(self._start), repr(self._stop), repr(self._step)\n            )\n\n    def __reversed__(self):\n        return iter(\n            numeric_range(\n                self._get_by_index(-1), self._start - self._step, -self._step\n            )\n        )\n\n    def count(self, value):\n        return int(value in self)\n\n    def index(self, value):\n        if self._growing:\n            if self._start <= value < self._stop:\n                q, r = divmod(value - self._start, self._step)\n                if r == self._zero:\n                    return int(q)\n        else:\n            if self._start >= value > self._stop:\n                q, r = divmod(self._start - value, -self._step)\n                if r == self._zero:\n                    return int(q)\n\n        raise ValueError(\"{} is not in numeric range\".format(value))\n\n    def _get_by_index(self, i):\n        if i < 0:\n            i += self._len\n        if i < 0 or i >= self._len:\n            raise IndexError(\"numeric range object index out of range\")\n        return self._start + i * self._step\n\n\ndef count_cycle(iterable, n=None):\n    \"\"\"Cycle through the items from *iterable* up to *n* times, yielding\n    the number of completed cycles along with each item. If *n* is omitted the\n    process repeats indefinitely.\n\n    >>> list(count_cycle('AB', 3))\n    [(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]\n\n    \"\"\"\n    iterable = tuple(iterable)\n    if not iterable:\n        return iter(())\n    counter = count() if n is None else range(n)\n    return ((i, item) for i in counter for item in iterable)\n\n\ndef mark_ends(iterable):\n    \"\"\"Yield 3-tuples of the form ``(is_first, is_last, item)``.\n\n    >>> list(mark_ends('ABC'))\n    [(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]\n\n    Use this when looping over an iterable to take special action on its first\n    and/or last items:\n\n    >>> iterable = ['Header', 100, 200, 'Footer']\n    >>> total = 0\n    >>> for is_first, is_last, item in mark_ends(iterable):\n    ...     if is_first:\n    ...         continue  # Skip the header\n    ...     if is_last:\n    ...         continue  # Skip the footer\n    ...     total += item\n    >>> print(total)\n    300\n    \"\"\"\n    it = iter(iterable)\n\n    try:\n        b = next(it)\n    except StopIteration:\n        return\n\n    try:\n        for i in count():\n            a = b\n            b = next(it)\n            yield i == 0, False, a\n\n    except StopIteration:\n        yield i == 0, True, a\n\n\ndef locate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(locate([0, 1, 1, 0, 1, 0, 0]))\n        [1, 2, 4]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item.\n\n        >>> list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b'))\n        [1, 3]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(locate(iterable, pred=pred, window_size=3))\n        [1, 5, 9]\n\n    Use with :func:`seekable` to find indexes and then retrieve the associated\n    items:\n\n        >>> from itertools import count\n        >>> from more_itertools import seekable\n        >>> source = (3 * n + 1 if (n % 2) else n // 2 for n in count())\n        >>> it = seekable(source)\n        >>> pred = lambda x: x > 100\n        >>> indexes = locate(it, pred=pred)\n        >>> i = next(indexes)\n        >>> it.seek(i)\n        >>> next(it)\n        106\n\n    \"\"\"\n    if window_size is None:\n        return compress(count(), map(pred, iterable))\n\n    if window_size < 1:\n        raise ValueError('window size must be at least 1')\n\n    it = windowed(iterable, window_size, fillvalue=_marker)\n    return compress(count(), starmap(pred, it))\n\n\ndef lstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the beginning\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the start of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(lstrip(iterable, pred))\n        [1, 2, None, 3, False, None]\n\n    This function is analogous to to :func:`str.lstrip`, and is essentially\n    an wrapper for :func:`itertools.dropwhile`.\n\n    \"\"\"\n    return dropwhile(pred, iterable)\n\n\ndef rstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the end\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the end of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(rstrip(iterable, pred))\n        [None, False, None, 1, 2, None, 3]\n\n    This function is analogous to :func:`str.rstrip`.\n\n    \"\"\"\n    cache = []\n    cache_append = cache.append\n    cache_clear = cache.clear\n    for x in iterable:\n        if pred(x):\n            cache_append(x)\n        else:\n            yield from cache\n            cache_clear()\n            yield x\n\n\ndef strip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the\n    beginning and end for which *pred* returns ``True``.\n\n    For example, to remove a set of items from both ends of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(strip(iterable, pred))\n        [1, 2, None, 3]\n\n    This function is analogous to :func:`str.strip`.\n\n    \"\"\"\n    return rstrip(lstrip(iterable, pred), pred)\n\n\nclass islice_extended:\n    \"\"\"An extension of :func:`itertools.islice` that supports negative values\n    for *stop*, *start*, and *step*.\n\n        >>> iterable = iter('abcdefgh')\n        >>> list(islice_extended(iterable, -4, -1))\n        ['e', 'f', 'g']\n\n    Slices with negative values require some caching of *iterable*, but this\n    function takes care to minimize the amount of memory required.\n\n    For example, you can use a negative step with an infinite iterator:\n\n        >>> from itertools import count\n        >>> list(islice_extended(count(), 110, 99, -2))\n        [110, 108, 106, 104, 102, 100]\n\n    You can also use slice notation directly:\n\n        >>> iterable = map(str, count())\n        >>> it = islice_extended(iterable)[10:20:2]\n        >>> list(it)\n        ['10', '12', '14', '16', '18']\n\n    \"\"\"\n\n    def __init__(self, iterable, *args):\n        it = iter(iterable)\n        if args:\n            self._iterable = _islice_helper(it, slice(*args))\n        else:\n            self._iterable = it\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return next(self._iterable)\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return islice_extended(_islice_helper(self._iterable, key))\n\n        raise TypeError('islice_extended.__getitem__ argument must be a slice')\n\n\ndef _islice_helper(it, s):\n    start = s.start\n    stop = s.stop\n    if s.step == 0:\n        raise ValueError('step argument must be a non-zero integer or None.')\n    step = s.step or 1\n\n    if step > 0:\n        start = 0 if (start is None) else start\n\n        if start < 0:\n            # Consume all but the last -start items\n            cache = deque(enumerate(it, 1), maxlen=-start)\n            len_iter = cache[-1][0] if cache else 0\n\n            # Adjust start to be positive\n            i = max(len_iter + start, 0)\n\n            # Adjust stop to be positive\n            if stop is None:\n                j = len_iter\n            elif stop >= 0:\n                j = min(stop, len_iter)\n            else:\n                j = max(len_iter + stop, 0)\n\n            # Slice the cache\n            n = j - i\n            if n <= 0:\n                return\n\n            for index, item in islice(cache, 0, n, step):\n                yield item\n        elif (stop is not None) and (stop < 0):\n            # Advance to the start position\n            next(islice(it, start, start), None)\n\n            # When stop is negative, we have to carry -stop items while\n            # iterating\n            cache = deque(islice(it, -stop), maxlen=-stop)\n\n            for index, item in enumerate(it):\n                cached_item = cache.popleft()\n                if index % step == 0:\n                    yield cached_item\n                cache.append(item)\n        else:\n            # When both start and stop are positive we have the normal case\n            yield from islice(it, start, stop, step)\n    else:\n        start = -1 if (start is None) else start\n\n        if (stop is not None) and (stop < 0):\n            # Consume all but the last items\n            n = -stop - 1\n            cache = deque(enumerate(it, 1), maxlen=n)\n            len_iter = cache[-1][0] if cache else 0\n\n            # If start and stop are both negative they are comparable and\n            # we can just slice. Otherwise we can adjust start to be negative\n            # and then slice.\n            if start < 0:\n                i, j = start, stop\n            else:\n                i, j = min(start - len_iter, -1), None\n\n            for index, item in list(cache)[i:j:step]:\n                yield item\n        else:\n            # Advance to the stop position\n            if stop is not None:\n                m = stop + 1\n                next(islice(it, m, m), None)\n\n            # stop is positive, so if start is negative they are not comparable\n            # and we need the rest of the items.\n            if start < 0:\n                i = start\n                n = None\n            # stop is None and start is positive, so we just need items up to\n            # the start index.\n            elif stop is None:\n                i = None\n                n = start + 1\n            # Both stop and start are positive, so they are comparable.\n            else:\n                i = None\n                n = start - stop\n                if n <= 0:\n                    return\n\n            cache = list(islice(it, n))\n\n            yield from cache[i::step]\n\n\ndef always_reversible(iterable):\n    \"\"\"An extension of :func:`reversed` that supports all iterables, not\n    just those which implement the ``Reversible`` or ``Sequence`` protocols.\n\n        >>> print(*always_reversible(x for x in range(3)))\n        2 1 0\n\n    If the iterable is already reversible, this function returns the\n    result of :func:`reversed()`. If the iterable is not reversible,\n    this function will cache the remaining items in the iterable and\n    yield them in reverse order, which may require significant storage.\n    \"\"\"\n    try:\n        return reversed(iterable)\n    except TypeError:\n        return reversed(list(iterable))\n\n\ndef consecutive_groups(iterable, ordering=lambda x: x):\n    \"\"\"Yield groups of consecutive items using :func:`itertools.groupby`.\n    The *ordering* function determines whether two items are adjacent by\n    returning their position.\n\n    By default, the ordering function is the identity function. This is\n    suitable for finding runs of numbers:\n\n        >>> iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]\n        >>> for group in consecutive_groups(iterable):\n        ...     print(list(group))\n        [1]\n        [10, 11, 12]\n        [20]\n        [30, 31, 32, 33]\n        [40]\n\n    For finding runs of adjacent letters, try using the :meth:`index` method\n    of a string of letters:\n\n        >>> from string import ascii_lowercase\n        >>> iterable = 'abcdfgilmnop'\n        >>> ordering = ascii_lowercase.index\n        >>> for group in consecutive_groups(iterable, ordering):\n        ...     print(list(group))\n        ['a', 'b', 'c', 'd']\n        ['f', 'g']\n        ['i']\n        ['l', 'm', 'n', 'o', 'p']\n\n    Each group of consecutive items is an iterator that shares it source with\n    *iterable*. When an an output group is advanced, the previous group is\n    no longer available unless its elements are copied (e.g., into a ``list``).\n\n        >>> iterable = [1, 2, 11, 12, 21, 22]\n        >>> saved_groups = []\n        >>> for group in consecutive_groups(iterable):\n        ...     saved_groups.append(list(group))  # Copy group elements\n        >>> saved_groups\n        [[1, 2], [11, 12], [21, 22]]\n\n    \"\"\"\n    for k, g in groupby(\n        enumerate(iterable), key=lambda x: x[0] - ordering(x[1])\n    ):\n        yield map(itemgetter(1), g)\n\n\ndef difference(iterable, func=sub, *, initial=None):\n    \"\"\"This function is the inverse of :func:`itertools.accumulate`. By default\n    it will compute the first difference of *iterable* using\n    :func:`operator.sub`:\n\n        >>> from itertools import accumulate\n        >>> iterable = accumulate([0, 1, 2, 3, 4])  # produces 0, 1, 3, 6, 10\n        >>> list(difference(iterable))\n        [0, 1, 2, 3, 4]\n\n    *func* defaults to :func:`operator.sub`, but other functions can be\n    specified. They will be applied as follows::\n\n        A, B, C, D, ... --> A, func(B, A), func(C, B), func(D, C), ...\n\n    For example, to do progressive division:\n\n        >>> iterable = [1, 2, 6, 24, 120]\n        >>> func = lambda x, y: x // y\n        >>> list(difference(iterable, func))\n        [1, 2, 3, 4, 5]\n\n    If the *initial* keyword is set, the first element will be skipped when\n    computing successive differences.\n\n        >>> it = [10, 11, 13, 16]  # from accumulate([1, 2, 3], initial=10)\n        >>> list(difference(it, initial=10))\n        [1, 2, 3]\n\n    \"\"\"\n    a, b = tee(iterable)\n    try:\n        first = [next(b)]\n    except StopIteration:\n        return iter([])\n\n    if initial is not None:\n        first = []\n\n    return chain(first, starmap(func, zip(b, a)))\n\n\nclass SequenceView(Sequence):\n    \"\"\"Return a read-only view of the sequence object *target*.\n\n    :class:`SequenceView` objects are analogous to Python's built-in\n    \"dictionary view\" types. They provide a dynamic view of a sequence's items,\n    meaning that when the sequence updates, so does the view.\n\n        >>> seq = ['0', '1', '2']\n        >>> view = SequenceView(seq)\n        >>> view\n        SequenceView(['0', '1', '2'])\n        >>> seq.append('3')\n        >>> view\n        SequenceView(['0', '1', '2', '3'])\n\n    Sequence views support indexing, slicing, and length queries. They act\n    like the underlying sequence, except they don't allow assignment:\n\n        >>> view[1]\n        '1'\n        >>> view[1:-1]\n        ['1', '2']\n        >>> len(view)\n        4\n\n    Sequence views are useful as an alternative to copying, as they don't\n    require (much) extra storage.\n\n    \"\"\"\n\n    def __init__(self, target):\n        if not isinstance(target, Sequence):\n            raise TypeError\n        self._target = target\n\n    def __getitem__(self, index):\n        return self._target[index]\n\n    def __len__(self):\n        return len(self._target)\n\n    def __repr__(self):\n        return '{}({})'.format(self.__class__.__name__, repr(self._target))\n\n\nclass seekable:\n    \"\"\"Wrap an iterator to allow for seeking backward and forward. This\n    progressively caches the items in the source iterable so they can be\n    re-visited.\n\n    Call :meth:`seek` with an index to seek to that position in the source\n    iterable.\n\n    To \"reset\" an iterator, seek to ``0``:\n\n        >>> from itertools import count\n        >>> it = seekable((str(n) for n in count()))\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> it.seek(0)\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> next(it)\n        '3'\n\n    You can also seek forward:\n\n        >>> it = seekable((str(n) for n in range(20)))\n        >>> it.seek(10)\n        >>> next(it)\n        '10'\n        >>> it.seek(20)  # Seeking past the end of the source isn't a problem\n        >>> list(it)\n        []\n        >>> it.seek(0)  # Resetting works even after hitting the end\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n\n    Call :meth:`peek` to look ahead one item without advancing the iterator:\n\n        >>> it = seekable('1234')\n        >>> it.peek()\n        '1'\n        >>> list(it)\n        ['1', '2', '3', '4']\n        >>> it.peek(default='empty')\n        'empty'\n\n    Before the iterator is at its end, calling :func:`bool` on it will return\n    ``True``. After it will return ``False``:\n\n        >>> it = seekable('5678')\n        >>> bool(it)\n        True\n        >>> list(it)\n        ['5', '6', '7', '8']\n        >>> bool(it)\n        False\n\n    You may view the contents of the cache with the :meth:`elements` method.\n    That returns a :class:`SequenceView`, a view that updates automatically:\n\n        >>> it = seekable((str(n) for n in range(10)))\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> elements = it.elements()\n        >>> elements\n        SequenceView(['0', '1', '2'])\n        >>> next(it)\n        '3'\n        >>> elements\n        SequenceView(['0', '1', '2', '3'])\n\n    By default, the cache grows as the source iterable progresses, so beware of\n    wrapping very large or infinite iterables. Supply *maxlen* to limit the\n    size of the cache (this of course limits how far back you can seek).\n\n        >>> from itertools import count\n        >>> it = seekable((str(n) for n in count()), maxlen=2)\n        >>> next(it), next(it), next(it), next(it)\n        ('0', '1', '2', '3')\n        >>> list(it.elements())\n        ['2', '3']\n        >>> it.seek(0)\n        >>> next(it), next(it), next(it), next(it)\n        ('2', '3', '4', '5')\n        >>> next(it)\n        '6'\n\n    \"\"\"\n\n    def __init__(self, iterable, maxlen=None):\n        self._source = iter(iterable)\n        if maxlen is None:\n            self._cache = []\n        else:\n            self._cache = deque([], maxlen)\n        self._index = None\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self._index is not None:\n            try:\n                item = self._cache[self._index]\n            except IndexError:\n                self._index = None\n            else:\n                self._index += 1\n                return item\n\n        item = next(self._source)\n        self._cache.append(item)\n        return item\n\n    def __bool__(self):\n        try:\n            self.peek()\n        except StopIteration:\n            return False\n        return True\n\n    def peek(self, default=_marker):\n        try:\n            peeked = next(self)\n        except StopIteration:\n            if default is _marker:\n                raise\n            return default\n        if self._index is None:\n            self._index = len(self._cache)\n        self._index -= 1\n        return peeked\n\n    def elements(self):\n        return SequenceView(self._cache)\n\n    def seek(self, index):\n        self._index = index\n        remainder = index - len(self._cache)\n        if remainder > 0:\n            consume(self, remainder)\n\n\nclass run_length:\n    \"\"\"\n    :func:`run_length.encode` compresses an iterable with run-length encoding.\n    It yields groups of repeated items with the count of how many times they\n    were repeated:\n\n        >>> uncompressed = 'abbcccdddd'\n        >>> list(run_length.encode(uncompressed))\n        [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n\n    :func:`run_length.decode` decompresses an iterable that was previously\n    compressed with run-length encoding. It yields the items of the\n    decompressed iterable:\n\n        >>> compressed = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> list(run_length.decode(compressed))\n        ['a', 'b', 'b', 'c', 'c', 'c', 'd', 'd', 'd', 'd']\n\n    \"\"\"\n\n    @staticmethod\n    def encode(iterable):\n        return ((k, ilen(g)) for k, g in groupby(iterable))\n\n    @staticmethod\n    def decode(iterable):\n        return chain.from_iterable(repeat(k, n) for k, n in iterable)\n\n\ndef exactly_n(iterable, n, predicate=bool):\n    \"\"\"Return ``True`` if exactly ``n`` items in the iterable are ``True``\n    according to the *predicate* function.\n\n        >>> exactly_n([True, True, False], 2)\n        True\n        >>> exactly_n([True, True, False], 1)\n        False\n        >>> exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x < 3)\n        True\n\n    The iterable will be advanced until ``n + 1`` truthy items are encountered,\n    so avoid calling it on infinite iterables.\n\n    \"\"\"\n    return len(take(n + 1, filter(predicate, iterable))) == n\n\n\ndef circular_shifts(iterable):\n    \"\"\"Return a list of circular shifts of *iterable*.\n\n    >>> circular_shifts(range(4))\n    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n    \"\"\"\n    lst = list(iterable)\n    return take(len(lst), windowed(cycle(lst), len(lst)))\n\n\ndef make_decorator(wrapping_func, result_index=0):\n    \"\"\"Return a decorator version of *wrapping_func*, which is a function that\n    modifies an iterable. *result_index* is the position in that function's\n    signature where the iterable goes.\n\n    This lets you use itertools on the \"production end,\" i.e. at function\n    definition. This can augment what the function returns without changing the\n    function's code.\n\n    For example, to produce a decorator version of :func:`chunked`:\n\n        >>> from more_itertools import chunked\n        >>> chunker = make_decorator(chunked, result_index=0)\n        >>> @chunker(3)\n        ... def iter_range(n):\n        ...     return iter(range(n))\n        ...\n        >>> list(iter_range(9))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n    To only allow truthy items to be returned:\n\n        >>> truth_serum = make_decorator(filter, result_index=1)\n        >>> @truth_serum(bool)\n        ... def boolean_test():\n        ...     return [0, 1, '', ' ', False, True]\n        ...\n        >>> list(boolean_test())\n        [1, ' ', True]\n\n    The :func:`peekable` and :func:`seekable` wrappers make for practical\n    decorators:\n\n        >>> from more_itertools import peekable\n        >>> peekable_function = make_decorator(peekable)\n        >>> @peekable_function()\n        ... def str_range(*args):\n        ...     return (str(x) for x in range(*args))\n        ...\n        >>> it = str_range(1, 20, 2)\n        >>> next(it), next(it), next(it)\n        ('1', '3', '5')\n        >>> it.peek()\n        '7'\n        >>> next(it)\n        '7'\n\n    \"\"\"\n    # See https://sites.google.com/site/bbayles/index/decorator_factory for\n    # notes on how this works.\n    def decorator(*wrapping_args, **wrapping_kwargs):\n        def outer_wrapper(f):\n            def inner_wrapper(*args, **kwargs):\n                result = f(*args, **kwargs)\n                wrapping_args_ = list(wrapping_args)\n                wrapping_args_.insert(result_index, result)\n                return wrapping_func(*wrapping_args_, **wrapping_kwargs)\n\n            return inner_wrapper\n\n        return outer_wrapper\n\n    return decorator\n\n\ndef map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):\n    \"\"\"Return a dictionary that maps the items in *iterable* to categories\n    defined by *keyfunc*, transforms them with *valuefunc*, and\n    then summarizes them by category with *reducefunc*.\n\n    *valuefunc* defaults to the identity function if it is unspecified.\n    If *reducefunc* is unspecified, no summarization takes place:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> result = map_reduce('abbccc', keyfunc)\n        >>> sorted(result.items())\n        [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    Specifying *valuefunc* transforms the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc)\n        >>> sorted(result.items())\n        [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    Specifying *reducefunc* summarizes the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> reducefunc = sum\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)\n        >>> sorted(result.items())\n        [('A', 1), ('B', 2), ('C', 3)]\n\n    You may want to filter the input iterable before applying the map/reduce\n    procedure:\n\n        >>> all_items = range(30)\n        >>> items = [x for x in all_items if 10 <= x <= 20]  # Filter\n        >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n        >>> categories = map_reduce(items, keyfunc=keyfunc)\n        >>> sorted(categories.items())\n        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n        >>> summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)\n        >>> sorted(summaries.items())\n        [(0, 90), (1, 75)]\n\n    Note that all items in the iterable are gathered into a list before the\n    summarization step, which may require significant storage.\n\n    The returned object is a :obj:`collections.defaultdict` with the\n    ``default_factory`` set to ``None``, such that it behaves like a normal\n    dictionary.\n\n    \"\"\"\n    valuefunc = (lambda x: x) if (valuefunc is None) else valuefunc\n\n    ret = defaultdict(list)\n    for item in iterable:\n        key = keyfunc(item)\n        value = valuefunc(item)\n        ret[key].append(value)\n\n    if reducefunc is not None:\n        for key, value_list in ret.items():\n            ret[key] = reducefunc(value_list)\n\n    ret.default_factory = None\n    return ret\n\n\ndef rlocate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``, starting from the right and moving left.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(rlocate([0, 1, 1, 0, 1, 0, 0]))  # Truthy at 1, 2, and 4\n        [4, 2, 1]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item:\n\n        >>> iterable = iter('abcb')\n        >>> pred = lambda x: x == 'b'\n        >>> list(rlocate(iterable, pred))\n        [3, 1]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(rlocate(iterable, pred=pred, window_size=3))\n        [9, 5, 1]\n\n    Beware, this function won't return anything for infinite iterables.\n    If *iterable* is reversible, ``rlocate`` will reverse it and search from\n    the right. Otherwise, it will search from the left and return the results\n    in reverse order.\n\n    See :func:`locate` to for other example applications.\n\n    \"\"\"\n    if window_size is None:\n        try:\n            len_iter = len(iterable)\n            return (len_iter - i - 1 for i in locate(reversed(iterable), pred))\n        except TypeError:\n            pass\n\n    return reversed(list(locate(iterable, pred, window_size)))\n\n\ndef replace(iterable, pred, substitutes, count=None, window_size=1):\n    \"\"\"Yield the items from *iterable*, replacing the items for which *pred*\n    returns ``True`` with the items from the iterable *substitutes*.\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = (2, 3)\n        >>> list(replace(iterable, pred, substitutes))\n        [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]\n\n    If *count* is given, the number of replacements will be limited:\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = [None]\n        >>> list(replace(iterable, pred, substitutes, count=2))\n        [1, 1, None, 1, 1, None, 1, 1, 0]\n\n    Use *window_size* to control the number of items passed as arguments to\n    *pred*. This allows for locating and replacing subsequences.\n\n        >>> iterable = [0, 1, 2, 5, 0, 1, 2, 5]\n        >>> window_size = 3\n        >>> pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred\n        >>> substitutes = [3, 4] # Splice in these items\n        >>> list(replace(iterable, pred, substitutes, window_size=window_size))\n        [3, 4, 5, 3, 4, 5]\n\n    \"\"\"\n    if window_size < 1:\n        raise ValueError('window_size must be at least 1')\n\n    # Save the substitutes iterable, since it's used more than once\n    substitutes = tuple(substitutes)\n\n    # Add padding such that the number of windows matches the length of the\n    # iterable\n    it = chain(iterable, [_marker] * (window_size - 1))\n    windows = windowed(it, window_size)\n\n    n = 0\n    for w in windows:\n        # If the current window matches our predicate (and we haven't hit\n        # our maximum number of replacements), splice in the substitutes\n        # and then consume the following windows that overlap with this one.\n        # For example, if the iterable is (0, 1, 2, 3, 4...)\n        # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...\n        # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)\n        if pred(*w):\n            if (count is None) or (n < count):\n                n += 1\n                yield from substitutes\n                consume(windows, window_size - 1)\n                continue\n\n        # If there was no match (or we've reached the replacement limit),\n        # yield the first item from the window.\n        if w and (w[0] is not _marker):\n            yield w[0]\n\n\ndef partitions(iterable):\n    \"\"\"Yield all possible order-preserving partitions of *iterable*.\n\n    >>> iterable = 'abc'\n    >>> for part in partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['a', 'b', 'c']\n\n    This is unrelated to :func:`partition`.\n\n    \"\"\"\n    sequence = list(iterable)\n    n = len(sequence)\n    for i in powerset(range(1, n)):\n        yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]\n\n\ndef set_partitions(iterable, k=None):\n    \"\"\"\n    Yield the set partitions of *iterable* into *k* parts. Set partitions are\n    not order-preserving.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable, 2):\n    ...     print([''.join(p) for p in part])\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n\n\n    If *k* is not given, every set partition is generated.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n    ['a', 'b', 'c']\n\n    \"\"\"\n    L = list(iterable)\n    n = len(L)\n    if k is not None:\n        if k < 1:\n            raise ValueError(\n                \"Can't partition in a negative or zero number of groups\"\n            )\n        elif k > n:\n            return\n\n    def set_partitions_helper(L, k):\n        n = len(L)\n        if k == 1:\n            yield [L]\n        elif n == k:\n            yield [[s] for s in L]\n        else:\n            e, *M = L\n            for p in set_partitions_helper(M, k - 1):\n                yield [[e], *p]\n            for p in set_partitions_helper(M, k):\n                for i in range(len(p)):\n                    yield p[:i] + [[e] + p[i]] + p[i + 1 :]\n\n    if k is None:\n        for k in range(1, n + 1):\n            yield from set_partitions_helper(L, k)\n    else:\n        yield from set_partitions_helper(L, k)\n\n\nclass time_limited:\n    \"\"\"\n    Yield items from *iterable* until *limit_seconds* have passed.\n    If the time limit expires before all items have been yielded, the\n    ``timed_out`` parameter will be set to ``True``.\n\n    >>> from time import sleep\n    >>> def generator():\n    ...     yield 1\n    ...     yield 2\n    ...     sleep(0.2)\n    ...     yield 3\n    >>> iterable = time_limited(0.1, generator())\n    >>> list(iterable)\n    [1, 2]\n    >>> iterable.timed_out\n    True\n\n    Note that the time is checked before each item is yielded, and iteration\n    stops if  the time elapsed is greater than *limit_seconds*. If your time\n    limit is 1 second, but it takes 2 seconds to generate the first item from\n    the iterable, the function will run for 2 seconds and not yield anything.\n\n    \"\"\"\n\n    def __init__(self, limit_seconds, iterable):\n        if limit_seconds < 0:\n            raise ValueError('limit_seconds must be positive')\n        self.limit_seconds = limit_seconds\n        self._iterable = iter(iterable)\n        self._start_time = monotonic()\n        self.timed_out = False\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        item = next(self._iterable)\n        if monotonic() - self._start_time > self.limit_seconds:\n            self.timed_out = True\n            raise StopIteration\n\n        return item\n\n\ndef only(iterable, default=None, too_long=None):\n    \"\"\"If *iterable* has only one item, return it.\n    If it has zero items, return *default*.\n    If it has more than one item, raise the exception given by *too_long*,\n    which is ``ValueError`` by default.\n\n    >>> only([], default='missing')\n    'missing'\n    >>> only([1])\n    1\n    >>> only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: Expected exactly one item in iterable, but got 1, 2,\n     and perhaps more.'\n    >>> only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    TypeError\n\n    Note that :func:`only` attempts to advance *iterable* twice to ensure there\n    is only one item.  See :func:`spy` or :func:`peekable` to check\n    iterable contents less destructively.\n    \"\"\"\n    it = iter(iterable)\n    first_value = next(it, default)\n\n    try:\n        second_value = next(it)\n    except StopIteration:\n        pass\n    else:\n        msg = (\n            'Expected exactly one item in iterable, but got {!r}, {!r}, '\n            'and perhaps more.'.format(first_value, second_value)\n        )\n        raise too_long or ValueError(msg)\n\n    return first_value\n\n\ndef ichunked(iterable, n):\n    \"\"\"Break *iterable* into sub-iterables with *n* elements each.\n    :func:`ichunked` is like :func:`chunked`, but it yields iterables\n    instead of lists.\n\n    If the sub-iterables are read in order, the elements of *iterable*\n    won't be stored in memory.\n    If they are read out of order, :func:`itertools.tee` is used to cache\n    elements as necessary.\n\n    >>> from itertools import count\n    >>> all_chunks = ichunked(count(), 4)\n    >>> c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)\n    >>> list(c_2)  # c_1's elements have been cached; c_3's haven't been\n    [4, 5, 6, 7]\n    >>> list(c_1)\n    [0, 1, 2, 3]\n    >>> list(c_3)\n    [8, 9, 10, 11]\n\n    \"\"\"\n    source = iter(iterable)\n\n    while True:\n        # Check to see whether we're at the end of the source iterable\n        item = next(source, _marker)\n        if item is _marker:\n            return\n\n        # Clone the source and yield an n-length slice\n        source, it = tee(chain([item], source))\n        yield islice(it, n)\n\n        # Advance the source iterable\n        consume(source, n)\n\n\ndef distinct_combinations(iterable, r):\n    \"\"\"Yield the distinct combinations of *r* items taken from *iterable*.\n\n        >>> list(distinct_combinations([0, 0, 1], 2))\n        [(0, 0), (0, 1)]\n\n    Equivalent to ``set(combinations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    \"\"\"\n    if r < 0:\n        raise ValueError('r must be non-negative')\n    elif r == 0:\n        yield ()\n        return\n    pool = tuple(iterable)\n    generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]\n    current_combo = [None] * r\n    level = 0\n    while generators:\n        try:\n            cur_idx, p = next(generators[-1])\n        except StopIteration:\n            generators.pop()\n            level -= 1\n            continue\n        current_combo[level] = p\n        if level + 1 == r:\n            yield tuple(current_combo)\n        else:\n            generators.append(\n                unique_everseen(\n                    enumerate(pool[cur_idx + 1 :], cur_idx + 1),\n                    key=itemgetter(1),\n                )\n            )\n            level += 1\n\n\ndef filter_except(validator, iterable, *exceptions):\n    \"\"\"Yield the items from *iterable* for which the *validator* function does\n    not raise one of the specified *exceptions*.\n\n    *validator* is called for each item in *iterable*.\n    It should be a function that accepts one argument and raises an exception\n    if that item is not valid.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(filter_except(int, iterable, ValueError, TypeError))\n    ['1', '2', '4']\n\n    If an exception other than one given by *exceptions* is raised by\n    *validator*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            validator(item)\n        except exceptions:\n            pass\n        else:\n            yield item\n\n\ndef map_except(function, iterable, *exceptions):\n    \"\"\"Transform each item from *iterable* with *function* and yield the\n    result, unless *function* raises one of the specified *exceptions*.\n\n    *function* is called to transform each item in *iterable*.\n    It should be a accept one argument.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(map_except(int, iterable, ValueError, TypeError))\n    [1, 2, 4]\n\n    If an exception other than one given by *exceptions* is raised by\n    *function*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            yield function(item)\n        except exceptions:\n            pass\n\n\ndef _sample_unweighted(iterable, k):\n    # Implementation of \"Algorithm L\" from the 1994 paper by Kim-Hung Li:\n    # \"Reservoir-Sampling Algorithms of Time Complexity O(n(1+log(N/n)))\".\n\n    # Fill up the reservoir (collection of samples) with the first `k` samples\n    reservoir = take(k, iterable)\n\n    # Generate random number that's the largest in a sample of k U(0,1) numbers\n    # Largest order statistic: https://en.wikipedia.org/wiki/Order_statistic\n    W = exp(log(random()) / k)\n\n    # The number of elements to skip before changing the reservoir is a random\n    # number with a geometric distribution. Sample it using random() and logs.\n    next_index = k + floor(log(random()) / log(1 - W))\n\n    for index, element in enumerate(iterable, k):\n\n        if index == next_index:\n            reservoir[randrange(k)] = element\n            # The new W is the largest in a sample of k U(0, `old_W`) numbers\n            W *= exp(log(random()) / k)\n            next_index += floor(log(random()) / log(1 - W)) + 1\n\n    return reservoir\n\n\ndef _sample_weighted(iterable, k, weights):\n    # Implementation of \"A-ExpJ\" from the 2006 paper by Efraimidis et al. :\n    # \"Weighted random sampling with a reservoir\".\n\n    # Log-transform for numerical stability for weights that are small/large\n    weight_keys = (log(random()) / weight for weight in weights)\n\n    # Fill up the reservoir (collection of samples) with the first `k`\n    # weight-keys and elements, then heapify the list.\n    reservoir = take(k, zip(weight_keys, iterable))\n    heapify(reservoir)\n\n    # The number of jumps before changing the reservoir is a random variable\n    # with an exponential distribution. Sample it using random() and logs.\n    smallest_weight_key, _ = reservoir[0]\n    weights_to_skip = log(random()) / smallest_weight_key\n\n    for weight, element in zip(weights, iterable):\n        if weight >= weights_to_skip:\n            # The notation here is consistent with the paper, but we store\n            # the weight-keys in log-space for better numerical stability.\n            smallest_weight_key, _ = reservoir[0]\n            t_w = exp(weight * smallest_weight_key)\n            r_2 = uniform(t_w, 1)  # generate U(t_w, 1)\n            weight_key = log(r_2) / weight\n            heapreplace(reservoir, (weight_key, element))\n            smallest_weight_key, _ = reservoir[0]\n            weights_to_skip = log(random()) / smallest_weight_key\n        else:\n            weights_to_skip -= weight\n\n    # Equivalent to [element for weight_key, element in sorted(reservoir)]\n    return [heappop(reservoir)[1] for _ in range(k)]\n\n\ndef sample(iterable, k, weights=None):\n    \"\"\"Return a *k*-length list of elements chosen (without replacement)\n    from the *iterable*. Like :func:`random.sample`, but works on iterables\n    of unknown length.\n\n    >>> iterable = range(100)\n    >>> sample(iterable, 5)  # doctest: +SKIP\n    [81, 60, 96, 16, 4]\n\n    An iterable with *weights* may also be given:\n\n    >>> iterable = range(100)\n    >>> weights = (i * i + 1 for i in range(100))\n    >>> sampled = sample(iterable, 5, weights=weights)  # doctest: +SKIP\n    [79, 67, 74, 66, 78]\n\n    The algorithm can also be used to generate weighted random permutations.\n    The relative weight of each item determines the probability that it\n    appears late in the permutation.\n\n    >>> data = \"abcdefgh\"\n    >>> weights = range(1, len(data) + 1)\n    >>> sample(data, k=len(data), weights=weights)  # doctest: +SKIP\n    ['c', 'a', 'b', 'e', 'g', 'd', 'h', 'f']\n    \"\"\"\n    if k == 0:\n        return []\n\n    iterable = iter(iterable)\n    if weights is None:\n        return _sample_unweighted(iterable, k)\n    else:\n        weights = iter(weights)\n        return _sample_weighted(iterable, k, weights)\n\n\ndef is_sorted(iterable, key=None, reverse=False):\n    \"\"\"Returns ``True`` if the items of iterable are in sorted order, and\n    ``False`` otherwise. *key* and *reverse* have the same meaning that they do\n    in the built-in :func:`sorted` function.\n\n    >>> is_sorted(['1', '2', '3', '4', '5'], key=int)\n    True\n    >>> is_sorted([5, 4, 3, 1, 2], reverse=True)\n    False\n\n    The function returns ``False`` after encountering the first out-of-order\n    item. If there are no out-of-order items, the iterable is exhausted.\n    \"\"\"\n\n    compare = lt if reverse else gt\n    it = iterable if (key is None) else map(key, iterable)\n    return not any(starmap(compare, pairwise(it)))\n\n\nclass AbortThread(BaseException):\n    pass\n\n\nclass callback_iter:\n    \"\"\"Convert a function that uses callbacks to an iterator.\n\n    Let *func* be a function that takes a `callback` keyword argument.\n    For example:\n\n    >>> def func(callback=None):\n    ...     for i, c in [(1, 'a'), (2, 'b'), (3, 'c')]:\n    ...         if callback:\n    ...             callback(i, c)\n    ...     return 4\n\n\n    Use ``with callback_iter(func)`` to get an iterator over the parameters\n    that are delivered to the callback.\n\n    >>> with callback_iter(func) as it:\n    ...     for args, kwargs in it:\n    ...         print(args)\n    (1, 'a')\n    (2, 'b')\n    (3, 'c')\n\n    The function will be called in a background thread. The ``done`` property\n    indicates whether it has completed execution.\n\n    >>> it.done\n    True\n\n    If it completes successfully, its return value will be available\n    in the ``result`` property.\n\n    >>> it.result\n    4\n\n    Notes:\n\n    * If the function uses some keyword argument besides ``callback``, supply\n      *callback_kwd*.\n    * If it finished executing, but raised an exception, accessing the\n      ``result`` property will raise the same exception.\n    * If it hasn't finished executing, accessing the ``result``\n      property from within the ``with`` block will raise ``RuntimeError``.\n    * If it hasn't finished executing, accessing the ``result`` property from\n      outside the ``with`` block will raise a\n      ``more_itertools.AbortThread`` exception.\n    * Provide *wait_seconds* to adjust how frequently the it is polled for\n      output.\n\n    \"\"\"\n\n    def __init__(self, func, callback_kwd='callback', wait_seconds=0.1):\n        self._func = func\n        self._callback_kwd = callback_kwd\n        self._aborted = False\n        self._future = None\n        self._wait_seconds = wait_seconds\n        self._executor = __import__(\"concurrent.futures\").futures.ThreadPoolExecutor(max_workers=1)\n        self._iterator = self._reader()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self._aborted = True\n        self._executor.shutdown()\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return next(self._iterator)\n\n    @property\n    def done(self):\n        if self._future is None:\n            return False\n        return self._future.done()\n\n    @property\n    def result(self):\n        if not self.done:\n            raise RuntimeError('Function has not yet completed')\n\n        return self._future.result()\n\n    def _reader(self):\n        q = Queue()\n\n        def callback(*args, **kwargs):\n            if self._aborted:\n                raise AbortThread('canceled by user')\n\n            q.put((args, kwargs))\n\n        self._future = self._executor.submit(\n            self._func, **{self._callback_kwd: callback}\n        )\n\n        while True:\n            try:\n                item = q.get(timeout=self._wait_seconds)\n            except Empty:\n                pass\n            else:\n                q.task_done()\n                yield item\n\n            if self._future.done():\n                break\n\n        remaining = []\n        while True:\n            try:\n                item = q.get_nowait()\n            except Empty:\n                break\n            else:\n                q.task_done()\n                remaining.append(item)\n        q.join()\n        yield from remaining\n\n\ndef windowed_complete(iterable, n):\n    \"\"\"\n    Yield ``(beginning, middle, end)`` tuples, where:\n\n    * Each ``middle`` has *n* items from *iterable*\n    * Each ``beginning`` has the items before the ones in ``middle``\n    * Each ``end`` has the items after the ones in ``middle``\n\n    >>> iterable = range(7)\n    >>> n = 3\n    >>> for beginning, middle, end in windowed_complete(iterable, n):\n    ...     print(beginning, middle, end)\n    () (0, 1, 2) (3, 4, 5, 6)\n    (0,) (1, 2, 3) (4, 5, 6)\n    (0, 1) (2, 3, 4) (5, 6)\n    (0, 1, 2) (3, 4, 5) (6,)\n    (0, 1, 2, 3) (4, 5, 6) ()\n\n    Note that *n* must be at least 0 and most equal to the length of\n    *iterable*.\n\n    This function will exhaust the iterable and may require significant\n    storage.\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be >= 0')\n\n    seq = tuple(iterable)\n    size = len(seq)\n\n    if n > size:\n        raise ValueError('n must be <= len(seq)')\n\n    for i in range(size - n + 1):\n        beginning = seq[:i]\n        middle = seq[i : i + n]\n        end = seq[i + n :]\n        yield beginning, middle, end\n\n\ndef all_unique(iterable, key=None):\n    \"\"\"\n    Returns ``True`` if all the elements of *iterable* are unique (no two\n    elements are equal).\n\n        >>> all_unique('ABCB')\n        False\n\n    If a *key* function is specified, it will be used to make comparisons.\n\n        >>> all_unique('ABCb')\n        True\n        >>> all_unique('ABCb', str.lower)\n        False\n\n    The function returns as soon as the first non-unique element is\n    encountered. Iterables with a mix of hashable and unhashable items can\n    be used, but the function will be slower for unhashable items.\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    for element in map(key, iterable) if key else iterable:\n        try:\n            if element in seenset:\n                return False\n            seenset_add(element)\n        except TypeError:\n            if element in seenlist:\n                return False\n            seenlist_add(element)\n    return True\n\n\ndef nth_product(index, *args):\n    \"\"\"Equivalent to ``list(product(*args))[index]``.\n\n    The products of *args* can be ordered lexicographically.\n    :func:`nth_product` computes the product at sort position *index* without\n    computing the previous products.\n\n        >>> nth_product(8, range(2), range(2), range(2), range(2))\n        (1, 0, 0, 0)\n\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pools = list(map(tuple, reversed(args)))\n    ns = list(map(len, pools))\n\n    c = reduce(mul, ns)\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = []\n    for pool, n in zip(pools, ns):\n        result.append(pool[index % n])\n        index //= n\n\n    return tuple(reversed(result))\n\n\ndef nth_permutation(iterable, r, index):\n    \"\"\"Equivalent to ``list(permutations(iterable, r))[index]```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`nth_permutation`\n    computes the subsequence at sort position *index* directly, without\n    computing the previous subsequences.\n\n        >>> nth_permutation('ghijk', 2, 5)\n        ('h', 'i')\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = list(iterable)\n    n = len(pool)\n\n    if r is None or r == n:\n        r, c = n, factorial(n)\n    elif not 0 <= r < n:\n        raise ValueError\n    else:\n        c = factorial(n) // factorial(n - r)\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    if c == 0:\n        return tuple()\n\n    result = [0] * r\n    q = index * factorial(n) // c if r < n else index\n    for d in range(1, n + 1):\n        q, i = divmod(q, d)\n        if 0 <= n - d < r:\n            result[n - d] = i\n        if q == 0:\n            break\n\n    return tuple(map(pool.pop, result))\n\n\ndef value_chain(*args):\n    \"\"\"Yield all arguments passed to the function in the same order in which\n    they were passed. If an argument itself is iterable then iterate over its\n    values.\n\n        >>> list(value_chain(1, 2, 3, [4, 5, 6]))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and are emitted\n    as-is:\n\n        >>> list(value_chain('12', '34', ['56', '78']))\n        ['12', '34', '56', '78']\n\n\n    Multiple levels of nesting are not flattened.\n\n    \"\"\"\n    for value in args:\n        if isinstance(value, (str, bytes)):\n            yield value\n            continue\n        try:\n            yield from value\n        except TypeError:\n            yield value\n\n\ndef product_index(element, *args):\n    \"\"\"Equivalent to ``list(product(*args)).index(element)``\n\n    The products of *args* can be ordered lexicographically.\n    :func:`product_index` computes the first index of *element* without\n    computing the previous products.\n\n        >>> product_index([8, 2], range(10), range(5))\n        42\n\n    ``ValueError`` will be raised if the given *element* isn't in the product\n    of *args*.\n    \"\"\"\n    index = 0\n\n    for x, pool in zip_longest(element, args, fillvalue=_marker):\n        if x is _marker or pool is _marker:\n            raise ValueError('element is not a product of args')\n\n        pool = tuple(pool)\n        index = index * len(pool) + pool.index(x)\n\n    return index\n\n\ndef combination_index(element, iterable):\n    \"\"\"Equivalent to ``list(combinations(iterable, r)).index(element)``\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`combination_index` computes the index of the\n    first *element*, without computing the previous combinations.\n\n        >>> combination_index('adf', 'abcdefg')\n        10\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations of *iterable*.\n    \"\"\"\n    element = enumerate(element)\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = enumerate(iterable)\n    for n, x in pool:\n        if x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n    else:\n        raise ValueError('element is not a combination of iterable')\n\n    n, _ = last(pool, default=(n, None))\n\n    # Python versiosn below 3.8 don't have math.comb\n    index = 1\n    for i, j in enumerate(reversed(indexes), start=1):\n        j = n - j\n        if i <= j:\n            index += factorial(j) // (factorial(i) * factorial(j - i))\n\n    return factorial(n + 1) // (factorial(k + 1) * factorial(n - k)) - index\n\n\ndef permutation_index(element, iterable):\n    \"\"\"Equivalent to ``list(permutations(iterable, r)).index(element)```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`permutation_index`\n    computes the index of the first *element* directly, without computing\n    the previous permutations.\n\n        >>> permutation_index([1, 3, 2], range(5))\n        19\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    permutations of *iterable*.\n    \"\"\"\n    index = 0\n    pool = list(iterable)\n    for i, x in zip(range(len(pool), -1, -1), element):\n        r = pool.index(x)\n        index = index * i + r\n        del pool[r]\n\n    return index\n\n\nclass countable:\n    \"\"\"Wrap *iterable* and keep a count of how many items have been consumed.\n\n    The ``items_seen`` attribute starts at ``0`` and increments as the iterable\n    is consumed:\n\n        >>> iterable = map(str, range(10))\n        >>> it = countable(iterable)\n        >>> it.items_seen\n        0\n        >>> next(it), next(it)\n        ('0', '1')\n        >>> list(it)\n        ['2', '3', '4', '5', '6', '7', '8', '9']\n        >>> it.items_seen\n        10\n    \"\"\"\n\n    def __init__(self, iterable):\n        self._it = iter(iterable)\n        self.items_seen = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        item = next(self._it)\n        self.items_seen += 1\n\n        return item\n", "setuptools/_vendor/more_itertools/recipes.py": "\"\"\"Imported from the recipes section of the itertools documentation.\n\nAll functions taken from the recipes section of the itertools library docs\n[1]_.\nSome backward-compatible usability improvements have been made.\n\n.. [1] http://docs.python.org/library/itertools.html#recipes\n\n\"\"\"\nimport warnings\nfrom collections import deque\nfrom itertools import (\n    chain,\n    combinations,\n    count,\n    cycle,\n    groupby,\n    islice,\n    repeat,\n    starmap,\n    tee,\n    zip_longest,\n)\nimport operator\nfrom random import randrange, sample, choice\n\n__all__ = [\n    'all_equal',\n    'consume',\n    'convolve',\n    'dotproduct',\n    'first_true',\n    'flatten',\n    'grouper',\n    'iter_except',\n    'ncycles',\n    'nth',\n    'nth_combination',\n    'padnone',\n    'pad_none',\n    'pairwise',\n    'partition',\n    'powerset',\n    'prepend',\n    'quantify',\n    'random_combination_with_replacement',\n    'random_combination',\n    'random_permutation',\n    'random_product',\n    'repeatfunc',\n    'roundrobin',\n    'tabulate',\n    'tail',\n    'take',\n    'unique_everseen',\n    'unique_justseen',\n]\n\n\ndef take(n, iterable):\n    \"\"\"Return first *n* items of the iterable as a list.\n\n        >>> take(3, range(10))\n        [0, 1, 2]\n\n    If there are fewer than *n* items in the iterable, all of them are\n    returned.\n\n        >>> take(10, range(3))\n        [0, 1, 2]\n\n    \"\"\"\n    return list(islice(iterable, n))\n\n\ndef tabulate(function, start=0):\n    \"\"\"Return an iterator over the results of ``func(start)``,\n    ``func(start + 1)``, ``func(start + 2)``...\n\n    *func* should be a function that accepts one integer argument.\n\n    If *start* is not specified it defaults to 0. It will be incremented each\n    time the iterator is advanced.\n\n        >>> square = lambda x: x ** 2\n        >>> iterator = tabulate(square, -3)\n        >>> take(4, iterator)\n        [9, 4, 1, 0]\n\n    \"\"\"\n    return map(function, count(start))\n\n\ndef tail(n, iterable):\n    \"\"\"Return an iterator over the last *n* items of *iterable*.\n\n    >>> t = tail(3, 'ABCDEFG')\n    >>> list(t)\n    ['E', 'F', 'G']\n\n    \"\"\"\n    return iter(deque(iterable, maxlen=n))\n\n\ndef consume(iterator, n=None):\n    \"\"\"Advance *iterable* by *n* steps. If *n* is ``None``, consume it\n    entirely.\n\n    Efficiently exhausts an iterator without returning values. Defaults to\n    consuming the whole iterator, but an optional second argument may be\n    provided to limit consumption.\n\n        >>> i = (x for x in range(10))\n        >>> next(i)\n        0\n        >>> consume(i, 3)\n        >>> next(i)\n        4\n        >>> consume(i)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    If the iterator has fewer items remaining than the provided limit, the\n    whole iterator will be consumed.\n\n        >>> i = (x for x in range(3))\n        >>> consume(i, 5)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    \"\"\"\n    # Use functions that consume iterators at C speed.\n    if n is None:\n        # feed the entire iterator into a zero-length deque\n        deque(iterator, maxlen=0)\n    else:\n        # advance to the empty slice starting at position n\n        next(islice(iterator, n, n), None)\n\n\ndef nth(iterable, n, default=None):\n    \"\"\"Returns the nth item or a default value.\n\n    >>> l = range(10)\n    >>> nth(l, 3)\n    3\n    >>> nth(l, 20, \"zebra\")\n    'zebra'\n\n    \"\"\"\n    return next(islice(iterable, n, None), default)\n\n\ndef all_equal(iterable):\n    \"\"\"\n    Returns ``True`` if all the elements are equal to each other.\n\n        >>> all_equal('aaaa')\n        True\n        >>> all_equal('aaab')\n        False\n\n    \"\"\"\n    g = groupby(iterable)\n    return next(g, True) and not next(g, False)\n\n\ndef quantify(iterable, pred=bool):\n    \"\"\"Return the how many times the predicate is true.\n\n    >>> quantify([True, False, True])\n    2\n\n    \"\"\"\n    return sum(map(pred, iterable))\n\n\ndef pad_none(iterable):\n    \"\"\"Returns the sequence of elements and then returns ``None`` indefinitely.\n\n        >>> take(5, pad_none(range(3)))\n        [0, 1, 2, None, None]\n\n    Useful for emulating the behavior of the built-in :func:`map` function.\n\n    See also :func:`padded`.\n\n    \"\"\"\n    return chain(iterable, repeat(None))\n\n\npadnone = pad_none\n\n\ndef ncycles(iterable, n):\n    \"\"\"Returns the sequence elements *n* times\n\n    >>> list(ncycles([\"a\", \"b\"], 3))\n    ['a', 'b', 'a', 'b', 'a', 'b']\n\n    \"\"\"\n    return chain.from_iterable(repeat(tuple(iterable), n))\n\n\ndef dotproduct(vec1, vec2):\n    \"\"\"Returns the dot product of the two iterables.\n\n    >>> dotproduct([10, 10], [20, 20])\n    400\n\n    \"\"\"\n    return sum(map(operator.mul, vec1, vec2))\n\n\ndef flatten(listOfLists):\n    \"\"\"Return an iterator flattening one level of nesting in a list of lists.\n\n        >>> list(flatten([[0, 1], [2, 3]]))\n        [0, 1, 2, 3]\n\n    See also :func:`collapse`, which can flatten multiple levels of nesting.\n\n    \"\"\"\n    return chain.from_iterable(listOfLists)\n\n\ndef repeatfunc(func, times=None, *args):\n    \"\"\"Call *func* with *args* repeatedly, returning an iterable over the\n    results.\n\n    If *times* is specified, the iterable will terminate after that many\n    repetitions:\n\n        >>> from operator import add\n        >>> times = 4\n        >>> args = 3, 5\n        >>> list(repeatfunc(add, times, *args))\n        [8, 8, 8, 8]\n\n    If *times* is ``None`` the iterable will not terminate:\n\n        >>> from random import randrange\n        >>> times = None\n        >>> args = 1, 11\n        >>> take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP\n        [2, 4, 8, 1, 8, 4]\n\n    \"\"\"\n    if times is None:\n        return starmap(func, repeat(args))\n    return starmap(func, repeat(args, times))\n\n\ndef _pairwise(iterable):\n    \"\"\"Returns an iterator of paired items, overlapping, from the original\n\n    >>> take(4, pairwise(count()))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n\n    On Python 3.10 and above, this is an alias for :func:`itertools.pairwise`.\n\n    \"\"\"\n    a, b = tee(iterable)\n    next(b, None)\n    yield from zip(a, b)\n\n\ntry:\n    from itertools import pairwise as itertools_pairwise\nexcept ImportError:\n    pairwise = _pairwise\nelse:\n\n    def pairwise(iterable):\n        yield from itertools_pairwise(iterable)\n\n    pairwise.__doc__ = _pairwise.__doc__\n\n\ndef grouper(iterable, n, fillvalue=None):\n    \"\"\"Collect data into fixed-length chunks or blocks.\n\n    >>> list(grouper('ABCDEFG', 3, 'x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')]\n\n    \"\"\"\n    if isinstance(iterable, int):\n        warnings.warn(\n            \"grouper expects iterable as first parameter\", DeprecationWarning\n        )\n        n, iterable = iterable, n\n    args = [iter(iterable)] * n\n    return zip_longest(fillvalue=fillvalue, *args)\n\n\ndef roundrobin(*iterables):\n    \"\"\"Yields an item from each iterable, alternating between them.\n\n        >>> list(roundrobin('ABC', 'D', 'EF'))\n        ['A', 'D', 'E', 'B', 'F', 'C']\n\n    This function produces the same output as :func:`interleave_longest`, but\n    may perform better for some inputs (in particular when the number of\n    iterables is small).\n\n    \"\"\"\n    # Recipe credited to George Sakkis\n    pending = len(iterables)\n    nexts = cycle(iter(it).__next__ for it in iterables)\n    while pending:\n        try:\n            for next in nexts:\n                yield next()\n        except StopIteration:\n            pending -= 1\n            nexts = cycle(islice(nexts, pending))\n\n\ndef partition(pred, iterable):\n    \"\"\"\n    Returns a 2-tuple of iterables derived from the input iterable.\n    The first yields the items that have ``pred(item) == False``.\n    The second yields the items that have ``pred(item) == True``.\n\n        >>> is_odd = lambda x: x % 2 != 0\n        >>> iterable = range(10)\n        >>> even_items, odd_items = partition(is_odd, iterable)\n        >>> list(even_items), list(odd_items)\n        ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9])\n\n    If *pred* is None, :func:`bool` is used.\n\n        >>> iterable = [0, 1, False, True, '', ' ']\n        >>> false_items, true_items = partition(None, iterable)\n        >>> list(false_items), list(true_items)\n        ([0, False, ''], [1, True, ' '])\n\n    \"\"\"\n    if pred is None:\n        pred = bool\n\n    evaluations = ((pred(x), x) for x in iterable)\n    t1, t2 = tee(evaluations)\n    return (\n        (x for (cond, x) in t1 if not cond),\n        (x for (cond, x) in t2 if cond),\n    )\n\n\ndef powerset(iterable):\n    \"\"\"Yields all possible subsets of the iterable.\n\n        >>> list(powerset([1, 2, 3]))\n        [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]\n\n    :func:`powerset` will operate on iterables that aren't :class:`set`\n    instances, so repeated elements in the input will produce repeated elements\n    in the output. Use :func:`unique_everseen` on the input to avoid generating\n    duplicates:\n\n        >>> seq = [1, 1, 0]\n        >>> list(powerset(seq))\n        [(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)]\n        >>> from more_itertools import unique_everseen\n        >>> list(powerset(unique_everseen(seq)))\n        [(), (1,), (0,), (1, 0)]\n\n    \"\"\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n\n\ndef unique_everseen(iterable, key=None):\n    \"\"\"\n    Yield unique elements, preserving order.\n\n        >>> list(unique_everseen('AAAABBBCCDAABBB'))\n        ['A', 'B', 'C', 'D']\n        >>> list(unique_everseen('ABBCcAD', str.lower))\n        ['A', 'B', 'C', 'D']\n\n    Sequences with a mix of hashable and unhashable items can be used.\n    The function will be slower (i.e., `O(n^2)`) for unhashable items.\n\n    Remember that ``list`` objects are unhashable - you can use the *key*\n    parameter to transform the list to a tuple (which is hashable) to\n    avoid a slowdown.\n\n        >>> iterable = ([1, 2], [2, 3], [1, 2])\n        >>> list(unique_everseen(iterable))  # Slow\n        [[1, 2], [2, 3]]\n        >>> list(unique_everseen(iterable, key=tuple))  # Faster\n        [[1, 2], [2, 3]]\n\n    Similary, you may want to convert unhashable ``set`` objects with\n    ``key=frozenset``. For ``dict`` objects,\n    ``key=lambda x: frozenset(x.items())`` can be used.\n\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seenset:\n                seenset_add(k)\n                yield element\n        except TypeError:\n            if k not in seenlist:\n                seenlist_add(k)\n                yield element\n\n\ndef unique_justseen(iterable, key=None):\n    \"\"\"Yields elements in order, ignoring serial duplicates\n\n    >>> list(unique_justseen('AAAABBBCCDAABBB'))\n    ['A', 'B', 'C', 'D', 'A', 'B']\n    >>> list(unique_justseen('ABBCcAD', str.lower))\n    ['A', 'B', 'C', 'A', 'D']\n\n    \"\"\"\n    return map(next, map(operator.itemgetter(1), groupby(iterable, key)))\n\n\ndef iter_except(func, exception, first=None):\n    \"\"\"Yields results from a function repeatedly until an exception is raised.\n\n    Converts a call-until-exception interface to an iterator interface.\n    Like ``iter(func, sentinel)``, but uses an exception instead of a sentinel\n    to end the loop.\n\n        >>> l = [0, 1, 2]\n        >>> list(iter_except(l.pop, IndexError))\n        [2, 1, 0]\n\n    \"\"\"\n    try:\n        if first is not None:\n            yield first()\n        while 1:\n            yield func()\n    except exception:\n        pass\n\n\ndef first_true(iterable, default=None, pred=None):\n    \"\"\"\n    Returns the first true value in the iterable.\n\n    If no true value is found, returns *default*\n\n    If *pred* is not None, returns the first item for which\n    ``pred(item) == True`` .\n\n        >>> first_true(range(10))\n        1\n        >>> first_true(range(10), pred=lambda x: x > 5)\n        6\n        >>> first_true(range(10), default='missing', pred=lambda x: x > 9)\n        'missing'\n\n    \"\"\"\n    return next(filter(pred, iterable), default)\n\n\ndef random_product(*args, repeat=1):\n    \"\"\"Draw an item at random from each of the input iterables.\n\n        >>> random_product('abc', range(4), 'XYZ')  # doctest:+SKIP\n        ('c', 3, 'Z')\n\n    If *repeat* is provided as a keyword argument, that many items will be\n    drawn from each iterable.\n\n        >>> random_product('abcd', range(4), repeat=2)  # doctest:+SKIP\n        ('a', 2, 'd', 3)\n\n    This equivalent to taking a random selection from\n    ``itertools.product(*args, **kwarg)``.\n\n    \"\"\"\n    pools = [tuple(pool) for pool in args] * repeat\n    return tuple(choice(pool) for pool in pools)\n\n\ndef random_permutation(iterable, r=None):\n    \"\"\"Return a random *r* length permutation of the elements in *iterable*.\n\n    If *r* is not specified or is ``None``, then *r* defaults to the length of\n    *iterable*.\n\n        >>> random_permutation(range(5))  # doctest:+SKIP\n        (3, 4, 0, 1, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.permutations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    r = len(pool) if r is None else r\n    return tuple(sample(pool, r))\n\n\ndef random_combination(iterable, r):\n    \"\"\"Return a random *r* length subsequence of the elements in *iterable*.\n\n        >>> random_combination(range(5), 3)  # doctest:+SKIP\n        (2, 3, 4)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(sample(range(n), r))\n    return tuple(pool[i] for i in indices)\n\n\ndef random_combination_with_replacement(iterable, r):\n    \"\"\"Return a random *r* length subsequence of elements in *iterable*,\n    allowing individual elements to be repeated.\n\n        >>> random_combination_with_replacement(range(3), 5) # doctest:+SKIP\n        (0, 0, 1, 2, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations_with_replacement(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(randrange(n) for i in range(r))\n    return tuple(pool[i] for i in indices)\n\n\ndef nth_combination(iterable, r, index):\n    \"\"\"Equivalent to ``list(combinations(iterable, r))[index]``.\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`nth_combination` computes the subsequence at\n    sort position *index* directly, without computing the previous\n    subsequences.\n\n        >>> nth_combination(range(5), 3, 5)\n        (0, 3, 4)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = 1\n    k = min(r, n - r)\n    for i in range(1, k + 1):\n        c = c * (n - k + i) // i\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    while r:\n        c, n, r = c * r // n, n - 1, r - 1\n        while index >= c:\n            index -= c\n            c, n = c * (n - r) // n, n - 1\n        result.append(pool[-1 - n])\n\n    return tuple(result)\n\n\ndef prepend(value, iterator):\n    \"\"\"Yield *value*, followed by the elements in *iterator*.\n\n        >>> value = '0'\n        >>> iterator = ['1', '2', '3']\n        >>> list(prepend(value, iterator))\n        ['0', '1', '2', '3']\n\n    To prepend multiple values, see :func:`itertools.chain`\n    or :func:`value_chain`.\n\n    \"\"\"\n    return chain([value], iterator)\n\n\ndef convolve(signal, kernel):\n    \"\"\"Convolve the iterable *signal* with the iterable *kernel*.\n\n        >>> signal = (1, 2, 3, 4, 5)\n        >>> kernel = [3, 2, 1]\n        >>> list(convolve(signal, kernel))\n        [3, 8, 14, 20, 26, 14, 5]\n\n    Note: the input arguments are not interchangeable, as the *kernel*\n    is immediately consumed and stored.\n\n    \"\"\"\n    kernel = tuple(kernel)[::-1]\n    n = len(kernel)\n    window = deque([0], maxlen=n) * n\n    for x in chain(signal, repeat(0, n - 1)):\n        window.append(x)\n        yield sum(map(operator.mul, kernel, window))\n", "setuptools/_vendor/more_itertools/__init__.py": "from .more import *  # noqa\nfrom .recipes import *  # noqa\n\n__version__ = '8.8.0'\n", "setuptools/command/register.py": "from distutils import log\nimport distutils.command.register as orig\n\nfrom setuptools.errors import RemovedCommandError\n\n\nclass register(orig.register):\n    \"\"\"Formerly used to register packages on PyPI.\"\"\"\n\n    def run(self):\n        msg = (\n            \"The register command has been removed, use twine to upload \"\n            + \"instead (https://pypi.org/p/twine)\"\n        )\n\n        self.announce(\"ERROR: \" + msg, log.ERROR)\n\n        raise RemovedCommandError(msg)\n", "setuptools/command/_requirestxt.py": "\"\"\"Helper code used to generate ``requires.txt`` files in the egg-info directory.\n\nThe ``requires.txt`` file has an specific format:\n    - Environment markers need to be part of the section headers and\n      should not be part of the requirement spec itself.\n\nSee https://setuptools.pypa.io/en/latest/deprecated/python_eggs.html#requires-txt\n\"\"\"\n\nfrom __future__ import annotations\n\nimport io\nfrom collections import defaultdict\nfrom itertools import filterfalse\nfrom typing import Dict, Mapping, TypeVar\n\nfrom .. import _reqs\nfrom ..extern.jaraco.text import yield_lines\nfrom ..extern.packaging.requirements import Requirement\n\n\n# dict can work as an ordered set\n_T = TypeVar(\"_T\")\n_Ordered = Dict[_T, None]\n_ordered = dict\n_StrOrIter = _reqs._StrOrIter\n\n\ndef _prepare(\n    install_requires: _StrOrIter, extras_require: Mapping[str, _StrOrIter]\n) -> tuple[list[str], dict[str, list[str]]]:\n    \"\"\"Given values for ``install_requires`` and ``extras_require``\n    create modified versions in a way that can be written in ``requires.txt``\n    \"\"\"\n    extras = _convert_extras_requirements(extras_require)\n    return _move_install_requirements_markers(install_requires, extras)\n\n\ndef _convert_extras_requirements(\n    extras_require: Mapping[str, _StrOrIter],\n) -> Mapping[str, _Ordered[Requirement]]:\n    \"\"\"\n    Convert requirements in `extras_require` of the form\n    `\"extra\": [\"barbazquux; {marker}\"]` to\n    `\"extra:{marker}\": [\"barbazquux\"]`.\n    \"\"\"\n    output: Mapping[str, _Ordered[Requirement]] = defaultdict(dict)\n    for section, v in extras_require.items():\n        # Do not strip empty sections.\n        output[section]\n        for r in _reqs.parse(v):\n            output[section + _suffix_for(r)].setdefault(r)\n\n    return output\n\n\ndef _move_install_requirements_markers(\n    install_requires: _StrOrIter, extras_require: Mapping[str, _Ordered[Requirement]]\n) -> tuple[list[str], dict[str, list[str]]]:\n    \"\"\"\n    The ``requires.txt`` file has an specific format:\n        - Environment markers need to be part of the section headers and\n          should not be part of the requirement spec itself.\n\n    Move requirements in ``install_requires`` that are using environment\n    markers ``extras_require``.\n    \"\"\"\n\n    # divide the install_requires into two sets, simple ones still\n    # handled by install_requires and more complex ones handled by extras_require.\n\n    inst_reqs = list(_reqs.parse(install_requires))\n    simple_reqs = filter(_no_marker, inst_reqs)\n    complex_reqs = filterfalse(_no_marker, inst_reqs)\n    simple_install_requires = list(map(str, simple_reqs))\n\n    for r in complex_reqs:\n        extras_require[':' + str(r.marker)].setdefault(r)\n\n    expanded_extras = dict(\n        # list(dict.fromkeys(...))  ensures a list of unique strings\n        (k, list(dict.fromkeys(str(r) for r in map(_clean_req, v))))\n        for k, v in extras_require.items()\n    )\n\n    return simple_install_requires, expanded_extras\n\n\ndef _suffix_for(req):\n    \"\"\"Return the 'extras_require' suffix for a given requirement.\"\"\"\n    return ':' + str(req.marker) if req.marker else ''\n\n\ndef _clean_req(req):\n    \"\"\"Given a Requirement, remove environment markers and return it\"\"\"\n    r = Requirement(str(req))  # create a copy before modifying\n    r.marker = None\n    return r\n\n\ndef _no_marker(req):\n    return not req.marker\n\n\ndef _write_requirements(stream, reqs):\n    lines = yield_lines(reqs or ())\n\n    def append_cr(line):\n        return line + '\\n'\n\n    lines = map(append_cr, lines)\n    stream.writelines(lines)\n\n\ndef write_requirements(cmd, basename, filename):\n    dist = cmd.distribution\n    data = io.StringIO()\n    install_requires, extras_require = _prepare(\n        dist.install_requires or (), dist.extras_require or {}\n    )\n    _write_requirements(data, install_requires)\n    for extra in sorted(extras_require):\n        data.write('\\n[{extra}]\\n'.format(**vars()))\n        _write_requirements(data, extras_require[extra])\n    cmd.write_or_delete_file(\"requirements\", filename, data.getvalue())\n\n\ndef write_setup_requirements(cmd, basename, filename):\n    data = io.StringIO()\n    _write_requirements(data, cmd.distribution.setup_requires)\n    cmd.write_or_delete_file(\"setup-requirements\", filename, data.getvalue())\n", "setuptools/command/install_egg_info.py": "from distutils import log, dir_util\nimport os\n\nfrom setuptools import Command\nfrom setuptools import namespaces\nfrom setuptools.archive_util import unpack_archive\nfrom .._path import ensure_directory\n\n\nclass install_egg_info(namespaces.Installer, Command):\n    \"\"\"Install an .egg-info directory for the package\"\"\"\n\n    description = \"Install an .egg-info directory for the package\"\n\n    user_options = [\n        ('install-dir=', 'd', \"directory to install to\"),\n    ]\n\n    def initialize_options(self):\n        self.install_dir = None\n\n    def finalize_options(self):\n        self.set_undefined_options('install_lib', ('install_dir', 'install_dir'))\n        ei_cmd = self.get_finalized_command(\"egg_info\")\n        basename = f\"{ei_cmd._get_egg_basename()}.egg-info\"\n        self.source = ei_cmd.egg_info\n        self.target = os.path.join(self.install_dir, basename)\n        self.outputs = []\n\n    def run(self):\n        self.run_command('egg_info')\n        if os.path.isdir(self.target) and not os.path.islink(self.target):\n            dir_util.remove_tree(self.target, dry_run=self.dry_run)\n        elif os.path.exists(self.target):\n            self.execute(os.unlink, (self.target,), \"Removing \" + self.target)\n        if not self.dry_run:\n            ensure_directory(self.target)\n        self.execute(self.copytree, (), \"Copying %s to %s\" % (self.source, self.target))\n        self.install_namespaces()\n\n    def get_outputs(self):\n        return self.outputs\n\n    def copytree(self):\n        # Copy the .egg-info tree to site-packages\n        def skimmer(src, dst):\n            # filter out source-control directories; note that 'src' is always\n            # a '/'-separated path, regardless of platform.  'dst' is a\n            # platform-specific path.\n            for skip in '.svn/', 'CVS/':\n                if src.startswith(skip) or '/' + skip in src:\n                    return None\n            self.outputs.append(dst)\n            log.debug(\"Copying %s to %s\", src, dst)\n            return dst\n\n        unpack_archive(self.source, self.target, skimmer)\n", "setuptools/command/saveopts.py": "from setuptools.command.setopt import edit_config, option_base\n\n\nclass saveopts(option_base):\n    \"\"\"Save command-line options to a file\"\"\"\n\n    description = \"save supplied options to setup.cfg or other config file\"\n\n    def run(self):\n        dist = self.distribution\n        settings = {}\n\n        for cmd in dist.command_options:\n            if cmd == 'saveopts':\n                continue  # don't save our own options!\n\n            for opt, (src, val) in dist.get_option_dict(cmd).items():\n                if src == \"command line\":\n                    settings.setdefault(cmd, {})[opt] = val\n\n        edit_config(self.filename, settings, self.dry_run)\n", "setuptools/command/bdist_wheel.py": "\"\"\"\nCreate a wheel (.whl) distribution.\n\nA wheel is a built archive format.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport re\nimport shutil\nimport stat\nimport struct\nimport sys\nimport sysconfig\nimport warnings\nfrom email.generator import BytesGenerator, Generator\nfrom email.policy import EmailPolicy\nfrom distutils import log\nfrom glob import iglob\nfrom shutil import rmtree\nfrom typing import TYPE_CHECKING, Callable, Iterable, Literal, Sequence, cast\nfrom zipfile import ZIP_DEFLATED, ZIP_STORED\n\nfrom .. import Command, __version__\nfrom ..extern.wheel.metadata import pkginfo_to_metadata\nfrom ..extern.packaging import tags\nfrom ..extern.packaging import version as _packaging_version\nfrom ..extern.wheel.wheelfile import WheelFile\n\nif TYPE_CHECKING:\n    import types\n\n\ndef safe_name(name: str) -> str:\n    \"\"\"Convert an arbitrary string to a standard distribution name\n    Any runs of non-alphanumeric/. characters are replaced with a single '-'.\n    \"\"\"\n    return re.sub(\"[^A-Za-z0-9.]+\", \"-\", name)\n\n\ndef safe_version(version: str) -> str:\n    \"\"\"\n    Convert an arbitrary string to a standard version string\n    \"\"\"\n    try:\n        # normalize the version\n        return str(_packaging_version.Version(version))\n    except _packaging_version.InvalidVersion:\n        version = version.replace(\" \", \".\")\n        return re.sub(\"[^A-Za-z0-9.]+\", \"-\", version)\n\n\nsetuptools_major_version = int(__version__.split(\".\")[0])\n\nPY_LIMITED_API_PATTERN = r\"cp3\\d\"\n\n\ndef _is_32bit_interpreter() -> bool:\n    return struct.calcsize(\"P\") == 4\n\n\ndef python_tag() -> str:\n    return f\"py{sys.version_info[0]}\"\n\n\ndef get_platform(archive_root: str | None) -> str:\n    \"\"\"Return our platform name 'win32', 'linux_x86_64'\"\"\"\n    result = sysconfig.get_platform()\n    if result.startswith(\"macosx\") and archive_root is not None:\n        from ..extern.wheel.macosx_libfile import calculate_macosx_platform_tag\n\n        result = calculate_macosx_platform_tag(archive_root, result)\n    elif _is_32bit_interpreter():\n        if result == \"linux-x86_64\":\n            # pip pull request #3497\n            result = \"linux-i686\"\n        elif result == \"linux-aarch64\":\n            # packaging pull request #234\n            # TODO armv8l, packaging pull request #690 => this did not land\n            # in pip/packaging yet\n            result = \"linux-armv7l\"\n\n    return result.replace(\"-\", \"_\")\n\n\ndef get_flag(\n    var: str, fallback: bool, expected: bool = True, warn: bool = True\n) -> bool:\n    \"\"\"Use a fallback value for determining SOABI flags if the needed config\n    var is unset or unavailable.\"\"\"\n    val = sysconfig.get_config_var(var)\n    if val is None:\n        if warn:\n            warnings.warn(\n                f\"Config variable '{var}' is unset, Python ABI tag may be incorrect\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n        return fallback\n    return val == expected\n\n\ndef get_abi_tag() -> str | None:\n    \"\"\"Return the ABI tag based on SOABI (if available) or emulate SOABI (PyPy2).\"\"\"\n    soabi: str = sysconfig.get_config_var(\"SOABI\")\n    impl = tags.interpreter_name()\n    if not soabi and impl in (\"cp\", \"pp\") and hasattr(sys, \"maxunicode\"):\n        d = \"\"\n        m = \"\"\n        u = \"\"\n        if get_flag(\"Py_DEBUG\", hasattr(sys, \"gettotalrefcount\"), warn=(impl == \"cp\")):\n            d = \"d\"\n\n        if get_flag(\n            \"WITH_PYMALLOC\",\n            impl == \"cp\",\n            warn=(impl == \"cp\" and sys.version_info < (3, 8)),\n        ) and sys.version_info < (3, 8):\n            m = \"m\"\n\n        abi = f\"{impl}{tags.interpreter_version()}{d}{m}{u}\"\n    elif soabi and impl == \"cp\" and soabi.startswith(\"cpython\"):\n        # non-Windows\n        abi = \"cp\" + soabi.split(\"-\")[1]\n    elif soabi and impl == \"cp\" and soabi.startswith(\"cp\"):\n        # Windows\n        abi = soabi.split(\"-\")[0]\n    elif soabi and impl == \"pp\":\n        # we want something like pypy36-pp73\n        abi = \"-\".join(soabi.split(\"-\")[:2])\n        abi = abi.replace(\".\", \"_\").replace(\"-\", \"_\")\n    elif soabi and impl == \"graalpy\":\n        abi = \"-\".join(soabi.split(\"-\")[:3])\n        abi = abi.replace(\".\", \"_\").replace(\"-\", \"_\")\n    elif soabi:\n        abi = soabi.replace(\".\", \"_\").replace(\"-\", \"_\")\n    else:\n        abi = None\n\n    return abi\n\n\ndef safer_name(name: str) -> str:\n    return safe_name(name).replace(\"-\", \"_\")\n\n\ndef safer_version(version: str) -> str:\n    return safe_version(version).replace(\"-\", \"_\")\n\n\ndef remove_readonly(\n    func: Callable[..., object],\n    path: str,\n    excinfo: tuple[type[Exception], Exception, types.TracebackType],\n) -> None:\n    remove_readonly_exc(func, path, excinfo[1])\n\n\ndef remove_readonly_exc(func: Callable[..., object], path: str, exc: Exception) -> None:\n    os.chmod(path, stat.S_IWRITE)\n    func(path)\n\n\nclass bdist_wheel(Command):\n    description = \"create a wheel distribution\"\n\n    supported_compressions = {\n        \"stored\": ZIP_STORED,\n        \"deflated\": ZIP_DEFLATED,\n    }\n\n    user_options = [\n        (\"bdist-dir=\", \"b\", \"temporary directory for creating the distribution\"),\n        (\n            \"plat-name=\",\n            \"p\",\n            \"platform name to embed in generated filenames \"\n            f\"(default: {get_platform(None)})\",\n        ),\n        (\n            \"keep-temp\",\n            \"k\",\n            \"keep the pseudo-installation tree around after \"\n            \"creating the distribution archive\",\n        ),\n        (\"dist-dir=\", \"d\", \"directory to put final built distributions in\"),\n        (\"skip-build\", None, \"skip rebuilding everything (for testing/debugging)\"),\n        (\n            \"relative\",\n            None,\n            \"build the archive using relative paths (default: false)\",\n        ),\n        (\n            \"owner=\",\n            \"u\",\n            \"Owner name used when creating a tar file [default: current user]\",\n        ),\n        (\n            \"group=\",\n            \"g\",\n            \"Group name used when creating a tar file [default: current group]\",\n        ),\n        (\"universal\", None, \"make a universal wheel (default: false)\"),\n        (\n            \"compression=\",\n            None,\n            \"zipfile compression (one of: {}) (default: 'deflated')\".format(\n                \", \".join(supported_compressions)\n            ),\n        ),\n        (\n            \"python-tag=\",\n            None,\n            f\"Python implementation compatibility tag (default: '{python_tag()}')\",\n        ),\n        (\n            \"build-number=\",\n            None,\n            \"Build number for this particular version. \"\n            \"As specified in PEP-0427, this must start with a digit. \"\n            \"[default: None]\",\n        ),\n        (\n            \"py-limited-api=\",\n            None,\n            \"Python tag (cp32|cp33|cpNN) for abi3 wheel tag (default: false)\",\n        ),\n    ]\n\n    boolean_options = [\"keep-temp\", \"skip-build\", \"relative\", \"universal\"]\n\n    def initialize_options(self) -> None:\n        self.bdist_dir: str | None = None\n        self.data_dir = None\n        self.plat_name: str | None = None\n        self.plat_tag = None\n        self.format = \"zip\"\n        self.keep_temp = False\n        self.dist_dir: str | None = None\n        self.egginfo_dir = None\n        self.root_is_pure: bool | None = None\n        self.skip_build = None\n        self.relative = False\n        self.owner = None\n        self.group = None\n        self.universal: bool = False\n        self.compression: str | int = \"deflated\"\n        self.python_tag: str = python_tag()\n        self.build_number: str | None = None\n        self.py_limited_api: str | Literal[False] = False\n        self.plat_name_supplied = False\n\n    def finalize_options(self):\n        if self.bdist_dir is None:\n            bdist_base = self.get_finalized_command(\"bdist\").bdist_base\n            self.bdist_dir = os.path.join(bdist_base, \"wheel\")\n\n        egg_info = self.distribution.get_command_obj(\"egg_info\")\n        egg_info.ensure_finalized()  # needed for correct `wheel_dist_name`\n\n        self.data_dir = self.wheel_dist_name + \".data\"\n        self.plat_name_supplied = self.plat_name is not None\n\n        try:\n            self.compression = self.supported_compressions[self.compression]\n        except KeyError:\n            raise ValueError(f\"Unsupported compression: {self.compression}\") from None\n\n        need_options = (\"dist_dir\", \"plat_name\", \"skip_build\")\n\n        self.set_undefined_options(\"bdist\", *zip(need_options, need_options))\n\n        self.root_is_pure = not (\n            self.distribution.has_ext_modules() or self.distribution.has_c_libraries()\n        )\n\n        if self.py_limited_api and not re.match(\n            PY_LIMITED_API_PATTERN, self.py_limited_api\n        ):\n            raise ValueError(f\"py-limited-api must match '{PY_LIMITED_API_PATTERN}'\")\n\n        # Support legacy [wheel] section for setting universal\n        wheel = self.distribution.get_option_dict(\"wheel\")\n        if \"universal\" in wheel:\n            # please don't define this in your global configs\n            log.warn(\"The [wheel] section is deprecated. Use [bdist_wheel] instead.\")\n            val = wheel[\"universal\"][1].strip()\n            if val.lower() in (\"1\", \"true\", \"yes\"):\n                self.universal = True\n\n        if self.build_number is not None and not self.build_number[:1].isdigit():\n            raise ValueError(\"Build tag (build-number) must start with a digit.\")\n\n    @property\n    def wheel_dist_name(self):\n        \"\"\"Return distribution full name with - replaced with _\"\"\"\n        components = (\n            safer_name(self.distribution.get_name()),\n            safer_version(self.distribution.get_version()),\n        )\n        if self.build_number:\n            components += (self.build_number,)\n        return \"-\".join(components)\n\n    def get_tag(self) -> tuple[str, str, str]:\n        # bdist sets self.plat_name if unset, we should only use it for purepy\n        # wheels if the user supplied it.\n        if self.plat_name_supplied:\n            plat_name = cast(str, self.plat_name)\n        elif self.root_is_pure:\n            plat_name = \"any\"\n        else:\n            # macosx contains system version in platform name so need special handle\n            if self.plat_name and not self.plat_name.startswith(\"macosx\"):\n                plat_name = self.plat_name\n            else:\n                # on macosx always limit the platform name to comply with any\n                # c-extension modules in bdist_dir, since the user can specify\n                # a higher MACOSX_DEPLOYMENT_TARGET via tools like CMake\n\n                # on other platforms, and on macosx if there are no c-extension\n                # modules, use the default platform name.\n                plat_name = get_platform(self.bdist_dir)\n\n            if _is_32bit_interpreter():\n                if plat_name in (\"linux-x86_64\", \"linux_x86_64\"):\n                    plat_name = \"linux_i686\"\n                if plat_name in (\"linux-aarch64\", \"linux_aarch64\"):\n                    # TODO armv8l, packaging pull request #690 => this did not land\n                    # in pip/packaging yet\n                    plat_name = \"linux_armv7l\"\n\n        plat_name = (\n            plat_name.lower().replace(\"-\", \"_\").replace(\".\", \"_\").replace(\" \", \"_\")\n        )\n\n        if self.root_is_pure:\n            if self.universal:\n                impl = \"py2.py3\"\n            else:\n                impl = self.python_tag\n            tag = (impl, \"none\", plat_name)\n        else:\n            impl_name = tags.interpreter_name()\n            impl_ver = tags.interpreter_version()\n            impl = impl_name + impl_ver\n            # We don't work on CPython 3.1, 3.0.\n            if self.py_limited_api and (impl_name + impl_ver).startswith(\"cp3\"):\n                impl = self.py_limited_api\n                abi_tag = \"abi3\"\n            else:\n                abi_tag = str(get_abi_tag()).lower()\n            tag = (impl, abi_tag, plat_name)\n            # issue gh-374: allow overriding plat_name\n            supported_tags = [\n                (t.interpreter, t.abi, plat_name) for t in tags.sys_tags()\n            ]\n            assert (\n                tag in supported_tags\n            ), f\"would build wheel with unsupported tag {tag}\"\n        return tag\n\n    def run(self):\n        build_scripts = self.reinitialize_command(\"build_scripts\")\n        build_scripts.executable = \"python\"\n        build_scripts.force = True\n\n        build_ext = self.reinitialize_command(\"build_ext\")\n        build_ext.inplace = False\n\n        if not self.skip_build:\n            self.run_command(\"build\")\n\n        install = self.reinitialize_command(\"install\", reinit_subcommands=True)\n        install.root = self.bdist_dir\n        install.compile = False\n        install.skip_build = self.skip_build\n        install.warn_dir = False\n\n        # A wheel without setuptools scripts is more cross-platform.\n        # Use the (undocumented) `no_ep` option to setuptools'\n        # install_scripts command to avoid creating entry point scripts.\n        install_scripts = self.reinitialize_command(\"install_scripts\")\n        install_scripts.no_ep = True\n\n        # Use a custom scheme for the archive, because we have to decide\n        # at installation time which scheme to use.\n        for key in (\"headers\", \"scripts\", \"data\", \"purelib\", \"platlib\"):\n            setattr(install, \"install_\" + key, os.path.join(self.data_dir, key))\n\n        basedir_observed = \"\"\n\n        if os.name == \"nt\":\n            # win32 barfs if any of these are ''; could be '.'?\n            # (distutils.command.install:change_roots bug)\n            basedir_observed = os.path.normpath(os.path.join(self.data_dir, \"..\"))\n            self.install_libbase = self.install_lib = basedir_observed\n\n        setattr(\n            install,\n            \"install_purelib\" if self.root_is_pure else \"install_platlib\",\n            basedir_observed,\n        )\n\n        log.info(f\"installing to {self.bdist_dir}\")\n\n        self.run_command(\"install\")\n\n        impl_tag, abi_tag, plat_tag = self.get_tag()\n        archive_basename = f\"{self.wheel_dist_name}-{impl_tag}-{abi_tag}-{plat_tag}\"\n        if not self.relative:\n            archive_root = self.bdist_dir\n        else:\n            archive_root = os.path.join(\n                self.bdist_dir, self._ensure_relative(install.install_base)\n            )\n\n        self.set_undefined_options(\"install_egg_info\", (\"target\", \"egginfo_dir\"))\n        distinfo_dirname = (\n            f\"{safer_name(self.distribution.get_name())}-\"\n            f\"{safer_version(self.distribution.get_version())}.dist-info\"\n        )\n        distinfo_dir = os.path.join(self.bdist_dir, distinfo_dirname)\n        self.egg2dist(self.egginfo_dir, distinfo_dir)\n\n        self.write_wheelfile(distinfo_dir)\n\n        # Make the archive\n        if not os.path.exists(self.dist_dir):\n            os.makedirs(self.dist_dir)\n\n        wheel_path = os.path.join(self.dist_dir, archive_basename + \".whl\")\n        with WheelFile(wheel_path, \"w\", self.compression) as wf:\n            wf.write_files(archive_root)\n\n        # Add to 'Distribution.dist_files' so that the \"upload\" command works\n        getattr(self.distribution, \"dist_files\", []).append((\n            \"bdist_wheel\",\n            \"{}.{}\".format(*sys.version_info[:2]),  # like 3.7\n            wheel_path,\n        ))\n\n        if not self.keep_temp:\n            log.info(f\"removing {self.bdist_dir}\")\n            if not self.dry_run:\n                if sys.version_info < (3, 12):\n                    rmtree(self.bdist_dir, onerror=remove_readonly)\n                else:\n                    rmtree(self.bdist_dir, onexc=remove_readonly_exc)\n\n    def write_wheelfile(\n        self, wheelfile_base: str, generator: str = f\"setuptools ({__version__})\"\n    ):\n        from email.message import Message\n\n        msg = Message()\n        msg[\"Wheel-Version\"] = \"1.0\"  # of the spec\n        msg[\"Generator\"] = generator\n        msg[\"Root-Is-Purelib\"] = str(self.root_is_pure).lower()\n        if self.build_number is not None:\n            msg[\"Build\"] = self.build_number\n\n        # Doesn't work for bdist_wininst\n        impl_tag, abi_tag, plat_tag = self.get_tag()\n        for impl in impl_tag.split(\".\"):\n            for abi in abi_tag.split(\".\"):\n                for plat in plat_tag.split(\".\"):\n                    msg[\"Tag\"] = \"-\".join((impl, abi, plat))\n\n        wheelfile_path = os.path.join(wheelfile_base, \"WHEEL\")\n        log.info(f\"creating {wheelfile_path}\")\n        with open(wheelfile_path, \"wb\") as f:\n            BytesGenerator(f, maxheaderlen=0).flatten(msg)\n\n    def _ensure_relative(self, path: str) -> str:\n        # copied from dir_util, deleted\n        drive, path = os.path.splitdrive(path)\n        if path[0:1] == os.sep:\n            path = drive + path[1:]\n        return path\n\n    @property\n    def license_paths(self) -> Iterable[str]:\n        if setuptools_major_version >= 57:\n            # Setuptools has resolved any patterns to actual file names\n            return self.distribution.metadata.license_files or ()\n\n        files: set[str] = set()\n        metadata = self.distribution.get_option_dict(\"metadata\")\n        if setuptools_major_version >= 42:\n            # Setuptools recognizes the license_files option but does not do globbing\n            patterns = cast(Sequence[str], self.distribution.metadata.license_files)\n        else:\n            # Prior to those, wheel is entirely responsible for handling license files\n            if \"license_files\" in metadata:\n                patterns = metadata[\"license_files\"][1].split()\n            else:\n                patterns = ()\n\n        if \"license_file\" in metadata:\n            warnings.warn(\n                'The \"license_file\" option is deprecated. Use \"license_files\" instead.',\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            files.add(metadata[\"license_file\"][1])\n\n        if not files and not patterns and not isinstance(patterns, list):\n            patterns = (\"LICEN[CS]E*\", \"COPYING*\", \"NOTICE*\", \"AUTHORS*\")\n\n        for pattern in patterns:\n            for path in iglob(pattern):\n                if path.endswith(\"~\"):\n                    log.debug(\n                        f'ignoring license file \"{path}\" as it looks like a backup'\n                    )\n                    continue\n\n                if path not in files and os.path.isfile(path):\n                    log.info(\n                        f'adding license file \"{path}\" (matched pattern \"{pattern}\")'\n                    )\n                    files.add(path)\n\n        return files\n\n    def egg2dist(self, egginfo_path: str, distinfo_path: str):\n        \"\"\"Convert an .egg-info directory into a .dist-info directory\"\"\"\n\n        def adios(p: str) -> None:\n            \"\"\"Appropriately delete directory, file or link.\"\"\"\n            if os.path.exists(p) and not os.path.islink(p) and os.path.isdir(p):\n                shutil.rmtree(p)\n            elif os.path.exists(p):\n                os.unlink(p)\n\n        adios(distinfo_path)\n\n        if not os.path.exists(egginfo_path):\n            # There is no egg-info. This is probably because the egg-info\n            # file/directory is not named matching the distribution name used\n            # to name the archive file. Check for this case and report\n            # accordingly.\n            import glob\n\n            pat = os.path.join(os.path.dirname(egginfo_path), \"*.egg-info\")\n            possible = glob.glob(pat)\n            err = f\"Egg metadata expected at {egginfo_path} but not found\"\n            if possible:\n                alt = os.path.basename(possible[0])\n                err += f\" ({alt} found - possible misnamed archive file?)\"\n\n            raise ValueError(err)\n\n        if os.path.isfile(egginfo_path):\n            # .egg-info is a single file\n            pkg_info = pkginfo_to_metadata(egginfo_path, egginfo_path)\n            os.mkdir(distinfo_path)\n        else:\n            # .egg-info is a directory\n            pkginfo_path = os.path.join(egginfo_path, \"PKG-INFO\")\n            pkg_info = pkginfo_to_metadata(egginfo_path, pkginfo_path)\n\n            # ignore common egg metadata that is useless to wheel\n            shutil.copytree(\n                egginfo_path,\n                distinfo_path,\n                ignore=lambda x, y: {\n                    \"PKG-INFO\",\n                    \"requires.txt\",\n                    \"SOURCES.txt\",\n                    \"not-zip-safe\",\n                },\n            )\n\n            # delete dependency_links if it is only whitespace\n            dependency_links_path = os.path.join(distinfo_path, \"dependency_links.txt\")\n            with open(dependency_links_path, encoding=\"utf-8\") as dependency_links_file:\n                dependency_links = dependency_links_file.read().strip()\n            if not dependency_links:\n                adios(dependency_links_path)\n\n        pkg_info_path = os.path.join(distinfo_path, \"METADATA\")\n        serialization_policy = EmailPolicy(\n            utf8=True,\n            mangle_from_=False,\n            max_line_length=0,\n        )\n        with open(pkg_info_path, \"w\", encoding=\"utf-8\") as out:\n            Generator(out, policy=serialization_policy).flatten(pkg_info)\n\n        for license_path in self.license_paths:\n            filename = os.path.basename(license_path)\n            shutil.copy(license_path, os.path.join(distinfo_path, filename))\n\n        adios(egginfo_path)\n", "setuptools/command/sdist.py": "from distutils import log\nimport distutils.command.sdist as orig\nimport os\nimport contextlib\nfrom itertools import chain\n\nfrom .._importlib import metadata\nfrom .build import _ORIGINAL_SUBCOMMANDS\n\n_default_revctrl = list\n\n\ndef walk_revctrl(dirname=''):\n    \"\"\"Find all files under revision control\"\"\"\n    for ep in metadata.entry_points(group='setuptools.file_finders'):\n        yield from ep.load()(dirname)\n\n\nclass sdist(orig.sdist):\n    \"\"\"Smart sdist that finds anything supported by revision control\"\"\"\n\n    user_options = [\n        ('formats=', None, \"formats for source distribution (comma-separated list)\"),\n        (\n            'keep-temp',\n            'k',\n            \"keep the distribution tree around after creating \" + \"archive file(s)\",\n        ),\n        (\n            'dist-dir=',\n            'd',\n            \"directory to put the source distribution archive(s) in \" \"[default: dist]\",\n        ),\n        (\n            'owner=',\n            'u',\n            \"Owner name used when creating a tar file [default: current user]\",\n        ),\n        (\n            'group=',\n            'g',\n            \"Group name used when creating a tar file [default: current group]\",\n        ),\n    ]\n\n    negative_opt = {}\n\n    README_EXTENSIONS = ['', '.rst', '.txt', '.md']\n    READMES = tuple('README{0}'.format(ext) for ext in README_EXTENSIONS)\n\n    def run(self):\n        self.run_command('egg_info')\n        ei_cmd = self.get_finalized_command('egg_info')\n        self.filelist = ei_cmd.filelist\n        self.filelist.append(os.path.join(ei_cmd.egg_info, 'SOURCES.txt'))\n        self.check_readme()\n\n        # Run sub commands\n        for cmd_name in self.get_sub_commands():\n            self.run_command(cmd_name)\n\n        self.make_distribution()\n\n        dist_files = getattr(self.distribution, 'dist_files', [])\n        for file in self.archive_files:\n            data = ('sdist', '', file)\n            if data not in dist_files:\n                dist_files.append(data)\n\n    def initialize_options(self):\n        orig.sdist.initialize_options(self)\n\n    def make_distribution(self):\n        \"\"\"\n        Workaround for #516\n        \"\"\"\n        with self._remove_os_link():\n            orig.sdist.make_distribution(self)\n\n    @staticmethod\n    @contextlib.contextmanager\n    def _remove_os_link():\n        \"\"\"\n        In a context, remove and restore os.link if it exists\n        \"\"\"\n\n        class NoValue:\n            pass\n\n        orig_val = getattr(os, 'link', NoValue)\n        try:\n            del os.link\n        except Exception:\n            pass\n        try:\n            yield\n        finally:\n            if orig_val is not NoValue:\n                os.link = orig_val\n\n    def add_defaults(self):\n        super().add_defaults()\n        self._add_defaults_build_sub_commands()\n\n    def _add_defaults_optional(self):\n        super()._add_defaults_optional()\n        if os.path.isfile('pyproject.toml'):\n            self.filelist.append('pyproject.toml')\n\n    def _add_defaults_python(self):\n        \"\"\"getting python files\"\"\"\n        if self.distribution.has_pure_modules():\n            build_py = self.get_finalized_command('build_py')\n            self.filelist.extend(build_py.get_source_files())\n            self._add_data_files(self._safe_data_files(build_py))\n\n    def _add_defaults_build_sub_commands(self):\n        build = self.get_finalized_command(\"build\")\n        missing_cmds = set(build.get_sub_commands()) - _ORIGINAL_SUBCOMMANDS\n        # ^-- the original built-in sub-commands are already handled by default.\n        cmds = (self.get_finalized_command(c) for c in missing_cmds)\n        files = (c.get_source_files() for c in cmds if hasattr(c, \"get_source_files\"))\n        self.filelist.extend(chain.from_iterable(files))\n\n    def _safe_data_files(self, build_py):\n        \"\"\"\n        Since the ``sdist`` class is also used to compute the MANIFEST\n        (via :obj:`setuptools.command.egg_info.manifest_maker`),\n        there might be recursion problems when trying to obtain the list of\n        data_files and ``include_package_data=True`` (which in turn depends on\n        the files included in the MANIFEST).\n\n        To avoid that, ``manifest_maker`` should be able to overwrite this\n        method and avoid recursive attempts to build/analyze the MANIFEST.\n        \"\"\"\n        return build_py.data_files\n\n    def _add_data_files(self, data_files):\n        \"\"\"\n        Add data files as found in build_py.data_files.\n        \"\"\"\n        self.filelist.extend(\n            os.path.join(src_dir, name)\n            for _, src_dir, _, filenames in data_files\n            for name in filenames\n        )\n\n    def _add_defaults_data_files(self):\n        try:\n            super()._add_defaults_data_files()\n        except TypeError:\n            log.warn(\"data_files contains unexpected objects\")\n\n    def check_readme(self):\n        for f in self.READMES:\n            if os.path.exists(f):\n                return\n        else:\n            self.warn(\n                \"standard file not found: should have one of \" + ', '.join(self.READMES)\n            )\n\n    def make_release_tree(self, base_dir, files):\n        orig.sdist.make_release_tree(self, base_dir, files)\n\n        # Save any egg_info command line options used to create this sdist\n        dest = os.path.join(base_dir, 'setup.cfg')\n        if hasattr(os, 'link') and os.path.exists(dest):\n            # unlink and re-copy, since it might be hard-linked, and\n            # we don't want to change the source version\n            os.unlink(dest)\n            self.copy_file('setup.cfg', dest)\n\n        self.get_finalized_command('egg_info').save_version_info(dest)\n\n    def _manifest_is_not_generated(self):\n        # check for special comment used in 2.7.1 and higher\n        if not os.path.isfile(self.manifest):\n            return False\n\n        with open(self.manifest, 'rb') as fp:\n            first_line = fp.readline()\n        return first_line != b'# file GENERATED by distutils, do NOT edit\\n'\n\n    def read_manifest(self):\n        \"\"\"Read the manifest file (named by 'self.manifest') and use it to\n        fill in 'self.filelist', the list of files to include in the source\n        distribution.\n        \"\"\"\n        log.info(\"reading manifest file '%s'\", self.manifest)\n        manifest = open(self.manifest, 'rb')\n        for line in manifest:\n            # The manifest must contain UTF-8. See #303.\n            try:\n                line = line.decode('UTF-8')\n            except UnicodeDecodeError:\n                log.warn(\"%r not UTF-8 decodable -- skipping\" % line)\n                continue\n            # ignore comments and blank lines\n            line = line.strip()\n            if line.startswith('#') or not line:\n                continue\n            self.filelist.append(line)\n        manifest.close()\n", "setuptools/command/install.py": "from distutils.errors import DistutilsArgError\nimport inspect\nimport glob\nimport platform\nimport distutils.command.install as orig\nfrom typing import cast\n\nimport setuptools\nfrom ..warnings import SetuptoolsDeprecationWarning, SetuptoolsWarning\nfrom .bdist_egg import bdist_egg as bdist_egg_cls\n\n# Prior to numpy 1.9, NumPy relies on the '_install' name, so provide it for\n# now. See https://github.com/pypa/setuptools/issues/199/\n_install = orig.install\n\n\nclass install(orig.install):\n    \"\"\"Use easy_install to install the package, w/dependencies\"\"\"\n\n    user_options = orig.install.user_options + [\n        ('old-and-unmanageable', None, \"Try not to use this!\"),\n        (\n            'single-version-externally-managed',\n            None,\n            \"used by system package builders to create 'flat' eggs\",\n        ),\n    ]\n    boolean_options = orig.install.boolean_options + [\n        'old-and-unmanageable',\n        'single-version-externally-managed',\n    ]\n    new_commands = [\n        ('install_egg_info', lambda self: True),\n        ('install_scripts', lambda self: True),\n    ]\n    _nc = dict(new_commands)\n\n    def initialize_options(self):\n        SetuptoolsDeprecationWarning.emit(\n            \"setup.py install is deprecated.\",\n            \"\"\"\n            Please avoid running ``setup.py`` directly.\n            Instead, use pypa/build, pypa/installer or other\n            standards-based tools.\n            \"\"\",\n            see_url=\"https://blog.ganssle.io/articles/2021/10/setup-py-deprecated.html\",\n            # TODO: Document how to bootstrap setuptools without install\n            #       (e.g. by unziping the wheel file)\n            #       and then add a due_date to this warning.\n        )\n\n        super().initialize_options()\n        self.old_and_unmanageable = None\n        self.single_version_externally_managed = None\n\n    def finalize_options(self):\n        super().finalize_options()\n        if self.root:\n            self.single_version_externally_managed = True\n        elif self.single_version_externally_managed:\n            if not self.root and not self.record:\n                raise DistutilsArgError(\n                    \"You must specify --record or --root when building system\"\n                    \" packages\"\n                )\n\n    def handle_extra_path(self):\n        if self.root or self.single_version_externally_managed:\n            # explicit backward-compatibility mode, allow extra_path to work\n            return orig.install.handle_extra_path(self)\n\n        # Ignore extra_path when installing an egg (or being run by another\n        # command without --root or --single-version-externally-managed\n        self.path_file = None\n        self.extra_dirs = ''\n        return None\n\n    def run(self):\n        # Explicit request for old-style install?  Just do it\n        if self.old_and_unmanageable or self.single_version_externally_managed:\n            return super().run()\n\n        if not self._called_from_setup(inspect.currentframe()):\n            # Run in backward-compatibility mode to support bdist_* commands.\n            super().run()\n        else:\n            self.do_egg_install()\n\n        return None\n\n    @staticmethod\n    def _called_from_setup(run_frame):\n        \"\"\"\n        Attempt to detect whether run() was called from setup() or by another\n        command.  If called by setup(), the parent caller will be the\n        'run_command' method in 'distutils.dist', and *its* caller will be\n        the 'run_commands' method.  If called any other way, the\n        immediate caller *might* be 'run_command', but it won't have been\n        called by 'run_commands'. Return True in that case or if a call stack\n        is unavailable. Return False otherwise.\n        \"\"\"\n        if run_frame is None:\n            msg = \"Call stack not available. bdist_* commands may fail.\"\n            SetuptoolsWarning.emit(msg)\n            if platform.python_implementation() == 'IronPython':\n                msg = \"For best results, pass -X:Frames to enable call stack.\"\n                SetuptoolsWarning.emit(msg)\n            return True\n\n        frames = inspect.getouterframes(run_frame)\n        for frame in frames[2:4]:\n            (caller,) = frame[:1]\n            info = inspect.getframeinfo(caller)\n            caller_module = caller.f_globals.get('__name__', '')\n\n            if caller_module == \"setuptools.dist\" and info.function == \"run_command\":\n                # Starting from v61.0.0 setuptools overwrites dist.run_command\n                continue\n\n            return caller_module == 'distutils.dist' and info.function == 'run_commands'\n\n        return False\n\n    def do_egg_install(self):\n        easy_install = self.distribution.get_command_class('easy_install')\n\n        cmd = easy_install(\n            self.distribution,\n            args=\"x\",\n            root=self.root,\n            record=self.record,\n        )\n        cmd.ensure_finalized()  # finalize before bdist_egg munges install cmd\n        cmd.always_copy_from = '.'  # make sure local-dir eggs get installed\n\n        # pick up setup-dir .egg files only: no .egg-info\n        cmd.package_index.scan(glob.glob('*.egg'))\n\n        self.run_command('bdist_egg')\n        bdist_egg = cast(bdist_egg_cls, self.distribution.get_command_obj('bdist_egg'))\n        args = [bdist_egg.egg_output]\n\n        if setuptools.bootstrap_install_from:\n            # Bootstrap self-installation of setuptools\n            args.insert(0, setuptools.bootstrap_install_from)\n\n        cmd.args = args\n        cmd.run(show_deprecation=False)\n        setuptools.bootstrap_install_from = None\n\n\n# XXX Python 3.1 doesn't see _nc if this is inside the class\ninstall.sub_commands = [\n    cmd for cmd in orig.install.sub_commands if cmd[0] not in install._nc\n] + install.new_commands\n", "setuptools/command/rotate.py": "from __future__ import annotations\n\nfrom distutils.util import convert_path\nfrom distutils import log\nfrom distutils.errors import DistutilsOptionError\nimport os\nimport shutil\n\nfrom setuptools import Command\n\n\nclass rotate(Command):\n    \"\"\"Delete older distributions\"\"\"\n\n    description = \"delete older distributions, keeping N newest files\"\n    user_options = [\n        ('match=', 'm', \"patterns to match (required)\"),\n        ('dist-dir=', 'd', \"directory where the distributions are\"),\n        ('keep=', 'k', \"number of matching distributions to keep\"),\n    ]\n\n    boolean_options: list[str] = []\n\n    def initialize_options(self):\n        self.match = None\n        self.dist_dir = None\n        self.keep = None\n\n    def finalize_options(self):\n        if self.match is None:\n            raise DistutilsOptionError(\n                \"Must specify one or more (comma-separated) match patterns \"\n                \"(e.g. '.zip' or '.egg')\"\n            )\n        if self.keep is None:\n            raise DistutilsOptionError(\"Must specify number of files to keep\")\n        try:\n            self.keep = int(self.keep)\n        except ValueError as e:\n            raise DistutilsOptionError(\"--keep must be an integer\") from e\n        if isinstance(self.match, str):\n            self.match = [convert_path(p.strip()) for p in self.match.split(',')]\n        self.set_undefined_options('bdist', ('dist_dir', 'dist_dir'))\n\n    def run(self):\n        self.run_command(\"egg_info\")\n        from glob import glob\n\n        for pattern in self.match:\n            pattern = self.distribution.get_name() + '*' + pattern\n            files = glob(os.path.join(self.dist_dir, pattern))\n            files = [(os.path.getmtime(f), f) for f in files]\n            files.sort()\n            files.reverse()\n\n            log.info(\"%d file(s) matching %s\", len(files), pattern)\n            files = files[self.keep :]\n            for t, f in files:\n                log.info(\"Deleting %s\", f)\n                if not self.dry_run:\n                    if os.path.isdir(f):\n                        shutil.rmtree(f)\n                    else:\n                        os.unlink(f)\n", "setuptools/command/build_clib.py": "import distutils.command.build_clib as orig\nfrom distutils.errors import DistutilsSetupError\nfrom distutils import log\n\ntry:\n    from distutils._modified import newer_pairwise_group\nexcept ImportError:\n    # fallback for SETUPTOOLS_USE_DISTUTILS=stdlib\n    from .._distutils._modified import newer_pairwise_group\n\n\nclass build_clib(orig.build_clib):\n    \"\"\"\n    Override the default build_clib behaviour to do the following:\n\n    1. Implement a rudimentary timestamp-based dependency system\n       so 'compile()' doesn't run every time.\n    2. Add more keys to the 'build_info' dictionary:\n        * obj_deps - specify dependencies for each object compiled.\n                     this should be a dictionary mapping a key\n                     with the source filename to a list of\n                     dependencies. Use an empty string for global\n                     dependencies.\n        * cflags   - specify a list of additional flags to pass to\n                     the compiler.\n    \"\"\"\n\n    def build_libraries(self, libraries):\n        for lib_name, build_info in libraries:\n            sources = build_info.get('sources')\n            if sources is None or not isinstance(sources, (list, tuple)):\n                raise DistutilsSetupError(\n                    \"in 'libraries' option (library '%s'), \"\n                    \"'sources' must be present and must be \"\n                    \"a list of source filenames\" % lib_name\n                )\n            sources = sorted(list(sources))\n\n            log.info(\"building '%s' library\", lib_name)\n\n            # Make sure everything is the correct type.\n            # obj_deps should be a dictionary of keys as sources\n            # and a list/tuple of files that are its dependencies.\n            obj_deps = build_info.get('obj_deps', dict())\n            if not isinstance(obj_deps, dict):\n                raise DistutilsSetupError(\n                    \"in 'libraries' option (library '%s'), \"\n                    \"'obj_deps' must be a dictionary of \"\n                    \"type 'source: list'\" % lib_name\n                )\n            dependencies = []\n\n            # Get the global dependencies that are specified by the '' key.\n            # These will go into every source's dependency list.\n            global_deps = obj_deps.get('', list())\n            if not isinstance(global_deps, (list, tuple)):\n                raise DistutilsSetupError(\n                    \"in 'libraries' option (library '%s'), \"\n                    \"'obj_deps' must be a dictionary of \"\n                    \"type 'source: list'\" % lib_name\n                )\n\n            # Build the list to be used by newer_pairwise_group\n            # each source will be auto-added to its dependencies.\n            for source in sources:\n                src_deps = [source]\n                src_deps.extend(global_deps)\n                extra_deps = obj_deps.get(source, list())\n                if not isinstance(extra_deps, (list, tuple)):\n                    raise DistutilsSetupError(\n                        \"in 'libraries' option (library '%s'), \"\n                        \"'obj_deps' must be a dictionary of \"\n                        \"type 'source: list'\" % lib_name\n                    )\n                src_deps.extend(extra_deps)\n                dependencies.append(src_deps)\n\n            expected_objects = self.compiler.object_filenames(\n                sources,\n                output_dir=self.build_temp,\n            )\n\n            if newer_pairwise_group(dependencies, expected_objects) != ([], []):\n                # First, compile the source code to object files in the library\n                # directory.  (This should probably change to putting object\n                # files in a temporary build directory.)\n                macros = build_info.get('macros')\n                include_dirs = build_info.get('include_dirs')\n                cflags = build_info.get('cflags')\n                self.compiler.compile(\n                    sources,\n                    output_dir=self.build_temp,\n                    macros=macros,\n                    include_dirs=include_dirs,\n                    extra_postargs=cflags,\n                    debug=self.debug,\n                )\n\n            # Now \"link\" the object files together into a static library.\n            # (On Unix at least, this isn't really linking -- it just\n            # builds an archive.  Whatever.)\n            self.compiler.create_static_lib(\n                expected_objects, lib_name, output_dir=self.build_clib, debug=self.debug\n            )\n", "setuptools/command/bdist_egg.py": "\"\"\"setuptools.command.bdist_egg\n\nBuild .egg distributions\"\"\"\n\nfrom distutils.dir_util import remove_tree, mkpath\nfrom distutils import log\nfrom types import CodeType\nimport sys\nimport os\nimport re\nimport textwrap\nimport marshal\n\nfrom setuptools.extension import Library\nfrom setuptools import Command\nfrom .._path import ensure_directory\n\nfrom sysconfig import get_path, get_python_version\n\n\ndef _get_purelib():\n    return get_path(\"purelib\")\n\n\ndef strip_module(filename):\n    if '.' in filename:\n        filename = os.path.splitext(filename)[0]\n    if filename.endswith('module'):\n        filename = filename[:-6]\n    return filename\n\n\ndef sorted_walk(dir):\n    \"\"\"Do os.walk in a reproducible way,\n    independent of indeterministic filesystem readdir order\n    \"\"\"\n    for base, dirs, files in os.walk(dir):\n        dirs.sort()\n        files.sort()\n        yield base, dirs, files\n\n\ndef write_stub(resource, pyfile):\n    _stub_template = textwrap.dedent(\n        \"\"\"\n        def __bootstrap__():\n            global __bootstrap__, __loader__, __file__\n            import sys, pkg_resources, importlib.util\n            __file__ = pkg_resources.resource_filename(__name__, %r)\n            __loader__ = None; del __bootstrap__, __loader__\n            spec = importlib.util.spec_from_file_location(__name__,__file__)\n            mod = importlib.util.module_from_spec(spec)\n            spec.loader.exec_module(mod)\n        __bootstrap__()\n        \"\"\"\n    ).lstrip()\n    with open(pyfile, 'w', encoding=\"utf-8\") as f:\n        f.write(_stub_template % resource)\n\n\nclass bdist_egg(Command):\n    description = \"create an \\\"egg\\\" distribution\"\n\n    user_options = [\n        ('bdist-dir=', 'b', \"temporary directory for creating the distribution\"),\n        (\n            'plat-name=',\n            'p',\n            \"platform name to embed in generated filenames \"\n            \"(by default uses `pkg_resources.get_build_platform()`)\",\n        ),\n        ('exclude-source-files', None, \"remove all .py files from the generated egg\"),\n        (\n            'keep-temp',\n            'k',\n            \"keep the pseudo-installation tree around after \"\n            + \"creating the distribution archive\",\n        ),\n        ('dist-dir=', 'd', \"directory to put final built distributions in\"),\n        ('skip-build', None, \"skip rebuilding everything (for testing/debugging)\"),\n    ]\n\n    boolean_options = ['keep-temp', 'skip-build', 'exclude-source-files']\n\n    def initialize_options(self):\n        self.bdist_dir = None\n        self.plat_name = None\n        self.keep_temp = False\n        self.dist_dir = None\n        self.skip_build = False\n        self.egg_output = None\n        self.exclude_source_files = None\n\n    def finalize_options(self):\n        ei_cmd = self.ei_cmd = self.get_finalized_command(\"egg_info\")\n        self.egg_info = ei_cmd.egg_info\n\n        if self.bdist_dir is None:\n            bdist_base = self.get_finalized_command('bdist').bdist_base\n            self.bdist_dir = os.path.join(bdist_base, 'egg')\n\n        if self.plat_name is None:\n            from pkg_resources import get_build_platform\n\n            self.plat_name = get_build_platform()\n\n        self.set_undefined_options('bdist', ('dist_dir', 'dist_dir'))\n\n        if self.egg_output is None:\n            # Compute filename of the output egg\n            basename = ei_cmd._get_egg_basename(\n                py_version=get_python_version(),\n                platform=self.distribution.has_ext_modules() and self.plat_name,\n            )\n\n            self.egg_output = os.path.join(self.dist_dir, basename + '.egg')\n\n    def do_install_data(self):\n        # Hack for packages that install data to install's --install-lib\n        self.get_finalized_command('install').install_lib = self.bdist_dir\n\n        site_packages = os.path.normcase(os.path.realpath(_get_purelib()))\n        old, self.distribution.data_files = self.distribution.data_files, []\n\n        for item in old:\n            if isinstance(item, tuple) and len(item) == 2:\n                if os.path.isabs(item[0]):\n                    realpath = os.path.realpath(item[0])\n                    normalized = os.path.normcase(realpath)\n                    if normalized == site_packages or normalized.startswith(\n                        site_packages + os.sep\n                    ):\n                        item = realpath[len(site_packages) + 1 :], item[1]\n                        # XXX else: raise ???\n            self.distribution.data_files.append(item)\n\n        try:\n            log.info(\"installing package data to %s\", self.bdist_dir)\n            self.call_command('install_data', force=False, root=None)\n        finally:\n            self.distribution.data_files = old\n\n    def get_outputs(self):\n        return [self.egg_output]\n\n    def call_command(self, cmdname, **kw):\n        \"\"\"Invoke reinitialized command `cmdname` with keyword args\"\"\"\n        for dirname in INSTALL_DIRECTORY_ATTRS:\n            kw.setdefault(dirname, self.bdist_dir)\n        kw.setdefault('skip_build', self.skip_build)\n        kw.setdefault('dry_run', self.dry_run)\n        cmd = self.reinitialize_command(cmdname, **kw)\n        self.run_command(cmdname)\n        return cmd\n\n    def run(self):  # noqa: C901  # is too complex (14)  # FIXME\n        # Generate metadata first\n        self.run_command(\"egg_info\")\n        # We run install_lib before install_data, because some data hacks\n        # pull their data path from the install_lib command.\n        log.info(\"installing library code to %s\", self.bdist_dir)\n        instcmd = self.get_finalized_command('install')\n        old_root = instcmd.root\n        instcmd.root = None\n        if self.distribution.has_c_libraries() and not self.skip_build:\n            self.run_command('build_clib')\n        cmd = self.call_command('install_lib', warn_dir=False)\n        instcmd.root = old_root\n\n        all_outputs, ext_outputs = self.get_ext_outputs()\n        self.stubs = []\n        to_compile = []\n        for p, ext_name in enumerate(ext_outputs):\n            filename, ext = os.path.splitext(ext_name)\n            pyfile = os.path.join(self.bdist_dir, strip_module(filename) + '.py')\n            self.stubs.append(pyfile)\n            log.info(\"creating stub loader for %s\", ext_name)\n            if not self.dry_run:\n                write_stub(os.path.basename(ext_name), pyfile)\n            to_compile.append(pyfile)\n            ext_outputs[p] = ext_name.replace(os.sep, '/')\n\n        if to_compile:\n            cmd.byte_compile(to_compile)\n        if self.distribution.data_files:\n            self.do_install_data()\n\n        # Make the EGG-INFO directory\n        archive_root = self.bdist_dir\n        egg_info = os.path.join(archive_root, 'EGG-INFO')\n        self.mkpath(egg_info)\n        if self.distribution.scripts:\n            script_dir = os.path.join(egg_info, 'scripts')\n            log.info(\"installing scripts to %s\", script_dir)\n            self.call_command('install_scripts', install_dir=script_dir, no_ep=True)\n\n        self.copy_metadata_to(egg_info)\n        native_libs = os.path.join(egg_info, \"native_libs.txt\")\n        if all_outputs:\n            log.info(\"writing %s\", native_libs)\n            if not self.dry_run:\n                ensure_directory(native_libs)\n                with open(native_libs, 'wt', encoding=\"utf-8\") as libs_file:\n                    libs_file.write('\\n'.join(all_outputs))\n                    libs_file.write('\\n')\n        elif os.path.isfile(native_libs):\n            log.info(\"removing %s\", native_libs)\n            if not self.dry_run:\n                os.unlink(native_libs)\n\n        write_safety_flag(os.path.join(archive_root, 'EGG-INFO'), self.zip_safe())\n\n        if os.path.exists(os.path.join(self.egg_info, 'depends.txt')):\n            log.warn(\n                \"WARNING: 'depends.txt' will not be used by setuptools 0.6!\\n\"\n                \"Use the install_requires/extras_require setup() args instead.\"\n            )\n\n        if self.exclude_source_files:\n            self.zap_pyfiles()\n\n        # Make the archive\n        make_zipfile(\n            self.egg_output,\n            archive_root,\n            verbose=self.verbose,\n            dry_run=self.dry_run,\n            mode=self.gen_header(),\n        )\n        if not self.keep_temp:\n            remove_tree(self.bdist_dir, dry_run=self.dry_run)\n\n        # Add to 'Distribution.dist_files' so that the \"upload\" command works\n        getattr(self.distribution, 'dist_files', []).append((\n            'bdist_egg',\n            get_python_version(),\n            self.egg_output,\n        ))\n\n    def zap_pyfiles(self):\n        log.info(\"Removing .py files from temporary directory\")\n        for base, dirs, files in walk_egg(self.bdist_dir):\n            for name in files:\n                path = os.path.join(base, name)\n\n                if name.endswith('.py'):\n                    log.debug(\"Deleting %s\", path)\n                    os.unlink(path)\n\n                if base.endswith('__pycache__'):\n                    path_old = path\n\n                    pattern = r'(?P<name>.+)\\.(?P<magic>[^.]+)\\.pyc'\n                    m = re.match(pattern, name)\n                    path_new = os.path.join(base, os.pardir, m.group('name') + '.pyc')\n                    log.info(\"Renaming file from [%s] to [%s]\" % (path_old, path_new))\n                    try:\n                        os.remove(path_new)\n                    except OSError:\n                        pass\n                    os.rename(path_old, path_new)\n\n    def zip_safe(self):\n        safe = getattr(self.distribution, 'zip_safe', None)\n        if safe is not None:\n            return safe\n        log.warn(\"zip_safe flag not set; analyzing archive contents...\")\n        return analyze_egg(self.bdist_dir, self.stubs)\n\n    def gen_header(self):\n        return 'w'\n\n    def copy_metadata_to(self, target_dir):\n        \"Copy metadata (egg info) to the target_dir\"\n        # normalize the path (so that a forward-slash in egg_info will\n        # match using startswith below)\n        norm_egg_info = os.path.normpath(self.egg_info)\n        prefix = os.path.join(norm_egg_info, '')\n        for path in self.ei_cmd.filelist.files:\n            if path.startswith(prefix):\n                target = os.path.join(target_dir, path[len(prefix) :])\n                ensure_directory(target)\n                self.copy_file(path, target)\n\n    def get_ext_outputs(self):\n        \"\"\"Get a list of relative paths to C extensions in the output distro\"\"\"\n\n        all_outputs = []\n        ext_outputs = []\n\n        paths = {self.bdist_dir: ''}\n        for base, dirs, files in sorted_walk(self.bdist_dir):\n            for filename in files:\n                if os.path.splitext(filename)[1].lower() in NATIVE_EXTENSIONS:\n                    all_outputs.append(paths[base] + filename)\n            for filename in dirs:\n                paths[os.path.join(base, filename)] = paths[base] + filename + '/'\n\n        if self.distribution.has_ext_modules():\n            build_cmd = self.get_finalized_command('build_ext')\n            for ext in build_cmd.extensions:\n                if isinstance(ext, Library):\n                    continue\n                fullname = build_cmd.get_ext_fullname(ext.name)\n                filename = build_cmd.get_ext_filename(fullname)\n                if not os.path.basename(filename).startswith('dl-'):\n                    if os.path.exists(os.path.join(self.bdist_dir, filename)):\n                        ext_outputs.append(filename)\n\n        return all_outputs, ext_outputs\n\n\nNATIVE_EXTENSIONS = dict.fromkeys('.dll .so .dylib .pyd'.split())\n\n\ndef walk_egg(egg_dir):\n    \"\"\"Walk an unpacked egg's contents, skipping the metadata directory\"\"\"\n    walker = sorted_walk(egg_dir)\n    base, dirs, files = next(walker)\n    if 'EGG-INFO' in dirs:\n        dirs.remove('EGG-INFO')\n    yield base, dirs, files\n    yield from walker\n\n\ndef analyze_egg(egg_dir, stubs):\n    # check for existing flag in EGG-INFO\n    for flag, fn in safety_flags.items():\n        if os.path.exists(os.path.join(egg_dir, 'EGG-INFO', fn)):\n            return flag\n    if not can_scan():\n        return False\n    safe = True\n    for base, dirs, files in walk_egg(egg_dir):\n        for name in files:\n            if name.endswith('.py') or name.endswith('.pyw'):\n                continue\n            elif name.endswith('.pyc') or name.endswith('.pyo'):\n                # always scan, even if we already know we're not safe\n                safe = scan_module(egg_dir, base, name, stubs) and safe\n    return safe\n\n\ndef write_safety_flag(egg_dir, safe):\n    # Write or remove zip safety flag file(s)\n    for flag, fn in safety_flags.items():\n        fn = os.path.join(egg_dir, fn)\n        if os.path.exists(fn):\n            if safe is None or bool(safe) != flag:\n                os.unlink(fn)\n        elif safe is not None and bool(safe) == flag:\n            with open(fn, 'wt', encoding=\"utf-8\") as f:\n                f.write('\\n')\n\n\nsafety_flags = {\n    True: 'zip-safe',\n    False: 'not-zip-safe',\n}\n\n\ndef scan_module(egg_dir, base, name, stubs):\n    \"\"\"Check whether module possibly uses unsafe-for-zipfile stuff\"\"\"\n\n    filename = os.path.join(base, name)\n    if filename[:-1] in stubs:\n        return True  # Extension module\n    pkg = base[len(egg_dir) + 1 :].replace(os.sep, '.')\n    module = pkg + (pkg and '.' or '') + os.path.splitext(name)[0]\n    skip = 16  # skip magic & reserved? & date & file size\n    f = open(filename, 'rb')\n    f.read(skip)\n    code = marshal.load(f)\n    f.close()\n    safe = True\n    symbols = dict.fromkeys(iter_symbols(code))\n    for bad in ['__file__', '__path__']:\n        if bad in symbols:\n            log.warn(\"%s: module references %s\", module, bad)\n            safe = False\n    if 'inspect' in symbols:\n        for bad in [\n            'getsource',\n            'getabsfile',\n            'getfile',\n            'getsourcefile',\n            'getsourcelines',\n            'findsource',\n            'getcomments',\n            'getframeinfo',\n            'getinnerframes',\n            'getouterframes',\n            'stack',\n            'trace',\n        ]:\n            if bad in symbols:\n                log.warn(\"%s: module MAY be using inspect.%s\", module, bad)\n                safe = False\n    return safe\n\n\ndef iter_symbols(code):\n    \"\"\"Yield names and strings used by `code` and its nested code objects\"\"\"\n    yield from code.co_names\n    for const in code.co_consts:\n        if isinstance(const, str):\n            yield const\n        elif isinstance(const, CodeType):\n            yield from iter_symbols(const)\n\n\ndef can_scan():\n    if not sys.platform.startswith('java') and sys.platform != 'cli':\n        # CPython, PyPy, etc.\n        return True\n    log.warn(\"Unable to analyze compiled code on this platform.\")\n    log.warn(\n        \"Please ask the author to include a 'zip_safe'\"\n        \" setting (either True or False) in the package's setup.py\"\n    )\n    return False\n\n\n# Attribute names of options for commands that might need to be convinced to\n# install to the egg build directory\n\nINSTALL_DIRECTORY_ATTRS = ['install_lib', 'install_dir', 'install_data', 'install_base']\n\n\ndef make_zipfile(\n    zip_filename, base_dir, verbose=False, dry_run=False, compress=True, mode='w'\n):\n    \"\"\"Create a zip file from all the files under 'base_dir'.  The output\n    zip file will be named 'base_dir' + \".zip\".  Uses either the \"zipfile\"\n    Python module (if available) or the InfoZIP \"zip\" utility (if installed\n    and found on the default search path).  If neither tool is available,\n    raises DistutilsExecError.  Returns the name of the output zip file.\n    \"\"\"\n    import zipfile\n\n    mkpath(os.path.dirname(zip_filename), dry_run=dry_run)\n    log.info(\"creating '%s' and adding '%s' to it\", zip_filename, base_dir)\n\n    def visit(z, dirname, names):\n        for name in names:\n            path = os.path.normpath(os.path.join(dirname, name))\n            if os.path.isfile(path):\n                p = path[len(base_dir) + 1 :]\n                if not dry_run:\n                    z.write(path, p)\n                log.debug(\"adding '%s'\", p)\n\n    compression = zipfile.ZIP_DEFLATED if compress else zipfile.ZIP_STORED\n    if not dry_run:\n        z = zipfile.ZipFile(zip_filename, mode, compression=compression)\n        for dirname, dirs, files in sorted_walk(base_dir):\n            visit(z, dirname, files)\n        z.close()\n    else:\n        for dirname, dirs, files in sorted_walk(base_dir):\n            visit(None, dirname, files)\n    return zip_filename\n", "setuptools/command/install_scripts.py": "from __future__ import annotations\n\nfrom distutils import log\nimport distutils.command.install_scripts as orig\nimport os\nimport sys\n\nfrom .._path import ensure_directory\n\n\nclass install_scripts(orig.install_scripts):\n    \"\"\"Do normal script install, plus any egg_info wrapper scripts\"\"\"\n\n    def initialize_options(self):\n        orig.install_scripts.initialize_options(self)\n        self.no_ep = False\n\n    def run(self) -> None:\n        self.run_command(\"egg_info\")\n        if self.distribution.scripts:\n            orig.install_scripts.run(self)  # run first to set up self.outfiles\n        else:\n            self.outfiles: list[str] = []\n        if self.no_ep:\n            # don't install entry point scripts into .egg file!\n            return\n        self._install_ep_scripts()\n\n    def _install_ep_scripts(self):\n        # Delay import side-effects\n        from pkg_resources import Distribution, PathMetadata\n        from . import easy_install as ei\n\n        ei_cmd = self.get_finalized_command(\"egg_info\")\n        dist = Distribution(\n            ei_cmd.egg_base,\n            PathMetadata(ei_cmd.egg_base, ei_cmd.egg_info),\n            ei_cmd.egg_name,\n            ei_cmd.egg_version,\n        )\n        bs_cmd = self.get_finalized_command('build_scripts')\n        exec_param = getattr(bs_cmd, 'executable', None)\n        writer = ei.ScriptWriter\n        if exec_param == sys.executable:\n            # In case the path to the Python executable contains a space, wrap\n            # it so it's not split up.\n            exec_param = [exec_param]\n        # resolve the writer to the environment\n        writer = writer.best()\n        cmd = writer.command_spec_class.best().from_param(exec_param)\n        for args in writer.get_args(dist, cmd.as_header()):\n            self.write_script(*args)\n\n    def write_script(self, script_name, contents, mode=\"t\", *ignored):\n        \"\"\"Write an executable file to the scripts directory\"\"\"\n        from setuptools.command.easy_install import chmod, current_umask\n\n        log.info(\"Installing %s script to %s\", script_name, self.install_dir)\n        target = os.path.join(self.install_dir, script_name)\n        self.outfiles.append(target)\n\n        encoding = None if \"b\" in mode else \"utf-8\"\n        mask = current_umask()\n        if not self.dry_run:\n            ensure_directory(target)\n            with open(target, \"w\" + mode, encoding=encoding) as f:\n                f.write(contents)\n            chmod(target, 0o777 - mask)\n", "setuptools/command/develop.py": "from distutils.util import convert_path\nfrom distutils import log\nfrom distutils.errors import DistutilsOptionError\nimport os\nimport glob\n\nfrom setuptools.command.easy_install import easy_install\nfrom setuptools import _normalization\nfrom setuptools import _path\nfrom setuptools import namespaces\nimport setuptools\n\nfrom ..unicode_utils import _read_utf8_with_fallback\n\n\nclass develop(namespaces.DevelopInstaller, easy_install):\n    \"\"\"Set up package for development\"\"\"\n\n    description = \"install package in 'development mode'\"\n\n    user_options = easy_install.user_options + [\n        (\"uninstall\", \"u\", \"Uninstall this source package\"),\n        (\"egg-path=\", None, \"Set the path to be used in the .egg-link file\"),\n    ]\n\n    boolean_options = easy_install.boolean_options + ['uninstall']\n\n    command_consumes_arguments = False  # override base\n\n    def run(self):\n        if self.uninstall:\n            self.multi_version = True\n            self.uninstall_link()\n            self.uninstall_namespaces()\n        else:\n            self.install_for_development()\n        self.warn_deprecated_options()\n\n    def initialize_options(self):\n        self.uninstall = None\n        self.egg_path = None\n        easy_install.initialize_options(self)\n        self.setup_path = None\n        self.always_copy_from = '.'  # always copy eggs installed in curdir\n\n    def finalize_options(self):\n        import pkg_resources\n\n        ei = self.get_finalized_command(\"egg_info\")\n        self.args = [ei.egg_name]\n\n        easy_install.finalize_options(self)\n        self.expand_basedirs()\n        self.expand_dirs()\n        # pick up setup-dir .egg files only: no .egg-info\n        self.package_index.scan(glob.glob('*.egg'))\n\n        egg_link_fn = (\n            _normalization.filename_component_broken(ei.egg_name) + '.egg-link'\n        )\n        self.egg_link = os.path.join(self.install_dir, egg_link_fn)\n        self.egg_base = ei.egg_base\n        if self.egg_path is None:\n            self.egg_path = os.path.abspath(ei.egg_base)\n\n        target = _path.normpath(self.egg_base)\n        egg_path = _path.normpath(os.path.join(self.install_dir, self.egg_path))\n        if egg_path != target:\n            raise DistutilsOptionError(\n                \"--egg-path must be a relative path from the install\"\n                \" directory to \" + target\n            )\n\n        # Make a distribution for the package's source\n        self.dist = pkg_resources.Distribution(\n            target,\n            pkg_resources.PathMetadata(target, os.path.abspath(ei.egg_info)),\n            project_name=ei.egg_name,\n        )\n\n        self.setup_path = self._resolve_setup_path(\n            self.egg_base,\n            self.install_dir,\n            self.egg_path,\n        )\n\n    @staticmethod\n    def _resolve_setup_path(egg_base, install_dir, egg_path):\n        \"\"\"\n        Generate a path from egg_base back to '.' where the\n        setup script resides and ensure that path points to the\n        setup path from $install_dir/$egg_path.\n        \"\"\"\n        path_to_setup = egg_base.replace(os.sep, '/').rstrip('/')\n        if path_to_setup != os.curdir:\n            path_to_setup = '../' * (path_to_setup.count('/') + 1)\n        resolved = _path.normpath(os.path.join(install_dir, egg_path, path_to_setup))\n        curdir = _path.normpath(os.curdir)\n        if resolved != curdir:\n            raise DistutilsOptionError(\n                \"Can't get a consistent path to setup script from\"\n                \" installation directory\",\n                resolved,\n                curdir,\n            )\n        return path_to_setup\n\n    def install_for_development(self):\n        self.run_command('egg_info')\n\n        # Build extensions in-place\n        self.reinitialize_command('build_ext', inplace=True)\n        self.run_command('build_ext')\n\n        if setuptools.bootstrap_install_from:\n            self.easy_install(setuptools.bootstrap_install_from)\n            setuptools.bootstrap_install_from = None\n\n        self.install_namespaces()\n\n        # create an .egg-link in the installation dir, pointing to our egg\n        log.info(\"Creating %s (link to %s)\", self.egg_link, self.egg_base)\n        if not self.dry_run:\n            with open(self.egg_link, \"w\", encoding=\"utf-8\") as f:\n                f.write(self.egg_path + \"\\n\" + self.setup_path)\n        # postprocess the installed distro, fixing up .pth, installing scripts,\n        # and handling requirements\n        self.process_distribution(None, self.dist, not self.no_deps)\n\n    def uninstall_link(self):\n        if os.path.exists(self.egg_link):\n            log.info(\"Removing %s (link to %s)\", self.egg_link, self.egg_base)\n\n            contents = [\n                line.rstrip()\n                for line in _read_utf8_with_fallback(self.egg_link).splitlines()\n            ]\n\n            if contents not in ([self.egg_path], [self.egg_path, self.setup_path]):\n                log.warn(\"Link points to %s: uninstall aborted\", contents)\n                return\n            if not self.dry_run:\n                os.unlink(self.egg_link)\n        if not self.dry_run:\n            self.update_pth(self.dist)  # remove any .pth link to us\n        if self.distribution.scripts:\n            # XXX should also check for entry point scripts!\n            log.warn(\"Note: you must uninstall or replace scripts manually!\")\n\n    def install_egg_scripts(self, dist):\n        if dist is not self.dist:\n            # Installing a dependency, so fall back to normal behavior\n            return easy_install.install_egg_scripts(self, dist)\n\n        # create wrapper scripts in the script dir, pointing to dist.scripts\n\n        # new-style...\n        self.install_wrapper_scripts(dist)\n\n        # ...and old-style\n        for script_name in self.distribution.scripts or []:\n            script_path = os.path.abspath(convert_path(script_name))\n            script_name = os.path.basename(script_path)\n            script_text = _read_utf8_with_fallback(script_path)\n            self.install_script(dist, script_name, script_text, script_path)\n\n        return None\n\n    def install_wrapper_scripts(self, dist):\n        dist = VersionlessRequirement(dist)\n        return easy_install.install_wrapper_scripts(self, dist)\n\n\nclass VersionlessRequirement:\n    \"\"\"\n    Adapt a pkg_resources.Distribution to simply return the project\n    name as the 'requirement' so that scripts will work across\n    multiple versions.\n\n    >>> from pkg_resources import Distribution\n    >>> dist = Distribution(project_name='foo', version='1.0')\n    >>> str(dist.as_requirement())\n    'foo==1.0'\n    >>> adapted_dist = VersionlessRequirement(dist)\n    >>> str(adapted_dist.as_requirement())\n    'foo'\n    \"\"\"\n\n    def __init__(self, dist):\n        self.__dist = dist\n\n    def __getattr__(self, name):\n        return getattr(self.__dist, name)\n\n    def as_requirement(self):\n        return self.project_name\n", "setuptools/command/upload.py": "from distutils import log\nfrom distutils.command import upload as orig\n\nfrom setuptools.errors import RemovedCommandError\n\n\nclass upload(orig.upload):\n    \"\"\"Formerly used to upload packages to PyPI.\"\"\"\n\n    def run(self):\n        msg = (\n            \"The upload command has been removed, use twine to upload \"\n            + \"instead (https://pypi.org/p/twine)\"\n        )\n\n        self.announce(\"ERROR: \" + msg, log.ERROR)\n        raise RemovedCommandError(msg)\n", "setuptools/command/dist_info.py": "\"\"\"\nCreate a dist_info directory\nAs defined in the wheel specification\n\"\"\"\n\nimport os\nimport shutil\nfrom contextlib import contextmanager\nfrom distutils import log\nfrom distutils.core import Command\nfrom pathlib import Path\nfrom typing import cast\n\nfrom .. import _normalization\nfrom .egg_info import egg_info as egg_info_cls\n\n\nclass dist_info(Command):\n    \"\"\"\n    This command is private and reserved for internal use of setuptools,\n    users should rely on ``setuptools.build_meta`` APIs.\n    \"\"\"\n\n    description = \"DO NOT CALL DIRECTLY, INTERNAL ONLY: create .dist-info directory\"\n\n    user_options = [\n        (\n            'output-dir=',\n            'o',\n            \"directory inside of which the .dist-info will be\"\n            \"created (default: top of the source tree)\",\n        ),\n        ('tag-date', 'd', \"Add date stamp (e.g. 20050528) to version number\"),\n        ('tag-build=', 'b', \"Specify explicit tag to add to version number\"),\n        ('no-date', 'D', \"Don't include date stamp [default]\"),\n        ('keep-egg-info', None, \"*TRANSITIONAL* will be removed in the future\"),\n    ]\n\n    boolean_options = ['tag-date', 'keep-egg-info']\n    negative_opt = {'no-date': 'tag-date'}\n\n    def initialize_options(self):\n        self.output_dir = None\n        self.name = None\n        self.dist_info_dir = None\n        self.tag_date = None\n        self.tag_build = None\n        self.keep_egg_info = False\n\n    def finalize_options(self):\n        dist = self.distribution\n        project_dir = dist.src_root or os.curdir\n        self.output_dir = Path(self.output_dir or project_dir)\n\n        egg_info = cast(egg_info_cls, self.reinitialize_command(\"egg_info\"))\n        egg_info.egg_base = str(self.output_dir)\n\n        if self.tag_date:\n            egg_info.tag_date = self.tag_date\n        else:\n            self.tag_date = egg_info.tag_date\n\n        if self.tag_build:\n            egg_info.tag_build = self.tag_build\n        else:\n            self.tag_build = egg_info.tag_build\n\n        egg_info.finalize_options()\n        self.egg_info = egg_info\n\n        name = _normalization.safer_name(dist.get_name())\n        version = _normalization.safer_best_effort_version(dist.get_version())\n        self.name = f\"{name}-{version}\"\n        self.dist_info_dir = os.path.join(self.output_dir, f\"{self.name}.dist-info\")\n\n    @contextmanager\n    def _maybe_bkp_dir(self, dir_path: str, requires_bkp: bool):\n        if requires_bkp:\n            bkp_name = f\"{dir_path}.__bkp__\"\n            _rm(bkp_name, ignore_errors=True)\n            shutil.copytree(dir_path, bkp_name, dirs_exist_ok=True, symlinks=True)\n            try:\n                yield\n            finally:\n                _rm(dir_path, ignore_errors=True)\n                shutil.move(bkp_name, dir_path)\n        else:\n            yield\n\n    def run(self):\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        self.egg_info.run()\n        egg_info_dir = self.egg_info.egg_info\n        assert os.path.isdir(egg_info_dir), \".egg-info dir should have been created\"\n\n        log.info(\"creating '{}'\".format(os.path.abspath(self.dist_info_dir)))\n        bdist_wheel = self.get_finalized_command('bdist_wheel')\n\n        # TODO: if bdist_wheel if merged into setuptools, just add \"keep_egg_info\" there\n        with self._maybe_bkp_dir(egg_info_dir, self.keep_egg_info):\n            bdist_wheel.egg2dist(egg_info_dir, self.dist_info_dir)\n\n\ndef _rm(dir_name, **opts):\n    if os.path.isdir(dir_name):\n        shutil.rmtree(dir_name, **opts)\n", "setuptools/command/alias.py": "from distutils.errors import DistutilsOptionError\n\nfrom setuptools.command.setopt import edit_config, option_base, config_file\n\n\ndef shquote(arg):\n    \"\"\"Quote an argument for later parsing by shlex.split()\"\"\"\n    for c in '\"', \"'\", \"\\\\\", \"#\":\n        if c in arg:\n            return repr(arg)\n    if arg.split() != [arg]:\n        return repr(arg)\n    return arg\n\n\nclass alias(option_base):\n    \"\"\"Define a shortcut that invokes one or more commands\"\"\"\n\n    description = \"define a shortcut to invoke one or more commands\"\n    command_consumes_arguments = True\n\n    user_options = [\n        ('remove', 'r', 'remove (unset) the alias'),\n    ] + option_base.user_options\n\n    boolean_options = option_base.boolean_options + ['remove']\n\n    def initialize_options(self):\n        option_base.initialize_options(self)\n        self.args = None\n        self.remove = None\n\n    def finalize_options(self):\n        option_base.finalize_options(self)\n        if self.remove and len(self.args) != 1:\n            raise DistutilsOptionError(\n                \"Must specify exactly one argument (the alias name) when \"\n                \"using --remove\"\n            )\n\n    def run(self):\n        aliases = self.distribution.get_option_dict('aliases')\n\n        if not self.args:\n            print(\"Command Aliases\")\n            print(\"---------------\")\n            for alias in aliases:\n                print(\"setup.py alias\", format_alias(alias, aliases))\n            return\n\n        elif len(self.args) == 1:\n            (alias,) = self.args\n            if self.remove:\n                command = None\n            elif alias in aliases:\n                print(\"setup.py alias\", format_alias(alias, aliases))\n                return\n            else:\n                print(\"No alias definition found for %r\" % alias)\n                return\n        else:\n            alias = self.args[0]\n            command = ' '.join(map(shquote, self.args[1:]))\n\n        edit_config(self.filename, {'aliases': {alias: command}}, self.dry_run)\n\n\ndef format_alias(name, aliases):\n    source, command = aliases[name]\n    if source == config_file('global'):\n        source = '--global-config '\n    elif source == config_file('user'):\n        source = '--user-config '\n    elif source == config_file('local'):\n        source = ''\n    else:\n        source = '--filename=%r' % source\n    return source + name + ' ' + command\n", "setuptools/command/easy_install.py": "\"\"\"\nEasy Install\n------------\n\nA tool for doing automatic download/extract/build of distutils-based Python\npackages.  For detailed documentation, see the accompanying EasyInstall.txt\nfile, or visit the `EasyInstall home page`__.\n\n__ https://setuptools.pypa.io/en/latest/deprecated/easy_install.html\n\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom glob import glob\nfrom distutils.util import get_platform\nfrom distutils.util import convert_path, subst_vars\nfrom distutils.errors import (\n    DistutilsArgError,\n    DistutilsOptionError,\n    DistutilsError,\n    DistutilsPlatformError,\n)\nfrom distutils import log, dir_util\nfrom distutils.command.build_scripts import first_line_re\nfrom distutils.spawn import find_executable\nfrom distutils.command import install\nimport sys\nimport os\nimport zipimport\nimport shutil\nimport tempfile\nimport zipfile\nimport re\nimport stat\nimport random\nimport textwrap\nimport warnings\nimport site\nimport struct\nimport contextlib\nimport subprocess\nimport shlex\nimport io\nimport configparser\nimport sysconfig\n\nfrom sysconfig import get_path\n\nfrom setuptools import Command\nfrom setuptools.sandbox import run_setup\nfrom setuptools.command import setopt\nfrom setuptools.archive_util import unpack_archive\nfrom setuptools.package_index import (\n    PackageIndex,\n    parse_requirement_arg,\n    URL_SCHEME,\n)\nfrom setuptools.command import bdist_egg, egg_info\nfrom setuptools.warnings import SetuptoolsDeprecationWarning, SetuptoolsWarning\nfrom setuptools.wheel import Wheel\nfrom pkg_resources import (\n    normalize_path,\n    resource_string,\n    get_distribution,\n    find_distributions,\n    Environment,\n    Requirement,\n    Distribution,\n    PathMetadata,\n    EggMetadata,\n    WorkingSet,\n    DistributionNotFound,\n    VersionConflict,\n    DEVELOP_DIST,\n)\nimport pkg_resources\nfrom ..compat import py39, py311\nfrom .._path import ensure_directory\nfrom ..extern.jaraco.text import yield_lines\n\n\n# Turn on PEP440Warnings\nwarnings.filterwarnings(\"default\", category=pkg_resources.PEP440Warning)\n\n__all__ = [\n    'easy_install',\n    'PthDistributions',\n    'extract_wininst_cfg',\n    'get_exe_prefixes',\n]\n\n\ndef is_64bit():\n    return struct.calcsize(\"P\") == 8\n\n\ndef _to_bytes(s):\n    return s.encode('utf8')\n\n\ndef isascii(s):\n    try:\n        s.encode('ascii')\n        return True\n    except UnicodeError:\n        return False\n\n\ndef _one_liner(text):\n    return textwrap.dedent(text).strip().replace('\\n', '; ')\n\n\nclass easy_install(Command):\n    \"\"\"Manage a download/build/install process\"\"\"\n\n    description = \"Find/get/install Python packages\"\n    command_consumes_arguments = True\n\n    user_options = [\n        ('prefix=', None, \"installation prefix\"),\n        (\"zip-ok\", \"z\", \"install package as a zipfile\"),\n        (\"multi-version\", \"m\", \"make apps have to require() a version\"),\n        (\"upgrade\", \"U\", \"force upgrade (searches PyPI for latest versions)\"),\n        (\"install-dir=\", \"d\", \"install package to DIR\"),\n        (\"script-dir=\", \"s\", \"install scripts to DIR\"),\n        (\"exclude-scripts\", \"x\", \"Don't install scripts\"),\n        (\"always-copy\", \"a\", \"Copy all needed packages to install dir\"),\n        (\"index-url=\", \"i\", \"base URL of Python Package Index\"),\n        (\"find-links=\", \"f\", \"additional URL(s) to search for packages\"),\n        (\"build-directory=\", \"b\", \"download/extract/build in DIR; keep the results\"),\n        (\n            'optimize=',\n            'O',\n            \"also compile with optimization: -O1 for \\\"python -O\\\", \"\n            \"-O2 for \\\"python -OO\\\", and -O0 to disable [default: -O0]\",\n        ),\n        ('record=', None, \"filename in which to record list of installed files\"),\n        ('always-unzip', 'Z', \"don't install as a zipfile, no matter what\"),\n        ('site-dirs=', 'S', \"list of directories where .pth files work\"),\n        ('editable', 'e', \"Install specified packages in editable form\"),\n        ('no-deps', 'N', \"don't install dependencies\"),\n        ('allow-hosts=', 'H', \"pattern(s) that hostnames must match\"),\n        ('local-snapshots-ok', 'l', \"allow building eggs from local checkouts\"),\n        ('version', None, \"print version information and exit\"),\n        (\n            'no-find-links',\n            None,\n            \"Don't load find-links defined in packages being installed\",\n        ),\n        ('user', None, \"install in user site-package '%s'\" % site.USER_SITE),\n    ]\n    boolean_options = [\n        'zip-ok',\n        'multi-version',\n        'exclude-scripts',\n        'upgrade',\n        'always-copy',\n        'editable',\n        'no-deps',\n        'local-snapshots-ok',\n        'version',\n        'user',\n    ]\n\n    negative_opt = {'always-unzip': 'zip-ok'}\n    create_index = PackageIndex\n\n    def initialize_options(self):\n        EasyInstallDeprecationWarning.emit()\n\n        # the --user option seems to be an opt-in one,\n        # so the default should be False.\n        self.user = False\n        self.zip_ok = self.local_snapshots_ok = None\n        self.install_dir = self.script_dir = self.exclude_scripts = None\n        self.index_url = None\n        self.find_links = None\n        self.build_directory = None\n        self.args = None\n        self.optimize = self.record = None\n        self.upgrade = self.always_copy = self.multi_version = None\n        self.editable = self.no_deps = self.allow_hosts = None\n        self.root = self.prefix = self.no_report = None\n        self.version = None\n        self.install_purelib = None  # for pure module distributions\n        self.install_platlib = None  # non-pure (dists w/ extensions)\n        self.install_headers = None  # for C/C++ headers\n        self.install_lib = None  # set to either purelib or platlib\n        self.install_scripts = None\n        self.install_data = None\n        self.install_base = None\n        self.install_platbase = None\n        self.install_userbase = site.USER_BASE\n        self.install_usersite = site.USER_SITE\n        self.no_find_links = None\n\n        # Options not specifiable via command line\n        self.package_index = None\n        self.pth_file = self.always_copy_from = None\n        self.site_dirs = None\n        self.installed_projects = {}\n        # Always read easy_install options, even if we are subclassed, or have\n        # an independent instance created.  This ensures that defaults will\n        # always come from the standard configuration file(s)' \"easy_install\"\n        # section, even if this is a \"develop\" or \"install\" command, or some\n        # other embedding.\n        self._dry_run = None\n        self.verbose = self.distribution.verbose\n        self.distribution._set_command_options(\n            self, self.distribution.get_option_dict('easy_install')\n        )\n\n    def delete_blockers(self, blockers):\n        extant_blockers = (\n            filename\n            for filename in blockers\n            if os.path.exists(filename) or os.path.islink(filename)\n        )\n        list(map(self._delete_path, extant_blockers))\n\n    def _delete_path(self, path):\n        log.info(\"Deleting %s\", path)\n        if self.dry_run:\n            return\n\n        is_tree = os.path.isdir(path) and not os.path.islink(path)\n        remover = _rmtree if is_tree else os.unlink\n        remover(path)\n\n    @staticmethod\n    def _render_version():\n        \"\"\"\n        Render the Setuptools version and installation details, then exit.\n        \"\"\"\n        ver = '{}.{}'.format(*sys.version_info)\n        dist = get_distribution('setuptools')\n        tmpl = 'setuptools {dist.version} from {dist.location} (Python {ver})'\n        print(tmpl.format(**locals()))\n        raise SystemExit()\n\n    def finalize_options(self):  # noqa: C901  # is too complex (25)  # FIXME\n        self.version and self._render_version()\n\n        py_version = sys.version.split()[0]\n\n        self.config_vars = dict(sysconfig.get_config_vars())\n\n        self.config_vars.update({\n            'dist_name': self.distribution.get_name(),\n            'dist_version': self.distribution.get_version(),\n            'dist_fullname': self.distribution.get_fullname(),\n            'py_version': py_version,\n            'py_version_short': f'{sys.version_info.major}.{sys.version_info.minor}',\n            'py_version_nodot': f'{sys.version_info.major}{sys.version_info.minor}',\n            'sys_prefix': self.config_vars['prefix'],\n            'sys_exec_prefix': self.config_vars['exec_prefix'],\n            # Only POSIX systems have abiflags\n            'abiflags': getattr(sys, 'abiflags', ''),\n            # Only python 3.9+ has platlibdir\n            'platlibdir': getattr(sys, 'platlibdir', 'lib'),\n        })\n        with contextlib.suppress(AttributeError):\n            # only for distutils outside stdlib\n            self.config_vars.update({\n                'implementation_lower': install._get_implementation().lower(),\n                'implementation': install._get_implementation(),\n            })\n\n        # pypa/distutils#113 Python 3.9 compat\n        self.config_vars.setdefault(\n            'py_version_nodot_plat',\n            getattr(sys, 'windir', '').replace('.', ''),\n        )\n\n        self.config_vars['userbase'] = self.install_userbase\n        self.config_vars['usersite'] = self.install_usersite\n        if self.user and not site.ENABLE_USER_SITE:\n            log.warn(\"WARNING: The user site-packages directory is disabled.\")\n\n        self._fix_install_dir_for_user_site()\n\n        self.expand_basedirs()\n        self.expand_dirs()\n\n        self._expand(\n            'install_dir',\n            'script_dir',\n            'build_directory',\n            'site_dirs',\n        )\n        # If a non-default installation directory was specified, default the\n        # script directory to match it.\n        if self.script_dir is None:\n            self.script_dir = self.install_dir\n\n        if self.no_find_links is None:\n            self.no_find_links = False\n\n        # Let install_dir get set by install_lib command, which in turn\n        # gets its info from the install command, and takes into account\n        # --prefix and --home and all that other crud.\n        self.set_undefined_options('install_lib', ('install_dir', 'install_dir'))\n        # Likewise, set default script_dir from 'install_scripts.install_dir'\n        self.set_undefined_options('install_scripts', ('install_dir', 'script_dir'))\n\n        if self.user and self.install_purelib:\n            self.install_dir = self.install_purelib\n            self.script_dir = self.install_scripts\n        # default --record from the install command\n        self.set_undefined_options('install', ('record', 'record'))\n        self.all_site_dirs = get_site_dirs()\n        self.all_site_dirs.extend(self._process_site_dirs(self.site_dirs))\n\n        if not self.editable:\n            self.check_site_dir()\n        default_index = os.getenv(\"__EASYINSTALL_INDEX\", \"https://pypi.org/simple/\")\n        # ^ Private API for testing purposes only\n        self.index_url = self.index_url or default_index\n        self.shadow_path = self.all_site_dirs[:]\n        for path_item in self.install_dir, normalize_path(self.script_dir):\n            if path_item not in self.shadow_path:\n                self.shadow_path.insert(0, path_item)\n\n        if self.allow_hosts is not None:\n            hosts = [s.strip() for s in self.allow_hosts.split(',')]\n        else:\n            hosts = ['*']\n        if self.package_index is None:\n            self.package_index = self.create_index(\n                self.index_url,\n                search_path=self.shadow_path,\n                hosts=hosts,\n            )\n        self.local_index = Environment(self.shadow_path + sys.path)\n\n        if self.find_links is not None:\n            if isinstance(self.find_links, str):\n                self.find_links = self.find_links.split()\n        else:\n            self.find_links = []\n        if self.local_snapshots_ok:\n            self.package_index.scan_egg_links(self.shadow_path + sys.path)\n        if not self.no_find_links:\n            self.package_index.add_find_links(self.find_links)\n        self.set_undefined_options('install_lib', ('optimize', 'optimize'))\n        self.optimize = self._validate_optimize(self.optimize)\n\n        if self.editable and not self.build_directory:\n            raise DistutilsArgError(\n                \"Must specify a build directory (-b) when using --editable\"\n            )\n        if not self.args:\n            raise DistutilsArgError(\n                \"No urls, filenames, or requirements specified (see --help)\"\n            )\n\n        self.outputs = []\n\n    @staticmethod\n    def _process_site_dirs(site_dirs):\n        if site_dirs is None:\n            return\n\n        normpath = map(normalize_path, sys.path)\n        site_dirs = [os.path.expanduser(s.strip()) for s in site_dirs.split(',')]\n        for d in site_dirs:\n            if not os.path.isdir(d):\n                log.warn(\"%s (in --site-dirs) does not exist\", d)\n            elif normalize_path(d) not in normpath:\n                raise DistutilsOptionError(d + \" (in --site-dirs) is not on sys.path\")\n            else:\n                yield normalize_path(d)\n\n    @staticmethod\n    def _validate_optimize(value):\n        try:\n            value = int(value)\n            if value not in range(3):\n                raise ValueError\n        except ValueError as e:\n            raise DistutilsOptionError(\"--optimize must be 0, 1, or 2\") from e\n\n        return value\n\n    def _fix_install_dir_for_user_site(self):\n        \"\"\"\n        Fix the install_dir if \"--user\" was used.\n        \"\"\"\n        if not self.user:\n            return\n\n        self.create_home_path()\n        if self.install_userbase is None:\n            msg = \"User base directory is not specified\"\n            raise DistutilsPlatformError(msg)\n        self.install_base = self.install_platbase = self.install_userbase\n        scheme_name = f'{os.name}_user'\n        self.select_scheme(scheme_name)\n\n    def _expand_attrs(self, attrs):\n        for attr in attrs:\n            val = getattr(self, attr)\n            if val is not None:\n                if os.name == 'posix' or os.name == 'nt':\n                    val = os.path.expanduser(val)\n                val = subst_vars(val, self.config_vars)\n                setattr(self, attr, val)\n\n    def expand_basedirs(self):\n        \"\"\"Calls `os.path.expanduser` on install_base, install_platbase and\n        root.\"\"\"\n        self._expand_attrs(['install_base', 'install_platbase', 'root'])\n\n    def expand_dirs(self):\n        \"\"\"Calls `os.path.expanduser` on install dirs.\"\"\"\n        dirs = [\n            'install_purelib',\n            'install_platlib',\n            'install_lib',\n            'install_headers',\n            'install_scripts',\n            'install_data',\n        ]\n        self._expand_attrs(dirs)\n\n    def run(self, show_deprecation=True):\n        if show_deprecation:\n            self.announce(\n                \"WARNING: The easy_install command is deprecated \"\n                \"and will be removed in a future version.\",\n                log.WARN,\n            )\n        if self.verbose != self.distribution.verbose:\n            log.set_verbosity(self.verbose)\n        try:\n            for spec in self.args:\n                self.easy_install(spec, not self.no_deps)\n            if self.record:\n                outputs = self.outputs\n                if self.root:  # strip any package prefix\n                    root_len = len(self.root)\n                    for counter in range(len(outputs)):\n                        outputs[counter] = outputs[counter][root_len:]\n                from distutils import file_util\n\n                self.execute(\n                    file_util.write_file,\n                    (self.record, outputs),\n                    \"writing list of installed files to '%s'\" % self.record,\n                )\n            self.warn_deprecated_options()\n        finally:\n            log.set_verbosity(self.distribution.verbose)\n\n    def pseudo_tempname(self):\n        \"\"\"Return a pseudo-tempname base in the install directory.\n        This code is intentionally naive; if a malicious party can write to\n        the target directory you're already in deep doodoo.\n        \"\"\"\n        try:\n            pid = os.getpid()\n        except Exception:\n            pid = random.randint(0, sys.maxsize)\n        return os.path.join(self.install_dir, \"test-easy-install-%s\" % pid)\n\n    def warn_deprecated_options(self):\n        pass\n\n    def check_site_dir(self):  # noqa: C901  # is too complex (12)  # FIXME\n        \"\"\"Verify that self.install_dir is .pth-capable dir, if needed\"\"\"\n\n        instdir = normalize_path(self.install_dir)\n        pth_file = os.path.join(instdir, 'easy-install.pth')\n\n        if not os.path.exists(instdir):\n            try:\n                os.makedirs(instdir)\n            except OSError:\n                self.cant_write_to_target()\n\n        # Is it a configured, PYTHONPATH, implicit, or explicit site dir?\n        is_site_dir = instdir in self.all_site_dirs\n\n        if not is_site_dir and not self.multi_version:\n            # No?  Then directly test whether it does .pth file processing\n            is_site_dir = self.check_pth_processing()\n        else:\n            # make sure we can write to target dir\n            testfile = self.pseudo_tempname() + '.write-test'\n            test_exists = os.path.exists(testfile)\n            try:\n                if test_exists:\n                    os.unlink(testfile)\n                open(testfile, 'wb').close()\n                os.unlink(testfile)\n            except OSError:\n                self.cant_write_to_target()\n\n        if not is_site_dir and not self.multi_version:\n            # Can't install non-multi to non-site dir with easy_install\n            pythonpath = os.environ.get('PYTHONPATH', '')\n            log.warn(self.__no_default_msg, self.install_dir, pythonpath)\n\n        if is_site_dir:\n            if self.pth_file is None:\n                self.pth_file = PthDistributions(pth_file, self.all_site_dirs)\n        else:\n            self.pth_file = None\n\n        if self.multi_version and not os.path.exists(pth_file):\n            self.pth_file = None  # don't create a .pth file\n        self.install_dir = instdir\n\n    __cant_write_msg = textwrap.dedent(\n        \"\"\"\n        can't create or remove files in install directory\n\n        The following error occurred while trying to add or remove files in the\n        installation directory:\n\n            %s\n\n        The installation directory you specified (via --install-dir, --prefix, or\n        the distutils default setting) was:\n\n            %s\n        \"\"\"\n    ).lstrip()  # noqa\n\n    __not_exists_id = textwrap.dedent(\n        \"\"\"\n        This directory does not currently exist.  Please create it and try again, or\n        choose a different installation directory (using the -d or --install-dir\n        option).\n        \"\"\"\n    ).lstrip()  # noqa\n\n    __access_msg = textwrap.dedent(\n        \"\"\"\n        Perhaps your account does not have write access to this directory?  If the\n        installation directory is a system-owned directory, you may need to sign in\n        as the administrator or \"root\" account.  If you do not have administrative\n        access to this machine, you may wish to choose a different installation\n        directory, preferably one that is listed in your PYTHONPATH environment\n        variable.\n\n        For information on other options, you may wish to consult the\n        documentation at:\n\n          https://setuptools.pypa.io/en/latest/deprecated/easy_install.html\n\n        Please make the appropriate changes for your system and try again.\n        \"\"\"\n    ).lstrip()  # noqa\n\n    def cant_write_to_target(self):\n        msg = self.__cant_write_msg % (\n            sys.exc_info()[1],\n            self.install_dir,\n        )\n\n        if not os.path.exists(self.install_dir):\n            msg += '\\n' + self.__not_exists_id\n        else:\n            msg += '\\n' + self.__access_msg\n        raise DistutilsError(msg)\n\n    def check_pth_processing(self):  # noqa: C901\n        \"\"\"Empirically verify whether .pth files are supported in inst. dir\"\"\"\n        instdir = self.install_dir\n        log.info(\"Checking .pth file support in %s\", instdir)\n        pth_file = self.pseudo_tempname() + \".pth\"\n        ok_file = pth_file + '.ok'\n        ok_exists = os.path.exists(ok_file)\n        tmpl = (\n            _one_liner(\n                \"\"\"\n            import os\n            f = open({ok_file!r}, 'w', encoding=\"utf-8\")\n            f.write('OK')\n            f.close()\n            \"\"\"\n            )\n            + '\\n'\n        )\n        try:\n            if ok_exists:\n                os.unlink(ok_file)\n            dirname = os.path.dirname(ok_file)\n            os.makedirs(dirname, exist_ok=True)\n            f = open(pth_file, 'w', encoding=py39.LOCALE_ENCODING)\n            # ^-- Requires encoding=\"locale\" instead of \"utf-8\" (python/cpython#77102).\n        except OSError:\n            self.cant_write_to_target()\n        else:\n            try:\n                f.write(tmpl.format(**locals()))\n                f.close()\n                f = None\n                executable = sys.executable\n                if os.name == 'nt':\n                    dirname, basename = os.path.split(executable)\n                    alt = os.path.join(dirname, 'pythonw.exe')\n                    use_alt = basename.lower() == 'python.exe' and os.path.exists(alt)\n                    if use_alt:\n                        # use pythonw.exe to avoid opening a console window\n                        executable = alt\n\n                from distutils.spawn import spawn\n\n                spawn([executable, '-E', '-c', 'pass'], 0)\n\n                if os.path.exists(ok_file):\n                    log.info(\"TEST PASSED: %s appears to support .pth files\", instdir)\n                    return True\n            finally:\n                if f:\n                    f.close()\n                if os.path.exists(ok_file):\n                    os.unlink(ok_file)\n                if os.path.exists(pth_file):\n                    os.unlink(pth_file)\n        if not self.multi_version:\n            log.warn(\"TEST FAILED: %s does NOT support .pth files\", instdir)\n        return False\n\n    def install_egg_scripts(self, dist):\n        \"\"\"Write all the scripts for `dist`, unless scripts are excluded\"\"\"\n        if not self.exclude_scripts and dist.metadata_isdir('scripts'):\n            for script_name in dist.metadata_listdir('scripts'):\n                if dist.metadata_isdir('scripts/' + script_name):\n                    # The \"script\" is a directory, likely a Python 3\n                    # __pycache__ directory, so skip it.\n                    continue\n                self.install_script(\n                    dist, script_name, dist.get_metadata('scripts/' + script_name)\n                )\n        self.install_wrapper_scripts(dist)\n\n    def add_output(self, path):\n        if os.path.isdir(path):\n            for base, dirs, files in os.walk(path):\n                for filename in files:\n                    self.outputs.append(os.path.join(base, filename))\n        else:\n            self.outputs.append(path)\n\n    def not_editable(self, spec):\n        if self.editable:\n            raise DistutilsArgError(\n                \"Invalid argument %r: you can't use filenames or URLs \"\n                \"with --editable (except via the --find-links option).\" % (spec,)\n            )\n\n    def check_editable(self, spec):\n        if not self.editable:\n            return\n\n        if os.path.exists(os.path.join(self.build_directory, spec.key)):\n            raise DistutilsArgError(\n                \"%r already exists in %s; can't do a checkout there\"\n                % (spec.key, self.build_directory)\n            )\n\n    @contextlib.contextmanager\n    def _tmpdir(self):\n        tmpdir = tempfile.mkdtemp(prefix=\"easy_install-\")\n        try:\n            # cast to str as workaround for #709 and #710 and #712\n            yield str(tmpdir)\n        finally:\n            os.path.exists(tmpdir) and _rmtree(tmpdir)\n\n    def easy_install(self, spec, deps=False):\n        with self._tmpdir() as tmpdir:\n            if not isinstance(spec, Requirement):\n                if URL_SCHEME(spec):\n                    # It's a url, download it to tmpdir and process\n                    self.not_editable(spec)\n                    dl = self.package_index.download(spec, tmpdir)\n                    return self.install_item(None, dl, tmpdir, deps, True)\n\n                elif os.path.exists(spec):\n                    # Existing file or directory, just process it directly\n                    self.not_editable(spec)\n                    return self.install_item(None, spec, tmpdir, deps, True)\n                else:\n                    spec = parse_requirement_arg(spec)\n\n            self.check_editable(spec)\n            dist = self.package_index.fetch_distribution(\n                spec,\n                tmpdir,\n                self.upgrade,\n                self.editable,\n                not self.always_copy,\n                self.local_index,\n            )\n            if dist is None:\n                msg = \"Could not find suitable distribution for %r\" % spec\n                if self.always_copy:\n                    msg += \" (--always-copy skips system and development eggs)\"\n                raise DistutilsError(msg)\n            elif dist.precedence == DEVELOP_DIST:\n                # .egg-info dists don't need installing, just process deps\n                self.process_distribution(spec, dist, deps, \"Using\")\n                return dist\n            else:\n                return self.install_item(spec, dist.location, tmpdir, deps)\n\n    def install_item(self, spec, download, tmpdir, deps, install_needed=False):\n        # Installation is also needed if file in tmpdir or is not an egg\n        install_needed = install_needed or self.always_copy\n        install_needed = install_needed or os.path.dirname(download) == tmpdir\n        install_needed = install_needed or not download.endswith('.egg')\n        install_needed = install_needed or (\n            self.always_copy_from is not None\n            and os.path.dirname(normalize_path(download))\n            == normalize_path(self.always_copy_from)\n        )\n\n        if spec and not install_needed:\n            # at this point, we know it's a local .egg, we just don't know if\n            # it's already installed.\n            for dist in self.local_index[spec.project_name]:\n                if dist.location == download:\n                    break\n            else:\n                install_needed = True  # it's not in the local index\n\n        log.info(\"Processing %s\", os.path.basename(download))\n\n        if install_needed:\n            dists = self.install_eggs(spec, download, tmpdir)\n            for dist in dists:\n                self.process_distribution(spec, dist, deps)\n        else:\n            dists = [self.egg_distribution(download)]\n            self.process_distribution(spec, dists[0], deps, \"Using\")\n\n        if spec is not None:\n            for dist in dists:\n                if dist in spec:\n                    return dist\n        return None\n\n    def select_scheme(self, name):\n        try:\n            install._select_scheme(self, name)\n        except AttributeError:\n            # stdlib distutils\n            install.install.select_scheme(self, name.replace('posix', 'unix'))\n\n    # FIXME: 'easy_install.process_distribution' is too complex (12)\n    def process_distribution(  # noqa: C901\n        self,\n        requirement,\n        dist,\n        deps=True,\n        *info,\n    ):\n        self.update_pth(dist)\n        self.package_index.add(dist)\n        if dist in self.local_index[dist.key]:\n            self.local_index.remove(dist)\n        self.local_index.add(dist)\n        self.install_egg_scripts(dist)\n        self.installed_projects[dist.key] = dist\n        log.info(self.installation_report(requirement, dist, *info))\n        if dist.has_metadata('dependency_links.txt') and not self.no_find_links:\n            self.package_index.add_find_links(\n                dist.get_metadata_lines('dependency_links.txt')\n            )\n        if not deps and not self.always_copy:\n            return\n        elif requirement is not None and dist.key != requirement.key:\n            log.warn(\"Skipping dependencies for %s\", dist)\n            return  # XXX this is not the distribution we were looking for\n        elif requirement is None or dist not in requirement:\n            # if we wound up with a different version, resolve what we've got\n            distreq = dist.as_requirement()\n            requirement = Requirement(str(distreq))\n        log.info(\"Processing dependencies for %s\", requirement)\n        try:\n            distros = WorkingSet([]).resolve(\n                [requirement], self.local_index, self.easy_install\n            )\n        except DistributionNotFound as e:\n            raise DistutilsError(str(e)) from e\n        except VersionConflict as e:\n            raise DistutilsError(e.report()) from e\n        if self.always_copy or self.always_copy_from:\n            # Force all the relevant distros to be copied or activated\n            for dist in distros:\n                if dist.key not in self.installed_projects:\n                    self.easy_install(dist.as_requirement())\n        log.info(\"Finished processing dependencies for %s\", requirement)\n\n    def should_unzip(self, dist):\n        if self.zip_ok is not None:\n            return not self.zip_ok\n        if dist.has_metadata('not-zip-safe'):\n            return True\n        if not dist.has_metadata('zip-safe'):\n            return True\n        return False\n\n    def maybe_move(self, spec, dist_filename, setup_base):\n        dst = os.path.join(self.build_directory, spec.key)\n        if os.path.exists(dst):\n            msg = \"%r already exists in %s; build directory %s will not be kept\"\n            log.warn(msg, spec.key, self.build_directory, setup_base)\n            return setup_base\n        if os.path.isdir(dist_filename):\n            setup_base = dist_filename\n        else:\n            if os.path.dirname(dist_filename) == setup_base:\n                os.unlink(dist_filename)  # get it out of the tmp dir\n            contents = os.listdir(setup_base)\n            if len(contents) == 1:\n                dist_filename = os.path.join(setup_base, contents[0])\n                if os.path.isdir(dist_filename):\n                    # if the only thing there is a directory, move it instead\n                    setup_base = dist_filename\n        ensure_directory(dst)\n        shutil.move(setup_base, dst)\n        return dst\n\n    def install_wrapper_scripts(self, dist):\n        if self.exclude_scripts:\n            return\n        for args in ScriptWriter.best().get_args(dist):\n            self.write_script(*args)\n\n    def install_script(self, dist, script_name, script_text, dev_path=None):\n        \"\"\"Generate a legacy script wrapper and install it\"\"\"\n        spec = str(dist.as_requirement())\n        is_script = is_python_script(script_text, script_name)\n\n        if is_script:\n            body = self._load_template(dev_path) % locals()\n            script_text = ScriptWriter.get_header(script_text) + body\n        self.write_script(script_name, _to_bytes(script_text), 'b')\n\n    @staticmethod\n    def _load_template(dev_path):\n        \"\"\"\n        There are a couple of template scripts in the package. This\n        function loads one of them and prepares it for use.\n        \"\"\"\n        # See https://github.com/pypa/setuptools/issues/134 for info\n        # on script file naming and downstream issues with SVR4\n        name = 'script.tmpl'\n        if dev_path:\n            name = name.replace('.tmpl', ' (dev).tmpl')\n\n        raw_bytes = resource_string('setuptools', name)\n        return raw_bytes.decode('utf-8')\n\n    def write_script(self, script_name, contents, mode=\"t\", blockers=()):\n        \"\"\"Write an executable file to the scripts directory\"\"\"\n        self.delete_blockers(  # clean up old .py/.pyw w/o a script\n            [os.path.join(self.script_dir, x) for x in blockers]\n        )\n        log.info(\"Installing %s script to %s\", script_name, self.script_dir)\n        target = os.path.join(self.script_dir, script_name)\n        self.add_output(target)\n\n        if self.dry_run:\n            return\n\n        mask = current_umask()\n        ensure_directory(target)\n        if os.path.exists(target):\n            os.unlink(target)\n\n        encoding = None if \"b\" in mode else \"utf-8\"\n        with open(target, \"w\" + mode, encoding=encoding) as f:\n            f.write(contents)\n        chmod(target, 0o777 - mask)\n\n    def install_eggs(self, spec, dist_filename, tmpdir):\n        # .egg dirs or files are already built, so just return them\n        installer_map = {\n            '.egg': self.install_egg,\n            '.exe': self.install_exe,\n            '.whl': self.install_wheel,\n        }\n        try:\n            install_dist = installer_map[dist_filename.lower()[-4:]]\n        except KeyError:\n            pass\n        else:\n            return [install_dist(dist_filename, tmpdir)]\n\n        # Anything else, try to extract and build\n        setup_base = tmpdir\n        if os.path.isfile(dist_filename) and not dist_filename.endswith('.py'):\n            unpack_archive(dist_filename, tmpdir, self.unpack_progress)\n        elif os.path.isdir(dist_filename):\n            setup_base = os.path.abspath(dist_filename)\n\n        if (\n            setup_base.startswith(tmpdir)  # something we downloaded\n            and self.build_directory\n            and spec is not None\n        ):\n            setup_base = self.maybe_move(spec, dist_filename, setup_base)\n\n        # Find the setup.py file\n        setup_script = os.path.join(setup_base, 'setup.py')\n\n        if not os.path.exists(setup_script):\n            setups = glob(os.path.join(setup_base, '*', 'setup.py'))\n            if not setups:\n                raise DistutilsError(\n                    \"Couldn't find a setup script in %s\"\n                    % os.path.abspath(dist_filename)\n                )\n            if len(setups) > 1:\n                raise DistutilsError(\n                    \"Multiple setup scripts in %s\" % os.path.abspath(dist_filename)\n                )\n            setup_script = setups[0]\n\n        # Now run it, and return the result\n        if self.editable:\n            log.info(self.report_editable(spec, setup_script))\n            return []\n        else:\n            return self.build_and_install(setup_script, setup_base)\n\n    def egg_distribution(self, egg_path):\n        if os.path.isdir(egg_path):\n            metadata = PathMetadata(egg_path, os.path.join(egg_path, 'EGG-INFO'))\n        else:\n            metadata = EggMetadata(zipimport.zipimporter(egg_path))\n        return Distribution.from_filename(egg_path, metadata=metadata)\n\n    # FIXME: 'easy_install.install_egg' is too complex (11)\n    def install_egg(self, egg_path, tmpdir):  # noqa: C901\n        destination = os.path.join(\n            self.install_dir,\n            os.path.basename(egg_path),\n        )\n        destination = os.path.abspath(destination)\n        if not self.dry_run:\n            ensure_directory(destination)\n\n        dist = self.egg_distribution(egg_path)\n        if not (\n            os.path.exists(destination) and os.path.samefile(egg_path, destination)\n        ):\n            if os.path.isdir(destination) and not os.path.islink(destination):\n                dir_util.remove_tree(destination, dry_run=self.dry_run)\n            elif os.path.exists(destination):\n                self.execute(\n                    os.unlink,\n                    (destination,),\n                    \"Removing \" + destination,\n                )\n            try:\n                new_dist_is_zipped = False\n                if os.path.isdir(egg_path):\n                    if egg_path.startswith(tmpdir):\n                        f, m = shutil.move, \"Moving\"\n                    else:\n                        f, m = shutil.copytree, \"Copying\"\n                elif self.should_unzip(dist):\n                    self.mkpath(destination)\n                    f, m = self.unpack_and_compile, \"Extracting\"\n                else:\n                    new_dist_is_zipped = True\n                    if egg_path.startswith(tmpdir):\n                        f, m = shutil.move, \"Moving\"\n                    else:\n                        f, m = shutil.copy2, \"Copying\"\n                self.execute(\n                    f,\n                    (egg_path, destination),\n                    (m + \" %s to %s\")\n                    % (os.path.basename(egg_path), os.path.dirname(destination)),\n                )\n                update_dist_caches(\n                    destination,\n                    fix_zipimporter_caches=new_dist_is_zipped,\n                )\n            except Exception:\n                update_dist_caches(destination, fix_zipimporter_caches=False)\n                raise\n\n        self.add_output(destination)\n        return self.egg_distribution(destination)\n\n    def install_exe(self, dist_filename, tmpdir):\n        # See if it's valid, get data\n        cfg = extract_wininst_cfg(dist_filename)\n        if cfg is None:\n            raise DistutilsError(\n                \"%s is not a valid distutils Windows .exe\" % dist_filename\n            )\n        # Create a dummy distribution object until we build the real distro\n        dist = Distribution(\n            None,\n            project_name=cfg.get('metadata', 'name'),\n            version=cfg.get('metadata', 'version'),\n            platform=get_platform(),\n        )\n\n        # Convert the .exe to an unpacked egg\n        egg_path = os.path.join(tmpdir, dist.egg_name() + '.egg')\n        dist.location = egg_path\n        egg_tmp = egg_path + '.tmp'\n        _egg_info = os.path.join(egg_tmp, 'EGG-INFO')\n        pkg_inf = os.path.join(_egg_info, 'PKG-INFO')\n        ensure_directory(pkg_inf)  # make sure EGG-INFO dir exists\n        dist._provider = PathMetadata(egg_tmp, _egg_info)  # XXX\n        self.exe_to_egg(dist_filename, egg_tmp)\n\n        # Write EGG-INFO/PKG-INFO\n        if not os.path.exists(pkg_inf):\n            with open(pkg_inf, 'w', encoding=\"utf-8\") as f:\n                f.write('Metadata-Version: 1.0\\n')\n                for k, v in cfg.items('metadata'):\n                    if k != 'target_version':\n                        f.write('%s: %s\\n' % (k.replace('_', '-').title(), v))\n        script_dir = os.path.join(_egg_info, 'scripts')\n        # delete entry-point scripts to avoid duping\n        self.delete_blockers([\n            os.path.join(script_dir, args[0]) for args in ScriptWriter.get_args(dist)\n        ])\n        # Build .egg file from tmpdir\n        bdist_egg.make_zipfile(\n            egg_path,\n            egg_tmp,\n            verbose=self.verbose,\n            dry_run=self.dry_run,\n        )\n        # install the .egg\n        return self.install_egg(egg_path, tmpdir)\n\n    # FIXME: 'easy_install.exe_to_egg' is too complex (12)\n    def exe_to_egg(self, dist_filename, egg_tmp):  # noqa: C901\n        \"\"\"Extract a bdist_wininst to the directories an egg would use\"\"\"\n        # Check for .pth file and set up prefix translations\n        prefixes = get_exe_prefixes(dist_filename)\n        to_compile = []\n        native_libs = []\n        top_level = set()\n\n        def process(src, dst):\n            s = src.lower()\n            for old, new in prefixes:\n                if s.startswith(old):\n                    src = new + src[len(old) :]\n                    parts = src.split('/')\n                    dst = os.path.join(egg_tmp, *parts)\n                    dl = dst.lower()\n                    if dl.endswith('.pyd') or dl.endswith('.dll'):\n                        parts[-1] = bdist_egg.strip_module(parts[-1])\n                        top_level.add([os.path.splitext(parts[0])[0]])\n                        native_libs.append(src)\n                    elif dl.endswith('.py') and old != 'SCRIPTS/':\n                        top_level.add([os.path.splitext(parts[0])[0]])\n                        to_compile.append(dst)\n                    return dst\n            if not src.endswith('.pth'):\n                log.warn(\"WARNING: can't process %s\", src)\n            return None\n\n        # extract, tracking .pyd/.dll->native_libs and .py -> to_compile\n        unpack_archive(dist_filename, egg_tmp, process)\n        stubs = []\n        for res in native_libs:\n            if res.lower().endswith('.pyd'):  # create stubs for .pyd's\n                parts = res.split('/')\n                resource = parts[-1]\n                parts[-1] = bdist_egg.strip_module(parts[-1]) + '.py'\n                pyfile = os.path.join(egg_tmp, *parts)\n                to_compile.append(pyfile)\n                stubs.append(pyfile)\n                bdist_egg.write_stub(resource, pyfile)\n        self.byte_compile(to_compile)  # compile .py's\n        bdist_egg.write_safety_flag(\n            os.path.join(egg_tmp, 'EGG-INFO'), bdist_egg.analyze_egg(egg_tmp, stubs)\n        )  # write zip-safety flag\n\n        for name in 'top_level', 'native_libs':\n            if locals()[name]:\n                txt = os.path.join(egg_tmp, 'EGG-INFO', name + '.txt')\n                if not os.path.exists(txt):\n                    with open(txt, 'w', encoding=\"utf-8\") as f:\n                        f.write('\\n'.join(locals()[name]) + '\\n')\n\n    def install_wheel(self, wheel_path, tmpdir):\n        wheel = Wheel(wheel_path)\n        assert wheel.is_compatible()\n        destination = os.path.join(self.install_dir, wheel.egg_name())\n        destination = os.path.abspath(destination)\n        if not self.dry_run:\n            ensure_directory(destination)\n        if os.path.isdir(destination) and not os.path.islink(destination):\n            dir_util.remove_tree(destination, dry_run=self.dry_run)\n        elif os.path.exists(destination):\n            self.execute(\n                os.unlink,\n                (destination,),\n                \"Removing \" + destination,\n            )\n        try:\n            self.execute(\n                wheel.install_as_egg,\n                (destination,),\n                (\"Installing %s to %s\")\n                % (os.path.basename(wheel_path), os.path.dirname(destination)),\n            )\n        finally:\n            update_dist_caches(destination, fix_zipimporter_caches=False)\n        self.add_output(destination)\n        return self.egg_distribution(destination)\n\n    __mv_warning = textwrap.dedent(\n        \"\"\"\n        Because this distribution was installed --multi-version, before you can\n        import modules from this package in an application, you will need to\n        'import pkg_resources' and then use a 'require()' call similar to one of\n        these examples, in order to select the desired version:\n\n            pkg_resources.require(\"%(name)s\")  # latest installed version\n            pkg_resources.require(\"%(name)s==%(version)s\")  # this exact version\n            pkg_resources.require(\"%(name)s>=%(version)s\")  # this version or higher\n        \"\"\"\n    ).lstrip()  # noqa\n\n    __id_warning = textwrap.dedent(\n        \"\"\"\n        Note also that the installation directory must be on sys.path at runtime for\n        this to work.  (e.g. by being the application's script directory, by being on\n        PYTHONPATH, or by being added to sys.path by your code.)\n        \"\"\"\n    )  # noqa\n\n    def installation_report(self, req, dist, what=\"Installed\"):\n        \"\"\"Helpful installation message for display to package users\"\"\"\n        msg = \"\\n%(what)s %(eggloc)s%(extras)s\"\n        if self.multi_version and not self.no_report:\n            msg += '\\n' + self.__mv_warning\n            if self.install_dir not in map(normalize_path, sys.path):\n                msg += '\\n' + self.__id_warning\n\n        eggloc = dist.location\n        name = dist.project_name\n        version = dist.version\n        extras = ''  # TODO: self.report_extras(req, dist)\n        return msg % locals()\n\n    __editable_msg = textwrap.dedent(\n        \"\"\"\n        Extracted editable version of %(spec)s to %(dirname)s\n\n        If it uses setuptools in its setup script, you can activate it in\n        \"development\" mode by going to that directory and running::\n\n            %(python)s setup.py develop\n\n        See the setuptools documentation for the \"develop\" command for more info.\n        \"\"\"\n    ).lstrip()  # noqa\n\n    def report_editable(self, spec, setup_script):\n        dirname = os.path.dirname(setup_script)\n        python = sys.executable\n        return '\\n' + self.__editable_msg % locals()\n\n    def run_setup(self, setup_script, setup_base, args):\n        sys.modules.setdefault('distutils.command.bdist_egg', bdist_egg)\n        sys.modules.setdefault('distutils.command.egg_info', egg_info)\n\n        args = list(args)\n        if self.verbose > 2:\n            v = 'v' * (self.verbose - 1)\n            args.insert(0, '-' + v)\n        elif self.verbose < 2:\n            args.insert(0, '-q')\n        if self.dry_run:\n            args.insert(0, '-n')\n        log.info(\"Running %s %s\", setup_script[len(setup_base) + 1 :], ' '.join(args))\n        try:\n            run_setup(setup_script, args)\n        except SystemExit as v:\n            raise DistutilsError(\"Setup script exited with %s\" % (v.args[0],)) from v\n\n    def build_and_install(self, setup_script, setup_base):\n        args = ['bdist_egg', '--dist-dir']\n\n        dist_dir = tempfile.mkdtemp(\n            prefix='egg-dist-tmp-', dir=os.path.dirname(setup_script)\n        )\n        try:\n            self._set_fetcher_options(os.path.dirname(setup_script))\n            args.append(dist_dir)\n\n            self.run_setup(setup_script, setup_base, args)\n            all_eggs = Environment([dist_dir])\n            eggs = []\n            for key in all_eggs:\n                for dist in all_eggs[key]:\n                    eggs.append(self.install_egg(dist.location, setup_base))\n            if not eggs and not self.dry_run:\n                log.warn(\"No eggs found in %s (setup script problem?)\", dist_dir)\n            return eggs\n        finally:\n            _rmtree(dist_dir)\n            log.set_verbosity(self.verbose)  # restore our log verbosity\n\n    def _set_fetcher_options(self, base):\n        \"\"\"\n        When easy_install is about to run bdist_egg on a source dist, that\n        source dist might have 'setup_requires' directives, requiring\n        additional fetching. Ensure the fetcher options given to easy_install\n        are available to that command as well.\n        \"\"\"\n        # find the fetch options from easy_install and write them out\n        # to the setup.cfg file.\n        ei_opts = self.distribution.get_option_dict('easy_install').copy()\n        fetch_directives = (\n            'find_links',\n            'site_dirs',\n            'index_url',\n            'optimize',\n            'allow_hosts',\n        )\n        fetch_options = {}\n        for key, val in ei_opts.items():\n            if key not in fetch_directives:\n                continue\n            fetch_options[key] = val[1]\n        # create a settings dictionary suitable for `edit_config`\n        settings = dict(easy_install=fetch_options)\n        cfg_filename = os.path.join(base, 'setup.cfg')\n        setopt.edit_config(cfg_filename, settings)\n\n    def update_pth(self, dist):  # noqa: C901  # is too complex (11)  # FIXME\n        if self.pth_file is None:\n            return\n\n        for d in self.pth_file[dist.key]:  # drop old entries\n            if not self.multi_version and d.location == dist.location:\n                continue\n\n            log.info(\"Removing %s from easy-install.pth file\", d)\n            self.pth_file.remove(d)\n            if d.location in self.shadow_path:\n                self.shadow_path.remove(d.location)\n\n        if not self.multi_version:\n            if dist.location in self.pth_file.paths:\n                log.info(\n                    \"%s is already the active version in easy-install.pth\",\n                    dist,\n                )\n            else:\n                log.info(\"Adding %s to easy-install.pth file\", dist)\n                self.pth_file.add(dist)  # add new entry\n                if dist.location not in self.shadow_path:\n                    self.shadow_path.append(dist.location)\n\n        if self.dry_run:\n            return\n\n        self.pth_file.save()\n\n        if dist.key != 'setuptools':\n            return\n\n        # Ensure that setuptools itself never becomes unavailable!\n        # XXX should this check for latest version?\n        filename = os.path.join(self.install_dir, 'setuptools.pth')\n        if os.path.islink(filename):\n            os.unlink(filename)\n\n        with open(filename, 'wt', encoding=py39.LOCALE_ENCODING) as f:\n            # Requires encoding=\"locale\" instead of \"utf-8\" (python/cpython#77102).\n            f.write(self.pth_file.make_relative(dist.location) + '\\n')\n\n    def unpack_progress(self, src, dst):\n        # Progress filter for unpacking\n        log.debug(\"Unpacking %s to %s\", src, dst)\n        return dst  # only unpack-and-compile skips files for dry run\n\n    def unpack_and_compile(self, egg_path, destination):\n        to_compile = []\n        to_chmod = []\n\n        def pf(src, dst):\n            if dst.endswith('.py') and not src.startswith('EGG-INFO/'):\n                to_compile.append(dst)\n            elif dst.endswith('.dll') or dst.endswith('.so'):\n                to_chmod.append(dst)\n            self.unpack_progress(src, dst)\n            return not self.dry_run and dst or None\n\n        unpack_archive(egg_path, destination, pf)\n        self.byte_compile(to_compile)\n        if not self.dry_run:\n            for f in to_chmod:\n                mode = ((os.stat(f)[stat.ST_MODE]) | 0o555) & 0o7755\n                chmod(f, mode)\n\n    def byte_compile(self, to_compile):\n        if sys.dont_write_bytecode:\n            return\n\n        from distutils.util import byte_compile\n\n        try:\n            # try to make the byte compile messages quieter\n            log.set_verbosity(self.verbose - 1)\n\n            byte_compile(to_compile, optimize=0, force=True, dry_run=self.dry_run)\n            if self.optimize:\n                byte_compile(\n                    to_compile,\n                    optimize=self.optimize,\n                    force=True,\n                    dry_run=self.dry_run,\n                )\n        finally:\n            log.set_verbosity(self.verbose)  # restore original verbosity\n\n    __no_default_msg = textwrap.dedent(\n        \"\"\"\n        bad install directory or PYTHONPATH\n\n        You are attempting to install a package to a directory that is not\n        on PYTHONPATH and which Python does not read \".pth\" files from.  The\n        installation directory you specified (via --install-dir, --prefix, or\n        the distutils default setting) was:\n\n            %s\n\n        and your PYTHONPATH environment variable currently contains:\n\n            %r\n\n        Here are some of your options for correcting the problem:\n\n        * You can choose a different installation directory, i.e., one that is\n          on PYTHONPATH or supports .pth files\n\n        * You can add the installation directory to the PYTHONPATH environment\n          variable.  (It must then also be on PYTHONPATH whenever you run\n          Python and want to use the package(s) you are installing.)\n\n        * You can set up the installation directory to support \".pth\" files by\n          using one of the approaches described here:\n\n          https://setuptools.pypa.io/en/latest/deprecated/easy_install.html#custom-installation-locations\n\n\n        Please make the appropriate changes for your system and try again.\n        \"\"\"\n    ).strip()\n\n    def create_home_path(self):\n        \"\"\"Create directories under ~.\"\"\"\n        if not self.user:\n            return\n        home = convert_path(os.path.expanduser(\"~\"))\n        for path in only_strs(self.config_vars.values()):\n            if path.startswith(home) and not os.path.isdir(path):\n                self.debug_print(\"os.makedirs('%s', 0o700)\" % path)\n                os.makedirs(path, 0o700)\n\n    INSTALL_SCHEMES = dict(\n        posix=dict(\n            install_dir='$base/lib/python$py_version_short/site-packages',\n            script_dir='$base/bin',\n        ),\n    )\n\n    DEFAULT_SCHEME = dict(\n        install_dir='$base/Lib/site-packages',\n        script_dir='$base/Scripts',\n    )\n\n    def _expand(self, *attrs):\n        config_vars = self.get_finalized_command('install').config_vars\n\n        if self.prefix:\n            # Set default install_dir/scripts from --prefix\n            config_vars = dict(config_vars)\n            config_vars['base'] = self.prefix\n            scheme = self.INSTALL_SCHEMES.get(os.name, self.DEFAULT_SCHEME)\n            for attr, val in scheme.items():\n                if getattr(self, attr, None) is None:\n                    setattr(self, attr, val)\n\n        from distutils.util import subst_vars\n\n        for attr in attrs:\n            val = getattr(self, attr)\n            if val is not None:\n                val = subst_vars(val, config_vars)\n                if os.name == 'posix':\n                    val = os.path.expanduser(val)\n                setattr(self, attr, val)\n\n\ndef _pythonpath():\n    items = os.environ.get('PYTHONPATH', '').split(os.pathsep)\n    return filter(None, items)\n\n\ndef get_site_dirs():\n    \"\"\"\n    Return a list of 'site' dirs\n    \"\"\"\n\n    sitedirs = []\n\n    # start with PYTHONPATH\n    sitedirs.extend(_pythonpath())\n\n    prefixes = [sys.prefix]\n    if sys.exec_prefix != sys.prefix:\n        prefixes.append(sys.exec_prefix)\n    for prefix in prefixes:\n        if not prefix:\n            continue\n\n        if sys.platform in ('os2emx', 'riscos'):\n            sitedirs.append(os.path.join(prefix, \"Lib\", \"site-packages\"))\n        elif os.sep == '/':\n            sitedirs.extend([\n                os.path.join(\n                    prefix,\n                    \"lib\",\n                    \"python{}.{}\".format(*sys.version_info),\n                    \"site-packages\",\n                ),\n                os.path.join(prefix, \"lib\", \"site-python\"),\n            ])\n        else:\n            sitedirs.extend([\n                prefix,\n                os.path.join(prefix, \"lib\", \"site-packages\"),\n            ])\n        if sys.platform != 'darwin':\n            continue\n\n        # for framework builds *only* we add the standard Apple\n        # locations. Currently only per-user, but /Library and\n        # /Network/Library could be added too\n        if 'Python.framework' not in prefix:\n            continue\n\n        home = os.environ.get('HOME')\n        if not home:\n            continue\n\n        home_sp = os.path.join(\n            home,\n            'Library',\n            'Python',\n            '{}.{}'.format(*sys.version_info),\n            'site-packages',\n        )\n        sitedirs.append(home_sp)\n    lib_paths = get_path('purelib'), get_path('platlib')\n\n    sitedirs.extend(s for s in lib_paths if s not in sitedirs)\n\n    if site.ENABLE_USER_SITE:\n        sitedirs.append(site.USER_SITE)\n\n    with contextlib.suppress(AttributeError):\n        sitedirs.extend(site.getsitepackages())\n\n    return list(map(normalize_path, sitedirs))\n\n\ndef expand_paths(inputs):  # noqa: C901  # is too complex (11)  # FIXME\n    \"\"\"Yield sys.path directories that might contain \"old-style\" packages\"\"\"\n\n    seen = set()\n\n    for dirname in inputs:\n        dirname = normalize_path(dirname)\n        if dirname in seen:\n            continue\n\n        seen.add(dirname)\n        if not os.path.isdir(dirname):\n            continue\n\n        files = os.listdir(dirname)\n        yield dirname, files\n\n        for name in files:\n            if not name.endswith('.pth'):\n                # We only care about the .pth files\n                continue\n            if name in ('easy-install.pth', 'setuptools.pth'):\n                # Ignore .pth files that we control\n                continue\n\n            # Read the .pth file\n            with open(os.path.join(dirname, name), encoding=py39.LOCALE_ENCODING) as f:\n                # Requires encoding=\"locale\" instead of \"utf-8\" (python/cpython#77102).\n                lines = list(yield_lines(f))\n\n            # Yield existing non-dupe, non-import directory lines from it\n            for line in lines:\n                if line.startswith(\"import\"):\n                    continue\n\n                line = normalize_path(line.rstrip())\n                if line in seen:\n                    continue\n\n                seen.add(line)\n                if not os.path.isdir(line):\n                    continue\n\n                yield line, os.listdir(line)\n\n\ndef extract_wininst_cfg(dist_filename):\n    \"\"\"Extract configuration data from a bdist_wininst .exe\n\n    Returns a configparser.RawConfigParser, or None\n    \"\"\"\n    f = open(dist_filename, 'rb')\n    try:\n        endrec = zipfile._EndRecData(f)\n        if endrec is None:\n            return None\n\n        prepended = (endrec[9] - endrec[5]) - endrec[6]\n        if prepended < 12:  # no wininst data here\n            return None\n        f.seek(prepended - 12)\n\n        tag, cfglen, bmlen = struct.unpack(\"<iii\", f.read(12))\n        if tag not in (0x1234567A, 0x1234567B):\n            return None  # not a valid tag\n\n        f.seek(prepended - (12 + cfglen))\n        init = {'version': '', 'target_version': ''}\n        cfg = configparser.RawConfigParser(init)\n        try:\n            part = f.read(cfglen)\n            # Read up to the first null byte.\n            config = part.split(b'\\0', 1)[0]\n            # Now the config is in bytes, but for RawConfigParser, it should\n            #  be text, so decode it.\n            config = config.decode(sys.getfilesystemencoding())\n            cfg.read_file(io.StringIO(config))\n        except configparser.Error:\n            return None\n        if not cfg.has_section('metadata') or not cfg.has_section('Setup'):\n            return None\n        return cfg\n\n    finally:\n        f.close()\n\n\ndef get_exe_prefixes(exe_filename):\n    \"\"\"Get exe->egg path translations for a given .exe file\"\"\"\n\n    prefixes = [\n        ('PURELIB/', ''),\n        ('PLATLIB/pywin32_system32', ''),\n        ('PLATLIB/', ''),\n        ('SCRIPTS/', 'EGG-INFO/scripts/'),\n        ('DATA/lib/site-packages', ''),\n    ]\n    z = zipfile.ZipFile(exe_filename)\n    try:\n        for info in z.infolist():\n            name = info.filename\n            parts = name.split('/')\n            if len(parts) == 3 and parts[2] == 'PKG-INFO':\n                if parts[1].endswith('.egg-info'):\n                    prefixes.insert(0, ('/'.join(parts[:2]), 'EGG-INFO/'))\n                    break\n            if len(parts) != 2 or not name.endswith('.pth'):\n                continue\n            if name.endswith('-nspkg.pth'):\n                continue\n            if parts[0].upper() in ('PURELIB', 'PLATLIB'):\n                contents = z.read(name).decode()\n                for pth in yield_lines(contents):\n                    pth = pth.strip().replace('\\\\', '/')\n                    if not pth.startswith('import'):\n                        prefixes.append((('%s/%s/' % (parts[0], pth)), ''))\n    finally:\n        z.close()\n    prefixes = [(x.lower(), y) for x, y in prefixes]\n    prefixes.sort()\n    prefixes.reverse()\n    return prefixes\n\n\nclass PthDistributions(Environment):\n    \"\"\"A .pth file with Distribution paths in it\"\"\"\n\n    def __init__(self, filename, sitedirs=()):\n        self.filename = filename\n        self.sitedirs = list(map(normalize_path, sitedirs))\n        self.basedir = normalize_path(os.path.dirname(self.filename))\n        self.paths, self.dirty = self._load()\n        # keep a copy if someone manually updates the paths attribute on the instance\n        self._init_paths = self.paths[:]\n        super().__init__([], None, None)\n        for path in yield_lines(self.paths):\n            list(map(self.add, find_distributions(path, True)))\n\n    def _load_raw(self):\n        paths = []\n        dirty = saw_import = False\n        seen = set(self.sitedirs)\n        f = open(self.filename, 'rt', encoding=py39.LOCALE_ENCODING)\n        # ^-- Requires encoding=\"locale\" instead of \"utf-8\" (python/cpython#77102).\n        for line in f:\n            path = line.rstrip()\n            # still keep imports and empty/commented lines for formatting\n            paths.append(path)\n            if line.startswith(('import ', 'from ')):\n                saw_import = True\n                continue\n            stripped_path = path.strip()\n            if not stripped_path or stripped_path.startswith('#'):\n                continue\n            # skip non-existent paths, in case somebody deleted a package\n            # manually, and duplicate paths as well\n            normalized_path = normalize_path(os.path.join(self.basedir, path))\n            if normalized_path in seen or not os.path.exists(normalized_path):\n                log.debug(\"cleaned up dirty or duplicated %r\", path)\n                dirty = True\n                paths.pop()\n                continue\n            seen.add(normalized_path)\n        f.close()\n        # remove any trailing empty/blank line\n        while paths and not paths[-1].strip():\n            paths.pop()\n            dirty = True\n        return paths, dirty or (paths and saw_import)\n\n    def _load(self):\n        if os.path.isfile(self.filename):\n            return self._load_raw()\n        return [], False\n\n    def save(self):\n        \"\"\"Write changed .pth file back to disk\"\"\"\n        # first reload the file\n        last_paths, last_dirty = self._load()\n        # and check that there are no difference with what we have.\n        # there can be difference if someone else has written to the file\n        # since we first loaded it.\n        # we don't want to lose the eventual new paths added since then.\n        for path in last_paths[:]:\n            if path not in self.paths:\n                self.paths.append(path)\n                log.info(\"detected new path %r\", path)\n                last_dirty = True\n            else:\n                last_paths.remove(path)\n        # also, re-check that all paths are still valid before saving them\n        for path in self.paths[:]:\n            if path not in last_paths and not path.startswith((\n                'import ',\n                'from ',\n                '#',\n            )):\n                absolute_path = os.path.join(self.basedir, path)\n                if not os.path.exists(absolute_path):\n                    self.paths.remove(path)\n                    log.info(\"removing now non-existent path %r\", path)\n                    last_dirty = True\n\n        self.dirty |= last_dirty or self.paths != self._init_paths\n        if not self.dirty:\n            return\n\n        rel_paths = list(map(self.make_relative, self.paths))\n        if rel_paths:\n            log.debug(\"Saving %s\", self.filename)\n            lines = self._wrap_lines(rel_paths)\n            data = '\\n'.join(lines) + '\\n'\n            if os.path.islink(self.filename):\n                os.unlink(self.filename)\n            with open(self.filename, 'wt', encoding=py39.LOCALE_ENCODING) as f:\n                # Requires encoding=\"locale\" instead of \"utf-8\" (python/cpython#77102).\n                f.write(data)\n        elif os.path.exists(self.filename):\n            log.debug(\"Deleting empty %s\", self.filename)\n            os.unlink(self.filename)\n\n        self.dirty = False\n        self._init_paths[:] = self.paths[:]\n\n    @staticmethod\n    def _wrap_lines(lines):\n        return lines\n\n    def add(self, dist):\n        \"\"\"Add `dist` to the distribution map\"\"\"\n        new_path = dist.location not in self.paths and (\n            dist.location not in self.sitedirs\n            or\n            # account for '.' being in PYTHONPATH\n            dist.location == os.getcwd()\n        )\n        if new_path:\n            self.paths.append(dist.location)\n            self.dirty = True\n        super().add(dist)\n\n    def remove(self, dist):\n        \"\"\"Remove `dist` from the distribution map\"\"\"\n        while dist.location in self.paths:\n            self.paths.remove(dist.location)\n            self.dirty = True\n        super().remove(dist)\n\n    def make_relative(self, path):\n        npath, last = os.path.split(normalize_path(path))\n        baselen = len(self.basedir)\n        parts = [last]\n        sep = os.altsep == '/' and '/' or os.sep\n        while len(npath) >= baselen:\n            if npath == self.basedir:\n                parts.append(os.curdir)\n                parts.reverse()\n                return sep.join(parts)\n            npath, last = os.path.split(npath)\n            parts.append(last)\n        else:\n            return path\n\n\nclass RewritePthDistributions(PthDistributions):\n    @classmethod\n    def _wrap_lines(cls, lines):\n        yield cls.prelude\n        yield from lines\n        yield cls.postlude\n\n    prelude = _one_liner(\n        \"\"\"\n        import sys\n        sys.__plen = len(sys.path)\n        \"\"\"\n    )\n    postlude = _one_liner(\n        \"\"\"\n        import sys\n        new = sys.path[sys.__plen:]\n        del sys.path[sys.__plen:]\n        p = getattr(sys, '__egginsert', 0)\n        sys.path[p:p] = new\n        sys.__egginsert = p + len(new)\n        \"\"\"\n    )\n\n\nif os.environ.get('SETUPTOOLS_SYS_PATH_TECHNIQUE', 'raw') == 'rewrite':\n    PthDistributions = RewritePthDistributions  # type: ignore[misc]  # Overwriting type\n\n\ndef _first_line_re():\n    \"\"\"\n    Return a regular expression based on first_line_re suitable for matching\n    strings.\n    \"\"\"\n    if isinstance(first_line_re.pattern, str):\n        return first_line_re\n\n    # first_line_re in Python >=3.1.4 and >=3.2.1 is a bytes pattern.\n    return re.compile(first_line_re.pattern.decode())\n\n\ndef auto_chmod(func, arg, exc):\n    if func in [os.unlink, os.remove] and os.name == 'nt':\n        chmod(arg, stat.S_IWRITE)\n        return func(arg)\n    et, ev, _ = sys.exc_info()\n    # TODO: This code doesn't make sense. What is it trying to do?\n    raise (ev[0], ev[1] + (\" %s %s\" % (func, arg)))\n\n\ndef update_dist_caches(dist_path, fix_zipimporter_caches):\n    \"\"\"\n    Fix any globally cached `dist_path` related data\n\n    `dist_path` should be a path of a newly installed egg distribution (zipped\n    or unzipped).\n\n    sys.path_importer_cache contains finder objects that have been cached when\n    importing data from the original distribution. Any such finders need to be\n    cleared since the replacement distribution might be packaged differently,\n    e.g. a zipped egg distribution might get replaced with an unzipped egg\n    folder or vice versa. Having the old finders cached may then cause Python\n    to attempt loading modules from the replacement distribution using an\n    incorrect loader.\n\n    zipimport.zipimporter objects are Python loaders charged with importing\n    data packaged inside zip archives. If stale loaders referencing the\n    original distribution, are left behind, they can fail to load modules from\n    the replacement distribution. E.g. if an old zipimport.zipimporter instance\n    is used to load data from a new zipped egg archive, it may cause the\n    operation to attempt to locate the requested data in the wrong location -\n    one indicated by the original distribution's zip archive directory\n    information. Such an operation may then fail outright, e.g. report having\n    read a 'bad local file header', or even worse, it may fail silently &\n    return invalid data.\n\n    zipimport._zip_directory_cache contains cached zip archive directory\n    information for all existing zipimport.zipimporter instances and all such\n    instances connected to the same archive share the same cached directory\n    information.\n\n    If asked, and the underlying Python implementation allows it, we can fix\n    all existing zipimport.zipimporter instances instead of having to track\n    them down and remove them one by one, by updating their shared cached zip\n    archive directory information. This, of course, assumes that the\n    replacement distribution is packaged as a zipped egg.\n\n    If not asked to fix existing zipimport.zipimporter instances, we still do\n    our best to clear any remaining zipimport.zipimporter related cached data\n    that might somehow later get used when attempting to load data from the new\n    distribution and thus cause such load operations to fail. Note that when\n    tracking down such remaining stale data, we can not catch every conceivable\n    usage from here, and we clear only those that we know of and have found to\n    cause problems if left alive. Any remaining caches should be updated by\n    whomever is in charge of maintaining them, i.e. they should be ready to\n    handle us replacing their zip archives with new distributions at runtime.\n\n    \"\"\"\n    # There are several other known sources of stale zipimport.zipimporter\n    # instances that we do not clear here, but might if ever given a reason to\n    # do so:\n    # * Global setuptools pkg_resources.working_set (a.k.a. 'master working\n    # set') may contain distributions which may in turn contain their\n    #   zipimport.zipimporter loaders.\n    # * Several zipimport.zipimporter loaders held by local variables further\n    #   up the function call stack when running the setuptools installation.\n    # * Already loaded modules may have their __loader__ attribute set to the\n    #   exact loader instance used when importing them. Python 3.4 docs state\n    #   that this information is intended mostly for introspection and so is\n    #   not expected to cause us problems.\n    normalized_path = normalize_path(dist_path)\n    _uncache(normalized_path, sys.path_importer_cache)\n    if fix_zipimporter_caches:\n        _replace_zip_directory_cache_data(normalized_path)\n    else:\n        # Here, even though we do not want to fix existing and now stale\n        # zipimporter cache information, we still want to remove it. Related to\n        # Python's zip archive directory information cache, we clear each of\n        # its stale entries in two phases:\n        #   1. Clear the entry so attempting to access zip archive information\n        #      via any existing stale zipimport.zipimporter instances fails.\n        #   2. Remove the entry from the cache so any newly constructed\n        #      zipimport.zipimporter instances do not end up using old stale\n        #      zip archive directory information.\n        # This whole stale data removal step does not seem strictly necessary,\n        # but has been left in because it was done before we started replacing\n        # the zip archive directory information cache content if possible, and\n        # there are no relevant unit tests that we can depend on to tell us if\n        # this is really needed.\n        _remove_and_clear_zip_directory_cache_data(normalized_path)\n\n\ndef _collect_zipimporter_cache_entries(normalized_path, cache):\n    \"\"\"\n    Return zipimporter cache entry keys related to a given normalized path.\n\n    Alternative path spellings (e.g. those using different character case or\n    those using alternative path separators) related to the same path are\n    included. Any sub-path entries are included as well, i.e. those\n    corresponding to zip archives embedded in other zip archives.\n\n    \"\"\"\n    result = []\n    prefix_len = len(normalized_path)\n    for p in cache:\n        np = normalize_path(p)\n        if np.startswith(normalized_path) and np[prefix_len : prefix_len + 1] in (\n            os.sep,\n            '',\n        ):\n            result.append(p)\n    return result\n\n\ndef _update_zipimporter_cache(normalized_path, cache, updater=None):\n    \"\"\"\n    Update zipimporter cache data for a given normalized path.\n\n    Any sub-path entries are processed as well, i.e. those corresponding to zip\n    archives embedded in other zip archives.\n\n    Given updater is a callable taking a cache entry key and the original entry\n    (after already removing the entry from the cache), and expected to update\n    the entry and possibly return a new one to be inserted in its place.\n    Returning None indicates that the entry should not be replaced with a new\n    one. If no updater is given, the cache entries are simply removed without\n    any additional processing, the same as if the updater simply returned None.\n\n    \"\"\"\n    for p in _collect_zipimporter_cache_entries(normalized_path, cache):\n        # N.B. pypy's custom zipimport._zip_directory_cache implementation does\n        # not support the complete dict interface:\n        # * Does not support item assignment, thus not allowing this function\n        #    to be used only for removing existing cache entries.\n        #  * Does not support the dict.pop() method, forcing us to use the\n        #    get/del patterns instead. For more detailed information see the\n        #    following links:\n        #      https://github.com/pypa/setuptools/issues/202#issuecomment-202913420\n        #      https://foss.heptapod.net/pypy/pypy/-/blob/144c4e65cb6accb8e592f3a7584ea38265d1873c/pypy/module/zipimport/interp_zipimport.py\n        old_entry = cache[p]\n        del cache[p]\n        new_entry = updater and updater(p, old_entry)\n        if new_entry is not None:\n            cache[p] = new_entry\n\n\ndef _uncache(normalized_path, cache):\n    _update_zipimporter_cache(normalized_path, cache)\n\n\ndef _remove_and_clear_zip_directory_cache_data(normalized_path):\n    def clear_and_remove_cached_zip_archive_directory_data(path, old_entry):\n        old_entry.clear()\n\n    _update_zipimporter_cache(\n        normalized_path,\n        zipimport._zip_directory_cache,\n        updater=clear_and_remove_cached_zip_archive_directory_data,\n    )\n\n\n# PyPy Python implementation does not allow directly writing to the\n# zipimport._zip_directory_cache and so prevents us from attempting to correct\n# its content. The best we can do there is clear the problematic cache content\n# and have PyPy repopulate it as needed. The downside is that if there are any\n# stale zipimport.zipimporter instances laying around, attempting to use them\n# will fail due to not having its zip archive directory information available\n# instead of being automatically corrected to use the new correct zip archive\n# directory information.\nif '__pypy__' in sys.builtin_module_names:\n    _replace_zip_directory_cache_data = _remove_and_clear_zip_directory_cache_data\nelse:\n\n    def _replace_zip_directory_cache_data(normalized_path):\n        def replace_cached_zip_archive_directory_data(path, old_entry):\n            # N.B. In theory, we could load the zip directory information just\n            # once for all updated path spellings, and then copy it locally and\n            # update its contained path strings to contain the correct\n            # spelling, but that seems like a way too invasive move (this cache\n            # structure is not officially documented anywhere and could in\n            # theory change with new Python releases) for no significant\n            # benefit.\n            old_entry.clear()\n            zipimport.zipimporter(path)\n            old_entry.update(zipimport._zip_directory_cache[path])\n            return old_entry\n\n        _update_zipimporter_cache(\n            normalized_path,\n            zipimport._zip_directory_cache,\n            updater=replace_cached_zip_archive_directory_data,\n        )\n\n\ndef is_python(text, filename='<string>'):\n    \"Is this string a valid Python script?\"\n    try:\n        compile(text, filename, 'exec')\n    except (SyntaxError, TypeError):\n        return False\n    else:\n        return True\n\n\ndef is_sh(executable):\n    \"\"\"Determine if the specified executable is a .sh (contains a #! line)\"\"\"\n    try:\n        with open(executable, encoding='latin-1') as fp:\n            magic = fp.read(2)\n    except OSError:\n        return executable\n    return magic == '#!'\n\n\ndef nt_quote_arg(arg):\n    \"\"\"Quote a command line argument according to Windows parsing rules\"\"\"\n    return subprocess.list2cmdline([arg])\n\n\ndef is_python_script(script_text, filename):\n    \"\"\"Is this text, as a whole, a Python script? (as opposed to shell/bat/etc.\"\"\"\n    if filename.endswith('.py') or filename.endswith('.pyw'):\n        return True  # extension says it's Python\n    if is_python(script_text, filename):\n        return True  # it's syntactically valid Python\n    if script_text.startswith('#!'):\n        # It begins with a '#!' line, so check if 'python' is in it somewhere\n        return 'python' in script_text.splitlines()[0].lower()\n\n    return False  # Not any Python I can recognize\n\n\ntry:\n    from os import chmod as _chmod\nexcept ImportError:\n    # Jython compatibility\n    def _chmod(*args: object, **kwargs: object) -> None:  # type: ignore[misc] # Mypy re-uses the imported definition anyway\n        pass\n\n\ndef chmod(path, mode):\n    log.debug(\"changing mode of %s to %o\", path, mode)\n    try:\n        _chmod(path, mode)\n    except OSError as e:\n        log.debug(\"chmod failed: %s\", e)\n\n\nclass CommandSpec(list):\n    \"\"\"\n    A command spec for a #! header, specified as a list of arguments akin to\n    those passed to Popen.\n    \"\"\"\n\n    options: list[str] = []\n    split_args: dict[str, bool] = dict()\n\n    @classmethod\n    def best(cls):\n        \"\"\"\n        Choose the best CommandSpec class based on environmental conditions.\n        \"\"\"\n        return cls\n\n    @classmethod\n    def _sys_executable(cls):\n        _default = os.path.normpath(sys.executable)\n        return os.environ.get('__PYVENV_LAUNCHER__', _default)\n\n    @classmethod\n    def from_param(cls, param):\n        \"\"\"\n        Construct a CommandSpec from a parameter to build_scripts, which may\n        be None.\n        \"\"\"\n        if isinstance(param, cls):\n            return param\n        if isinstance(param, list):\n            return cls(param)\n        if param is None:\n            return cls.from_environment()\n        # otherwise, assume it's a string.\n        return cls.from_string(param)\n\n    @classmethod\n    def from_environment(cls):\n        return cls([cls._sys_executable()])\n\n    @classmethod\n    def from_string(cls, string):\n        \"\"\"\n        Construct a command spec from a simple string representing a command\n        line parseable by shlex.split.\n        \"\"\"\n        items = shlex.split(string, **cls.split_args)\n        return cls(items)\n\n    def install_options(self, script_text):\n        self.options = shlex.split(self._extract_options(script_text))\n        cmdline = subprocess.list2cmdline(self)\n        if not isascii(cmdline):\n            self.options[:0] = ['-x']\n\n    @staticmethod\n    def _extract_options(orig_script):\n        \"\"\"\n        Extract any options from the first line of the script.\n        \"\"\"\n        first = (orig_script + '\\n').splitlines()[0]\n        match = _first_line_re().match(first)\n        options = match.group(1) or '' if match else ''\n        return options.strip()\n\n    def as_header(self):\n        return self._render(self + list(self.options))\n\n    @staticmethod\n    def _strip_quotes(item):\n        _QUOTES = '\"\\''\n        for q in _QUOTES:\n            if item.startswith(q) and item.endswith(q):\n                return item[1:-1]\n        return item\n\n    @staticmethod\n    def _render(items):\n        cmdline = subprocess.list2cmdline(\n            CommandSpec._strip_quotes(item.strip()) for item in items\n        )\n        return '#!' + cmdline + '\\n'\n\n\n# For pbr compat; will be removed in a future version.\nsys_executable = CommandSpec._sys_executable()\n\n\nclass WindowsCommandSpec(CommandSpec):\n    split_args = dict(posix=False)\n\n\nclass ScriptWriter:\n    \"\"\"\n    Encapsulates behavior around writing entry point scripts for console and\n    gui apps.\n    \"\"\"\n\n    template = textwrap.dedent(\n        r\"\"\"\n        # EASY-INSTALL-ENTRY-SCRIPT: %(spec)r,%(group)r,%(name)r\n        import re\n        import sys\n\n        # for compatibility with easy_install; see #2198\n        __requires__ = %(spec)r\n\n        try:\n            from importlib.metadata import distribution\n        except ImportError:\n            try:\n                from importlib_metadata import distribution\n            except ImportError:\n                from pkg_resources import load_entry_point\n\n\n        def importlib_load_entry_point(spec, group, name):\n            dist_name, _, _ = spec.partition('==')\n            matches = (\n                entry_point\n                for entry_point in distribution(dist_name).entry_points\n                if entry_point.group == group and entry_point.name == name\n            )\n            return next(matches).load()\n\n\n        globals().setdefault('load_entry_point', importlib_load_entry_point)\n\n\n        if __name__ == '__main__':\n            sys.argv[0] = re.sub(r'(-script\\.pyw?|\\.exe)?$', '', sys.argv[0])\n            sys.exit(load_entry_point(%(spec)r, %(group)r, %(name)r)())\n        \"\"\"\n    ).lstrip()\n\n    command_spec_class = CommandSpec\n\n    @classmethod\n    def get_args(cls, dist, header=None):\n        \"\"\"\n        Yield write_script() argument tuples for a distribution's\n        console_scripts and gui_scripts entry points.\n        \"\"\"\n        if header is None:\n            header = cls.get_header()\n        spec = str(dist.as_requirement())\n        for type_ in 'console', 'gui':\n            group = type_ + '_scripts'\n            for name, ep in dist.get_entry_map(group).items():\n                cls._ensure_safe_name(name)\n                script_text = cls.template % locals()\n                args = cls._get_script_args(type_, name, header, script_text)\n                yield from args\n\n    @staticmethod\n    def _ensure_safe_name(name):\n        \"\"\"\n        Prevent paths in *_scripts entry point names.\n        \"\"\"\n        has_path_sep = re.search(r'[\\\\/]', name)\n        if has_path_sep:\n            raise ValueError(\"Path separators not allowed in script names\")\n\n    @classmethod\n    def best(cls):\n        \"\"\"\n        Select the best ScriptWriter for this environment.\n        \"\"\"\n        if sys.platform == 'win32' or (os.name == 'java' and os._name == 'nt'):\n            return WindowsScriptWriter.best()\n        else:\n            return cls\n\n    @classmethod\n    def _get_script_args(cls, type_, name, header, script_text):\n        # Simply write the stub with no extension.\n        yield (name, header + script_text)\n\n    @classmethod\n    def get_header(cls, script_text=\"\", executable=None):\n        \"\"\"Create a #! line, getting options (if any) from script_text\"\"\"\n        cmd = cls.command_spec_class.best().from_param(executable)\n        cmd.install_options(script_text)\n        return cmd.as_header()\n\n\nclass WindowsScriptWriter(ScriptWriter):\n    command_spec_class = WindowsCommandSpec\n\n    @classmethod\n    def best(cls):\n        \"\"\"\n        Select the best ScriptWriter suitable for Windows\n        \"\"\"\n        writer_lookup = dict(\n            executable=WindowsExecutableLauncherWriter,\n            natural=cls,\n        )\n        # for compatibility, use the executable launcher by default\n        launcher = os.environ.get('SETUPTOOLS_LAUNCHER', 'executable')\n        return writer_lookup[launcher]\n\n    @classmethod\n    def _get_script_args(cls, type_, name, header, script_text):\n        \"For Windows, add a .py extension\"\n        ext = dict(console='.pya', gui='.pyw')[type_]\n        if ext not in os.environ['PATHEXT'].lower().split(';'):\n            msg = (\n                \"{ext} not listed in PATHEXT; scripts will not be \"\n                \"recognized as executables.\"\n            ).format(**locals())\n            SetuptoolsWarning.emit(msg)\n        old = ['.pya', '.py', '-script.py', '.pyc', '.pyo', '.pyw', '.exe']\n        old.remove(ext)\n        header = cls._adjust_header(type_, header)\n        blockers = [name + x for x in old]\n        yield name + ext, header + script_text, 't', blockers\n\n    @classmethod\n    def _adjust_header(cls, type_, orig_header):\n        \"\"\"\n        Make sure 'pythonw' is used for gui and 'python' is used for\n        console (regardless of what sys.executable is).\n        \"\"\"\n        pattern = 'pythonw.exe'\n        repl = 'python.exe'\n        if type_ == 'gui':\n            pattern, repl = repl, pattern\n        pattern_ob = re.compile(re.escape(pattern), re.IGNORECASE)\n        new_header = pattern_ob.sub(string=orig_header, repl=repl)\n        return new_header if cls._use_header(new_header) else orig_header\n\n    @staticmethod\n    def _use_header(new_header):\n        \"\"\"\n        Should _adjust_header use the replaced header?\n\n        On non-windows systems, always use. On\n        Windows systems, only use the replaced header if it resolves\n        to an executable on the system.\n        \"\"\"\n        clean_header = new_header[2:-1].strip('\"')\n        return sys.platform != 'win32' or find_executable(clean_header)\n\n\nclass WindowsExecutableLauncherWriter(WindowsScriptWriter):\n    @classmethod\n    def _get_script_args(cls, type_, name, header, script_text):\n        \"\"\"\n        For Windows, add a .py extension and an .exe launcher\n        \"\"\"\n        if type_ == 'gui':\n            launcher_type = 'gui'\n            ext = '-script.pyw'\n            old = ['.pyw']\n        else:\n            launcher_type = 'cli'\n            ext = '-script.py'\n            old = ['.py', '.pyc', '.pyo']\n        hdr = cls._adjust_header(type_, header)\n        blockers = [name + x for x in old]\n        yield (name + ext, hdr + script_text, 't', blockers)\n        yield (\n            name + '.exe',\n            get_win_launcher(launcher_type),\n            'b',  # write in binary mode\n        )\n        if not is_64bit():\n            # install a manifest for the launcher to prevent Windows\n            # from detecting it as an installer (which it will for\n            #  launchers like easy_install.exe). Consider only\n            #  adding a manifest for launchers detected as installers.\n            #  See Distribute #143 for details.\n            m_name = name + '.exe.manifest'\n            yield (m_name, load_launcher_manifest(name), 't')\n\n\ndef get_win_launcher(type):\n    \"\"\"\n    Load the Windows launcher (executable) suitable for launching a script.\n\n    `type` should be either 'cli' or 'gui'\n\n    Returns the executable as a byte string.\n    \"\"\"\n    launcher_fn = '%s.exe' % type\n    if is_64bit():\n        if get_platform() == \"win-arm64\":\n            launcher_fn = launcher_fn.replace(\".\", \"-arm64.\")\n        else:\n            launcher_fn = launcher_fn.replace(\".\", \"-64.\")\n    else:\n        launcher_fn = launcher_fn.replace(\".\", \"-32.\")\n    return resource_string('setuptools', launcher_fn)\n\n\ndef load_launcher_manifest(name):\n    manifest = pkg_resources.resource_string(__name__, 'launcher manifest.xml')\n    return manifest.decode('utf-8') % vars()\n\n\ndef _rmtree(path, ignore_errors=False, onexc=auto_chmod):\n    return py311.shutil_rmtree(path, ignore_errors, onexc)\n\n\ndef current_umask():\n    tmp = os.umask(0o022)\n    os.umask(tmp)\n    return tmp\n\n\ndef only_strs(values):\n    \"\"\"\n    Exclude non-str values. Ref #3063.\n    \"\"\"\n    return filter(lambda val: isinstance(val, str), values)\n\n\nclass EasyInstallDeprecationWarning(SetuptoolsDeprecationWarning):\n    _SUMMARY = \"easy_install command is deprecated.\"\n    _DETAILS = \"\"\"\n    Please avoid running ``setup.py`` and ``easy_install``.\n    Instead, use pypa/build, pypa/installer or other\n    standards-based tools.\n    \"\"\"\n    _SEE_URL = \"https://github.com/pypa/setuptools/issues/917\"\n    # _DUE_DATE not defined yet\n", "setuptools/command/build_ext.py": "from __future__ import annotations\n\nimport os\nimport sys\nimport itertools\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import cache_from_source as _compiled_file_name\nfrom typing import Iterator\nfrom pathlib import Path\n\nfrom distutils.command.build_ext import build_ext as _du_build_ext\nfrom distutils.ccompiler import new_compiler\nfrom distutils.sysconfig import customize_compiler, get_config_var\nfrom distutils import log\n\nfrom setuptools.errors import BaseError\nfrom setuptools.extension import Extension, Library\n\ntry:\n    # Attempt to use Cython for building extensions, if available\n    from Cython.Distutils.build_ext import build_ext as _build_ext  # type: ignore[import-not-found] # Cython not installed on CI tests\n\n    # Additionally, assert that the compiler module will load\n    # also. Ref #1229.\n    __import__('Cython.Compiler.Main')\nexcept ImportError:\n    _build_ext = _du_build_ext\n\n# make sure _config_vars is initialized\nget_config_var(\"LDSHARED\")\n# Not publicly exposed in typeshed distutils stubs, but this is done on purpose\n# See https://github.com/pypa/setuptools/pull/4228#issuecomment-1959856400\nfrom distutils.sysconfig import _config_vars as _CONFIG_VARS  # type: ignore # noqa\n\n\ndef _customize_compiler_for_shlib(compiler):\n    if sys.platform == \"darwin\":\n        # building .dylib requires additional compiler flags on OSX; here we\n        # temporarily substitute the pyconfig.h variables so that distutils'\n        # 'customize_compiler' uses them before we build the shared libraries.\n        tmp = _CONFIG_VARS.copy()\n        try:\n            # XXX Help!  I don't have any idea whether these are right...\n            _CONFIG_VARS['LDSHARED'] = (\n                \"gcc -Wl,-x -dynamiclib -undefined dynamic_lookup\"\n            )\n            _CONFIG_VARS['CCSHARED'] = \" -dynamiclib\"\n            _CONFIG_VARS['SO'] = \".dylib\"\n            customize_compiler(compiler)\n        finally:\n            _CONFIG_VARS.clear()\n            _CONFIG_VARS.update(tmp)\n    else:\n        customize_compiler(compiler)\n\n\nhave_rtld = False\nuse_stubs = False\nlibtype = 'shared'\n\nif sys.platform == \"darwin\":\n    use_stubs = True\nelif os.name != 'nt':\n    try:\n        import dl  # type: ignore[import-not-found] # https://github.com/python/mypy/issues/13002\n\n        use_stubs = have_rtld = hasattr(dl, 'RTLD_NOW')\n    except ImportError:\n        pass\n\n\ndef if_dl(s):\n    return s if have_rtld else ''\n\n\ndef get_abi3_suffix():\n    \"\"\"Return the file extension for an abi3-compliant Extension()\"\"\"\n    for suffix in EXTENSION_SUFFIXES:\n        if '.abi3' in suffix:  # Unix\n            return suffix\n        elif suffix == '.pyd':  # Windows\n            return suffix\n    return None\n\n\nclass build_ext(_build_ext):\n    editable_mode: bool = False\n    inplace: bool = False\n\n    def run(self):\n        \"\"\"Build extensions in build directory, then copy if --inplace\"\"\"\n        old_inplace, self.inplace = self.inplace, 0\n        _build_ext.run(self)\n        self.inplace = old_inplace\n        if old_inplace:\n            self.copy_extensions_to_source()\n\n    def _get_inplace_equivalent(self, build_py, ext: Extension) -> tuple[str, str]:\n        fullname = self.get_ext_fullname(ext.name)\n        filename = self.get_ext_filename(fullname)\n        modpath = fullname.split('.')\n        package = '.'.join(modpath[:-1])\n        package_dir = build_py.get_package_dir(package)\n        inplace_file = os.path.join(package_dir, os.path.basename(filename))\n        regular_file = os.path.join(self.build_lib, filename)\n        return (inplace_file, regular_file)\n\n    def copy_extensions_to_source(self):\n        build_py = self.get_finalized_command('build_py')\n        for ext in self.extensions:\n            inplace_file, regular_file = self._get_inplace_equivalent(build_py, ext)\n\n            # Always copy, even if source is older than destination, to ensure\n            # that the right extensions for the current Python/platform are\n            # used.\n            if os.path.exists(regular_file) or not ext.optional:\n                self.copy_file(regular_file, inplace_file, level=self.verbose)\n\n            if ext._needs_stub:\n                inplace_stub = self._get_equivalent_stub(ext, inplace_file)\n                self._write_stub_file(inplace_stub, ext, compile=True)\n                # Always compile stub and remove the original (leave the cache behind)\n                # (this behaviour was observed in previous iterations of the code)\n\n    def _get_equivalent_stub(self, ext: Extension, output_file: str) -> str:\n        dir_ = os.path.dirname(output_file)\n        _, _, name = ext.name.rpartition(\".\")\n        return f\"{os.path.join(dir_, name)}.py\"\n\n    def _get_output_mapping(self) -> Iterator[tuple[str, str]]:\n        if not self.inplace:\n            return\n\n        build_py = self.get_finalized_command('build_py')\n        opt = self.get_finalized_command('install_lib').optimize or \"\"\n\n        for ext in self.extensions:\n            inplace_file, regular_file = self._get_inplace_equivalent(build_py, ext)\n            yield (regular_file, inplace_file)\n\n            if ext._needs_stub:\n                # This version of `build_ext` always builds artifacts in another dir,\n                # when \"inplace=True\" is given it just copies them back.\n                # This is done in the `copy_extensions_to_source` function, which\n                # always compile stub files via `_compile_and_remove_stub`.\n                # At the end of the process, a `.pyc` stub file is created without the\n                # corresponding `.py`.\n\n                inplace_stub = self._get_equivalent_stub(ext, inplace_file)\n                regular_stub = self._get_equivalent_stub(ext, regular_file)\n                inplace_cache = _compiled_file_name(inplace_stub, optimization=opt)\n                output_cache = _compiled_file_name(regular_stub, optimization=opt)\n                yield (output_cache, inplace_cache)\n\n    def get_ext_filename(self, fullname):\n        so_ext = os.getenv('SETUPTOOLS_EXT_SUFFIX')\n        if so_ext:\n            filename = os.path.join(*fullname.split('.')) + so_ext\n        else:\n            filename = _build_ext.get_ext_filename(self, fullname)\n            so_ext = get_config_var('EXT_SUFFIX')\n\n        if fullname in self.ext_map:\n            ext = self.ext_map[fullname]\n            use_abi3 = ext.py_limited_api and get_abi3_suffix()\n            if use_abi3:\n                filename = filename[: -len(so_ext)]\n                so_ext = get_abi3_suffix()\n                filename = filename + so_ext\n            if isinstance(ext, Library):\n                fn, ext = os.path.splitext(filename)\n                return self.shlib_compiler.library_filename(fn, libtype)\n            elif use_stubs and ext._links_to_dynamic:\n                d, fn = os.path.split(filename)\n                return os.path.join(d, 'dl-' + fn)\n        return filename\n\n    def initialize_options(self):\n        _build_ext.initialize_options(self)\n        self.shlib_compiler = None\n        self.shlibs = []\n        self.ext_map = {}\n        self.editable_mode = False\n\n    def finalize_options(self):\n        _build_ext.finalize_options(self)\n        self.extensions = self.extensions or []\n        self.check_extensions_list(self.extensions)\n        self.shlibs = [ext for ext in self.extensions if isinstance(ext, Library)]\n        if self.shlibs:\n            self.setup_shlib_compiler()\n        for ext in self.extensions:\n            ext._full_name = self.get_ext_fullname(ext.name)\n        for ext in self.extensions:\n            fullname = ext._full_name\n            self.ext_map[fullname] = ext\n\n            # distutils 3.1 will also ask for module names\n            # XXX what to do with conflicts?\n            self.ext_map[fullname.split('.')[-1]] = ext\n\n            ltd = self.shlibs and self.links_to_dynamic(ext) or False\n            ns = ltd and use_stubs and not isinstance(ext, Library)\n            ext._links_to_dynamic = ltd\n            ext._needs_stub = ns\n            filename = ext._file_name = self.get_ext_filename(fullname)\n            libdir = os.path.dirname(os.path.join(self.build_lib, filename))\n            if ltd and libdir not in ext.library_dirs:\n                ext.library_dirs.append(libdir)\n            if ltd and use_stubs and os.curdir not in ext.runtime_library_dirs:\n                ext.runtime_library_dirs.append(os.curdir)\n\n        if self.editable_mode:\n            self.inplace = True\n\n    def setup_shlib_compiler(self):\n        compiler = self.shlib_compiler = new_compiler(\n            compiler=self.compiler, dry_run=self.dry_run, force=self.force\n        )\n        _customize_compiler_for_shlib(compiler)\n\n        if self.include_dirs is not None:\n            compiler.set_include_dirs(self.include_dirs)\n        if self.define is not None:\n            # 'define' option is a list of (name,value) tuples\n            for name, value in self.define:\n                compiler.define_macro(name, value)\n        if self.undef is not None:\n            for macro in self.undef:\n                compiler.undefine_macro(macro)\n        if self.libraries is not None:\n            compiler.set_libraries(self.libraries)\n        if self.library_dirs is not None:\n            compiler.set_library_dirs(self.library_dirs)\n        if self.rpath is not None:\n            compiler.set_runtime_library_dirs(self.rpath)\n        if self.link_objects is not None:\n            compiler.set_link_objects(self.link_objects)\n\n        # hack so distutils' build_extension() builds a library instead\n        compiler.link_shared_object = link_shared_object.__get__(compiler)\n\n    def get_export_symbols(self, ext):\n        if isinstance(ext, Library):\n            return ext.export_symbols\n        return _build_ext.get_export_symbols(self, ext)\n\n    def build_extension(self, ext):\n        ext._convert_pyx_sources_to_lang()\n        _compiler = self.compiler\n        try:\n            if isinstance(ext, Library):\n                self.compiler = self.shlib_compiler\n            _build_ext.build_extension(self, ext)\n            if ext._needs_stub:\n                build_lib = self.get_finalized_command('build_py').build_lib\n                self.write_stub(build_lib, ext)\n        finally:\n            self.compiler = _compiler\n\n    def links_to_dynamic(self, ext):\n        \"\"\"Return true if 'ext' links to a dynamic lib in the same package\"\"\"\n        # XXX this should check to ensure the lib is actually being built\n        # XXX as dynamic, and not just using a locally-found version or a\n        # XXX static-compiled version\n        libnames = dict.fromkeys([lib._full_name for lib in self.shlibs])\n        pkg = '.'.join(ext._full_name.split('.')[:-1] + [''])\n        return any(pkg + libname in libnames for libname in ext.libraries)\n\n    def get_source_files(self) -> list[str]:\n        return [*_build_ext.get_source_files(self), *self._get_internal_depends()]\n\n    def _get_internal_depends(self) -> Iterator[str]:\n        \"\"\"Yield ``ext.depends`` that are contained by the project directory\"\"\"\n        project_root = Path(self.distribution.src_root or os.curdir).resolve()\n        depends = (dep for ext in self.extensions for dep in ext.depends)\n\n        def skip(orig_path: str, reason: str) -> None:\n            log.info(\n                \"dependency %s won't be automatically \"\n                \"included in the manifest: the path %s\",\n                orig_path,\n                reason,\n            )\n\n        for dep in depends:\n            path = Path(dep)\n\n            if path.is_absolute():\n                skip(dep, \"must be relative\")\n                continue\n\n            if \"..\" in path.parts:\n                skip(dep, \"can't have `..` segments\")\n                continue\n\n            try:\n                resolved = (project_root / path).resolve(strict=True)\n            except OSError:\n                skip(dep, \"doesn't exist\")\n                continue\n\n            try:\n                resolved.relative_to(project_root)\n            except ValueError:\n                skip(dep, \"must be inside the project root\")\n                continue\n\n            yield path.as_posix()\n\n    def get_outputs(self) -> list[str]:\n        if self.inplace:\n            return list(self.get_output_mapping().keys())\n        return sorted(_build_ext.get_outputs(self) + self.__get_stubs_outputs())\n\n    def get_output_mapping(self) -> dict[str, str]:\n        \"\"\"See :class:`setuptools.commands.build.SubCommand`\"\"\"\n        mapping = self._get_output_mapping()\n        return dict(sorted(mapping, key=lambda x: x[0]))\n\n    def __get_stubs_outputs(self):\n        # assemble the base name for each extension that needs a stub\n        ns_ext_bases = (\n            os.path.join(self.build_lib, *ext._full_name.split('.'))\n            for ext in self.extensions\n            if ext._needs_stub\n        )\n        # pair each base with the extension\n        pairs = itertools.product(ns_ext_bases, self.__get_output_extensions())\n        return list(base + fnext for base, fnext in pairs)\n\n    def __get_output_extensions(self):\n        yield '.py'\n        yield '.pyc'\n        if self.get_finalized_command('build_py').optimize:\n            yield '.pyo'\n\n    def write_stub(self, output_dir, ext, compile=False):\n        stub_file = os.path.join(output_dir, *ext._full_name.split('.')) + '.py'\n        self._write_stub_file(stub_file, ext, compile)\n\n    def _write_stub_file(self, stub_file: str, ext: Extension, compile=False):\n        log.info(\"writing stub loader for %s to %s\", ext._full_name, stub_file)\n        if compile and os.path.exists(stub_file):\n            raise BaseError(stub_file + \" already exists! Please delete.\")\n        if not self.dry_run:\n            with open(stub_file, 'w', encoding=\"utf-8\") as f:\n                content = '\\n'.join([\n                    \"def __bootstrap__():\",\n                    \"   global __bootstrap__, __file__, __loader__\",\n                    \"   import sys, os, pkg_resources, importlib.util\" + if_dl(\", dl\"),\n                    \"   __file__ = pkg_resources.resource_filename\"\n                    \"(__name__,%r)\" % os.path.basename(ext._file_name),\n                    \"   del __bootstrap__\",\n                    \"   if '__loader__' in globals():\",\n                    \"       del __loader__\",\n                    if_dl(\"   old_flags = sys.getdlopenflags()\"),\n                    \"   old_dir = os.getcwd()\",\n                    \"   try:\",\n                    \"     os.chdir(os.path.dirname(__file__))\",\n                    if_dl(\"     sys.setdlopenflags(dl.RTLD_NOW)\"),\n                    \"     spec = importlib.util.spec_from_file_location(\",\n                    \"                __name__, __file__)\",\n                    \"     mod = importlib.util.module_from_spec(spec)\",\n                    \"     spec.loader.exec_module(mod)\",\n                    \"   finally:\",\n                    if_dl(\"     sys.setdlopenflags(old_flags)\"),\n                    \"     os.chdir(old_dir)\",\n                    \"__bootstrap__()\",\n                    \"\",  # terminal \\n\n                ])\n                f.write(content)\n        if compile:\n            self._compile_and_remove_stub(stub_file)\n\n    def _compile_and_remove_stub(self, stub_file: str):\n        from distutils.util import byte_compile\n\n        byte_compile([stub_file], optimize=0, force=True, dry_run=self.dry_run)\n        optimize = self.get_finalized_command('install_lib').optimize\n        if optimize > 0:\n            byte_compile(\n                [stub_file],\n                optimize=optimize,\n                force=True,\n                dry_run=self.dry_run,\n            )\n        if os.path.exists(stub_file) and not self.dry_run:\n            os.unlink(stub_file)\n\n\nif use_stubs or os.name == 'nt':\n    # Build shared libraries\n    #\n    def link_shared_object(\n        self,\n        objects,\n        output_libname,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        self.link(\n            self.SHARED_LIBRARY,\n            objects,\n            output_libname,\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            export_symbols,\n            debug,\n            extra_preargs,\n            extra_postargs,\n            build_temp,\n            target_lang,\n        )\n\nelse:\n    # Build static libraries everywhere else\n    libtype = 'static'\n\n    def link_shared_object(\n        self,\n        objects,\n        output_libname,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        # XXX we need to either disallow these attrs on Library instances,\n        # or warn/abort here if set, or something...\n        # libraries=None, library_dirs=None, runtime_library_dirs=None,\n        # export_symbols=None, extra_preargs=None, extra_postargs=None,\n        # build_temp=None\n\n        assert output_dir is None  # distutils build_ext doesn't pass this\n        output_dir, filename = os.path.split(output_libname)\n        basename, ext = os.path.splitext(filename)\n        if self.library_filename(\"x\").startswith('lib'):\n            # strip 'lib' prefix; this is kludgy if some platform uses\n            # a different prefix\n            basename = basename[3:]\n\n        self.create_static_lib(objects, basename, output_dir, debug, target_lang)\n", "setuptools/command/build.py": "from __future__ import annotations\n\nfrom typing import Protocol\nfrom distutils.command.build import build as _build\n\n_ORIGINAL_SUBCOMMANDS = {\"build_py\", \"build_clib\", \"build_ext\", \"build_scripts\"}\n\n\nclass build(_build):\n    # copy to avoid sharing the object with parent class\n    sub_commands = _build.sub_commands[:]\n\n\nclass SubCommand(Protocol):\n    \"\"\"In order to support editable installations (see :pep:`660`) all\n    build subcommands **SHOULD** implement this protocol. They also **MUST** inherit\n    from ``setuptools.Command``.\n\n    When creating an :pep:`editable wheel <660>`, ``setuptools`` will try to evaluate\n    custom ``build`` subcommands using the following procedure:\n\n    1. ``setuptools`` will set the ``editable_mode`` attribute to ``True``\n    2. ``setuptools`` will execute the ``run()`` command.\n\n       .. important::\n          Subcommands **SHOULD** take advantage of ``editable_mode=True`` to adequate\n          its behaviour or perform optimisations.\n\n          For example, if a subcommand doesn't need to generate an extra file and\n          all it does is to copy a source file into the build directory,\n          ``run()`` **SHOULD** simply \"early return\".\n\n          Similarly, if the subcommand creates files that would be placed alongside\n          Python files in the final distribution, during an editable install\n          the command **SHOULD** generate these files \"in place\" (i.e. write them to\n          the original source directory, instead of using the build directory).\n          Note that ``get_output_mapping()`` should reflect that and include mappings\n          for \"in place\" builds accordingly.\n\n    3. ``setuptools`` use any knowledge it can derive from the return values of\n       ``get_outputs()`` and ``get_output_mapping()`` to create an editable wheel.\n       When relevant ``setuptools`` **MAY** attempt to use file links based on the value\n       of ``get_output_mapping()``. Alternatively, ``setuptools`` **MAY** attempt to use\n       :doc:`import hooks <python:reference/import>` to redirect any attempt to import\n       to the directory with the original source code and other files built in place.\n\n    Please note that custom sub-commands **SHOULD NOT** rely on ``run()`` being\n    executed (or not) to provide correct return values for ``get_outputs()``,\n    ``get_output_mapping()`` or ``get_source_files()``. The ``get_*`` methods should\n    work independently of ``run()``.\n    \"\"\"\n\n    editable_mode: bool = False\n    \"\"\"Boolean flag that will be set to ``True`` when setuptools is used for an\n    editable installation (see :pep:`660`).\n    Implementations **SHOULD** explicitly set the default value of this attribute to\n    ``False``.\n    When subcommands run, they can use this flag to perform optimizations or change\n    their behaviour accordingly.\n    \"\"\"\n\n    build_lib: str\n    \"\"\"String representing the directory where the build artifacts should be stored,\n    e.g. ``build/lib``.\n    For example, if a distribution wants to provide a Python module named ``pkg.mod``,\n    then a corresponding file should be written to ``{build_lib}/package/module.py``.\n    A way of thinking about this is that the files saved under ``build_lib``\n    would be eventually copied to one of the directories in :obj:`site.PREFIXES`\n    upon installation.\n\n    A command that produces platform-independent files (e.g. compiling text templates\n    into Python functions), **CAN** initialize ``build_lib`` by copying its value from\n    the ``build_py`` command. On the other hand, a command that produces\n    platform-specific files **CAN** initialize ``build_lib`` by copying its value from\n    the ``build_ext`` command. In general this is done inside the ``finalize_options``\n    method with the help of the ``set_undefined_options`` command::\n\n        def finalize_options(self):\n            self.set_undefined_options(\"build_py\", (\"build_lib\", \"build_lib\"))\n            ...\n    \"\"\"\n\n    def initialize_options(self):\n        \"\"\"(Required by the original :class:`setuptools.Command` interface)\"\"\"\n\n    def finalize_options(self):\n        \"\"\"(Required by the original :class:`setuptools.Command` interface)\"\"\"\n\n    def run(self):\n        \"\"\"(Required by the original :class:`setuptools.Command` interface)\"\"\"\n\n    def get_source_files(self) -> list[str]:\n        \"\"\"\n        Return a list of all files that are used by the command to create the expected\n        outputs.\n        For example, if your build command transpiles Java files into Python, you should\n        list here all the Java files.\n        The primary purpose of this function is to help populating the ``sdist``\n        with all the files necessary to build the distribution.\n        All files should be strings relative to the project root directory.\n        \"\"\"\n\n    def get_outputs(self) -> list[str]:\n        \"\"\"\n        Return a list of files intended for distribution as they would have been\n        produced by the build.\n        These files should be strings in the form of\n        ``\"{build_lib}/destination/file/path\"``.\n\n        .. note::\n           The return value of ``get_output()`` should include all files used as keys\n           in ``get_output_mapping()`` plus files that are generated during the build\n           and don't correspond to any source file already present in the project.\n        \"\"\"\n\n    def get_output_mapping(self) -> dict[str, str]:\n        \"\"\"\n        Return a mapping between destination files as they would be produced by the\n        build (dict keys) into the respective existing (source) files (dict values).\n        Existing (source) files should be represented as strings relative to the project\n        root directory.\n        Destination files should be strings in the form of\n        ``\"{build_lib}/destination/file/path\"``.\n        \"\"\"\n", "setuptools/command/setopt.py": "from distutils.util import convert_path\nfrom distutils import log\nfrom distutils.errors import DistutilsOptionError\nimport distutils\nimport os\nimport configparser\n\nfrom .. import Command\nfrom ..unicode_utils import _cfg_read_utf8_with_fallback\n\n__all__ = ['config_file', 'edit_config', 'option_base', 'setopt']\n\n\ndef config_file(kind=\"local\"):\n    \"\"\"Get the filename of the distutils, local, global, or per-user config\n\n    `kind` must be one of \"local\", \"global\", or \"user\"\n    \"\"\"\n    if kind == 'local':\n        return 'setup.cfg'\n    if kind == 'global':\n        return os.path.join(os.path.dirname(distutils.__file__), 'distutils.cfg')\n    if kind == 'user':\n        dot = os.name == 'posix' and '.' or ''\n        return os.path.expanduser(convert_path(\"~/%spydistutils.cfg\" % dot))\n    raise ValueError(\"config_file() type must be 'local', 'global', or 'user'\", kind)\n\n\ndef edit_config(filename, settings, dry_run=False):\n    \"\"\"Edit a configuration file to include `settings`\n\n    `settings` is a dictionary of dictionaries or ``None`` values, keyed by\n    command/section name.  A ``None`` value means to delete the entire section,\n    while a dictionary lists settings to be changed or deleted in that section.\n    A setting of ``None`` means to delete that setting.\n    \"\"\"\n    log.debug(\"Reading configuration from %s\", filename)\n    opts = configparser.RawConfigParser()\n    opts.optionxform = lambda x: x\n    _cfg_read_utf8_with_fallback(opts, filename)\n\n    for section, options in settings.items():\n        if options is None:\n            log.info(\"Deleting section [%s] from %s\", section, filename)\n            opts.remove_section(section)\n        else:\n            if not opts.has_section(section):\n                log.debug(\"Adding new section [%s] to %s\", section, filename)\n                opts.add_section(section)\n            for option, value in options.items():\n                if value is None:\n                    log.debug(\"Deleting %s.%s from %s\", section, option, filename)\n                    opts.remove_option(section, option)\n                    if not opts.options(section):\n                        log.info(\n                            \"Deleting empty [%s] section from %s\", section, filename\n                        )\n                        opts.remove_section(section)\n                else:\n                    log.debug(\n                        \"Setting %s.%s to %r in %s\", section, option, value, filename\n                    )\n                    opts.set(section, option, value)\n\n    log.info(\"Writing %s\", filename)\n    if not dry_run:\n        with open(filename, 'w', encoding=\"utf-8\") as f:\n            opts.write(f)\n\n\nclass option_base(Command):\n    \"\"\"Abstract base class for commands that mess with config files\"\"\"\n\n    user_options = [\n        ('global-config', 'g', \"save options to the site-wide distutils.cfg file\"),\n        ('user-config', 'u', \"save options to the current user's pydistutils.cfg file\"),\n        ('filename=', 'f', \"configuration file to use (default=setup.cfg)\"),\n    ]\n\n    boolean_options = [\n        'global-config',\n        'user-config',\n    ]\n\n    def initialize_options(self):\n        self.global_config = None\n        self.user_config = None\n        self.filename = None\n\n    def finalize_options(self):\n        filenames = []\n        if self.global_config:\n            filenames.append(config_file('global'))\n        if self.user_config:\n            filenames.append(config_file('user'))\n        if self.filename is not None:\n            filenames.append(self.filename)\n        if not filenames:\n            filenames.append(config_file('local'))\n        if len(filenames) > 1:\n            raise DistutilsOptionError(\n                \"Must specify only one configuration file option\", filenames\n            )\n        (self.filename,) = filenames\n\n\nclass setopt(option_base):\n    \"\"\"Save command-line options to a file\"\"\"\n\n    description = \"set an option in setup.cfg or another config file\"\n\n    user_options = [\n        ('command=', 'c', 'command to set an option for'),\n        ('option=', 'o', 'option to set'),\n        ('set-value=', 's', 'value of the option'),\n        ('remove', 'r', 'remove (unset) the value'),\n    ] + option_base.user_options\n\n    boolean_options = option_base.boolean_options + ['remove']\n\n    def initialize_options(self):\n        option_base.initialize_options(self)\n        self.command = None\n        self.option = None\n        self.set_value = None\n        self.remove = None\n\n    def finalize_options(self):\n        option_base.finalize_options(self)\n        if self.command is None or self.option is None:\n            raise DistutilsOptionError(\"Must specify --command *and* --option\")\n        if self.set_value is None and not self.remove:\n            raise DistutilsOptionError(\"Must specify --set-value or --remove\")\n\n    def run(self):\n        edit_config(\n            self.filename,\n            {self.command: {self.option.replace('-', '_'): self.set_value}},\n            self.dry_run,\n        )\n", "setuptools/command/install_lib.py": "import os\nimport sys\nfrom itertools import product, starmap\nimport distutils.command.install_lib as orig\nfrom .._path import StrPath\n\n\nclass install_lib(orig.install_lib):\n    \"\"\"Don't add compiled flags to filenames of non-Python files\"\"\"\n\n    def run(self):\n        self.build()\n        outfiles = self.install()\n        if outfiles is not None:\n            # always compile, in case we have any extension stubs to deal with\n            self.byte_compile(outfiles)\n\n    def get_exclusions(self):\n        \"\"\"\n        Return a collections.Sized collections.Container of paths to be\n        excluded for single_version_externally_managed installations.\n        \"\"\"\n        all_packages = (\n            pkg\n            for ns_pkg in self._get_SVEM_NSPs()\n            for pkg in self._all_packages(ns_pkg)\n        )\n\n        excl_specs = product(all_packages, self._gen_exclusion_paths())\n        return set(starmap(self._exclude_pkg_path, excl_specs))\n\n    def _exclude_pkg_path(self, pkg, exclusion_path):\n        \"\"\"\n        Given a package name and exclusion path within that package,\n        compute the full exclusion path.\n        \"\"\"\n        parts = pkg.split('.') + [exclusion_path]\n        return os.path.join(self.install_dir, *parts)\n\n    @staticmethod\n    def _all_packages(pkg_name):\n        \"\"\"\n        >>> list(install_lib._all_packages('foo.bar.baz'))\n        ['foo.bar.baz', 'foo.bar', 'foo']\n        \"\"\"\n        while pkg_name:\n            yield pkg_name\n            pkg_name, sep, child = pkg_name.rpartition('.')\n\n    def _get_SVEM_NSPs(self):\n        \"\"\"\n        Get namespace packages (list) but only for\n        single_version_externally_managed installations and empty otherwise.\n        \"\"\"\n        # TODO: is it necessary to short-circuit here? i.e. what's the cost\n        # if get_finalized_command is called even when namespace_packages is\n        # False?\n        if not self.distribution.namespace_packages:\n            return []\n\n        install_cmd = self.get_finalized_command('install')\n        svem = install_cmd.single_version_externally_managed\n\n        return self.distribution.namespace_packages if svem else []\n\n    @staticmethod\n    def _gen_exclusion_paths():\n        \"\"\"\n        Generate file paths to be excluded for namespace packages (bytecode\n        cache files).\n        \"\"\"\n        # always exclude the package module itself\n        yield '__init__.py'\n\n        yield '__init__.pyc'\n        yield '__init__.pyo'\n\n        if not hasattr(sys, 'implementation'):\n            return\n\n        base = os.path.join('__pycache__', '__init__.' + sys.implementation.cache_tag)\n        yield base + '.pyc'\n        yield base + '.pyo'\n        yield base + '.opt-1.pyc'\n        yield base + '.opt-2.pyc'\n\n    def copy_tree(\n        self,\n        infile: StrPath,\n        outfile: str,\n        preserve_mode=True,\n        preserve_times=True,\n        preserve_symlinks=False,\n        level=1,\n    ):\n        assert preserve_mode and preserve_times and not preserve_symlinks\n        exclude = self.get_exclusions()\n\n        if not exclude:\n            return orig.install_lib.copy_tree(self, infile, outfile)  # type: ignore[arg-type] # Fixed upstream\n\n        # Exclude namespace package __init__.py* files from the output\n\n        from setuptools.archive_util import unpack_directory\n        from distutils import log\n\n        outfiles = []\n\n        def pf(src, dst):\n            if dst in exclude:\n                log.warn(\"Skipping installation of %s (namespace package)\", dst)\n                return False\n\n            log.info(\"copying %s -> %s\", src, os.path.dirname(dst))\n            outfiles.append(dst)\n            return dst\n\n        unpack_directory(infile, outfile, pf)\n        return outfiles\n\n    def get_outputs(self):\n        outputs = orig.install_lib.get_outputs(self)\n        exclude = self.get_exclusions()\n        if exclude:\n            return [f for f in outputs if f not in exclude]\n        return outputs\n", "setuptools/command/bdist_rpm.py": "import distutils.command.bdist_rpm as orig\n\nfrom ..warnings import SetuptoolsDeprecationWarning\n\n\nclass bdist_rpm(orig.bdist_rpm):\n    \"\"\"\n    Override the default bdist_rpm behavior to do the following:\n\n    1. Run egg_info to ensure the name and version are properly calculated.\n    2. Always run 'install' using --single-version-externally-managed to\n       disable eggs in RPM distributions.\n    \"\"\"\n\n    def run(self):\n        SetuptoolsDeprecationWarning.emit(\n            \"Deprecated command\",\n            \"\"\"\n            bdist_rpm is deprecated and will be removed in a future version.\n            Use bdist_wheel (wheel packages) instead.\n            \"\"\",\n            see_url=\"https://github.com/pypa/setuptools/issues/1988\",\n            due_date=(2023, 10, 30),  # Deprecation introduced in 22 Oct 2021.\n        )\n\n        # ensure distro name is up-to-date\n        self.run_command('egg_info')\n\n        orig.bdist_rpm.run(self)\n\n    def _make_spec_file(self):\n        spec = orig.bdist_rpm._make_spec_file(self)\n        return [\n            line.replace(\n                \"setup.py install \",\n                \"setup.py install --single-version-externally-managed \",\n            ).replace(\"%setup\", \"%setup -n %{name}-%{unmangled_version}\")\n            for line in spec\n        ]\n", "setuptools/command/__init__.py": "from distutils.command.bdist import bdist\nimport sys\n\nif 'egg' not in bdist.format_commands:\n    try:\n        bdist.format_commands['egg'] = ('bdist_egg', \"Python .egg file\")\n    except TypeError:\n        # For backward compatibility with older distutils (stdlib)\n        bdist.format_command['egg'] = ('bdist_egg', \"Python .egg file\")\n        bdist.format_commands.append('egg')\n\ndel bdist, sys\n", "setuptools/command/editable_wheel.py": "\"\"\"\nCreate a wheel that, when installed, will make the source package 'editable'\n(add it to the interpreter's path, including metadata) per PEP 660. Replaces\n'setup.py develop'.\n\n.. note::\n   One of the mechanisms briefly mentioned in PEP 660 to implement editable installs is\n   to create a separated directory inside ``build`` and use a .pth file to point to that\n   directory. In the context of this file such directory is referred as\n   *auxiliary build directory* or ``auxiliary_dir``.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport io\nimport os\nimport shutil\nimport traceback\nfrom contextlib import suppress\nfrom enum import Enum\nfrom inspect import cleandoc\nfrom itertools import chain, starmap\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom typing import (\n    TYPE_CHECKING,\n    Iterable,\n    Iterator,\n    Mapping,\n    Protocol,\n    TypeVar,\n    cast,\n)\n\nfrom .. import (\n    Command,\n    _normalization,\n    _path,\n    errors,\n    namespaces,\n)\nfrom .._path import StrPath\nfrom ..compat import py39\nfrom ..discovery import find_package_path\nfrom ..dist import Distribution\nfrom ..warnings import (\n    InformationOnly,\n    SetuptoolsDeprecationWarning,\n    SetuptoolsWarning,\n)\nfrom .build import build as build_cls\nfrom .build_py import build_py as build_py_cls\nfrom .dist_info import dist_info as dist_info_cls\nfrom .egg_info import egg_info as egg_info_cls\nfrom .install import install as install_cls\nfrom .install_scripts import install_scripts as install_scripts_cls\n\nif TYPE_CHECKING:\n    from .._vendor.wheel.wheelfile import WheelFile\n\n_P = TypeVar(\"_P\", bound=StrPath)\n_logger = logging.getLogger(__name__)\n\n\nclass _EditableMode(Enum):\n    \"\"\"\n    Possible editable installation modes:\n    `lenient` (new files automatically added to the package - DEFAULT);\n    `strict` (requires a new installation when files are added/removed); or\n    `compat` (attempts to emulate `python setup.py develop` - DEPRECATED).\n    \"\"\"\n\n    STRICT = \"strict\"\n    LENIENT = \"lenient\"\n    COMPAT = \"compat\"  # TODO: Remove `compat` after Dec/2022.\n\n    @classmethod\n    def convert(cls, mode: str | None) -> _EditableMode:\n        if not mode:\n            return _EditableMode.LENIENT  # default\n\n        _mode = mode.upper()\n        if _mode not in _EditableMode.__members__:\n            raise errors.OptionError(f\"Invalid editable mode: {mode!r}. Try: 'strict'.\")\n\n        if _mode == \"COMPAT\":\n            SetuptoolsDeprecationWarning.emit(\n                \"Compat editable installs\",\n                \"\"\"\n                The 'compat' editable mode is transitional and will be removed\n                in future versions of `setuptools`.\n                Please adapt your code accordingly to use either the 'strict' or the\n                'lenient' modes.\n                \"\"\",\n                see_docs=\"userguide/development_mode.html\",\n                # TODO: define due_date\n                # There is a series of shortcomings with the available editable install\n                # methods, and they are very controversial. This is something that still\n                # needs work.\n                # Moreover, `pip` is still hiding this warning, so users are not aware.\n            )\n\n        return _EditableMode[_mode]\n\n\n_STRICT_WARNING = \"\"\"\nNew or renamed files may not be automatically picked up without a new installation.\n\"\"\"\n\n_LENIENT_WARNING = \"\"\"\nOptions like `package-data`, `include/exclude-package-data` or\n`packages.find.exclude/include` may have no effect.\n\"\"\"\n\n\nclass editable_wheel(Command):\n    \"\"\"Build 'editable' wheel for development.\n    This command is private and reserved for internal use of setuptools,\n    users should rely on ``setuptools.build_meta`` APIs.\n    \"\"\"\n\n    description = \"DO NOT CALL DIRECTLY, INTERNAL ONLY: create PEP 660 editable wheel\"\n\n    user_options = [\n        (\"dist-dir=\", \"d\", \"directory to put final built distributions in\"),\n        (\"dist-info-dir=\", \"I\", \"path to a pre-build .dist-info directory\"),\n        (\"mode=\", None, cleandoc(_EditableMode.__doc__ or \"\")),\n    ]\n\n    def initialize_options(self):\n        self.dist_dir = None\n        self.dist_info_dir = None\n        self.project_dir = None\n        self.mode = None\n\n    def finalize_options(self):\n        dist = self.distribution\n        self.project_dir = dist.src_root or os.curdir\n        self.package_dir = dist.package_dir or {}\n        self.dist_dir = Path(self.dist_dir or os.path.join(self.project_dir, \"dist\"))\n\n    def run(self):\n        try:\n            self.dist_dir.mkdir(exist_ok=True)\n            self._ensure_dist_info()\n\n            # Add missing dist_info files\n            self.reinitialize_command(\"bdist_wheel\")\n            bdist_wheel = self.get_finalized_command(\"bdist_wheel\")\n            bdist_wheel.write_wheelfile(self.dist_info_dir)\n\n            self._create_wheel_file(bdist_wheel)\n        except Exception:\n            traceback.print_exc()\n            project = self.distribution.name or self.distribution.get_name()\n            _DebuggingTips.emit(project=project)\n            raise\n\n    def _ensure_dist_info(self):\n        if self.dist_info_dir is None:\n            dist_info = cast(dist_info_cls, self.reinitialize_command(\"dist_info\"))\n            dist_info.output_dir = self.dist_dir\n            dist_info.ensure_finalized()\n            dist_info.run()\n            self.dist_info_dir = dist_info.dist_info_dir\n        else:\n            assert str(self.dist_info_dir).endswith(\".dist-info\")\n            assert Path(self.dist_info_dir, \"METADATA\").exists()\n\n    def _install_namespaces(self, installation_dir, pth_prefix):\n        # XXX: Only required to support the deprecated namespace practice\n        dist = self.distribution\n        if not dist.namespace_packages:\n            return\n\n        src_root = Path(self.project_dir, self.package_dir.get(\"\", \".\")).resolve()\n        installer = _NamespaceInstaller(dist, installation_dir, pth_prefix, src_root)\n        installer.install_namespaces()\n\n    def _find_egg_info_dir(self) -> str | None:\n        parent_dir = Path(self.dist_info_dir).parent if self.dist_info_dir else Path()\n        candidates = map(str, parent_dir.glob(\"*.egg-info\"))\n        return next(candidates, None)\n\n    def _configure_build(\n        self, name: str, unpacked_wheel: StrPath, build_lib: StrPath, tmp_dir: StrPath\n    ):\n        \"\"\"Configure commands to behave in the following ways:\n\n        - Build commands can write to ``build_lib`` if they really want to...\n          (but this folder is expected to be ignored and modules are expected to live\n          in the project directory...)\n        - Binary extensions should be built in-place (editable_mode = True)\n        - Data/header/script files are not part of the \"editable\" specification\n          so they are written directly to the unpacked_wheel directory.\n        \"\"\"\n        # Non-editable files (data, headers, scripts) are written directly to the\n        # unpacked_wheel\n\n        dist = self.distribution\n        wheel = str(unpacked_wheel)\n        build_lib = str(build_lib)\n        data = str(Path(unpacked_wheel, f\"{name}.data\", \"data\"))\n        headers = str(Path(unpacked_wheel, f\"{name}.data\", \"headers\"))\n        scripts = str(Path(unpacked_wheel, f\"{name}.data\", \"scripts\"))\n\n        # egg-info may be generated again to create a manifest (used for package data)\n        egg_info = cast(\n            egg_info_cls, dist.reinitialize_command(\"egg_info\", reinit_subcommands=True)\n        )\n        egg_info.egg_base = str(tmp_dir)\n        egg_info.ignore_egg_info_in_manifest = True\n\n        build = cast(\n            build_cls, dist.reinitialize_command(\"build\", reinit_subcommands=True)\n        )\n        install = cast(\n            install_cls, dist.reinitialize_command(\"install\", reinit_subcommands=True)\n        )\n\n        build.build_platlib = build.build_purelib = build.build_lib = build_lib\n        install.install_purelib = install.install_platlib = install.install_lib = wheel\n        install.install_scripts = build.build_scripts = scripts\n        install.install_headers = headers\n        install.install_data = data\n\n        install_scripts = cast(\n            install_scripts_cls, dist.get_command_obj(\"install_scripts\")\n        )\n        install_scripts.no_ep = True\n\n        build.build_temp = str(tmp_dir)\n\n        build_py = cast(build_py_cls, dist.get_command_obj(\"build_py\"))\n        build_py.compile = False\n        build_py.existing_egg_info_dir = self._find_egg_info_dir()\n\n        self._set_editable_mode()\n\n        build.ensure_finalized()\n        install.ensure_finalized()\n\n    def _set_editable_mode(self):\n        \"\"\"Set the ``editable_mode`` flag in the build sub-commands\"\"\"\n        dist = self.distribution\n        build = dist.get_command_obj(\"build\")\n        # TODO: Update typeshed distutils stubs to overload non-None return type by default\n        for cmd_name in build.get_sub_commands():\n            cmd = dist.get_command_obj(cmd_name)\n            if hasattr(cmd, \"editable_mode\"):\n                cmd.editable_mode = True\n            elif hasattr(cmd, \"inplace\"):\n                cmd.inplace = True  # backward compatibility with distutils\n\n    def _collect_build_outputs(self) -> tuple[list[str], dict[str, str]]:\n        files: list[str] = []\n        mapping: dict[str, str] = {}\n        build = self.get_finalized_command(\"build\")\n\n        for cmd_name in build.get_sub_commands():\n            cmd = self.get_finalized_command(cmd_name)\n            if hasattr(cmd, \"get_outputs\"):\n                files.extend(cmd.get_outputs() or [])\n            if hasattr(cmd, \"get_output_mapping\"):\n                mapping.update(cmd.get_output_mapping() or {})\n\n        return files, mapping\n\n    def _run_build_commands(\n        self,\n        dist_name: str,\n        unpacked_wheel: StrPath,\n        build_lib: StrPath,\n        tmp_dir: StrPath,\n    ) -> tuple[list[str], dict[str, str]]:\n        self._configure_build(dist_name, unpacked_wheel, build_lib, tmp_dir)\n        self._run_build_subcommands()\n        files, mapping = self._collect_build_outputs()\n        self._run_install(\"headers\")\n        self._run_install(\"scripts\")\n        self._run_install(\"data\")\n        return files, mapping\n\n    def _run_build_subcommands(self) -> None:\n        \"\"\"\n        Issue #3501 indicates that some plugins/customizations might rely on:\n\n        1. ``build_py`` not running\n        2. ``build_py`` always copying files to ``build_lib``\n\n        However both these assumptions may be false in editable_wheel.\n        This method implements a temporary workaround to support the ecosystem\n        while the implementations catch up.\n        \"\"\"\n        # TODO: Once plugins/customisations had the chance to catch up, replace\n        #       `self._run_build_subcommands()` with `self.run_command(\"build\")`.\n        #       Also remove _safely_run, TestCustomBuildPy. Suggested date: Aug/2023.\n        build = self.get_finalized_command(\"build\")\n        for name in build.get_sub_commands():\n            cmd = self.get_finalized_command(name)\n            if name == \"build_py\" and type(cmd) != build_py_cls:\n                self._safely_run(name)\n            else:\n                self.run_command(name)\n\n    def _safely_run(self, cmd_name: str):\n        try:\n            return self.run_command(cmd_name)\n        except Exception:\n            SetuptoolsDeprecationWarning.emit(\n                \"Customization incompatible with editable install\",\n                f\"\"\"\n                {traceback.format_exc()}\n\n                If you are seeing this warning it is very likely that a setuptools\n                plugin or customization overrides the `{cmd_name}` command, without\n                taking into consideration how editable installs run build steps\n                starting from setuptools v64.0.0.\n\n                Plugin authors and developers relying on custom build steps are\n                encouraged to update their `{cmd_name}` implementation considering the\n                information about editable installs in\n                https://setuptools.pypa.io/en/latest/userguide/extension.html.\n\n                For the time being `setuptools` will silence this error and ignore\n                the faulty command, but this behaviour will change in future versions.\n                \"\"\",\n                # TODO: define due_date\n                # There is a series of shortcomings with the available editable install\n                # methods, and they are very controversial. This is something that still\n                # needs work.\n            )\n\n    def _create_wheel_file(self, bdist_wheel):\n        from ..extern.wheel.wheelfile import WheelFile\n\n        dist_info = self.get_finalized_command(\"dist_info\")\n        dist_name = dist_info.name\n        tag = \"-\".join(bdist_wheel.get_tag())\n        build_tag = \"0.editable\"  # According to PEP 427 needs to start with digit\n        archive_name = f\"{dist_name}-{build_tag}-{tag}.whl\"\n        wheel_path = Path(self.dist_dir, archive_name)\n        if wheel_path.exists():\n            wheel_path.unlink()\n\n        unpacked_wheel = TemporaryDirectory(suffix=archive_name)\n        build_lib = TemporaryDirectory(suffix=\".build-lib\")\n        build_tmp = TemporaryDirectory(suffix=\".build-temp\")\n\n        with unpacked_wheel as unpacked, build_lib as lib, build_tmp as tmp:\n            unpacked_dist_info = Path(unpacked, Path(self.dist_info_dir).name)\n            shutil.copytree(self.dist_info_dir, unpacked_dist_info)\n            self._install_namespaces(unpacked, dist_name)\n            files, mapping = self._run_build_commands(dist_name, unpacked, lib, tmp)\n            strategy = self._select_strategy(dist_name, tag, lib)\n            with strategy, WheelFile(wheel_path, \"w\") as wheel_obj:\n                strategy(wheel_obj, files, mapping)\n                wheel_obj.write_files(unpacked)\n\n        return wheel_path\n\n    def _run_install(self, category: str):\n        has_category = getattr(self.distribution, f\"has_{category}\", None)\n        if has_category and has_category():\n            _logger.info(f\"Installing {category} as non editable\")\n            self.run_command(f\"install_{category}\")\n\n    def _select_strategy(\n        self,\n        name: str,\n        tag: str,\n        build_lib: StrPath,\n    ) -> EditableStrategy:\n        \"\"\"Decides which strategy to use to implement an editable installation.\"\"\"\n        build_name = f\"__editable__.{name}-{tag}\"\n        project_dir = Path(self.project_dir)\n        mode = _EditableMode.convert(self.mode)\n\n        if mode is _EditableMode.STRICT:\n            auxiliary_dir = _empty_dir(Path(self.project_dir, \"build\", build_name))\n            return _LinkTree(self.distribution, name, auxiliary_dir, build_lib)\n\n        packages = _find_packages(self.distribution)\n        has_simple_layout = _simple_layout(packages, self.package_dir, project_dir)\n        is_compat_mode = mode is _EditableMode.COMPAT\n        if set(self.package_dir) == {\"\"} and has_simple_layout or is_compat_mode:\n            # src-layout(ish) is relatively safe for a simple pth file\n            src_dir = self.package_dir.get(\"\", \".\")\n            return _StaticPth(self.distribution, name, [Path(project_dir, src_dir)])\n\n        # Use a MetaPathFinder to avoid adding accidental top-level packages/modules\n        return _TopLevelFinder(self.distribution, name)\n\n\nclass EditableStrategy(Protocol):\n    def __call__(self, wheel: WheelFile, files: list[str], mapping: dict[str, str]): ...\n\n    def __enter__(self): ...\n\n    def __exit__(self, _exc_type, _exc_value, _traceback): ...\n\n\nclass _StaticPth:\n    def __init__(self, dist: Distribution, name: str, path_entries: list[Path]):\n        self.dist = dist\n        self.name = name\n        self.path_entries = path_entries\n\n    def __call__(self, wheel: WheelFile, files: list[str], mapping: dict[str, str]):\n        entries = \"\\n\".join(str(p.resolve()) for p in self.path_entries)\n        contents = _encode_pth(f\"{entries}\\n\")\n        wheel.writestr(f\"__editable__.{self.name}.pth\", contents)\n\n    def __enter__(self):\n        msg = f\"\"\"\n        Editable install will be performed using .pth file to extend `sys.path` with:\n        {list(map(os.fspath, self.path_entries))!r}\n        \"\"\"\n        _logger.warning(msg + _LENIENT_WARNING)\n        return self\n\n    def __exit__(self, _exc_type, _exc_value, _traceback): ...\n\n\nclass _LinkTree(_StaticPth):\n    \"\"\"\n    Creates a ``.pth`` file that points to a link tree in the ``auxiliary_dir``.\n\n    This strategy will only link files (not dirs), so it can be implemented in\n    any OS, even if that means using hardlinks instead of symlinks.\n\n    By collocating ``auxiliary_dir`` and the original source code, limitations\n    with hardlinks should be avoided.\n    \"\"\"\n\n    def __init__(\n        self,\n        dist: Distribution,\n        name: str,\n        auxiliary_dir: StrPath,\n        build_lib: StrPath,\n    ):\n        self.auxiliary_dir = Path(auxiliary_dir)\n        self.build_lib = Path(build_lib).resolve()\n        # TODO: Update typeshed distutils stubs to overload non-None return type by default\n        self._file = dist.get_command_obj(\"build_py\").copy_file  # type: ignore[union-attr]\n        super().__init__(dist, name, [self.auxiliary_dir])\n\n    def __call__(self, wheel: WheelFile, files: list[str], mapping: dict[str, str]):\n        self._create_links(files, mapping)\n        super().__call__(wheel, files, mapping)\n\n    def _normalize_output(self, file: str) -> str | None:\n        # Files relative to build_lib will be normalized to None\n        with suppress(ValueError):\n            path = Path(file).resolve().relative_to(self.build_lib)\n            return str(path).replace(os.sep, '/')\n        return None\n\n    def _create_file(self, relative_output: str, src_file: str, link=None):\n        dest = self.auxiliary_dir / relative_output\n        if not dest.parent.is_dir():\n            dest.parent.mkdir(parents=True)\n        # TODO: Update typeshed distutils stubs so distutils.cmd.Command.copy_file, accepts PathLike\n        # same with methods used by copy_file\n        self._file(src_file, dest, link=link)  # type: ignore[arg-type]\n\n    def _create_links(self, outputs, output_mapping):\n        self.auxiliary_dir.mkdir(parents=True, exist_ok=True)\n        link_type = \"sym\" if _can_symlink_files(self.auxiliary_dir) else \"hard\"\n        mappings = {self._normalize_output(k): v for k, v in output_mapping.items()}\n        mappings.pop(None, None)  # remove files that are not relative to build_lib\n\n        for output in outputs:\n            relative = self._normalize_output(output)\n            if relative and relative not in mappings:\n                self._create_file(relative, output)\n\n        for relative, src in mappings.items():\n            self._create_file(relative, src, link=link_type)\n\n    def __enter__(self):\n        msg = \"Strict editable install will be performed using a link tree.\\n\"\n        _logger.warning(msg + _STRICT_WARNING)\n        return self\n\n    def __exit__(self, _exc_type, _exc_value, _traceback):\n        msg = f\"\"\"\\n\n        Strict editable installation performed using the auxiliary directory:\n            {self.auxiliary_dir}\n\n        Please be careful to not remove this directory, otherwise you might not be able\n        to import/use your package.\n        \"\"\"\n        InformationOnly.emit(\"Editable installation.\", msg)\n\n\nclass _TopLevelFinder:\n    def __init__(self, dist: Distribution, name: str):\n        self.dist = dist\n        self.name = name\n\n    def template_vars(self) -> tuple[str, str, dict[str, str], dict[str, list[str]]]:\n        src_root = self.dist.src_root or os.curdir\n        top_level = chain(_find_packages(self.dist), _find_top_level_modules(self.dist))\n        package_dir = self.dist.package_dir or {}\n        roots = _find_package_roots(top_level, package_dir, src_root)\n\n        namespaces_: dict[str, list[str]] = dict(\n            chain(\n                _find_namespaces(self.dist.packages or [], roots),\n                ((ns, []) for ns in _find_virtual_namespaces(roots)),\n            )\n        )\n\n        legacy_namespaces = {\n            pkg: find_package_path(pkg, roots, self.dist.src_root or \"\")\n            for pkg in self.dist.namespace_packages or []\n        }\n\n        mapping = {**roots, **legacy_namespaces}\n        # ^-- We need to explicitly add the legacy_namespaces to the mapping to be\n        #     able to import their modules even if another package sharing the same\n        #     namespace is installed in a conventional (non-editable) way.\n\n        name = f\"__editable__.{self.name}.finder\"\n        finder = _normalization.safe_identifier(name)\n        return finder, name, mapping, namespaces_\n\n    def get_implementation(self) -> Iterator[tuple[str, bytes]]:\n        finder, name, mapping, namespaces_ = self.template_vars()\n\n        content = bytes(_finder_template(name, mapping, namespaces_), \"utf-8\")\n        yield (f\"{finder}.py\", content)\n\n        content = _encode_pth(f\"import {finder}; {finder}.install()\")\n        yield (f\"__editable__.{self.name}.pth\", content)\n\n    def __call__(self, wheel: WheelFile, files: list[str], mapping: dict[str, str]):\n        for file, content in self.get_implementation():\n            wheel.writestr(file, content)\n\n    def __enter__(self):\n        msg = \"Editable install will be performed using a meta path finder.\\n\"\n        _logger.warning(msg + _LENIENT_WARNING)\n        return self\n\n    def __exit__(self, _exc_type, _exc_value, _traceback):\n        msg = \"\"\"\\n\n        Please be careful with folders in your working directory with the same\n        name as your package as they may take precedence during imports.\n        \"\"\"\n        InformationOnly.emit(\"Editable installation.\", msg)\n\n\ndef _encode_pth(content: str) -> bytes:\n    \"\"\".pth files are always read with 'locale' encoding, the recommendation\n    from the cpython core developers is to write them as ``open(path, \"w\")``\n    and ignore warnings (see python/cpython#77102, pypa/setuptools#3937).\n    This function tries to simulate this behaviour without having to create an\n    actual file, in a way that supports a range of active Python versions.\n    (There seems to be some variety in the way different version of Python handle\n    ``encoding=None``, not all of them use ``locale.getpreferredencoding(False)``\n    or ``locale.getencoding()``).\n    \"\"\"\n    with io.BytesIO() as buffer:\n        wrapper = io.TextIOWrapper(buffer, encoding=py39.LOCALE_ENCODING)\n        wrapper.write(content)\n        wrapper.flush()\n        buffer.seek(0)\n        return buffer.read()\n\n\ndef _can_symlink_files(base_dir: Path) -> bool:\n    with TemporaryDirectory(dir=str(base_dir.resolve())) as tmp:\n        path1, path2 = Path(tmp, \"file1.txt\"), Path(tmp, \"file2.txt\")\n        path1.write_text(\"file1\", encoding=\"utf-8\")\n        with suppress(AttributeError, NotImplementedError, OSError):\n            os.symlink(path1, path2)\n            if path2.is_symlink() and path2.read_text(encoding=\"utf-8\") == \"file1\":\n                return True\n\n        try:\n            os.link(path1, path2)  # Ensure hard links can be created\n        except Exception as ex:\n            msg = (\n                \"File system does not seem to support either symlinks or hard links. \"\n                \"Strict editable installs require one of them to be supported.\"\n            )\n            raise LinksNotSupported(msg) from ex\n        return False\n\n\ndef _simple_layout(\n    packages: Iterable[str], package_dir: dict[str, str], project_dir: StrPath\n) -> bool:\n    \"\"\"Return ``True`` if:\n    - all packages are contained by the same parent directory, **and**\n    - all packages become importable if the parent directory is added to ``sys.path``.\n\n    >>> _simple_layout(['a'], {\"\": \"src\"}, \"/tmp/myproj\")\n    True\n    >>> _simple_layout(['a', 'a.b'], {\"\": \"src\"}, \"/tmp/myproj\")\n    True\n    >>> _simple_layout(['a', 'a.b'], {}, \"/tmp/myproj\")\n    True\n    >>> _simple_layout(['a', 'a.a1', 'a.a1.a2', 'b'], {\"\": \"src\"}, \"/tmp/myproj\")\n    True\n    >>> _simple_layout(['a', 'a.a1', 'a.a1.a2', 'b'], {\"a\": \"a\", \"b\": \"b\"}, \".\")\n    True\n    >>> _simple_layout(['a', 'a.a1', 'a.a1.a2', 'b'], {\"a\": \"_a\", \"b\": \"_b\"}, \".\")\n    False\n    >>> _simple_layout(['a', 'a.a1', 'a.a1.a2', 'b'], {\"a\": \"_a\"}, \"/tmp/myproj\")\n    False\n    >>> _simple_layout(['a', 'a.a1', 'a.a1.a2', 'b'], {\"a.a1.a2\": \"_a2\"}, \".\")\n    False\n    >>> _simple_layout(['a', 'a.b'], {\"\": \"src\", \"a.b\": \"_ab\"}, \"/tmp/myproj\")\n    False\n    >>> # Special cases, no packages yet:\n    >>> _simple_layout([], {\"\": \"src\"}, \"/tmp/myproj\")\n    True\n    >>> _simple_layout([], {\"a\": \"_a\", \"\": \"src\"}, \"/tmp/myproj\")\n    False\n    \"\"\"\n    layout = {pkg: find_package_path(pkg, package_dir, project_dir) for pkg in packages}\n    if not layout:\n        return set(package_dir) in ({}, {\"\"})\n    parent = os.path.commonpath(starmap(_parent_path, layout.items()))\n    return all(\n        _path.same_path(Path(parent, *key.split('.')), value)\n        for key, value in layout.items()\n    )\n\n\ndef _parent_path(pkg, pkg_path):\n    \"\"\"Infer the parent path containing a package, that if added to ``sys.path`` would\n    allow importing that package.\n    When ``pkg`` is directly mapped into a directory with a different name, return its\n    own path.\n    >>> _parent_path(\"a\", \"src/a\")\n    'src'\n    >>> _parent_path(\"b\", \"src/c\")\n    'src/c'\n    \"\"\"\n    parent = pkg_path[: -len(pkg)] if pkg_path.endswith(pkg) else pkg_path\n    return parent.rstrip(\"/\" + os.sep)\n\n\ndef _find_packages(dist: Distribution) -> Iterator[str]:\n    yield from iter(dist.packages or [])\n\n    py_modules = dist.py_modules or []\n    nested_modules = [mod for mod in py_modules if \".\" in mod]\n    if dist.ext_package:\n        yield dist.ext_package\n    else:\n        ext_modules = dist.ext_modules or []\n        nested_modules += [x.name for x in ext_modules if \".\" in x.name]\n\n    for module in nested_modules:\n        package, _, _ = module.rpartition(\".\")\n        yield package\n\n\ndef _find_top_level_modules(dist: Distribution) -> Iterator[str]:\n    py_modules = dist.py_modules or []\n    yield from (mod for mod in py_modules if \".\" not in mod)\n\n    if not dist.ext_package:\n        ext_modules = dist.ext_modules or []\n        yield from (x.name for x in ext_modules if \".\" not in x.name)\n\n\ndef _find_package_roots(\n    packages: Iterable[str],\n    package_dir: Mapping[str, str],\n    src_root: StrPath,\n) -> dict[str, str]:\n    pkg_roots: dict[str, str] = {\n        pkg: _absolute_root(find_package_path(pkg, package_dir, src_root))\n        for pkg in sorted(packages)\n    }\n\n    return _remove_nested(pkg_roots)\n\n\ndef _absolute_root(path: StrPath) -> str:\n    \"\"\"Works for packages and top-level modules\"\"\"\n    path_ = Path(path)\n    parent = path_.parent\n\n    if path_.exists():\n        return str(path_.resolve())\n    else:\n        return str(parent.resolve() / path_.name)\n\n\ndef _find_virtual_namespaces(pkg_roots: dict[str, str]) -> Iterator[str]:\n    \"\"\"By carefully designing ``package_dir``, it is possible to implement the logical\n    structure of PEP 420 in a package without the corresponding directories.\n\n    Moreover a parent package can be purposefully/accidentally skipped in the discovery\n    phase (e.g. ``find_packages(include=[\"mypkg.*\"])``, when ``mypkg.foo`` is included\n    by ``mypkg`` itself is not).\n    We consider this case to also be a virtual namespace (ignoring the original\n    directory) to emulate a non-editable installation.\n\n    This function will try to find these kinds of namespaces.\n    \"\"\"\n    for pkg in pkg_roots:\n        if \".\" not in pkg:\n            continue\n        parts = pkg.split(\".\")\n        for i in range(len(parts) - 1, 0, -1):\n            partial_name = \".\".join(parts[:i])\n            path = Path(find_package_path(partial_name, pkg_roots, \"\"))\n            if not path.exists() or partial_name not in pkg_roots:\n                # partial_name not in pkg_roots ==> purposefully/accidentally skipped\n                yield partial_name\n\n\ndef _find_namespaces(\n    packages: list[str], pkg_roots: dict[str, str]\n) -> Iterator[tuple[str, list[str]]]:\n    for pkg in packages:\n        path = find_package_path(pkg, pkg_roots, \"\")\n        if Path(path).exists() and not Path(path, \"__init__.py\").exists():\n            yield (pkg, [path])\n\n\ndef _remove_nested(pkg_roots: dict[str, str]) -> dict[str, str]:\n    output = dict(pkg_roots.copy())\n\n    for pkg, path in reversed(list(pkg_roots.items())):\n        if any(\n            pkg != other and _is_nested(pkg, path, other, other_path)\n            for other, other_path in pkg_roots.items()\n        ):\n            output.pop(pkg)\n\n    return output\n\n\ndef _is_nested(pkg: str, pkg_path: str, parent: str, parent_path: str) -> bool:\n    \"\"\"\n    Return ``True`` if ``pkg`` is nested inside ``parent`` both logically and in the\n    file system.\n    >>> _is_nested(\"a.b\", \"path/a/b\", \"a\", \"path/a\")\n    True\n    >>> _is_nested(\"a.b\", \"path/a/b\", \"a\", \"otherpath/a\")\n    False\n    >>> _is_nested(\"a.b\", \"path/a/b\", \"c\", \"path/c\")\n    False\n    >>> _is_nested(\"a.a\", \"path/a/a\", \"a\", \"path/a\")\n    True\n    >>> _is_nested(\"b.a\", \"path/b/a\", \"a\", \"path/a\")\n    False\n    \"\"\"\n    norm_pkg_path = _path.normpath(pkg_path)\n    rest = pkg.replace(parent, \"\", 1).strip(\".\").split(\".\")\n    return pkg.startswith(parent) and norm_pkg_path == _path.normpath(\n        Path(parent_path, *rest)\n    )\n\n\ndef _empty_dir(dir_: _P) -> _P:\n    \"\"\"Create a directory ensured to be empty. Existing files may be removed.\"\"\"\n    shutil.rmtree(dir_, ignore_errors=True)\n    os.makedirs(dir_)\n    return dir_\n\n\nclass _NamespaceInstaller(namespaces.Installer):\n    def __init__(self, distribution, installation_dir, editable_name, src_root):\n        self.distribution = distribution\n        self.src_root = src_root\n        self.installation_dir = installation_dir\n        self.editable_name = editable_name\n        self.outputs = []\n        self.dry_run = False\n\n    def _get_nspkg_file(self):\n        \"\"\"Installation target.\"\"\"\n        return os.path.join(self.installation_dir, self.editable_name + self.nspkg_ext)\n\n    def _get_root(self):\n        \"\"\"Where the modules/packages should be loaded from.\"\"\"\n        return repr(str(self.src_root))\n\n\n_FINDER_TEMPLATE = \"\"\"\\\nfrom __future__ import annotations\nimport sys\nfrom importlib.machinery import ModuleSpec, PathFinder\nfrom importlib.machinery import all_suffixes as module_suffixes\nfrom importlib.util import spec_from_file_location\nfrom itertools import chain\nfrom pathlib import Path\n\nMAPPING: dict[str, str] = {mapping!r}\nNAMESPACES: dict[str, list[str]] = {namespaces!r}\nPATH_PLACEHOLDER = {name!r} + \".__path_hook__\"\n\n\nclass _EditableFinder:  # MetaPathFinder\n    @classmethod\n    def find_spec(cls, fullname: str, _path=None, _target=None) -> ModuleSpec | None:\n        # Top-level packages and modules (we know these exist in the FS)\n        if fullname in MAPPING:\n            pkg_path = MAPPING[fullname]\n            return cls._find_spec(fullname, Path(pkg_path))\n\n        # Handle immediate children modules (required for namespaces to work)\n        # To avoid problems with case sensitivity in the file system we delegate\n        # to the importlib.machinery implementation.\n        parent, _, child = fullname.rpartition(\".\")\n        if parent and parent in MAPPING:\n            return PathFinder.find_spec(fullname, path=[MAPPING[parent]])\n\n        # Other levels of nesting should be handled automatically by importlib\n        # using the parent path.\n        return None\n\n    @classmethod\n    def _find_spec(cls, fullname: str, candidate_path: Path) -> ModuleSpec | None:\n        init = candidate_path / \"__init__.py\"\n        candidates = (candidate_path.with_suffix(x) for x in module_suffixes())\n        for candidate in chain([init], candidates):\n            if candidate.exists():\n                return spec_from_file_location(fullname, candidate)\n        return None\n\n\nclass _EditableNamespaceFinder:  # PathEntryFinder\n    @classmethod\n    def _path_hook(cls, path) -> type[_EditableNamespaceFinder]:\n        if path == PATH_PLACEHOLDER:\n            return cls\n        raise ImportError\n\n    @classmethod\n    def _paths(cls, fullname: str) -> list[str]:\n        paths = NAMESPACES[fullname]\n        if not paths and fullname in MAPPING:\n            paths = [MAPPING[fullname]]\n        # Always add placeholder, for 2 reasons:\n        # 1. __path__ cannot be empty for the spec to be considered namespace.\n        # 2. In the case of nested namespaces, we need to force\n        #    import machinery to query _EditableNamespaceFinder again.\n        return [*paths, PATH_PLACEHOLDER]\n\n    @classmethod\n    def find_spec(cls, fullname: str, _target=None) -> ModuleSpec | None:\n        if fullname in NAMESPACES:\n            spec = ModuleSpec(fullname, None, is_package=True)\n            spec.submodule_search_locations = cls._paths(fullname)\n            return spec\n        return None\n\n    @classmethod\n    def find_module(cls, _fullname) -> None:\n        return None\n\n\ndef install():\n    if not any(finder == _EditableFinder for finder in sys.meta_path):\n        sys.meta_path.append(_EditableFinder)\n\n    if not NAMESPACES:\n        return\n\n    if not any(hook == _EditableNamespaceFinder._path_hook for hook in sys.path_hooks):\n        # PathEntryFinder is needed to create NamespaceSpec without private APIS\n        sys.path_hooks.append(_EditableNamespaceFinder._path_hook)\n    if PATH_PLACEHOLDER not in sys.path:\n        sys.path.append(PATH_PLACEHOLDER)  # Used just to trigger the path hook\n\"\"\"\n\n\ndef _finder_template(\n    name: str, mapping: Mapping[str, str], namespaces: dict[str, list[str]]\n) -> str:\n    \"\"\"Create a string containing the code for the``MetaPathFinder`` and\n    ``PathEntryFinder``.\n    \"\"\"\n    mapping = dict(sorted(mapping.items(), key=lambda p: p[0]))\n    return _FINDER_TEMPLATE.format(name=name, mapping=mapping, namespaces=namespaces)\n\n\nclass LinksNotSupported(errors.FileError):\n    \"\"\"File system does not seem to support either symlinks or hard links.\"\"\"\n\n\nclass _DebuggingTips(SetuptoolsWarning):\n    _SUMMARY = \"Problem in editable installation.\"\n    _DETAILS = \"\"\"\n    An error happened while installing `{project}` in editable mode.\n\n    The following steps are recommended to help debug this problem:\n\n    - Try to install the project normally, without using the editable mode.\n      Does the error still persist?\n      (If it does, try fixing the problem before attempting the editable mode).\n    - If you are using binary extensions, make sure you have all OS-level\n      dependencies installed (e.g. compilers, toolchains, binary libraries, ...).\n    - Try the latest version of setuptools (maybe the error was already fixed).\n    - If you (or your project dependencies) are using any setuptools extension\n      or customization, make sure they support the editable mode.\n\n    After following the steps above, if the problem still persists and\n    you think this is related to how setuptools handles editable installations,\n    please submit a reproducible example\n    (see https://stackoverflow.com/help/minimal-reproducible-example) to:\n\n        https://github.com/pypa/setuptools/issues\n    \"\"\"\n    _SEE_DOCS = \"userguide/development_mode.html\"\n", "setuptools/command/egg_info.py": "\"\"\"setuptools.command.egg_info\n\nCreate a distribution's .egg-info directory and contents\"\"\"\n\nfrom distutils.filelist import FileList as _FileList\nfrom distutils.errors import DistutilsInternalError\nfrom distutils.util import convert_path\nfrom distutils import log\nimport distutils.errors\nimport distutils.filelist\nimport functools\nimport os\nimport re\nimport sys\nimport time\nimport collections\n\nfrom .._importlib import metadata\nfrom .. import _entry_points, _normalization\nfrom . import _requirestxt\n\nfrom setuptools import Command\nfrom setuptools.command.sdist import sdist\nfrom setuptools.command.sdist import walk_revctrl\nfrom setuptools.command.setopt import edit_config\nfrom setuptools.command import bdist_egg\nimport setuptools.unicode_utils as unicode_utils\nfrom setuptools.glob import glob\n\nfrom setuptools.extern import packaging\nfrom ..warnings import SetuptoolsDeprecationWarning\n\n\nPY_MAJOR = '{}.{}'.format(*sys.version_info)\n\n\ndef translate_pattern(glob):  # noqa: C901  # is too complex (14)  # FIXME\n    \"\"\"\n    Translate a file path glob like '*.txt' in to a regular expression.\n    This differs from fnmatch.translate which allows wildcards to match\n    directory separators. It also knows about '**/' which matches any number of\n    directories.\n    \"\"\"\n    pat = ''\n\n    # This will split on '/' within [character classes]. This is deliberate.\n    chunks = glob.split(os.path.sep)\n\n    sep = re.escape(os.sep)\n    valid_char = '[^%s]' % (sep,)\n\n    for c, chunk in enumerate(chunks):\n        last_chunk = c == len(chunks) - 1\n\n        # Chunks that are a literal ** are globstars. They match anything.\n        if chunk == '**':\n            if last_chunk:\n                # Match anything if this is the last component\n                pat += '.*'\n            else:\n                # Match '(name/)*'\n                pat += '(?:%s+%s)*' % (valid_char, sep)\n            continue  # Break here as the whole path component has been handled\n\n        # Find any special characters in the remainder\n        i = 0\n        chunk_len = len(chunk)\n        while i < chunk_len:\n            char = chunk[i]\n            if char == '*':\n                # Match any number of name characters\n                pat += valid_char + '*'\n            elif char == '?':\n                # Match a name character\n                pat += valid_char\n            elif char == '[':\n                # Character class\n                inner_i = i + 1\n                # Skip initial !/] chars\n                if inner_i < chunk_len and chunk[inner_i] == '!':\n                    inner_i = inner_i + 1\n                if inner_i < chunk_len and chunk[inner_i] == ']':\n                    inner_i = inner_i + 1\n\n                # Loop till the closing ] is found\n                while inner_i < chunk_len and chunk[inner_i] != ']':\n                    inner_i = inner_i + 1\n\n                if inner_i >= chunk_len:\n                    # Got to the end of the string without finding a closing ]\n                    # Do not treat this as a matching group, but as a literal [\n                    pat += re.escape(char)\n                else:\n                    # Grab the insides of the [brackets]\n                    inner = chunk[i + 1 : inner_i]\n                    char_class = ''\n\n                    # Class negation\n                    if inner[0] == '!':\n                        char_class = '^'\n                        inner = inner[1:]\n\n                    char_class += re.escape(inner)\n                    pat += '[%s]' % (char_class,)\n\n                    # Skip to the end ]\n                    i = inner_i\n            else:\n                pat += re.escape(char)\n            i += 1\n\n        # Join each chunk with the dir separator\n        if not last_chunk:\n            pat += sep\n\n    pat += r'\\Z'\n    return re.compile(pat, flags=re.MULTILINE | re.DOTALL)\n\n\nclass InfoCommon:\n    tag_build = None\n    tag_date = None\n\n    @property\n    def name(self):\n        return _normalization.safe_name(self.distribution.get_name())\n\n    def tagged_version(self):\n        tagged = self._maybe_tag(self.distribution.get_version())\n        return _normalization.safe_version(tagged)\n\n    def _maybe_tag(self, version):\n        \"\"\"\n        egg_info may be called more than once for a distribution,\n        in which case the version string already contains all tags.\n        \"\"\"\n        return (\n            version\n            if self.vtags and self._already_tagged(version)\n            else version + self.vtags\n        )\n\n    def _already_tagged(self, version: str) -> bool:\n        # Depending on their format, tags may change with version normalization.\n        # So in addition the regular tags, we have to search for the normalized ones.\n        return version.endswith(self.vtags) or version.endswith(self._safe_tags())\n\n    def _safe_tags(self) -> str:\n        # To implement this we can rely on `safe_version` pretending to be version 0\n        # followed by tags. Then we simply discard the starting 0 (fake version number)\n        try:\n            return _normalization.safe_version(f\"0{self.vtags}\")[1:]\n        except packaging.version.InvalidVersion:\n            return _normalization.safe_name(self.vtags.replace(' ', '.'))\n\n    def tags(self) -> str:\n        version = ''\n        if self.tag_build:\n            version += self.tag_build\n        if self.tag_date:\n            version += time.strftime(\"%Y%m%d\")\n        return version\n\n    vtags = property(tags)\n\n\nclass egg_info(InfoCommon, Command):\n    description = \"create a distribution's .egg-info directory\"\n\n    user_options = [\n        (\n            'egg-base=',\n            'e',\n            \"directory containing .egg-info directories\"\n            \" (default: top of the source tree)\",\n        ),\n        ('tag-date', 'd', \"Add date stamp (e.g. 20050528) to version number\"),\n        ('tag-build=', 'b', \"Specify explicit tag to add to version number\"),\n        ('no-date', 'D', \"Don't include date stamp [default]\"),\n    ]\n\n    boolean_options = ['tag-date']\n    negative_opt = {\n        'no-date': 'tag-date',\n    }\n\n    def initialize_options(self):\n        self.egg_base = None\n        self.egg_name = None\n        self.egg_info = None\n        self.egg_version = None\n        self.ignore_egg_info_in_manifest = False\n\n    ####################################\n    # allow the 'tag_svn_revision' to be detected and\n    # set, supporting sdists built on older Setuptools.\n    @property\n    def tag_svn_revision(self):\n        pass\n\n    @tag_svn_revision.setter\n    def tag_svn_revision(self, value):\n        pass\n\n    ####################################\n\n    def save_version_info(self, filename):\n        \"\"\"\n        Materialize the value of date into the\n        build tag. Install build keys in a deterministic order\n        to avoid arbitrary reordering on subsequent builds.\n        \"\"\"\n        egg_info = collections.OrderedDict()\n        # follow the order these keys would have been added\n        # when PYTHONHASHSEED=0\n        egg_info['tag_build'] = self.tags()\n        egg_info['tag_date'] = 0\n        edit_config(filename, dict(egg_info=egg_info))\n\n    def finalize_options(self):\n        # Note: we need to capture the current value returned\n        # by `self.tagged_version()`, so we can later update\n        # `self.distribution.metadata.version` without\n        # repercussions.\n        self.egg_name = self.name\n        self.egg_version = self.tagged_version()\n        parsed_version = packaging.version.Version(self.egg_version)\n\n        try:\n            is_version = isinstance(parsed_version, packaging.version.Version)\n            spec = \"%s==%s\" if is_version else \"%s===%s\"\n            packaging.requirements.Requirement(spec % (self.egg_name, self.egg_version))\n        except ValueError as e:\n            raise distutils.errors.DistutilsOptionError(\n                \"Invalid distribution name or version syntax: %s-%s\"\n                % (self.egg_name, self.egg_version)\n            ) from e\n\n        if self.egg_base is None:\n            dirs = self.distribution.package_dir\n            self.egg_base = (dirs or {}).get('', os.curdir)\n\n        self.ensure_dirname('egg_base')\n        self.egg_info = _normalization.filename_component(self.egg_name) + '.egg-info'\n        if self.egg_base != os.curdir:\n            self.egg_info = os.path.join(self.egg_base, self.egg_info)\n\n        # Set package version for the benefit of dumber commands\n        # (e.g. sdist, bdist_wininst, etc.)\n        #\n        self.distribution.metadata.version = self.egg_version\n\n        # If we bootstrapped around the lack of a PKG-INFO, as might be the\n        # case in a fresh checkout, make sure that any special tags get added\n        # to the version info\n        #\n        pd = self.distribution._patched_dist\n        key = getattr(pd, \"key\", None) or getattr(pd, \"name\", None)\n        if pd is not None and key == self.egg_name.lower():\n            pd._version = self.egg_version\n            pd._parsed_version = packaging.version.Version(self.egg_version)\n            self.distribution._patched_dist = None\n\n    def _get_egg_basename(self, py_version=PY_MAJOR, platform=None):\n        \"\"\"Compute filename of the output egg. Private API.\"\"\"\n        return _egg_basename(self.egg_name, self.egg_version, py_version, platform)\n\n    def write_or_delete_file(self, what, filename, data, force=False):\n        \"\"\"Write `data` to `filename` or delete if empty\n\n        If `data` is non-empty, this routine is the same as ``write_file()``.\n        If `data` is empty but not ``None``, this is the same as calling\n        ``delete_file(filename)`.  If `data` is ``None``, then this is a no-op\n        unless `filename` exists, in which case a warning is issued about the\n        orphaned file (if `force` is false), or deleted (if `force` is true).\n        \"\"\"\n        if data:\n            self.write_file(what, filename, data)\n        elif os.path.exists(filename):\n            if data is None and not force:\n                log.warn(\"%s not set in setup(), but %s exists\", what, filename)\n                return\n            else:\n                self.delete_file(filename)\n\n    def write_file(self, what, filename, data):\n        \"\"\"Write `data` to `filename` (if not a dry run) after announcing it\n\n        `what` is used in a log message to identify what is being written\n        to the file.\n        \"\"\"\n        log.info(\"writing %s to %s\", what, filename)\n        data = data.encode(\"utf-8\")\n        if not self.dry_run:\n            f = open(filename, 'wb')\n            f.write(data)\n            f.close()\n\n    def delete_file(self, filename):\n        \"\"\"Delete `filename` (if not a dry run) after announcing it\"\"\"\n        log.info(\"deleting %s\", filename)\n        if not self.dry_run:\n            os.unlink(filename)\n\n    def run(self):\n        self.mkpath(self.egg_info)\n        try:\n            os.utime(self.egg_info, None)\n        except OSError as e:\n            msg = f\"Cannot update time stamp of directory '{self.egg_info}'\"\n            raise distutils.errors.DistutilsFileError(msg) from e\n        for ep in metadata.entry_points(group='egg_info.writers'):\n            writer = ep.load()\n            writer(self, ep.name, os.path.join(self.egg_info, ep.name))\n\n        # Get rid of native_libs.txt if it was put there by older bdist_egg\n        nl = os.path.join(self.egg_info, \"native_libs.txt\")\n        if os.path.exists(nl):\n            self.delete_file(nl)\n\n        self.find_sources()\n\n    def find_sources(self):\n        \"\"\"Generate SOURCES.txt manifest file\"\"\"\n        manifest_filename = os.path.join(self.egg_info, \"SOURCES.txt\")\n        mm = manifest_maker(self.distribution)\n        mm.ignore_egg_info_dir = self.ignore_egg_info_in_manifest\n        mm.manifest = manifest_filename\n        mm.run()\n        self.filelist = mm.filelist\n\n\nclass FileList(_FileList):\n    # Implementations of the various MANIFEST.in commands\n\n    def __init__(self, warn=None, debug_print=None, ignore_egg_info_dir=False):\n        super().__init__(warn, debug_print)\n        self.ignore_egg_info_dir = ignore_egg_info_dir\n\n    def process_template_line(self, line):\n        # Parse the line: split it up, make sure the right number of words\n        # is there, and return the relevant words.  'action' is always\n        # defined: it's the first word of the line.  Which of the other\n        # three are defined depends on the action; it'll be either\n        # patterns, (dir and patterns), or (dir_pattern).\n        (action, patterns, dir, dir_pattern) = self._parse_template_line(line)\n\n        action_map = {\n            'include': self.include,\n            'exclude': self.exclude,\n            'global-include': self.global_include,\n            'global-exclude': self.global_exclude,\n            'recursive-include': functools.partial(\n                self.recursive_include,\n                dir,\n            ),\n            'recursive-exclude': functools.partial(\n                self.recursive_exclude,\n                dir,\n            ),\n            'graft': self.graft,\n            'prune': self.prune,\n        }\n        log_map = {\n            'include': \"warning: no files found matching '%s'\",\n            'exclude': (\"warning: no previously-included files found \" \"matching '%s'\"),\n            'global-include': (\n                \"warning: no files found matching '%s' \" \"anywhere in distribution\"\n            ),\n            'global-exclude': (\n                \"warning: no previously-included files matching \"\n                \"'%s' found anywhere in distribution\"\n            ),\n            'recursive-include': (\n                \"warning: no files found matching '%s' \" \"under directory '%s'\"\n            ),\n            'recursive-exclude': (\n                \"warning: no previously-included files matching \"\n                \"'%s' found under directory '%s'\"\n            ),\n            'graft': \"warning: no directories found matching '%s'\",\n            'prune': \"no previously-included directories found matching '%s'\",\n        }\n\n        try:\n            process_action = action_map[action]\n        except KeyError:\n            msg = f\"Invalid MANIFEST.in: unknown action {action!r} in {line!r}\"\n            raise DistutilsInternalError(msg) from None\n\n        # OK, now we know that the action is valid and we have the\n        # right number of words on the line for that action -- so we\n        # can proceed with minimal error-checking.\n\n        action_is_recursive = action.startswith('recursive-')\n        if action in {'graft', 'prune'}:\n            patterns = [dir_pattern]\n        extra_log_args = (dir,) if action_is_recursive else ()\n        log_tmpl = log_map[action]\n\n        self.debug_print(\n            ' '.join(\n                [action] + ([dir] if action_is_recursive else []) + patterns,\n            )\n        )\n        for pattern in patterns:\n            if not process_action(pattern):\n                log.warn(log_tmpl, pattern, *extra_log_args)\n\n    def _remove_files(self, predicate):\n        \"\"\"\n        Remove all files from the file list that match the predicate.\n        Return True if any matching files were removed\n        \"\"\"\n        found = False\n        for i in range(len(self.files) - 1, -1, -1):\n            if predicate(self.files[i]):\n                self.debug_print(\" removing \" + self.files[i])\n                del self.files[i]\n                found = True\n        return found\n\n    def include(self, pattern):\n        \"\"\"Include files that match 'pattern'.\"\"\"\n        found = [f for f in glob(pattern) if not os.path.isdir(f)]\n        self.extend(found)\n        return bool(found)\n\n    def exclude(self, pattern):\n        \"\"\"Exclude files that match 'pattern'.\"\"\"\n        match = translate_pattern(pattern)\n        return self._remove_files(match.match)\n\n    def recursive_include(self, dir, pattern):\n        \"\"\"\n        Include all files anywhere in 'dir/' that match the pattern.\n        \"\"\"\n        full_pattern = os.path.join(dir, '**', pattern)\n        found = [f for f in glob(full_pattern, recursive=True) if not os.path.isdir(f)]\n        self.extend(found)\n        return bool(found)\n\n    def recursive_exclude(self, dir, pattern):\n        \"\"\"\n        Exclude any file anywhere in 'dir/' that match the pattern.\n        \"\"\"\n        match = translate_pattern(os.path.join(dir, '**', pattern))\n        return self._remove_files(match.match)\n\n    def graft(self, dir):\n        \"\"\"Include all files from 'dir/'.\"\"\"\n        found = [\n            item\n            for match_dir in glob(dir)\n            for item in distutils.filelist.findall(match_dir)\n        ]\n        self.extend(found)\n        return bool(found)\n\n    def prune(self, dir):\n        \"\"\"Filter out files from 'dir/'.\"\"\"\n        match = translate_pattern(os.path.join(dir, '**'))\n        return self._remove_files(match.match)\n\n    def global_include(self, pattern):\n        \"\"\"\n        Include all files anywhere in the current directory that match the\n        pattern. This is very inefficient on large file trees.\n        \"\"\"\n        if self.allfiles is None:\n            self.findall()\n        match = translate_pattern(os.path.join('**', pattern))\n        found = [f for f in self.allfiles if match.match(f)]\n        self.extend(found)\n        return bool(found)\n\n    def global_exclude(self, pattern):\n        \"\"\"\n        Exclude all files anywhere that match the pattern.\n        \"\"\"\n        match = translate_pattern(os.path.join('**', pattern))\n        return self._remove_files(match.match)\n\n    def append(self, item):\n        if item.endswith('\\r'):  # Fix older sdists built on Windows\n            item = item[:-1]\n        path = convert_path(item)\n\n        if self._safe_path(path):\n            self.files.append(path)\n\n    def extend(self, paths):\n        self.files.extend(filter(self._safe_path, paths))\n\n    def _repair(self):\n        \"\"\"\n        Replace self.files with only safe paths\n\n        Because some owners of FileList manipulate the underlying\n        ``files`` attribute directly, this method must be called to\n        repair those paths.\n        \"\"\"\n        self.files = list(filter(self._safe_path, self.files))\n\n    def _safe_path(self, path):\n        enc_warn = \"'%s' not %s encodable -- skipping\"\n\n        # To avoid accidental trans-codings errors, first to unicode\n        u_path = unicode_utils.filesys_decode(path)\n        if u_path is None:\n            log.warn(\"'%s' in unexpected encoding -- skipping\" % path)\n            return False\n\n        # Must ensure utf-8 encodability\n        utf8_path = unicode_utils.try_encode(u_path, \"utf-8\")\n        if utf8_path is None:\n            log.warn(enc_warn, path, 'utf-8')\n            return False\n\n        try:\n            # ignore egg-info paths\n            is_egg_info = \".egg-info\" in u_path or b\".egg-info\" in utf8_path\n            if self.ignore_egg_info_dir and is_egg_info:\n                return False\n            # accept is either way checks out\n            if os.path.exists(u_path) or os.path.exists(utf8_path):\n                return True\n        # this will catch any encode errors decoding u_path\n        except UnicodeEncodeError:\n            log.warn(enc_warn, path, sys.getfilesystemencoding())\n\n\nclass manifest_maker(sdist):\n    template = \"MANIFEST.in\"\n\n    def initialize_options(self):\n        self.use_defaults = True\n        self.prune = True\n        self.manifest_only = True\n        self.force_manifest = True\n        self.ignore_egg_info_dir = False\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        self.filelist = FileList(ignore_egg_info_dir=self.ignore_egg_info_dir)\n        if not os.path.exists(self.manifest):\n            self.write_manifest()  # it must exist so it'll get in the list\n        self.add_defaults()\n        if os.path.exists(self.template):\n            self.read_template()\n        self.add_license_files()\n        self._add_referenced_files()\n        self.prune_file_list()\n        self.filelist.sort()\n        self.filelist.remove_duplicates()\n        self.write_manifest()\n\n    def _manifest_normalize(self, path):\n        path = unicode_utils.filesys_decode(path)\n        return path.replace(os.sep, '/')\n\n    def write_manifest(self):\n        \"\"\"\n        Write the file list in 'self.filelist' to the manifest file\n        named by 'self.manifest'.\n        \"\"\"\n        self.filelist._repair()\n\n        # Now _repairs should encodability, but not unicode\n        files = [self._manifest_normalize(f) for f in self.filelist.files]\n        msg = \"writing manifest file '%s'\" % self.manifest\n        self.execute(write_file, (self.manifest, files), msg)\n\n    def warn(self, msg):\n        if not self._should_suppress_warning(msg):\n            sdist.warn(self, msg)\n\n    @staticmethod\n    def _should_suppress_warning(msg):\n        \"\"\"\n        suppress missing-file warnings from sdist\n        \"\"\"\n        return re.match(r\"standard file .*not found\", msg)\n\n    def add_defaults(self):\n        sdist.add_defaults(self)\n        self.filelist.append(self.template)\n        self.filelist.append(self.manifest)\n        rcfiles = list(walk_revctrl())\n        if rcfiles:\n            self.filelist.extend(rcfiles)\n        elif os.path.exists(self.manifest):\n            self.read_manifest()\n\n        if os.path.exists(\"setup.py\"):\n            # setup.py should be included by default, even if it's not\n            # the script called to create the sdist\n            self.filelist.append(\"setup.py\")\n\n        ei_cmd = self.get_finalized_command('egg_info')\n        self.filelist.graft(ei_cmd.egg_info)\n\n    def add_license_files(self):\n        license_files = self.distribution.metadata.license_files or []\n        for lf in license_files:\n            log.info(\"adding license file '%s'\", lf)\n        self.filelist.extend(license_files)\n\n    def _add_referenced_files(self):\n        \"\"\"Add files referenced by the config (e.g. `file:` directive) to filelist\"\"\"\n        referenced = getattr(self.distribution, '_referenced_files', [])\n        # ^-- fallback if dist comes from distutils or is a custom class\n        for rf in referenced:\n            log.debug(\"adding file referenced by config '%s'\", rf)\n        self.filelist.extend(referenced)\n\n    def prune_file_list(self):\n        build = self.get_finalized_command('build')\n        base_dir = self.distribution.get_fullname()\n        self.filelist.prune(build.build_base)\n        self.filelist.prune(base_dir)\n        sep = re.escape(os.sep)\n        self.filelist.exclude_pattern(\n            r'(^|' + sep + r')(RCS|CVS|\\.svn)' + sep, is_regex=True\n        )\n\n    def _safe_data_files(self, build_py):\n        \"\"\"\n        The parent class implementation of this method\n        (``sdist``) will try to include data files, which\n        might cause recursion problems when\n        ``include_package_data=True``.\n\n        Therefore, avoid triggering any attempt of\n        analyzing/building the manifest again.\n        \"\"\"\n        if hasattr(build_py, 'get_data_files_without_manifest'):\n            return build_py.get_data_files_without_manifest()\n\n        SetuptoolsDeprecationWarning.emit(\n            \"`build_py` command does not inherit from setuptools' `build_py`.\",\n            \"\"\"\n            Custom 'build_py' does not implement 'get_data_files_without_manifest'.\n            Please extend command classes from setuptools instead of distutils.\n            \"\"\",\n            see_url=\"https://peps.python.org/pep-0632/\",\n            # due_date not defined yet, old projects might still do it?\n        )\n        return build_py.get_data_files()\n\n\ndef write_file(filename, contents):\n    \"\"\"Create a file with the specified name and write 'contents' (a\n    sequence of strings without line terminators) to it.\n    \"\"\"\n    contents = \"\\n\".join(contents)\n\n    # assuming the contents has been vetted for utf-8 encoding\n    contents = contents.encode(\"utf-8\")\n\n    with open(filename, \"wb\") as f:  # always write POSIX-style manifest\n        f.write(contents)\n\n\ndef write_pkg_info(cmd, basename, filename):\n    log.info(\"writing %s\", filename)\n    if not cmd.dry_run:\n        metadata = cmd.distribution.metadata\n        metadata.version, oldver = cmd.egg_version, metadata.version\n        metadata.name, oldname = cmd.egg_name, metadata.name\n\n        try:\n            # write unescaped data to PKG-INFO, so older pkg_resources\n            # can still parse it\n            metadata.write_pkg_info(cmd.egg_info)\n        finally:\n            metadata.name, metadata.version = oldname, oldver\n\n        safe = getattr(cmd.distribution, 'zip_safe', None)\n\n        bdist_egg.write_safety_flag(cmd.egg_info, safe)\n\n\ndef warn_depends_obsolete(cmd, basename, filename):\n    \"\"\"\n    Unused: left to avoid errors when updating (from source) from <= 67.8.\n    Old installations have a .dist-info directory with the entry-point\n    ``depends.txt = setuptools.command.egg_info:warn_depends_obsolete``.\n    This may trigger errors when running the first egg_info in build_meta.\n    TODO: Remove this function in a version sufficiently > 68.\n    \"\"\"\n\n\n# Export API used in entry_points\nwrite_requirements = _requirestxt.write_requirements\nwrite_setup_requirements = _requirestxt.write_setup_requirements\n\n\ndef write_toplevel_names(cmd, basename, filename):\n    pkgs = dict.fromkeys([\n        k.split('.', 1)[0] for k in cmd.distribution.iter_distribution_names()\n    ])\n    cmd.write_file(\"top-level names\", filename, '\\n'.join(sorted(pkgs)) + '\\n')\n\n\ndef overwrite_arg(cmd, basename, filename):\n    write_arg(cmd, basename, filename, True)\n\n\ndef write_arg(cmd, basename, filename, force=False):\n    argname = os.path.splitext(basename)[0]\n    value = getattr(cmd.distribution, argname, None)\n    if value is not None:\n        value = '\\n'.join(value) + '\\n'\n    cmd.write_or_delete_file(argname, filename, value, force)\n\n\ndef write_entries(cmd, basename, filename):\n    eps = _entry_points.load(cmd.distribution.entry_points)\n    defn = _entry_points.render(eps)\n    cmd.write_or_delete_file('entry points', filename, defn, True)\n\n\ndef _egg_basename(egg_name, egg_version, py_version=None, platform=None):\n    \"\"\"Compute filename of the output egg. Private API.\"\"\"\n    name = _normalization.filename_component(egg_name)\n    version = _normalization.filename_component(egg_version)\n    egg = f\"{name}-{version}-py{py_version or PY_MAJOR}\"\n    if platform:\n        egg += f\"-{platform}\"\n    return egg\n\n\nclass EggInfoDeprecationWarning(SetuptoolsDeprecationWarning):\n    \"\"\"Deprecated behavior warning for EggInfo, bypassing suppression.\"\"\"\n", "setuptools/command/build_py.py": "from __future__ import annotations\n\nfrom functools import partial\nfrom glob import glob\nfrom distutils.util import convert_path\nimport distutils.command.build_py as orig\nimport os\nimport fnmatch\nimport textwrap\nimport distutils.errors\nimport itertools\nimport stat\nfrom pathlib import Path\nfrom typing import Iterable, Iterator\n\nfrom ..extern.more_itertools import unique_everseen\nfrom ..warnings import SetuptoolsDeprecationWarning\n\n\n_IMPLICIT_DATA_FILES = ('*.pyi', 'py.typed')\n\n\ndef make_writable(target):\n    os.chmod(target, os.stat(target).st_mode | stat.S_IWRITE)\n\n\nclass build_py(orig.build_py):\n    \"\"\"Enhanced 'build_py' command that includes data files with packages\n\n    The data files are specified via a 'package_data' argument to 'setup()'.\n    See 'setuptools.dist.Distribution' for more details.\n\n    Also, this version of the 'build_py' command allows you to specify both\n    'py_modules' and 'packages' in the same setup operation.\n    \"\"\"\n\n    editable_mode: bool = False\n    existing_egg_info_dir: str | None = None  #: Private API, internal use only.\n\n    def finalize_options(self):\n        orig.build_py.finalize_options(self)\n        self.package_data = self.distribution.package_data\n        self.exclude_package_data = self.distribution.exclude_package_data or {}\n        if 'data_files' in self.__dict__:\n            del self.__dict__['data_files']\n        self.__updated_files = []\n\n    def copy_file(\n        self,\n        infile,\n        outfile,\n        preserve_mode=True,\n        preserve_times=True,\n        link=None,\n        level=1,\n    ):\n        # Overwrite base class to allow using links\n        if link:\n            infile = str(Path(infile).resolve())\n            outfile = str(Path(outfile).resolve())\n        return super().copy_file(\n            infile, outfile, preserve_mode, preserve_times, link, level\n        )\n\n    def run(self):\n        \"\"\"Build modules, packages, and copy data files to build directory\"\"\"\n        if not (self.py_modules or self.packages) or self.editable_mode:\n            return\n\n        if self.py_modules:\n            self.build_modules()\n\n        if self.packages:\n            self.build_packages()\n            self.build_package_data()\n\n        # Only compile actual .py files, using our base class' idea of what our\n        # output files are.\n        self.byte_compile(orig.build_py.get_outputs(self, include_bytecode=False))\n\n    def __getattr__(self, attr):\n        \"lazily compute data files\"\n        if attr == 'data_files':\n            self.data_files = self._get_data_files()\n            return self.data_files\n        return orig.build_py.__getattr__(self, attr)\n\n    def build_module(self, module, module_file, package):\n        outfile, copied = orig.build_py.build_module(self, module, module_file, package)\n        if copied:\n            self.__updated_files.append(outfile)\n        return outfile, copied\n\n    def _get_data_files(self):\n        \"\"\"Generate list of '(package,src_dir,build_dir,filenames)' tuples\"\"\"\n        self.analyze_manifest()\n        return list(map(self._get_pkg_data_files, self.packages or ()))\n\n    def get_data_files_without_manifest(self):\n        \"\"\"\n        Generate list of ``(package,src_dir,build_dir,filenames)`` tuples,\n        but without triggering any attempt to analyze or build the manifest.\n        \"\"\"\n        # Prevent eventual errors from unset `manifest_files`\n        # (that would otherwise be set by `analyze_manifest`)\n        self.__dict__.setdefault('manifest_files', {})\n        return list(map(self._get_pkg_data_files, self.packages or ()))\n\n    def _get_pkg_data_files(self, package):\n        # Locate package source directory\n        src_dir = self.get_package_dir(package)\n\n        # Compute package build directory\n        build_dir = os.path.join(*([self.build_lib] + package.split('.')))\n\n        # Strip directory from globbed filenames\n        filenames = [\n            os.path.relpath(file, src_dir)\n            for file in self.find_data_files(package, src_dir)\n        ]\n        return package, src_dir, build_dir, filenames\n\n    def find_data_files(self, package, src_dir):\n        \"\"\"Return filenames for package's data files in 'src_dir'\"\"\"\n        patterns = self._get_platform_patterns(\n            self.package_data,\n            package,\n            src_dir,\n            extra_patterns=_IMPLICIT_DATA_FILES,\n        )\n        globs_expanded = map(partial(glob, recursive=True), patterns)\n        # flatten the expanded globs into an iterable of matches\n        globs_matches = itertools.chain.from_iterable(globs_expanded)\n        glob_files = filter(os.path.isfile, globs_matches)\n        files = itertools.chain(\n            self.manifest_files.get(package, []),\n            glob_files,\n        )\n        return self.exclude_data_files(package, src_dir, files)\n\n    def get_outputs(self, include_bytecode=True) -> list[str]:\n        \"\"\"See :class:`setuptools.commands.build.SubCommand`\"\"\"\n        if self.editable_mode:\n            return list(self.get_output_mapping().keys())\n        return super().get_outputs(include_bytecode)\n\n    def get_output_mapping(self) -> dict[str, str]:\n        \"\"\"See :class:`setuptools.commands.build.SubCommand`\"\"\"\n        mapping = itertools.chain(\n            self._get_package_data_output_mapping(),\n            self._get_module_mapping(),\n        )\n        return dict(sorted(mapping, key=lambda x: x[0]))\n\n    def _get_module_mapping(self) -> Iterator[tuple[str, str]]:\n        \"\"\"Iterate over all modules producing (dest, src) pairs.\"\"\"\n        for package, module, module_file in self.find_all_modules():\n            package = package.split('.')\n            filename = self.get_module_outfile(self.build_lib, package, module)\n            yield (filename, module_file)\n\n    def _get_package_data_output_mapping(self) -> Iterator[tuple[str, str]]:\n        \"\"\"Iterate over package data producing (dest, src) pairs.\"\"\"\n        for package, src_dir, build_dir, filenames in self.data_files:\n            for filename in filenames:\n                target = os.path.join(build_dir, filename)\n                srcfile = os.path.join(src_dir, filename)\n                yield (target, srcfile)\n\n    def build_package_data(self):\n        \"\"\"Copy data files into build directory\"\"\"\n        for target, srcfile in self._get_package_data_output_mapping():\n            self.mkpath(os.path.dirname(target))\n            _outf, _copied = self.copy_file(srcfile, target)\n            make_writable(target)\n\n    def analyze_manifest(self):\n        self.manifest_files = mf = {}\n        if not self.distribution.include_package_data:\n            return\n        src_dirs = {}\n        for package in self.packages or ():\n            # Locate package source directory\n            src_dirs[assert_relative(self.get_package_dir(package))] = package\n\n        if (\n            getattr(self, 'existing_egg_info_dir', None)\n            and Path(self.existing_egg_info_dir, \"SOURCES.txt\").exists()\n        ):\n            egg_info_dir = self.existing_egg_info_dir\n            manifest = Path(egg_info_dir, \"SOURCES.txt\")\n            files = manifest.read_text(encoding=\"utf-8\").splitlines()\n        else:\n            self.run_command('egg_info')\n            ei_cmd = self.get_finalized_command('egg_info')\n            egg_info_dir = ei_cmd.egg_info\n            files = ei_cmd.filelist.files\n\n        check = _IncludePackageDataAbuse()\n        for path in self._filter_build_files(files, egg_info_dir):\n            d, f = os.path.split(assert_relative(path))\n            prev = None\n            oldf = f\n            while d and d != prev and d not in src_dirs:\n                prev = d\n                d, df = os.path.split(d)\n                f = os.path.join(df, f)\n            if d in src_dirs:\n                if f == oldf:\n                    if check.is_module(f):\n                        continue  # it's a module, not data\n                else:\n                    importable = check.importable_subpackage(src_dirs[d], f)\n                    if importable:\n                        check.warn(importable)\n                mf.setdefault(src_dirs[d], []).append(path)\n\n    def _filter_build_files(self, files: Iterable[str], egg_info: str) -> Iterator[str]:\n        \"\"\"\n        ``build_meta`` may try to create egg_info outside of the project directory,\n        and this can be problematic for certain plugins (reported in issue #3500).\n\n        Extensions might also include between their sources files created on the\n        ``build_lib`` and ``build_temp`` directories.\n\n        This function should filter this case of invalid files out.\n        \"\"\"\n        build = self.get_finalized_command(\"build\")\n        build_dirs = (egg_info, self.build_lib, build.build_temp, build.build_base)\n        norm_dirs = [os.path.normpath(p) for p in build_dirs if p]\n\n        for file in files:\n            norm_path = os.path.normpath(file)\n            if not os.path.isabs(file) or all(d not in norm_path for d in norm_dirs):\n                yield file\n\n    def get_data_files(self):\n        pass  # Lazily compute data files in _get_data_files() function.\n\n    def check_package(self, package, package_dir):\n        \"\"\"Check namespace packages' __init__ for declare_namespace\"\"\"\n        try:\n            return self.packages_checked[package]\n        except KeyError:\n            pass\n\n        init_py = orig.build_py.check_package(self, package, package_dir)\n        self.packages_checked[package] = init_py\n\n        if not init_py or not self.distribution.namespace_packages:\n            return init_py\n\n        for pkg in self.distribution.namespace_packages:\n            if pkg == package or pkg.startswith(package + '.'):\n                break\n        else:\n            return init_py\n\n        with open(init_py, 'rb') as f:\n            contents = f.read()\n        if b'declare_namespace' not in contents:\n            raise distutils.errors.DistutilsError(\n                \"Namespace package problem: %s is a namespace package, but \"\n                \"its\\n__init__.py does not call declare_namespace()! Please \"\n                'fix it.\\n(See the setuptools manual under '\n                '\"Namespace Packages\" for details.)\\n\"' % (package,)\n            )\n        return init_py\n\n    def initialize_options(self):\n        self.packages_checked = {}\n        orig.build_py.initialize_options(self)\n        self.editable_mode = False\n        self.existing_egg_info_dir = None\n\n    def get_package_dir(self, package):\n        res = orig.build_py.get_package_dir(self, package)\n        if self.distribution.src_root is not None:\n            return os.path.join(self.distribution.src_root, res)\n        return res\n\n    def exclude_data_files(self, package, src_dir, files):\n        \"\"\"Filter filenames for package's data files in 'src_dir'\"\"\"\n        files = list(files)\n        patterns = self._get_platform_patterns(\n            self.exclude_package_data,\n            package,\n            src_dir,\n        )\n        match_groups = (fnmatch.filter(files, pattern) for pattern in patterns)\n        # flatten the groups of matches into an iterable of matches\n        matches = itertools.chain.from_iterable(match_groups)\n        bad = set(matches)\n        keepers = (fn for fn in files if fn not in bad)\n        # ditch dupes\n        return list(unique_everseen(keepers))\n\n    @staticmethod\n    def _get_platform_patterns(spec, package, src_dir, extra_patterns=()):\n        \"\"\"\n        yield platform-specific path patterns (suitable for glob\n        or fn_match) from a glob-based spec (such as\n        self.package_data or self.exclude_package_data)\n        matching package in src_dir.\n        \"\"\"\n        raw_patterns = itertools.chain(\n            extra_patterns,\n            spec.get('', []),\n            spec.get(package, []),\n        )\n        return (\n            # Each pattern has to be converted to a platform-specific path\n            os.path.join(src_dir, convert_path(pattern))\n            for pattern in raw_patterns\n        )\n\n\ndef assert_relative(path):\n    if not os.path.isabs(path):\n        return path\n    from distutils.errors import DistutilsSetupError\n\n    msg = (\n        textwrap.dedent(\n            \"\"\"\n        Error: setup script specifies an absolute path:\n\n            %s\n\n        setup() arguments must *always* be /-separated paths relative to the\n        setup.py directory, *never* absolute paths.\n        \"\"\"\n        ).lstrip()\n        % path\n    )\n    raise DistutilsSetupError(msg)\n\n\nclass _IncludePackageDataAbuse:\n    \"\"\"Inform users that package or module is included as 'data file'\"\"\"\n\n    class _Warning(SetuptoolsDeprecationWarning):\n        _SUMMARY = \"\"\"\n        Package {importable!r} is absent from the `packages` configuration.\n        \"\"\"\n\n        _DETAILS = \"\"\"\n        ############################\n        # Package would be ignored #\n        ############################\n        Python recognizes {importable!r} as an importable package[^1],\n        but it is absent from setuptools' `packages` configuration.\n\n        This leads to an ambiguous overall configuration. If you want to distribute this\n        package, please make sure that {importable!r} is explicitly added\n        to the `packages` configuration field.\n\n        Alternatively, you can also rely on setuptools' discovery methods\n        (for example by using `find_namespace_packages(...)`/`find_namespace:`\n        instead of `find_packages(...)`/`find:`).\n\n        You can read more about \"package discovery\" on setuptools documentation page:\n\n        - https://setuptools.pypa.io/en/latest/userguide/package_discovery.html\n\n        If you don't want {importable!r} to be distributed and are\n        already explicitly excluding {importable!r} via\n        `find_namespace_packages(...)/find_namespace` or `find_packages(...)/find`,\n        you can try to use `exclude_package_data`, or `include-package-data=False` in\n        combination with a more fine grained `package-data` configuration.\n\n        You can read more about \"package data files\" on setuptools documentation page:\n\n        - https://setuptools.pypa.io/en/latest/userguide/datafiles.html\n\n\n        [^1]: For Python, any directory (with suitable naming) can be imported,\n              even if it does not contain any `.py` files.\n              On the other hand, currently there is no concept of package data\n              directory, all directories are treated like packages.\n        \"\"\"\n        # _DUE_DATE: still not defined as this is particularly controversial.\n        # Warning initially introduced in May 2022. See issue #3340 for discussion.\n\n    def __init__(self):\n        self._already_warned = set()\n\n    def is_module(self, file):\n        return file.endswith(\".py\") and file[: -len(\".py\")].isidentifier()\n\n    def importable_subpackage(self, parent, file):\n        pkg = Path(file).parent\n        parts = list(itertools.takewhile(str.isidentifier, pkg.parts))\n        if parts:\n            return \".\".join([parent, *parts])\n        return None\n\n    def warn(self, importable):\n        if importable not in self._already_warned:\n            self._Warning.emit(importable=importable)\n            self._already_warned.add(importable)\n", "setuptools/_distutils/sysconfig.py": "\"\"\"Provide access to Python's configuration information.  The specific\nconfiguration variables available depend heavily on the platform and\nconfiguration.  The values may be retrieved using\nget_config_var(name), and the list of variables is available via\nget_config_vars().keys().  Additional convenience functions are also\navailable.\n\nWritten by:   Fred L. Drake, Jr.\nEmail:        <fdrake@acm.org>\n\"\"\"\n\nimport functools\nimport os\nimport pathlib\nimport re\nimport sys\nimport sysconfig\n\nfrom . import py39compat\nfrom ._functools import pass_none\nfrom .errors import DistutilsPlatformError\n\nIS_PYPY = '__pypy__' in sys.builtin_module_names\n\n# These are needed in a couple of spots, so just compute them once.\nPREFIX = os.path.normpath(sys.prefix)\nEXEC_PREFIX = os.path.normpath(sys.exec_prefix)\nBASE_PREFIX = os.path.normpath(sys.base_prefix)\nBASE_EXEC_PREFIX = os.path.normpath(sys.base_exec_prefix)\n\n# Path to the base directory of the project. On Windows the binary may\n# live in project/PCbuild/win32 or project/PCbuild/amd64.\n# set for cross builds\nif \"_PYTHON_PROJECT_BASE\" in os.environ:\n    project_base = os.path.abspath(os.environ[\"_PYTHON_PROJECT_BASE\"])\nelse:\n    if sys.executable:\n        project_base = os.path.dirname(os.path.abspath(sys.executable))\n    else:\n        # sys.executable can be empty if argv[0] has been changed and Python is\n        # unable to retrieve the real program name\n        project_base = os.getcwd()\n\n\ndef _is_python_source_dir(d):\n    \"\"\"\n    Return True if the target directory appears to point to an\n    un-installed Python.\n    \"\"\"\n    modules = pathlib.Path(d).joinpath('Modules')\n    return any(modules.joinpath(fn).is_file() for fn in ('Setup', 'Setup.local'))\n\n\n_sys_home = getattr(sys, '_home', None)\n\n\ndef _is_parent(dir_a, dir_b):\n    \"\"\"\n    Return True if a is a parent of b.\n    \"\"\"\n    return os.path.normcase(dir_a).startswith(os.path.normcase(dir_b))\n\n\nif os.name == 'nt':\n\n    @pass_none\n    def _fix_pcbuild(d):\n        # In a venv, sys._home will be inside BASE_PREFIX rather than PREFIX.\n        prefixes = PREFIX, BASE_PREFIX\n        matched = (\n            prefix\n            for prefix in prefixes\n            if _is_parent(d, os.path.join(prefix, \"PCbuild\"))\n        )\n        return next(matched, d)\n\n    project_base = _fix_pcbuild(project_base)\n    _sys_home = _fix_pcbuild(_sys_home)\n\n\ndef _python_build():\n    if _sys_home:\n        return _is_python_source_dir(_sys_home)\n    return _is_python_source_dir(project_base)\n\n\npython_build = _python_build()\n\n\n# Calculate the build qualifier flags if they are defined.  Adding the flags\n# to the include and lib directories only makes sense for an installation, not\n# an in-source build.\nbuild_flags = ''\ntry:\n    if not python_build:\n        build_flags = sys.abiflags\nexcept AttributeError:\n    # It's not a configure-based build, so the sys module doesn't have\n    # this attribute, which is fine.\n    pass\n\n\ndef get_python_version():\n    \"\"\"Return a string containing the major and minor Python version,\n    leaving off the patchlevel.  Sample return values could be '1.5'\n    or '2.2'.\n    \"\"\"\n    return '%d.%d' % sys.version_info[:2]\n\n\ndef get_python_inc(plat_specific=0, prefix=None):\n    \"\"\"Return the directory containing installed Python header files.\n\n    If 'plat_specific' is false (the default), this is the path to the\n    non-platform-specific header files, i.e. Python.h and so on;\n    otherwise, this is the path to platform-specific header files\n    (namely pyconfig.h).\n\n    If 'prefix' is supplied, use it instead of sys.base_prefix or\n    sys.base_exec_prefix -- i.e., ignore 'plat_specific'.\n    \"\"\"\n    default_prefix = BASE_EXEC_PREFIX if plat_specific else BASE_PREFIX\n    resolved_prefix = prefix if prefix is not None else default_prefix\n    try:\n        getter = globals()[f'_get_python_inc_{os.name}']\n    except KeyError:\n        raise DistutilsPlatformError(\n            \"I don't know where Python installs its C header files \"\n            \"on platform '%s'\" % os.name\n        )\n    return getter(resolved_prefix, prefix, plat_specific)\n\n\n@pass_none\ndef _extant(path):\n    \"\"\"\n    Replace path with None if it doesn't exist.\n    \"\"\"\n    return path if os.path.exists(path) else None\n\n\ndef _get_python_inc_posix(prefix, spec_prefix, plat_specific):\n    if IS_PYPY and sys.version_info < (3, 8):\n        return os.path.join(prefix, 'include')\n    return (\n        _get_python_inc_posix_python(plat_specific)\n        or _extant(_get_python_inc_from_config(plat_specific, spec_prefix))\n        or _get_python_inc_posix_prefix(prefix)\n    )\n\n\ndef _get_python_inc_posix_python(plat_specific):\n    \"\"\"\n    Assume the executable is in the build directory. The\n    pyconfig.h file should be in the same directory. Since\n    the build directory may not be the source directory,\n    use \"srcdir\" from the makefile to find the \"Include\"\n    directory.\n    \"\"\"\n    if not python_build:\n        return\n    if plat_specific:\n        return _sys_home or project_base\n    incdir = os.path.join(get_config_var('srcdir'), 'Include')\n    return os.path.normpath(incdir)\n\n\ndef _get_python_inc_from_config(plat_specific, spec_prefix):\n    \"\"\"\n    If no prefix was explicitly specified, provide the include\n    directory from the config vars. Useful when\n    cross-compiling, since the config vars may come from\n    the host\n    platform Python installation, while the current Python\n    executable is from the build platform installation.\n\n    >>> monkeypatch = getfixture('monkeypatch')\n    >>> gpifc = _get_python_inc_from_config\n    >>> monkeypatch.setitem(gpifc.__globals__, 'get_config_var', str.lower)\n    >>> gpifc(False, '/usr/bin/')\n    >>> gpifc(False, '')\n    >>> gpifc(False, None)\n    'includepy'\n    >>> gpifc(True, None)\n    'confincludepy'\n    \"\"\"\n    if spec_prefix is None:\n        return get_config_var('CONF' * plat_specific + 'INCLUDEPY')\n\n\ndef _get_python_inc_posix_prefix(prefix):\n    implementation = 'pypy' if IS_PYPY else 'python'\n    python_dir = implementation + get_python_version() + build_flags\n    return os.path.join(prefix, \"include\", python_dir)\n\n\ndef _get_python_inc_nt(prefix, spec_prefix, plat_specific):\n    if python_build:\n        # Include both include dirs to ensure we can find pyconfig.h\n        return (\n            os.path.join(prefix, \"include\")\n            + os.path.pathsep\n            + os.path.dirname(sysconfig.get_config_h_filename())\n        )\n    return os.path.join(prefix, \"include\")\n\n\n# allow this behavior to be monkey-patched. Ref pypa/distutils#2.\ndef _posix_lib(standard_lib, libpython, early_prefix, prefix):\n    if standard_lib:\n        return libpython\n    else:\n        return os.path.join(libpython, \"site-packages\")\n\n\ndef get_python_lib(plat_specific=0, standard_lib=0, prefix=None):\n    \"\"\"Return the directory containing the Python library (standard or\n    site additions).\n\n    If 'plat_specific' is true, return the directory containing\n    platform-specific modules, i.e. any module from a non-pure-Python\n    module distribution; otherwise, return the platform-shared library\n    directory.  If 'standard_lib' is true, return the directory\n    containing standard Python library modules; otherwise, return the\n    directory for site-specific modules.\n\n    If 'prefix' is supplied, use it instead of sys.base_prefix or\n    sys.base_exec_prefix -- i.e., ignore 'plat_specific'.\n    \"\"\"\n\n    if IS_PYPY and sys.version_info < (3, 8):\n        # PyPy-specific schema\n        if prefix is None:\n            prefix = PREFIX\n        if standard_lib:\n            return os.path.join(prefix, \"lib-python\", sys.version[0])\n        return os.path.join(prefix, 'site-packages')\n\n    early_prefix = prefix\n\n    if prefix is None:\n        if standard_lib:\n            prefix = plat_specific and BASE_EXEC_PREFIX or BASE_PREFIX\n        else:\n            prefix = plat_specific and EXEC_PREFIX or PREFIX\n\n    if os.name == \"posix\":\n        if plat_specific or standard_lib:\n            # Platform-specific modules (any module from a non-pure-Python\n            # module distribution) or standard Python library modules.\n            libdir = getattr(sys, \"platlibdir\", \"lib\")\n        else:\n            # Pure Python\n            libdir = \"lib\"\n        implementation = 'pypy' if IS_PYPY else 'python'\n        libpython = os.path.join(prefix, libdir, implementation + get_python_version())\n        return _posix_lib(standard_lib, libpython, early_prefix, prefix)\n    elif os.name == \"nt\":\n        if standard_lib:\n            return os.path.join(prefix, \"Lib\")\n        else:\n            return os.path.join(prefix, \"Lib\", \"site-packages\")\n    else:\n        raise DistutilsPlatformError(\n            \"I don't know where Python installs its library \"\n            \"on platform '%s'\" % os.name\n        )\n\n\n@functools.lru_cache\ndef _customize_macos():\n    \"\"\"\n    Perform first-time customization of compiler-related\n    config vars on macOS. Use after a compiler is known\n    to be needed. This customization exists primarily to support Pythons\n    from binary installers. The kind and paths to build tools on\n    the user system may vary significantly from the system\n    that Python itself was built on.  Also the user OS\n    version and build tools may not support the same set\n    of CPU architectures for universal builds.\n    \"\"\"\n\n    sys.platform == \"darwin\" and __import__('_osx_support').customize_compiler(\n        get_config_vars()\n    )\n\n\ndef customize_compiler(compiler):  # noqa: C901\n    \"\"\"Do any platform-specific customization of a CCompiler instance.\n\n    Mainly needed on Unix, so we can plug in the information that\n    varies across Unices and is stored in Python's Makefile.\n    \"\"\"\n    if compiler.compiler_type == \"unix\":\n        _customize_macos()\n\n        (\n            cc,\n            cxx,\n            cflags,\n            ccshared,\n            ldshared,\n            shlib_suffix,\n            ar,\n            ar_flags,\n        ) = get_config_vars(\n            'CC',\n            'CXX',\n            'CFLAGS',\n            'CCSHARED',\n            'LDSHARED',\n            'SHLIB_SUFFIX',\n            'AR',\n            'ARFLAGS',\n        )\n\n        if 'CC' in os.environ:\n            newcc = os.environ['CC']\n            if 'LDSHARED' not in os.environ and ldshared.startswith(cc):\n                # If CC is overridden, use that as the default\n                #       command for LDSHARED as well\n                ldshared = newcc + ldshared[len(cc) :]\n            cc = newcc\n        if 'CXX' in os.environ:\n            cxx = os.environ['CXX']\n        if 'LDSHARED' in os.environ:\n            ldshared = os.environ['LDSHARED']\n        if 'CPP' in os.environ:\n            cpp = os.environ['CPP']\n        else:\n            cpp = cc + \" -E\"  # not always\n        if 'LDFLAGS' in os.environ:\n            ldshared = ldshared + ' ' + os.environ['LDFLAGS']\n        if 'CFLAGS' in os.environ:\n            cflags = cflags + ' ' + os.environ['CFLAGS']\n            ldshared = ldshared + ' ' + os.environ['CFLAGS']\n        if 'CPPFLAGS' in os.environ:\n            cpp = cpp + ' ' + os.environ['CPPFLAGS']\n            cflags = cflags + ' ' + os.environ['CPPFLAGS']\n            ldshared = ldshared + ' ' + os.environ['CPPFLAGS']\n        if 'AR' in os.environ:\n            ar = os.environ['AR']\n        if 'ARFLAGS' in os.environ:\n            archiver = ar + ' ' + os.environ['ARFLAGS']\n        else:\n            archiver = ar + ' ' + ar_flags\n\n        cc_cmd = cc + ' ' + cflags\n        compiler.set_executables(\n            preprocessor=cpp,\n            compiler=cc_cmd,\n            compiler_so=cc_cmd + ' ' + ccshared,\n            compiler_cxx=cxx,\n            linker_so=ldshared,\n            linker_exe=cc,\n            archiver=archiver,\n        )\n\n        if 'RANLIB' in os.environ and compiler.executables.get('ranlib', None):\n            compiler.set_executables(ranlib=os.environ['RANLIB'])\n\n        compiler.shared_lib_extension = shlib_suffix\n\n\ndef get_config_h_filename():\n    \"\"\"Return full pathname of installed pyconfig.h file.\"\"\"\n    return sysconfig.get_config_h_filename()\n\n\ndef get_makefile_filename():\n    \"\"\"Return full pathname of installed Makefile from the Python build.\"\"\"\n    return sysconfig.get_makefile_filename()\n\n\ndef parse_config_h(fp, g=None):\n    \"\"\"Parse a config.h-style file.\n\n    A dictionary containing name/value pairs is returned.  If an\n    optional dictionary is passed in as the second argument, it is\n    used instead of a new dictionary.\n    \"\"\"\n    return sysconfig.parse_config_h(fp, vars=g)\n\n\n# Regexes needed for parsing Makefile (and similar syntaxes,\n# like old-style Setup files).\n_variable_rx = re.compile(r\"([a-zA-Z][a-zA-Z0-9_]+)\\s*=\\s*(.*)\")\n_findvar1_rx = re.compile(r\"\\$\\(([A-Za-z][A-Za-z0-9_]*)\\)\")\n_findvar2_rx = re.compile(r\"\\${([A-Za-z][A-Za-z0-9_]*)}\")\n\n\ndef parse_makefile(fn, g=None):  # noqa: C901\n    \"\"\"Parse a Makefile-style file.\n\n    A dictionary containing name/value pairs is returned.  If an\n    optional dictionary is passed in as the second argument, it is\n    used instead of a new dictionary.\n    \"\"\"\n    from distutils.text_file import TextFile\n\n    fp = TextFile(\n        fn, strip_comments=1, skip_blanks=1, join_lines=1, errors=\"surrogateescape\"\n    )\n\n    if g is None:\n        g = {}\n    done = {}\n    notdone = {}\n\n    while True:\n        line = fp.readline()\n        if line is None:  # eof\n            break\n        m = _variable_rx.match(line)\n        if m:\n            n, v = m.group(1, 2)\n            v = v.strip()\n            # `$$' is a literal `$' in make\n            tmpv = v.replace('$$', '')\n\n            if \"$\" in tmpv:\n                notdone[n] = v\n            else:\n                try:\n                    v = int(v)\n                except ValueError:\n                    # insert literal `$'\n                    done[n] = v.replace('$$', '$')\n                else:\n                    done[n] = v\n\n    # Variables with a 'PY_' prefix in the makefile. These need to\n    # be made available without that prefix through sysconfig.\n    # Special care is needed to ensure that variable expansion works, even\n    # if the expansion uses the name without a prefix.\n    renamed_variables = ('CFLAGS', 'LDFLAGS', 'CPPFLAGS')\n\n    # do variable interpolation here\n    while notdone:\n        for name in list(notdone):\n            value = notdone[name]\n            m = _findvar1_rx.search(value) or _findvar2_rx.search(value)\n            if m:\n                n = m.group(1)\n                found = True\n                if n in done:\n                    item = str(done[n])\n                elif n in notdone:\n                    # get it on a subsequent round\n                    found = False\n                elif n in os.environ:\n                    # do it like make: fall back to environment\n                    item = os.environ[n]\n\n                elif n in renamed_variables:\n                    if name.startswith('PY_') and name[3:] in renamed_variables:\n                        item = \"\"\n\n                    elif 'PY_' + n in notdone:\n                        found = False\n\n                    else:\n                        item = str(done['PY_' + n])\n                else:\n                    done[n] = item = \"\"\n                if found:\n                    after = value[m.end() :]\n                    value = value[: m.start()] + item + after\n                    if \"$\" in after:\n                        notdone[name] = value\n                    else:\n                        try:\n                            value = int(value)\n                        except ValueError:\n                            done[name] = value.strip()\n                        else:\n                            done[name] = value\n                        del notdone[name]\n\n                        if name.startswith('PY_') and name[3:] in renamed_variables:\n                            name = name[3:]\n                            if name not in done:\n                                done[name] = value\n            else:\n                # bogus variable reference; just drop it since we can't deal\n                del notdone[name]\n\n    fp.close()\n\n    # strip spurious spaces\n    for k, v in done.items():\n        if isinstance(v, str):\n            done[k] = v.strip()\n\n    # save the results in the global dictionary\n    g.update(done)\n    return g\n\n\ndef expand_makefile_vars(s, vars):\n    \"\"\"Expand Makefile-style variables -- \"${foo}\" or \"$(foo)\" -- in\n    'string' according to 'vars' (a dictionary mapping variable names to\n    values).  Variables not present in 'vars' are silently expanded to the\n    empty string.  The variable values in 'vars' should not contain further\n    variable expansions; if 'vars' is the output of 'parse_makefile()',\n    you're fine.  Returns a variable-expanded version of 's'.\n    \"\"\"\n\n    # This algorithm does multiple expansion, so if vars['foo'] contains\n    # \"${bar}\", it will expand ${foo} to ${bar}, and then expand\n    # ${bar}... and so forth.  This is fine as long as 'vars' comes from\n    # 'parse_makefile()', which takes care of such expansions eagerly,\n    # according to make's variable expansion semantics.\n\n    while True:\n        m = _findvar1_rx.search(s) or _findvar2_rx.search(s)\n        if m:\n            (beg, end) = m.span()\n            s = s[0:beg] + vars.get(m.group(1)) + s[end:]\n        else:\n            break\n    return s\n\n\n_config_vars = None\n\n\ndef get_config_vars(*args):\n    \"\"\"With no arguments, return a dictionary of all configuration\n    variables relevant for the current platform.  Generally this includes\n    everything needed to build extensions and install both pure modules and\n    extensions.  On Unix, this means every variable defined in Python's\n    installed Makefile; on Windows it's a much smaller set.\n\n    With arguments, return a list of values that result from looking up\n    each argument in the configuration variable dictionary.\n    \"\"\"\n    global _config_vars\n    if _config_vars is None:\n        _config_vars = sysconfig.get_config_vars().copy()\n        py39compat.add_ext_suffix(_config_vars)\n\n    return [_config_vars.get(name) for name in args] if args else _config_vars\n\n\ndef get_config_var(name):\n    \"\"\"Return the value of a single variable using the dictionary\n    returned by 'get_config_vars()'.  Equivalent to\n    get_config_vars().get(name)\n    \"\"\"\n    if name == 'SO':\n        import warnings\n\n        warnings.warn('SO is deprecated, use EXT_SUFFIX', DeprecationWarning, 2)\n    return get_config_vars().get(name)\n", "setuptools/_distutils/debug.py": "import os\n\n# If DISTUTILS_DEBUG is anything other than the empty string, we run in\n# debug mode.\nDEBUG = os.environ.get('DISTUTILS_DEBUG')\n", "setuptools/_distutils/_msvccompiler.py": "\"\"\"distutils._msvccompiler\n\nContains MSVCCompiler, an implementation of the abstract CCompiler class\nfor Microsoft Visual Studio 2015.\n\nThe module is compatible with VS 2015 and later. You can find legacy support\nfor older versions in distutils.msvc9compiler and distutils.msvccompiler.\n\"\"\"\n\n# Written by Perry Stoll\n# hacked by Robin Becker and Thomas Heller to do a better job of\n#   finding DevStudio (through the registry)\n# ported to VS 2005 and VS 2008 by Christian Heimes\n# ported to VS 2015 by Steve Dower\n\nimport contextlib\nimport os\nimport subprocess\nimport unittest.mock as mock\nimport warnings\n\nwith contextlib.suppress(ImportError):\n    import winreg\n\nfrom itertools import count\n\nfrom ._log import log\nfrom .ccompiler import CCompiler, gen_lib_options\nfrom .errors import (\n    CompileError,\n    DistutilsExecError,\n    DistutilsPlatformError,\n    LibError,\n    LinkError,\n)\nfrom .util import get_platform\n\n\ndef _find_vc2015():\n    try:\n        key = winreg.OpenKeyEx(\n            winreg.HKEY_LOCAL_MACHINE,\n            r\"Software\\Microsoft\\VisualStudio\\SxS\\VC7\",\n            access=winreg.KEY_READ | winreg.KEY_WOW64_32KEY,\n        )\n    except OSError:\n        log.debug(\"Visual C++ is not registered\")\n        return None, None\n\n    best_version = 0\n    best_dir = None\n    with key:\n        for i in count():\n            try:\n                v, vc_dir, vt = winreg.EnumValue(key, i)\n            except OSError:\n                break\n            if v and vt == winreg.REG_SZ and os.path.isdir(vc_dir):\n                try:\n                    version = int(float(v))\n                except (ValueError, TypeError):\n                    continue\n                if version >= 14 and version > best_version:\n                    best_version, best_dir = version, vc_dir\n    return best_version, best_dir\n\n\ndef _find_vc2017():\n    \"\"\"Returns \"15, path\" based on the result of invoking vswhere.exe\n    If no install is found, returns \"None, None\"\n\n    The version is returned to avoid unnecessarily changing the function\n    result. It may be ignored when the path is not None.\n\n    If vswhere.exe is not available, by definition, VS 2017 is not\n    installed.\n    \"\"\"\n    root = os.environ.get(\"ProgramFiles(x86)\") or os.environ.get(\"ProgramFiles\")\n    if not root:\n        return None, None\n\n    try:\n        path = subprocess.check_output(\n            [\n                os.path.join(\n                    root, \"Microsoft Visual Studio\", \"Installer\", \"vswhere.exe\"\n                ),\n                \"-latest\",\n                \"-prerelease\",\n                \"-requires\",\n                \"Microsoft.VisualStudio.Component.VC.Tools.x86.x64\",\n                \"-property\",\n                \"installationPath\",\n                \"-products\",\n                \"*\",\n            ],\n            encoding=\"mbcs\",\n            errors=\"strict\",\n        ).strip()\n    except (subprocess.CalledProcessError, OSError, UnicodeDecodeError):\n        return None, None\n\n    path = os.path.join(path, \"VC\", \"Auxiliary\", \"Build\")\n    if os.path.isdir(path):\n        return 15, path\n\n    return None, None\n\n\nPLAT_SPEC_TO_RUNTIME = {\n    'x86': 'x86',\n    'x86_amd64': 'x64',\n    'x86_arm': 'arm',\n    'x86_arm64': 'arm64',\n}\n\n\ndef _find_vcvarsall(plat_spec):\n    # bpo-38597: Removed vcruntime return value\n    _, best_dir = _find_vc2017()\n\n    if not best_dir:\n        best_version, best_dir = _find_vc2015()\n\n    if not best_dir:\n        log.debug(\"No suitable Visual C++ version found\")\n        return None, None\n\n    vcvarsall = os.path.join(best_dir, \"vcvarsall.bat\")\n    if not os.path.isfile(vcvarsall):\n        log.debug(\"%s cannot be found\", vcvarsall)\n        return None, None\n\n    return vcvarsall, None\n\n\ndef _get_vc_env(plat_spec):\n    if os.getenv(\"DISTUTILS_USE_SDK\"):\n        return {key.lower(): value for key, value in os.environ.items()}\n\n    vcvarsall, _ = _find_vcvarsall(plat_spec)\n    if not vcvarsall:\n        raise DistutilsPlatformError(\"Unable to find vcvarsall.bat\")\n\n    try:\n        out = subprocess.check_output(\n            f'cmd /u /c \"{vcvarsall}\" {plat_spec} && set',\n            stderr=subprocess.STDOUT,\n        ).decode('utf-16le', errors='replace')\n    except subprocess.CalledProcessError as exc:\n        log.error(exc.output)\n        raise DistutilsPlatformError(f\"Error executing {exc.cmd}\")\n\n    env = {\n        key.lower(): value\n        for key, _, value in (line.partition('=') for line in out.splitlines())\n        if key and value\n    }\n\n    return env\n\n\ndef _find_exe(exe, paths=None):\n    \"\"\"Return path to an MSVC executable program.\n\n    Tries to find the program in several places: first, one of the\n    MSVC program search paths from the registry; next, the directories\n    in the PATH environment variable.  If any of those work, return an\n    absolute path that is known to exist.  If none of them work, just\n    return the original program name, 'exe'.\n    \"\"\"\n    if not paths:\n        paths = os.getenv('path').split(os.pathsep)\n    for p in paths:\n        fn = os.path.join(os.path.abspath(p), exe)\n        if os.path.isfile(fn):\n            return fn\n    return exe\n\n\n# A map keyed by get_platform() return values to values accepted by\n# 'vcvarsall.bat'. Always cross-compile from x86 to work with the\n# lighter-weight MSVC installs that do not include native 64-bit tools.\nPLAT_TO_VCVARS = {\n    'win32': 'x86',\n    'win-amd64': 'x86_amd64',\n    'win-arm32': 'x86_arm',\n    'win-arm64': 'x86_arm64',\n}\n\n\nclass MSVCCompiler(CCompiler):\n    \"\"\"Concrete class that implements an interface to Microsoft Visual C++,\n    as defined by the CCompiler abstract class.\"\"\"\n\n    compiler_type = 'msvc'\n\n    # Just set this so CCompiler's constructor doesn't barf.  We currently\n    # don't use the 'set_executables()' bureaucracy provided by CCompiler,\n    # as it really isn't necessary for this sort of single-compiler class.\n    # Would be nice to have a consistent interface with UnixCCompiler,\n    # though, so it's worth thinking about.\n    executables = {}\n\n    # Private class data (need to distinguish C from C++ source for compiler)\n    _c_extensions = ['.c']\n    _cpp_extensions = ['.cc', '.cpp', '.cxx']\n    _rc_extensions = ['.rc']\n    _mc_extensions = ['.mc']\n\n    # Needed for the filename generation methods provided by the\n    # base class, CCompiler.\n    src_extensions = _c_extensions + _cpp_extensions + _rc_extensions + _mc_extensions\n    res_extension = '.res'\n    obj_extension = '.obj'\n    static_lib_extension = '.lib'\n    shared_lib_extension = '.dll'\n    static_lib_format = shared_lib_format = '%s%s'\n    exe_extension = '.exe'\n\n    def __init__(self, verbose=0, dry_run=0, force=0):\n        super().__init__(verbose, dry_run, force)\n        # target platform (.plat_name is consistent with 'bdist')\n        self.plat_name = None\n        self.initialized = False\n\n    @classmethod\n    def _configure(cls, vc_env):\n        \"\"\"\n        Set class-level include/lib dirs.\n        \"\"\"\n        cls.include_dirs = cls._parse_path(vc_env.get('include', ''))\n        cls.library_dirs = cls._parse_path(vc_env.get('lib', ''))\n\n    @staticmethod\n    def _parse_path(val):\n        return [dir.rstrip(os.sep) for dir in val.split(os.pathsep) if dir]\n\n    def initialize(self, plat_name=None):\n        # multi-init means we would need to check platform same each time...\n        assert not self.initialized, \"don't init multiple times\"\n        if plat_name is None:\n            plat_name = get_platform()\n        # sanity check for platforms to prevent obscure errors later.\n        if plat_name not in PLAT_TO_VCVARS:\n            raise DistutilsPlatformError(\n                f\"--plat-name must be one of {tuple(PLAT_TO_VCVARS)}\"\n            )\n\n        # Get the vcvarsall.bat spec for the requested platform.\n        plat_spec = PLAT_TO_VCVARS[plat_name]\n\n        vc_env = _get_vc_env(plat_spec)\n        if not vc_env:\n            raise DistutilsPlatformError(\n                \"Unable to find a compatible Visual Studio installation.\"\n            )\n        self._configure(vc_env)\n\n        self._paths = vc_env.get('path', '')\n        paths = self._paths.split(os.pathsep)\n        self.cc = _find_exe(\"cl.exe\", paths)\n        self.linker = _find_exe(\"link.exe\", paths)\n        self.lib = _find_exe(\"lib.exe\", paths)\n        self.rc = _find_exe(\"rc.exe\", paths)  # resource compiler\n        self.mc = _find_exe(\"mc.exe\", paths)  # message compiler\n        self.mt = _find_exe(\"mt.exe\", paths)  # message compiler\n\n        self.preprocess_options = None\n        # bpo-38597: Always compile with dynamic linking\n        # Future releases of Python 3.x will include all past\n        # versions of vcruntime*.dll for compatibility.\n        self.compile_options = ['/nologo', '/O2', '/W3', '/GL', '/DNDEBUG', '/MD']\n\n        self.compile_options_debug = [\n            '/nologo',\n            '/Od',\n            '/MDd',\n            '/Zi',\n            '/W3',\n            '/D_DEBUG',\n        ]\n\n        ldflags = ['/nologo', '/INCREMENTAL:NO', '/LTCG']\n\n        ldflags_debug = ['/nologo', '/INCREMENTAL:NO', '/LTCG', '/DEBUG:FULL']\n\n        self.ldflags_exe = [*ldflags, '/MANIFEST:EMBED,ID=1']\n        self.ldflags_exe_debug = [*ldflags_debug, '/MANIFEST:EMBED,ID=1']\n        self.ldflags_shared = [\n            *ldflags,\n            '/DLL',\n            '/MANIFEST:EMBED,ID=2',\n            '/MANIFESTUAC:NO',\n        ]\n        self.ldflags_shared_debug = [\n            *ldflags_debug,\n            '/DLL',\n            '/MANIFEST:EMBED,ID=2',\n            '/MANIFESTUAC:NO',\n        ]\n        self.ldflags_static = [*ldflags]\n        self.ldflags_static_debug = [*ldflags_debug]\n\n        self._ldflags = {\n            (CCompiler.EXECUTABLE, None): self.ldflags_exe,\n            (CCompiler.EXECUTABLE, False): self.ldflags_exe,\n            (CCompiler.EXECUTABLE, True): self.ldflags_exe_debug,\n            (CCompiler.SHARED_OBJECT, None): self.ldflags_shared,\n            (CCompiler.SHARED_OBJECT, False): self.ldflags_shared,\n            (CCompiler.SHARED_OBJECT, True): self.ldflags_shared_debug,\n            (CCompiler.SHARED_LIBRARY, None): self.ldflags_static,\n            (CCompiler.SHARED_LIBRARY, False): self.ldflags_static,\n            (CCompiler.SHARED_LIBRARY, True): self.ldflags_static_debug,\n        }\n\n        self.initialized = True\n\n    # -- Worker methods ------------------------------------------------\n\n    @property\n    def out_extensions(self):\n        return {\n            **super().out_extensions,\n            **{\n                ext: self.res_extension\n                for ext in self._rc_extensions + self._mc_extensions\n            },\n        }\n\n    def compile(  # noqa: C901\n        self,\n        sources,\n        output_dir=None,\n        macros=None,\n        include_dirs=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        depends=None,\n    ):\n        if not self.initialized:\n            self.initialize()\n        compile_info = self._setup_compile(\n            output_dir, macros, include_dirs, sources, depends, extra_postargs\n        )\n        macros, objects, extra_postargs, pp_opts, build = compile_info\n\n        compile_opts = extra_preargs or []\n        compile_opts.append('/c')\n        if debug:\n            compile_opts.extend(self.compile_options_debug)\n        else:\n            compile_opts.extend(self.compile_options)\n\n        add_cpp_opts = False\n\n        for obj in objects:\n            try:\n                src, ext = build[obj]\n            except KeyError:\n                continue\n            if debug:\n                # pass the full pathname to MSVC in debug mode,\n                # this allows the debugger to find the source file\n                # without asking the user to browse for it\n                src = os.path.abspath(src)\n\n            if ext in self._c_extensions:\n                input_opt = \"/Tc\" + src\n            elif ext in self._cpp_extensions:\n                input_opt = \"/Tp\" + src\n                add_cpp_opts = True\n            elif ext in self._rc_extensions:\n                # compile .RC to .RES file\n                input_opt = src\n                output_opt = \"/fo\" + obj\n                try:\n                    self.spawn([self.rc] + pp_opts + [output_opt, input_opt])\n                except DistutilsExecError as msg:\n                    raise CompileError(msg)\n                continue\n            elif ext in self._mc_extensions:\n                # Compile .MC to .RC file to .RES file.\n                #   * '-h dir' specifies the directory for the\n                #     generated include file\n                #   * '-r dir' specifies the target directory of the\n                #     generated RC file and the binary message resource\n                #     it includes\n                #\n                # For now (since there are no options to change this),\n                # we use the source-directory for the include file and\n                # the build directory for the RC file and message\n                # resources. This works at least for win32all.\n                h_dir = os.path.dirname(src)\n                rc_dir = os.path.dirname(obj)\n                try:\n                    # first compile .MC to .RC and .H file\n                    self.spawn([self.mc, '-h', h_dir, '-r', rc_dir, src])\n                    base, _ = os.path.splitext(os.path.basename(src))\n                    rc_file = os.path.join(rc_dir, base + '.rc')\n                    # then compile .RC to .RES file\n                    self.spawn([self.rc, \"/fo\" + obj, rc_file])\n\n                except DistutilsExecError as msg:\n                    raise CompileError(msg)\n                continue\n            else:\n                # how to handle this file?\n                raise CompileError(f\"Don't know how to compile {src} to {obj}\")\n\n            args = [self.cc] + compile_opts + pp_opts\n            if add_cpp_opts:\n                args.append('/EHsc')\n            args.extend((input_opt, \"/Fo\" + obj))\n            args.extend(extra_postargs)\n\n            try:\n                self.spawn(args)\n            except DistutilsExecError as msg:\n                raise CompileError(msg)\n\n        return objects\n\n    def create_static_lib(\n        self, objects, output_libname, output_dir=None, debug=0, target_lang=None\n    ):\n        if not self.initialized:\n            self.initialize()\n        objects, output_dir = self._fix_object_args(objects, output_dir)\n        output_filename = self.library_filename(output_libname, output_dir=output_dir)\n\n        if self._need_link(objects, output_filename):\n            lib_args = objects + ['/OUT:' + output_filename]\n            if debug:\n                pass  # XXX what goes here?\n            try:\n                log.debug('Executing \"%s\" %s', self.lib, ' '.join(lib_args))\n                self.spawn([self.lib] + lib_args)\n            except DistutilsExecError as msg:\n                raise LibError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    def link(\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        if not self.initialized:\n            self.initialize()\n        objects, output_dir = self._fix_object_args(objects, output_dir)\n        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)\n        libraries, library_dirs, runtime_library_dirs = fixed_args\n\n        if runtime_library_dirs:\n            self.warn(\n                \"I don't know what to do with 'runtime_library_dirs': \"\n                + str(runtime_library_dirs)\n            )\n\n        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)\n        if output_dir is not None:\n            output_filename = os.path.join(output_dir, output_filename)\n\n        if self._need_link(objects, output_filename):\n            ldflags = self._ldflags[target_desc, debug]\n\n            export_opts = [\"/EXPORT:\" + sym for sym in (export_symbols or [])]\n\n            ld_args = (\n                ldflags + lib_opts + export_opts + objects + ['/OUT:' + output_filename]\n            )\n\n            # The MSVC linker generates .lib and .exp files, which cannot be\n            # suppressed by any linker switches. The .lib files may even be\n            # needed! Make sure they are generated in the temporary build\n            # directory. Since they have different names for debug and release\n            # builds, they can go into the same directory.\n            build_temp = os.path.dirname(objects[0])\n            if export_symbols is not None:\n                (dll_name, dll_ext) = os.path.splitext(\n                    os.path.basename(output_filename)\n                )\n                implib_file = os.path.join(build_temp, self.library_filename(dll_name))\n                ld_args.append('/IMPLIB:' + implib_file)\n\n            if extra_preargs:\n                ld_args[:0] = extra_preargs\n            if extra_postargs:\n                ld_args.extend(extra_postargs)\n\n            output_dir = os.path.dirname(os.path.abspath(output_filename))\n            self.mkpath(output_dir)\n            try:\n                log.debug('Executing \"%s\" %s', self.linker, ' '.join(ld_args))\n                self.spawn([self.linker] + ld_args)\n            except DistutilsExecError as msg:\n                raise LinkError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    def spawn(self, cmd):\n        env = dict(os.environ, PATH=self._paths)\n        with self._fallback_spawn(cmd, env) as fallback:\n            return super().spawn(cmd, env=env)\n        return fallback.value\n\n    @contextlib.contextmanager\n    def _fallback_spawn(self, cmd, env):\n        \"\"\"\n        Discovered in pypa/distutils#15, some tools monkeypatch the compiler,\n        so the 'env' kwarg causes a TypeError. Detect this condition and\n        restore the legacy, unsafe behavior.\n        \"\"\"\n        bag = type('Bag', (), {})()\n        try:\n            yield bag\n        except TypeError as exc:\n            if \"unexpected keyword argument 'env'\" not in str(exc):\n                raise\n        else:\n            return\n        warnings.warn(\"Fallback spawn triggered. Please update distutils monkeypatch.\")\n        with mock.patch.dict('os.environ', env):\n            bag.value = super().spawn(cmd)\n\n    # -- Miscellaneous methods -----------------------------------------\n    # These are all used by the 'gen_lib_options() function, in\n    # ccompiler.py.\n\n    def library_dir_option(self, dir):\n        return \"/LIBPATH:\" + dir\n\n    def runtime_library_dir_option(self, dir):\n        raise DistutilsPlatformError(\n            \"don't know how to set runtime library search path for MSVC\"\n        )\n\n    def library_option(self, lib):\n        return self.library_filename(lib)\n\n    def find_library_file(self, dirs, lib, debug=0):\n        # Prefer a debugging library if found (and requested), but deal\n        # with it if we don't have one.\n        if debug:\n            try_names = [lib + \"_d\", lib]\n        else:\n            try_names = [lib]\n        for dir in dirs:\n            for name in try_names:\n                libfile = os.path.join(dir, self.library_filename(name))\n                if os.path.isfile(libfile):\n                    return libfile\n        else:\n            # Oops, didn't find it in *any* of 'dirs'\n            return None\n", "setuptools/_distutils/filelist.py": "\"\"\"distutils.filelist\n\nProvides the FileList class, used for poking about the filesystem\nand building lists of files.\n\"\"\"\n\nimport fnmatch\nimport functools\nimport os\nimport re\n\nfrom ._log import log\nfrom .errors import DistutilsInternalError, DistutilsTemplateError\nfrom .util import convert_path\n\n\nclass FileList:\n    \"\"\"A list of files built by on exploring the filesystem and filtered by\n    applying various patterns to what we find there.\n\n    Instance attributes:\n      dir\n        directory from which files will be taken -- only used if\n        'allfiles' not supplied to constructor\n      files\n        list of filenames currently being built/filtered/manipulated\n      allfiles\n        complete list of files under consideration (ie. without any\n        filtering applied)\n    \"\"\"\n\n    def __init__(self, warn=None, debug_print=None):\n        # ignore argument to FileList, but keep them for backwards\n        # compatibility\n        self.allfiles = None\n        self.files = []\n\n    def set_allfiles(self, allfiles):\n        self.allfiles = allfiles\n\n    def findall(self, dir=os.curdir):\n        self.allfiles = findall(dir)\n\n    def debug_print(self, msg):\n        \"\"\"Print 'msg' to stdout if the global DEBUG (taken from the\n        DISTUTILS_DEBUG environment variable) flag is true.\n        \"\"\"\n        from distutils.debug import DEBUG\n\n        if DEBUG:\n            print(msg)\n\n    # Collection methods\n\n    def append(self, item):\n        self.files.append(item)\n\n    def extend(self, items):\n        self.files.extend(items)\n\n    def sort(self):\n        # Not a strict lexical sort!\n        sortable_files = sorted(map(os.path.split, self.files))\n        self.files = []\n        for sort_tuple in sortable_files:\n            self.files.append(os.path.join(*sort_tuple))\n\n    # Other miscellaneous utility methods\n\n    def remove_duplicates(self):\n        # Assumes list has been sorted!\n        for i in range(len(self.files) - 1, 0, -1):\n            if self.files[i] == self.files[i - 1]:\n                del self.files[i]\n\n    # \"File template\" methods\n\n    def _parse_template_line(self, line):\n        words = line.split()\n        action = words[0]\n\n        patterns = dir = dir_pattern = None\n\n        if action in ('include', 'exclude', 'global-include', 'global-exclude'):\n            if len(words) < 2:\n                raise DistutilsTemplateError(\n                    \"'%s' expects <pattern1> <pattern2> ...\" % action\n                )\n            patterns = [convert_path(w) for w in words[1:]]\n        elif action in ('recursive-include', 'recursive-exclude'):\n            if len(words) < 3:\n                raise DistutilsTemplateError(\n                    \"'%s' expects <dir> <pattern1> <pattern2> ...\" % action\n                )\n            dir = convert_path(words[1])\n            patterns = [convert_path(w) for w in words[2:]]\n        elif action in ('graft', 'prune'):\n            if len(words) != 2:\n                raise DistutilsTemplateError(\n                    \"'%s' expects a single <dir_pattern>\" % action\n                )\n            dir_pattern = convert_path(words[1])\n        else:\n            raise DistutilsTemplateError(\"unknown action '%s'\" % action)\n\n        return (action, patterns, dir, dir_pattern)\n\n    def process_template_line(self, line):  # noqa: C901\n        # Parse the line: split it up, make sure the right number of words\n        # is there, and return the relevant words.  'action' is always\n        # defined: it's the first word of the line.  Which of the other\n        # three are defined depends on the action; it'll be either\n        # patterns, (dir and patterns), or (dir_pattern).\n        (action, patterns, dir, dir_pattern) = self._parse_template_line(line)\n\n        # OK, now we know that the action is valid and we have the\n        # right number of words on the line for that action -- so we\n        # can proceed with minimal error-checking.\n        if action == 'include':\n            self.debug_print(\"include \" + ' '.join(patterns))\n            for pattern in patterns:\n                if not self.include_pattern(pattern, anchor=1):\n                    log.warning(\"warning: no files found matching '%s'\", pattern)\n\n        elif action == 'exclude':\n            self.debug_print(\"exclude \" + ' '.join(patterns))\n            for pattern in patterns:\n                if not self.exclude_pattern(pattern, anchor=1):\n                    log.warning(\n                        (\n                            \"warning: no previously-included files \"\n                            \"found matching '%s'\"\n                        ),\n                        pattern,\n                    )\n\n        elif action == 'global-include':\n            self.debug_print(\"global-include \" + ' '.join(patterns))\n            for pattern in patterns:\n                if not self.include_pattern(pattern, anchor=0):\n                    log.warning(\n                        (\n                            \"warning: no files found matching '%s' \"\n                            \"anywhere in distribution\"\n                        ),\n                        pattern,\n                    )\n\n        elif action == 'global-exclude':\n            self.debug_print(\"global-exclude \" + ' '.join(patterns))\n            for pattern in patterns:\n                if not self.exclude_pattern(pattern, anchor=0):\n                    log.warning(\n                        (\n                            \"warning: no previously-included files matching \"\n                            \"'%s' found anywhere in distribution\"\n                        ),\n                        pattern,\n                    )\n\n        elif action == 'recursive-include':\n            self.debug_print(\"recursive-include {} {}\".format(dir, ' '.join(patterns)))\n            for pattern in patterns:\n                if not self.include_pattern(pattern, prefix=dir):\n                    msg = \"warning: no files found matching '%s' under directory '%s'\"\n                    log.warning(msg, pattern, dir)\n\n        elif action == 'recursive-exclude':\n            self.debug_print(\"recursive-exclude {} {}\".format(dir, ' '.join(patterns)))\n            for pattern in patterns:\n                if not self.exclude_pattern(pattern, prefix=dir):\n                    log.warning(\n                        (\n                            \"warning: no previously-included files matching \"\n                            \"'%s' found under directory '%s'\"\n                        ),\n                        pattern,\n                        dir,\n                    )\n\n        elif action == 'graft':\n            self.debug_print(\"graft \" + dir_pattern)\n            if not self.include_pattern(None, prefix=dir_pattern):\n                log.warning(\"warning: no directories found matching '%s'\", dir_pattern)\n\n        elif action == 'prune':\n            self.debug_print(\"prune \" + dir_pattern)\n            if not self.exclude_pattern(None, prefix=dir_pattern):\n                log.warning(\n                    (\"no previously-included directories found matching '%s'\"),\n                    dir_pattern,\n                )\n        else:\n            raise DistutilsInternalError(\n                \"this cannot happen: invalid action '%s'\" % action\n            )\n\n    # Filtering/selection methods\n\n    def include_pattern(self, pattern, anchor=1, prefix=None, is_regex=0):\n        \"\"\"Select strings (presumably filenames) from 'self.files' that\n        match 'pattern', a Unix-style wildcard (glob) pattern.  Patterns\n        are not quite the same as implemented by the 'fnmatch' module: '*'\n        and '?'  match non-special characters, where \"special\" is platform-\n        dependent: slash on Unix; colon, slash, and backslash on\n        DOS/Windows; and colon on Mac OS.\n\n        If 'anchor' is true (the default), then the pattern match is more\n        stringent: \"*.py\" will match \"foo.py\" but not \"foo/bar.py\".  If\n        'anchor' is false, both of these will match.\n\n        If 'prefix' is supplied, then only filenames starting with 'prefix'\n        (itself a pattern) and ending with 'pattern', with anything in between\n        them, will match.  'anchor' is ignored in this case.\n\n        If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and\n        'pattern' is assumed to be either a string containing a regex or a\n        regex object -- no translation is done, the regex is just compiled\n        and used as-is.\n\n        Selected strings will be added to self.files.\n\n        Return True if files are found, False otherwise.\n        \"\"\"\n        # XXX docstring lying about what the special chars are?\n        files_found = False\n        pattern_re = translate_pattern(pattern, anchor, prefix, is_regex)\n        self.debug_print(\"include_pattern: applying regex r'%s'\" % pattern_re.pattern)\n\n        # delayed loading of allfiles list\n        if self.allfiles is None:\n            self.findall()\n\n        for name in self.allfiles:\n            if pattern_re.search(name):\n                self.debug_print(\" adding \" + name)\n                self.files.append(name)\n                files_found = True\n        return files_found\n\n    def exclude_pattern(self, pattern, anchor=1, prefix=None, is_regex=0):\n        \"\"\"Remove strings (presumably filenames) from 'files' that match\n        'pattern'.  Other parameters are the same as for\n        'include_pattern()', above.\n        The list 'self.files' is modified in place.\n        Return True if files are found, False otherwise.\n        \"\"\"\n        files_found = False\n        pattern_re = translate_pattern(pattern, anchor, prefix, is_regex)\n        self.debug_print(\"exclude_pattern: applying regex r'%s'\" % pattern_re.pattern)\n        for i in range(len(self.files) - 1, -1, -1):\n            if pattern_re.search(self.files[i]):\n                self.debug_print(\" removing \" + self.files[i])\n                del self.files[i]\n                files_found = True\n        return files_found\n\n\n# Utility functions\n\n\ndef _find_all_simple(path):\n    \"\"\"\n    Find all files under 'path'\n    \"\"\"\n    all_unique = _UniqueDirs.filter(os.walk(path, followlinks=True))\n    results = (\n        os.path.join(base, file) for base, dirs, files in all_unique for file in files\n    )\n    return filter(os.path.isfile, results)\n\n\nclass _UniqueDirs(set):\n    \"\"\"\n    Exclude previously-seen dirs from walk results,\n    avoiding infinite recursion.\n    Ref https://bugs.python.org/issue44497.\n    \"\"\"\n\n    def __call__(self, walk_item):\n        \"\"\"\n        Given an item from an os.walk result, determine\n        if the item represents a unique dir for this instance\n        and if not, prevent further traversal.\n        \"\"\"\n        base, dirs, files = walk_item\n        stat = os.stat(base)\n        candidate = stat.st_dev, stat.st_ino\n        found = candidate in self\n        if found:\n            del dirs[:]\n        self.add(candidate)\n        return not found\n\n    @classmethod\n    def filter(cls, items):\n        return filter(cls(), items)\n\n\ndef findall(dir=os.curdir):\n    \"\"\"\n    Find all files under 'dir' and return the list of full filenames.\n    Unless dir is '.', return full filenames with dir prepended.\n    \"\"\"\n    files = _find_all_simple(dir)\n    if dir == os.curdir:\n        make_rel = functools.partial(os.path.relpath, start=dir)\n        files = map(make_rel, files)\n    return list(files)\n\n\ndef glob_to_re(pattern):\n    \"\"\"Translate a shell-like glob pattern to a regular expression; return\n    a string containing the regex.  Differs from 'fnmatch.translate()' in\n    that '*' does not match \"special characters\" (which are\n    platform-specific).\n    \"\"\"\n    pattern_re = fnmatch.translate(pattern)\n\n    # '?' and '*' in the glob pattern become '.' and '.*' in the RE, which\n    # IMHO is wrong -- '?' and '*' aren't supposed to match slash in Unix,\n    # and by extension they shouldn't match such \"special characters\" under\n    # any OS.  So change all non-escaped dots in the RE to match any\n    # character except the special characters (currently: just os.sep).\n    sep = os.sep\n    if os.sep == '\\\\':\n        # we're using a regex to manipulate a regex, so we need\n        # to escape the backslash twice\n        sep = r'\\\\\\\\'\n    escaped = r'\\1[^%s]' % sep\n    pattern_re = re.sub(r'((?<!\\\\)(\\\\\\\\)*)\\.', escaped, pattern_re)\n    return pattern_re\n\n\ndef translate_pattern(pattern, anchor=1, prefix=None, is_regex=0):\n    \"\"\"Translate a shell-like wildcard pattern to a compiled regular\n    expression.  Return the compiled regex.  If 'is_regex' true,\n    then 'pattern' is directly compiled to a regex (if it's a string)\n    or just returned as-is (assumes it's a regex object).\n    \"\"\"\n    if is_regex:\n        if isinstance(pattern, str):\n            return re.compile(pattern)\n        else:\n            return pattern\n\n    # ditch start and end characters\n    start, _, end = glob_to_re('_').partition('_')\n\n    if pattern:\n        pattern_re = glob_to_re(pattern)\n        assert pattern_re.startswith(start) and pattern_re.endswith(end)\n    else:\n        pattern_re = ''\n\n    if prefix is not None:\n        prefix_re = glob_to_re(prefix)\n        assert prefix_re.startswith(start) and prefix_re.endswith(end)\n        prefix_re = prefix_re[len(start) : len(prefix_re) - len(end)]\n        sep = os.sep\n        if os.sep == '\\\\':\n            sep = r'\\\\'\n        pattern_re = pattern_re[len(start) : len(pattern_re) - len(end)]\n        pattern_re = rf'{start}\\A{prefix_re}{sep}.*{pattern_re}{end}'\n    else:  # no prefix -- respect anchor flag\n        if anchor:\n            pattern_re = rf'{start}\\A{pattern_re[len(start) :]}'\n\n    return re.compile(pattern_re)\n", "setuptools/_distutils/log.py": "\"\"\"\nA simple log mechanism styled after PEP 282.\n\nRetained for compatibility and should not be used.\n\"\"\"\n\nimport logging\nimport warnings\n\nfrom ._log import log as _global_log\n\nDEBUG = logging.DEBUG\nINFO = logging.INFO\nWARN = logging.WARN\nERROR = logging.ERROR\nFATAL = logging.FATAL\n\nlog = _global_log.log\ndebug = _global_log.debug\ninfo = _global_log.info\nwarn = _global_log.warning\nerror = _global_log.error\nfatal = _global_log.fatal\n\n\ndef set_threshold(level):\n    orig = _global_log.level\n    _global_log.setLevel(level)\n    return orig\n\n\ndef set_verbosity(v):\n    if v <= 0:\n        set_threshold(logging.WARN)\n    elif v == 1:\n        set_threshold(logging.INFO)\n    elif v >= 2:\n        set_threshold(logging.DEBUG)\n\n\nclass Log(logging.Logger):\n    \"\"\"distutils.log.Log is deprecated, please use an alternative from `logging`.\"\"\"\n\n    def __init__(self, threshold=WARN):\n        warnings.warn(Log.__doc__)  # avoid DeprecationWarning to ensure warn is shown\n        super().__init__(__name__, level=threshold)\n\n    @property\n    def threshold(self):\n        return self.level\n\n    @threshold.setter\n    def threshold(self, level):\n        self.setLevel(level)\n\n    warn = logging.Logger.warning\n", "setuptools/_distutils/text_file.py": "\"\"\"text_file\n\nprovides the TextFile class, which gives an interface to text files\nthat (optionally) takes care of stripping comments, ignoring blank\nlines, and joining lines with backslashes.\"\"\"\n\nimport sys\n\n\nclass TextFile:\n    \"\"\"Provides a file-like object that takes care of all the things you\n    commonly want to do when processing a text file that has some\n    line-by-line syntax: strip comments (as long as \"#\" is your\n    comment character), skip blank lines, join adjacent lines by\n    escaping the newline (ie. backslash at end of line), strip\n    leading and/or trailing whitespace.  All of these are optional\n    and independently controllable.\n\n    Provides a 'warn()' method so you can generate warning messages that\n    report physical line number, even if the logical line in question\n    spans multiple physical lines.  Also provides 'unreadline()' for\n    implementing line-at-a-time lookahead.\n\n    Constructor is called as:\n\n        TextFile (filename=None, file=None, **options)\n\n    It bombs (RuntimeError) if both 'filename' and 'file' are None;\n    'filename' should be a string, and 'file' a file object (or\n    something that provides 'readline()' and 'close()' methods).  It is\n    recommended that you supply at least 'filename', so that TextFile\n    can include it in warning messages.  If 'file' is not supplied,\n    TextFile creates its own using 'io.open()'.\n\n    The options are all boolean, and affect the value returned by\n    'readline()':\n      strip_comments [default: true]\n        strip from \"#\" to end-of-line, as well as any whitespace\n        leading up to the \"#\" -- unless it is escaped by a backslash\n      lstrip_ws [default: false]\n        strip leading whitespace from each line before returning it\n      rstrip_ws [default: true]\n        strip trailing whitespace (including line terminator!) from\n        each line before returning it\n      skip_blanks [default: true}\n        skip lines that are empty *after* stripping comments and\n        whitespace.  (If both lstrip_ws and rstrip_ws are false,\n        then some lines may consist of solely whitespace: these will\n        *not* be skipped, even if 'skip_blanks' is true.)\n      join_lines [default: false]\n        if a backslash is the last non-newline character on a line\n        after stripping comments and whitespace, join the following line\n        to it to form one \"logical line\"; if N consecutive lines end\n        with a backslash, then N+1 physical lines will be joined to\n        form one logical line.\n      collapse_join [default: false]\n        strip leading whitespace from lines that are joined to their\n        predecessor; only matters if (join_lines and not lstrip_ws)\n      errors [default: 'strict']\n        error handler used to decode the file content\n\n    Note that since 'rstrip_ws' can strip the trailing newline, the\n    semantics of 'readline()' must differ from those of the builtin file\n    object's 'readline()' method!  In particular, 'readline()' returns\n    None for end-of-file: an empty string might just be a blank line (or\n    an all-whitespace line), if 'rstrip_ws' is true but 'skip_blanks' is\n    not.\"\"\"\n\n    default_options = {\n        'strip_comments': 1,\n        'skip_blanks': 1,\n        'lstrip_ws': 0,\n        'rstrip_ws': 1,\n        'join_lines': 0,\n        'collapse_join': 0,\n        'errors': 'strict',\n    }\n\n    def __init__(self, filename=None, file=None, **options):\n        \"\"\"Construct a new TextFile object.  At least one of 'filename'\n        (a string) and 'file' (a file-like object) must be supplied.\n        They keyword argument options are described above and affect\n        the values returned by 'readline()'.\"\"\"\n        if filename is None and file is None:\n            raise RuntimeError(\n                \"you must supply either or both of 'filename' and 'file'\"\n            )\n\n        # set values for all options -- either from client option hash\n        # or fallback to default_options\n        for opt in self.default_options.keys():\n            if opt in options:\n                setattr(self, opt, options[opt])\n            else:\n                setattr(self, opt, self.default_options[opt])\n\n        # sanity check client option hash\n        for opt in options.keys():\n            if opt not in self.default_options:\n                raise KeyError(\"invalid TextFile option '%s'\" % opt)\n\n        if file is None:\n            self.open(filename)\n        else:\n            self.filename = filename\n            self.file = file\n            self.current_line = 0  # assuming that file is at BOF!\n\n        # 'linebuf' is a stack of lines that will be emptied before we\n        # actually read from the file; it's only populated by an\n        # 'unreadline()' operation\n        self.linebuf = []\n\n    def open(self, filename):\n        \"\"\"Open a new file named 'filename'.  This overrides both the\n        'filename' and 'file' arguments to the constructor.\"\"\"\n        self.filename = filename\n        self.file = open(self.filename, errors=self.errors, encoding='utf-8')\n        self.current_line = 0\n\n    def close(self):\n        \"\"\"Close the current file and forget everything we know about it\n        (filename, current line number).\"\"\"\n        file = self.file\n        self.file = None\n        self.filename = None\n        self.current_line = None\n        file.close()\n\n    def gen_error(self, msg, line=None):\n        outmsg = []\n        if line is None:\n            line = self.current_line\n        outmsg.append(self.filename + \", \")\n        if isinstance(line, (list, tuple)):\n            outmsg.append(\"lines %d-%d: \" % tuple(line))\n        else:\n            outmsg.append(\"line %d: \" % line)\n        outmsg.append(str(msg))\n        return \"\".join(outmsg)\n\n    def error(self, msg, line=None):\n        raise ValueError(\"error: \" + self.gen_error(msg, line))\n\n    def warn(self, msg, line=None):\n        \"\"\"Print (to stderr) a warning message tied to the current logical\n        line in the current file.  If the current logical line in the\n        file spans multiple physical lines, the warning refers to the\n        whole range, eg. \"lines 3-5\".  If 'line' supplied, it overrides\n        the current line number; it may be a list or tuple to indicate a\n        range of physical lines, or an integer for a single physical\n        line.\"\"\"\n        sys.stderr.write(\"warning: \" + self.gen_error(msg, line) + \"\\n\")\n\n    def readline(self):  # noqa: C901\n        \"\"\"Read and return a single logical line from the current file (or\n        from an internal buffer if lines have previously been \"unread\"\n        with 'unreadline()').  If the 'join_lines' option is true, this\n        may involve reading multiple physical lines concatenated into a\n        single string.  Updates the current line number, so calling\n        'warn()' after 'readline()' emits a warning about the physical\n        line(s) just read.  Returns None on end-of-file, since the empty\n        string can occur if 'rstrip_ws' is true but 'strip_blanks' is\n        not.\"\"\"\n        # If any \"unread\" lines waiting in 'linebuf', return the top\n        # one.  (We don't actually buffer read-ahead data -- lines only\n        # get put in 'linebuf' if the client explicitly does an\n        # 'unreadline()'.\n        if self.linebuf:\n            line = self.linebuf[-1]\n            del self.linebuf[-1]\n            return line\n\n        buildup_line = ''\n\n        while True:\n            # read the line, make it None if EOF\n            line = self.file.readline()\n            if line == '':\n                line = None\n\n            if self.strip_comments and line:\n                # Look for the first \"#\" in the line.  If none, never\n                # mind.  If we find one and it's the first character, or\n                # is not preceded by \"\\\", then it starts a comment --\n                # strip the comment, strip whitespace before it, and\n                # carry on.  Otherwise, it's just an escaped \"#\", so\n                # unescape it (and any other escaped \"#\"'s that might be\n                # lurking in there) and otherwise leave the line alone.\n\n                pos = line.find(\"#\")\n                if pos == -1:  # no \"#\" -- no comments\n                    pass\n\n                # It's definitely a comment -- either \"#\" is the first\n                # character, or it's elsewhere and unescaped.\n                elif pos == 0 or line[pos - 1] != \"\\\\\":\n                    # Have to preserve the trailing newline, because it's\n                    # the job of a later step (rstrip_ws) to remove it --\n                    # and if rstrip_ws is false, we'd better preserve it!\n                    # (NB. this means that if the final line is all comment\n                    # and has no trailing newline, we will think that it's\n                    # EOF; I think that's OK.)\n                    eol = (line[-1] == '\\n') and '\\n' or ''\n                    line = line[0:pos] + eol\n\n                    # If all that's left is whitespace, then skip line\n                    # *now*, before we try to join it to 'buildup_line' --\n                    # that way constructs like\n                    #   hello \\\\\n                    #   # comment that should be ignored\n                    #   there\n                    # result in \"hello there\".\n                    if line.strip() == \"\":\n                        continue\n                else:  # it's an escaped \"#\"\n                    line = line.replace(\"\\\\#\", \"#\")\n\n            # did previous line end with a backslash? then accumulate\n            if self.join_lines and buildup_line:\n                # oops: end of file\n                if line is None:\n                    self.warn(\"continuation line immediately precedes end-of-file\")\n                    return buildup_line\n\n                if self.collapse_join:\n                    line = line.lstrip()\n                line = buildup_line + line\n\n                # careful: pay attention to line number when incrementing it\n                if isinstance(self.current_line, list):\n                    self.current_line[1] = self.current_line[1] + 1\n                else:\n                    self.current_line = [self.current_line, self.current_line + 1]\n            # just an ordinary line, read it as usual\n            else:\n                if line is None:  # eof\n                    return None\n\n                # still have to be careful about incrementing the line number!\n                if isinstance(self.current_line, list):\n                    self.current_line = self.current_line[1] + 1\n                else:\n                    self.current_line = self.current_line + 1\n\n            # strip whitespace however the client wants (leading and\n            # trailing, or one or the other, or neither)\n            if self.lstrip_ws and self.rstrip_ws:\n                line = line.strip()\n            elif self.lstrip_ws:\n                line = line.lstrip()\n            elif self.rstrip_ws:\n                line = line.rstrip()\n\n            # blank line (whether we rstrip'ed or not)? skip to next line\n            # if appropriate\n            if line in ('', '\\n') and self.skip_blanks:\n                continue\n\n            if self.join_lines:\n                if line[-1] == '\\\\':\n                    buildup_line = line[:-1]\n                    continue\n\n                if line[-2:] == '\\\\\\n':\n                    buildup_line = line[0:-2] + '\\n'\n                    continue\n\n            # well, I guess there's some actual content there: return it\n            return line\n\n    def readlines(self):\n        \"\"\"Read and return the list of all logical lines remaining in the\n        current file.\"\"\"\n        lines = []\n        while True:\n            line = self.readline()\n            if line is None:\n                return lines\n            lines.append(line)\n\n    def unreadline(self, line):\n        \"\"\"Push 'line' (a string) onto an internal buffer that will be\n        checked by future 'readline()' calls.  Handy for implementing\n        a parser with line-at-a-time lookahead.\"\"\"\n        self.linebuf.append(line)\n", "setuptools/_distutils/_log.py": "import logging\n\nlog = logging.getLogger()\n", "setuptools/_distutils/dir_util.py": "\"\"\"distutils.dir_util\n\nUtility functions for manipulating directories and directory trees.\"\"\"\n\nimport errno\nimport os\n\nfrom ._log import log\nfrom .errors import DistutilsFileError, DistutilsInternalError\n\n# cache for by mkpath() -- in addition to cheapening redundant calls,\n# eliminates redundant \"creating /foo/bar/baz\" messages in dry-run mode\n_path_created = {}\n\n\ndef mkpath(name, mode=0o777, verbose=1, dry_run=0):  # noqa: C901\n    \"\"\"Create a directory and any missing ancestor directories.\n\n    If the directory already exists (or if 'name' is the empty string, which\n    means the current directory, which of course exists), then do nothing.\n    Raise DistutilsFileError if unable to create some directory along the way\n    (eg. some sub-path exists, but is a file rather than a directory).\n    If 'verbose' is true, print a one-line summary of each mkdir to stdout.\n    Return the list of directories actually created.\n\n    os.makedirs is not used because:\n\n    a) It's new to Python 1.5.2, and\n    b) it blows up if the directory already exists (in which case it should\n       silently succeed).\n    \"\"\"\n\n    global _path_created\n\n    # Detect a common bug -- name is None\n    if not isinstance(name, str):\n        raise DistutilsInternalError(f\"mkpath: 'name' must be a string (got {name!r})\")\n\n    # XXX what's the better way to handle verbosity? print as we create\n    # each directory in the path (the current behaviour), or only announce\n    # the creation of the whole path? (quite easy to do the latter since\n    # we're not using a recursive algorithm)\n\n    name = os.path.normpath(name)\n    created_dirs = []\n    if os.path.isdir(name) or name == '':\n        return created_dirs\n    if _path_created.get(os.path.abspath(name)):\n        return created_dirs\n\n    (head, tail) = os.path.split(name)\n    tails = [tail]  # stack of lone dirs to create\n\n    while head and tail and not os.path.isdir(head):\n        (head, tail) = os.path.split(head)\n        tails.insert(0, tail)  # push next higher dir onto stack\n\n    # now 'head' contains the deepest directory that already exists\n    # (that is, the child of 'head' in 'name' is the highest directory\n    # that does *not* exist)\n    for d in tails:\n        # print \"head = %s, d = %s: \" % (head, d),\n        head = os.path.join(head, d)\n        abs_head = os.path.abspath(head)\n\n        if _path_created.get(abs_head):\n            continue\n\n        if verbose >= 1:\n            log.info(\"creating %s\", head)\n\n        if not dry_run:\n            try:\n                os.mkdir(head, mode)\n            except OSError as exc:\n                if not (exc.errno == errno.EEXIST and os.path.isdir(head)):\n                    raise DistutilsFileError(\n                        f\"could not create '{head}': {exc.args[-1]}\"\n                    )\n            created_dirs.append(head)\n\n        _path_created[abs_head] = 1\n    return created_dirs\n\n\ndef create_tree(base_dir, files, mode=0o777, verbose=1, dry_run=0):\n    \"\"\"Create all the empty directories under 'base_dir' needed to put 'files'\n    there.\n\n    'base_dir' is just the name of a directory which doesn't necessarily\n    exist yet; 'files' is a list of filenames to be interpreted relative to\n    'base_dir'.  'base_dir' + the directory portion of every file in 'files'\n    will be created if it doesn't already exist.  'mode', 'verbose' and\n    'dry_run' flags are as for 'mkpath()'.\n    \"\"\"\n    # First get the list of directories to create\n    need_dir = set(os.path.join(base_dir, os.path.dirname(file)) for file in files)\n\n    # Now create them\n    for dir in sorted(need_dir):\n        mkpath(dir, mode, verbose=verbose, dry_run=dry_run)\n\n\ndef copy_tree(  # noqa: C901\n    src,\n    dst,\n    preserve_mode=1,\n    preserve_times=1,\n    preserve_symlinks=0,\n    update=0,\n    verbose=1,\n    dry_run=0,\n):\n    \"\"\"Copy an entire directory tree 'src' to a new location 'dst'.\n\n    Both 'src' and 'dst' must be directory names.  If 'src' is not a\n    directory, raise DistutilsFileError.  If 'dst' does not exist, it is\n    created with 'mkpath()'.  The end result of the copy is that every\n    file in 'src' is copied to 'dst', and directories under 'src' are\n    recursively copied to 'dst'.  Return the list of files that were\n    copied or might have been copied, using their output name.  The\n    return value is unaffected by 'update' or 'dry_run': it is simply\n    the list of all files under 'src', with the names changed to be\n    under 'dst'.\n\n    'preserve_mode' and 'preserve_times' are the same as for\n    'copy_file'; note that they only apply to regular files, not to\n    directories.  If 'preserve_symlinks' is true, symlinks will be\n    copied as symlinks (on platforms that support them!); otherwise\n    (the default), the destination of the symlink will be copied.\n    'update' and 'verbose' are the same as for 'copy_file'.\n    \"\"\"\n    from distutils.file_util import copy_file\n\n    if not dry_run and not os.path.isdir(src):\n        raise DistutilsFileError(\"cannot copy tree '%s': not a directory\" % src)\n    try:\n        names = os.listdir(src)\n    except OSError as e:\n        if dry_run:\n            names = []\n        else:\n            raise DistutilsFileError(f\"error listing files in '{src}': {e.strerror}\")\n\n    if not dry_run:\n        mkpath(dst, verbose=verbose)\n\n    outputs = []\n\n    for n in names:\n        src_name = os.path.join(src, n)\n        dst_name = os.path.join(dst, n)\n\n        if n.startswith('.nfs'):\n            # skip NFS rename files\n            continue\n\n        if preserve_symlinks and os.path.islink(src_name):\n            link_dest = os.readlink(src_name)\n            if verbose >= 1:\n                log.info(\"linking %s -> %s\", dst_name, link_dest)\n            if not dry_run:\n                os.symlink(link_dest, dst_name)\n            outputs.append(dst_name)\n\n        elif os.path.isdir(src_name):\n            outputs.extend(\n                copy_tree(\n                    src_name,\n                    dst_name,\n                    preserve_mode,\n                    preserve_times,\n                    preserve_symlinks,\n                    update,\n                    verbose=verbose,\n                    dry_run=dry_run,\n                )\n            )\n        else:\n            copy_file(\n                src_name,\n                dst_name,\n                preserve_mode,\n                preserve_times,\n                update,\n                verbose=verbose,\n                dry_run=dry_run,\n            )\n            outputs.append(dst_name)\n\n    return outputs\n\n\ndef _build_cmdtuple(path, cmdtuples):\n    \"\"\"Helper for remove_tree().\"\"\"\n    for f in os.listdir(path):\n        real_f = os.path.join(path, f)\n        if os.path.isdir(real_f) and not os.path.islink(real_f):\n            _build_cmdtuple(real_f, cmdtuples)\n        else:\n            cmdtuples.append((os.remove, real_f))\n    cmdtuples.append((os.rmdir, path))\n\n\ndef remove_tree(directory, verbose=1, dry_run=0):\n    \"\"\"Recursively remove an entire directory tree.\n\n    Any errors are ignored (apart from being reported to stdout if 'verbose'\n    is true).\n    \"\"\"\n    global _path_created\n\n    if verbose >= 1:\n        log.info(\"removing '%s' (and everything under it)\", directory)\n    if dry_run:\n        return\n    cmdtuples = []\n    _build_cmdtuple(directory, cmdtuples)\n    for cmd in cmdtuples:\n        try:\n            cmd[0](cmd[1])\n            # remove dir from cache if it's already there\n            abspath = os.path.abspath(cmd[1])\n            if abspath in _path_created:\n                _path_created.pop(abspath)\n        except OSError as exc:\n            log.warning(\"error removing %s: %s\", directory, exc)\n\n\ndef ensure_relative(path):\n    \"\"\"Take the full path 'path', and make it a relative path.\n\n    This is useful to make 'path' the second argument to os.path.join().\n    \"\"\"\n    drive, path = os.path.splitdrive(path)\n    if path[0:1] == os.sep:\n        path = drive + path[1:]\n    return path\n", "setuptools/_distutils/versionpredicate.py": "\"\"\"Module for parsing and testing package version predicate strings.\"\"\"\n\nimport operator\nimport re\n\nfrom . import version\n\nre_validPackage = re.compile(r\"(?i)^\\s*([a-z_]\\w*(?:\\.[a-z_]\\w*)*)(.*)\", re.ASCII)\n# (package) (rest)\n\nre_paren = re.compile(r\"^\\s*\\((.*)\\)\\s*$\")  # (list) inside of parentheses\nre_splitComparison = re.compile(r\"^\\s*(<=|>=|<|>|!=|==)\\s*([^\\s,]+)\\s*$\")\n# (comp) (version)\n\n\ndef splitUp(pred):\n    \"\"\"Parse a single version comparison.\n\n    Return (comparison string, StrictVersion)\n    \"\"\"\n    res = re_splitComparison.match(pred)\n    if not res:\n        raise ValueError(\"bad package restriction syntax: %r\" % pred)\n    comp, verStr = res.groups()\n    with version.suppress_known_deprecation():\n        other = version.StrictVersion(verStr)\n    return (comp, other)\n\n\ncompmap = {\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \"==\": operator.eq,\n    \">\": operator.gt,\n    \">=\": operator.ge,\n    \"!=\": operator.ne,\n}\n\n\nclass VersionPredicate:\n    \"\"\"Parse and test package version predicates.\n\n    >>> v = VersionPredicate('pyepat.abc (>1.0, <3333.3a1, !=1555.1b3)')\n\n    The `name` attribute provides the full dotted name that is given::\n\n    >>> v.name\n    'pyepat.abc'\n\n    The str() of a `VersionPredicate` provides a normalized\n    human-readable version of the expression::\n\n    >>> print(v)\n    pyepat.abc (> 1.0, < 3333.3a1, != 1555.1b3)\n\n    The `satisfied_by()` method can be used to determine with a given\n    version number is included in the set described by the version\n    restrictions::\n\n    >>> v.satisfied_by('1.1')\n    True\n    >>> v.satisfied_by('1.4')\n    True\n    >>> v.satisfied_by('1.0')\n    False\n    >>> v.satisfied_by('4444.4')\n    False\n    >>> v.satisfied_by('1555.1b3')\n    False\n\n    `VersionPredicate` is flexible in accepting extra whitespace::\n\n    >>> v = VersionPredicate(' pat( ==  0.1  )  ')\n    >>> v.name\n    'pat'\n    >>> v.satisfied_by('0.1')\n    True\n    >>> v.satisfied_by('0.2')\n    False\n\n    If any version numbers passed in do not conform to the\n    restrictions of `StrictVersion`, a `ValueError` is raised::\n\n    >>> v = VersionPredicate('p1.p2.p3.p4(>=1.0, <=1.3a1, !=1.2zb3)')\n    Traceback (most recent call last):\n      ...\n    ValueError: invalid version number '1.2zb3'\n\n    It the module or package name given does not conform to what's\n    allowed as a legal module or package name, `ValueError` is\n    raised::\n\n    >>> v = VersionPredicate('foo-bar')\n    Traceback (most recent call last):\n      ...\n    ValueError: expected parenthesized list: '-bar'\n\n    >>> v = VersionPredicate('foo bar (12.21)')\n    Traceback (most recent call last):\n      ...\n    ValueError: expected parenthesized list: 'bar (12.21)'\n\n    \"\"\"\n\n    def __init__(self, versionPredicateStr):\n        \"\"\"Parse a version predicate string.\"\"\"\n        # Fields:\n        #    name:  package name\n        #    pred:  list of (comparison string, StrictVersion)\n\n        versionPredicateStr = versionPredicateStr.strip()\n        if not versionPredicateStr:\n            raise ValueError(\"empty package restriction\")\n        match = re_validPackage.match(versionPredicateStr)\n        if not match:\n            raise ValueError(\"bad package name in %r\" % versionPredicateStr)\n        self.name, paren = match.groups()\n        paren = paren.strip()\n        if paren:\n            match = re_paren.match(paren)\n            if not match:\n                raise ValueError(\"expected parenthesized list: %r\" % paren)\n            str = match.groups()[0]\n            self.pred = [splitUp(aPred) for aPred in str.split(\",\")]\n            if not self.pred:\n                raise ValueError(\"empty parenthesized list in %r\" % versionPredicateStr)\n        else:\n            self.pred = []\n\n    def __str__(self):\n        if self.pred:\n            seq = [cond + \" \" + str(ver) for cond, ver in self.pred]\n            return self.name + \" (\" + \", \".join(seq) + \")\"\n        else:\n            return self.name\n\n    def satisfied_by(self, version):\n        \"\"\"True if version is compatible with all the predicates in self.\n        The parameter version must be acceptable to the StrictVersion\n        constructor.  It may be either a string or StrictVersion.\n        \"\"\"\n        for cond, ver in self.pred:\n            if not compmap[cond](version, ver):\n                return False\n        return True\n\n\n_provision_rx = None\n\n\ndef split_provision(value):\n    \"\"\"Return the name and optional version number of a provision.\n\n    The version number, if given, will be returned as a `StrictVersion`\n    instance, otherwise it will be `None`.\n\n    >>> split_provision('mypkg')\n    ('mypkg', None)\n    >>> split_provision(' mypkg( 1.2 ) ')\n    ('mypkg', StrictVersion ('1.2'))\n    \"\"\"\n    global _provision_rx\n    if _provision_rx is None:\n        _provision_rx = re.compile(\n            r\"([a-zA-Z_]\\w*(?:\\.[a-zA-Z_]\\w*)*)(?:\\s*\\(\\s*([^)\\s]+)\\s*\\))?$\", re.ASCII\n        )\n    value = value.strip()\n    m = _provision_rx.match(value)\n    if not m:\n        raise ValueError(\"illegal provides specification: %r\" % value)\n    ver = m.group(2) or None\n    if ver:\n        with version.suppress_known_deprecation():\n            ver = version.StrictVersion(ver)\n    return m.group(1), ver\n", "setuptools/_distutils/zosccompiler.py": "\"\"\"distutils.zosccompiler\n\nContains the selection of the c & c++ compilers on z/OS. There are several\ndifferent c compilers on z/OS, all of them are optional, so the correct\none needs to be chosen based on the users input. This is compatible with\nthe following compilers:\n\nIBM C/C++ For Open Enterprise Languages on z/OS 2.0\nIBM Open XL C/C++ 1.1 for z/OS\nIBM XL C/C++ V2.4.1 for z/OS 2.4 and 2.5\nIBM z/OS XL C/C++\n\"\"\"\n\nimport os\n\nfrom . import sysconfig\nfrom .errors import CompileError, DistutilsExecError\nfrom .unixccompiler import UnixCCompiler\n\n_cc_args = {\n    'ibm-openxl': [\n        '-m64',\n        '-fvisibility=default',\n        '-fzos-le-char-mode=ascii',\n        '-fno-short-enums',\n    ],\n    'ibm-xlclang': [\n        '-q64',\n        '-qexportall',\n        '-qascii',\n        '-qstrict',\n        '-qnocsect',\n        '-Wa,asa,goff',\n        '-Wa,xplink',\n        '-qgonumber',\n        '-qenum=int',\n        '-Wc,DLL',\n    ],\n    'ibm-xlc': [\n        '-q64',\n        '-qexportall',\n        '-qascii',\n        '-qstrict',\n        '-qnocsect',\n        '-Wa,asa,goff',\n        '-Wa,xplink',\n        '-qgonumber',\n        '-qenum=int',\n        '-Wc,DLL',\n        '-qlanglvl=extc99',\n    ],\n}\n\n_cxx_args = {\n    'ibm-openxl': [\n        '-m64',\n        '-fvisibility=default',\n        '-fzos-le-char-mode=ascii',\n        '-fno-short-enums',\n    ],\n    'ibm-xlclang': [\n        '-q64',\n        '-qexportall',\n        '-qascii',\n        '-qstrict',\n        '-qnocsect',\n        '-Wa,asa,goff',\n        '-Wa,xplink',\n        '-qgonumber',\n        '-qenum=int',\n        '-Wc,DLL',\n    ],\n    'ibm-xlc': [\n        '-q64',\n        '-qexportall',\n        '-qascii',\n        '-qstrict',\n        '-qnocsect',\n        '-Wa,asa,goff',\n        '-Wa,xplink',\n        '-qgonumber',\n        '-qenum=int',\n        '-Wc,DLL',\n        '-qlanglvl=extended0x',\n    ],\n}\n\n_asm_args = {\n    'ibm-openxl': ['-fasm', '-fno-integrated-as', '-Wa,--ASA', '-Wa,--GOFF'],\n    'ibm-xlclang': [],\n    'ibm-xlc': [],\n}\n\n_ld_args = {\n    'ibm-openxl': [],\n    'ibm-xlclang': ['-Wl,dll', '-q64'],\n    'ibm-xlc': ['-Wl,dll', '-q64'],\n}\n\n\n# Python on z/OS is built with no compiler specific options in it's CFLAGS.\n# But each compiler requires it's own specific options to build successfully,\n# though some of the options are common between them\nclass zOSCCompiler(UnixCCompiler):\n    src_extensions = ['.c', '.C', '.cc', '.cxx', '.cpp', '.m', '.s']\n    _cpp_extensions = ['.cc', '.cpp', '.cxx', '.C']\n    _asm_extensions = ['.s']\n\n    def _get_zos_compiler_name(self):\n        zos_compiler_names = [\n            os.path.basename(binary)\n            for envvar in ('CC', 'CXX', 'LDSHARED')\n            if (binary := os.environ.get(envvar, None))\n        ]\n        if len(zos_compiler_names) == 0:\n            return 'ibm-openxl'\n\n        zos_compilers = {}\n        for compiler in (\n            'ibm-clang',\n            'ibm-clang64',\n            'ibm-clang++',\n            'ibm-clang++64',\n            'clang',\n            'clang++',\n            'clang-14',\n        ):\n            zos_compilers[compiler] = 'ibm-openxl'\n\n        for compiler in ('xlclang', 'xlclang++', 'njsc', 'njsc++'):\n            zos_compilers[compiler] = 'ibm-xlclang'\n\n        for compiler in ('xlc', 'xlC', 'xlc++'):\n            zos_compilers[compiler] = 'ibm-xlc'\n\n        return zos_compilers.get(zos_compiler_names[0], 'ibm-openxl')\n\n    def __init__(self, verbose=0, dry_run=0, force=0):\n        super().__init__(verbose, dry_run, force)\n        self.zos_compiler = self._get_zos_compiler_name()\n        sysconfig.customize_compiler(self)\n\n    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        local_args = []\n        if ext in self._cpp_extensions:\n            compiler = self.compiler_cxx\n            local_args.extend(_cxx_args[self.zos_compiler])\n        elif ext in self._asm_extensions:\n            compiler = self.compiler_so\n            local_args.extend(_cc_args[self.zos_compiler])\n            local_args.extend(_asm_args[self.zos_compiler])\n        else:\n            compiler = self.compiler_so\n            local_args.extend(_cc_args[self.zos_compiler])\n        local_args.extend(cc_args)\n\n        try:\n            self.spawn(compiler + local_args + [src, '-o', obj] + extra_postargs)\n        except DistutilsExecError as msg:\n            raise CompileError(msg)\n\n    def runtime_library_dir_option(self, dir):\n        return '-L' + dir\n\n    def link(\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        # For a built module to use functions from cpython, it needs to use Pythons\n        # side deck file. The side deck is located beside the libpython3.xx.so\n        ldversion = sysconfig.get_config_var('LDVERSION')\n        if sysconfig.python_build:\n            side_deck_path = os.path.join(\n                sysconfig.get_config_var('abs_builddir'),\n                f'libpython{ldversion}.x',\n            )\n        else:\n            side_deck_path = os.path.join(\n                sysconfig.get_config_var('installed_base'),\n                sysconfig.get_config_var('platlibdir'),\n                f'libpython{ldversion}.x',\n            )\n\n        if os.path.exists(side_deck_path):\n            if extra_postargs:\n                extra_postargs.append(side_deck_path)\n            else:\n                extra_postargs = [side_deck_path]\n\n        # Check and replace libraries included side deck files\n        if runtime_library_dirs:\n            for dir in runtime_library_dirs:\n                for library in libraries[:]:\n                    library_side_deck = os.path.join(dir, f'{library}.x')\n                    if os.path.exists(library_side_deck):\n                        libraries.remove(library)\n                        extra_postargs.append(library_side_deck)\n                        break\n\n        # Any required ld args for the given compiler\n        extra_postargs.extend(_ld_args[self.zos_compiler])\n\n        super().link(\n            target_desc,\n            objects,\n            output_filename,\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            export_symbols,\n            debug,\n            extra_preargs,\n            extra_postargs,\n            build_temp,\n            target_lang,\n        )\n", "setuptools/_distutils/config.py": "\"\"\"distutils.pypirc\n\nProvides the PyPIRCCommand class, the base class for the command classes\nthat uses .pypirc in the distutils.command package.\n\"\"\"\n\nimport email.message\nimport os\nfrom configparser import RawConfigParser\n\nfrom .cmd import Command\n\nDEFAULT_PYPIRC = \"\"\"\\\n[distutils]\nindex-servers =\n    pypi\n\n[pypi]\nusername:%s\npassword:%s\n\"\"\"\n\n\nclass PyPIRCCommand(Command):\n    \"\"\"Base command that knows how to handle the .pypirc file\"\"\"\n\n    DEFAULT_REPOSITORY = 'https://upload.pypi.org/legacy/'\n    DEFAULT_REALM = 'pypi'\n    repository = None\n    realm = None\n\n    user_options = [\n        ('repository=', 'r', \"url of repository [default: %s]\" % DEFAULT_REPOSITORY),\n        ('show-response', None, 'display full response text from server'),\n    ]\n\n    boolean_options = ['show-response']\n\n    def _get_rc_file(self):\n        \"\"\"Returns rc file path.\"\"\"\n        return os.path.join(os.path.expanduser('~'), '.pypirc')\n\n    def _store_pypirc(self, username, password):\n        \"\"\"Creates a default .pypirc file.\"\"\"\n        rc = self._get_rc_file()\n        raw = os.open(rc, os.O_CREAT | os.O_WRONLY, 0o600)\n        with os.fdopen(raw, 'w', encoding='utf-8') as f:\n            f.write(DEFAULT_PYPIRC % (username, password))\n\n    def _read_pypirc(self):  # noqa: C901\n        \"\"\"Reads the .pypirc file.\"\"\"\n        rc = self._get_rc_file()\n        if os.path.exists(rc):\n            self.announce('Using PyPI login from %s' % rc)\n            repository = self.repository or self.DEFAULT_REPOSITORY\n\n            config = RawConfigParser()\n            config.read(rc, encoding='utf-8')\n            sections = config.sections()\n            if 'distutils' in sections:\n                # let's get the list of servers\n                index_servers = config.get('distutils', 'index-servers')\n                _servers = [\n                    server.strip()\n                    for server in index_servers.split('\\n')\n                    if server.strip() != ''\n                ]\n                if _servers == []:\n                    # nothing set, let's try to get the default pypi\n                    if 'pypi' in sections:\n                        _servers = ['pypi']\n                    else:\n                        # the file is not properly defined, returning\n                        # an empty dict\n                        return {}\n                for server in _servers:\n                    current = {'server': server}\n                    current['username'] = config.get(server, 'username')\n\n                    # optional params\n                    for key, default in (\n                        ('repository', self.DEFAULT_REPOSITORY),\n                        ('realm', self.DEFAULT_REALM),\n                        ('password', None),\n                    ):\n                        if config.has_option(server, key):\n                            current[key] = config.get(server, key)\n                        else:\n                            current[key] = default\n\n                    # work around people having \"repository\" for the \"pypi\"\n                    # section of their config set to the HTTP (rather than\n                    # HTTPS) URL\n                    if server == 'pypi' and repository in (\n                        self.DEFAULT_REPOSITORY,\n                        'pypi',\n                    ):\n                        current['repository'] = self.DEFAULT_REPOSITORY\n                        return current\n\n                    if (\n                        current['server'] == repository\n                        or current['repository'] == repository\n                    ):\n                        return current\n            elif 'server-login' in sections:\n                # old format\n                server = 'server-login'\n                if config.has_option(server, 'repository'):\n                    repository = config.get(server, 'repository')\n                else:\n                    repository = self.DEFAULT_REPOSITORY\n                return {\n                    'username': config.get(server, 'username'),\n                    'password': config.get(server, 'password'),\n                    'repository': repository,\n                    'server': server,\n                    'realm': self.DEFAULT_REALM,\n                }\n\n        return {}\n\n    def _read_pypi_response(self, response):\n        \"\"\"Read and decode a PyPI HTTP response.\"\"\"\n        content_type = response.getheader('content-type', 'text/plain')\n        return response.read().decode(_extract_encoding(content_type))\n\n    def initialize_options(self):\n        \"\"\"Initialize options.\"\"\"\n        self.repository = None\n        self.realm = None\n        self.show_response = 0\n\n    def finalize_options(self):\n        \"\"\"Finalizes options.\"\"\"\n        if self.repository is None:\n            self.repository = self.DEFAULT_REPOSITORY\n        if self.realm is None:\n            self.realm = self.DEFAULT_REALM\n\n\ndef _extract_encoding(content_type):\n    \"\"\"\n    >>> _extract_encoding('text/plain')\n    'ascii'\n    >>> _extract_encoding('text/html; charset=\"utf8\"')\n    'utf8'\n    \"\"\"\n    msg = email.message.EmailMessage()\n    msg['content-type'] = content_type\n    return msg['content-type'].params.get('charset', 'ascii')\n", "setuptools/_distutils/_macos_compat.py": "import importlib\nimport sys\n\n\ndef bypass_compiler_fixup(cmd, args):\n    return cmd\n\n\nif sys.platform == 'darwin':\n    compiler_fixup = importlib.import_module('_osx_support').compiler_fixup\nelse:\n    compiler_fixup = bypass_compiler_fixup\n", "setuptools/_distutils/_itertools.py": "# from more_itertools 10.2\ndef always_iterable(obj, base_type=(str, bytes)):\n    \"\"\"If *obj* is iterable, return an iterator over its items::\n\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n\n    If *obj* is ``None``, return an empty iterable:\n\n        >>> obj = None\n        >>> list(always_iterable(None))\n        []\n\n    By default, binary and text strings are not considered iterable::\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj))\n        ['foo']\n\n    If *base_type* is set, objects for which ``isinstance(obj, base_type)``\n    returns ``True`` won't be considered iterable.\n\n        >>> obj = {'a': 1}\n        >>> list(always_iterable(obj))  # Iterate over the dict's keys\n        ['a']\n        >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n        [{'a': 1}]\n\n    Set *base_type* to ``None`` to avoid any special handling and treat objects\n    Python considers iterable as iterable:\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj, base_type=None))\n        ['f', 'o', 'o']\n    \"\"\"\n    if obj is None:\n        return iter(())\n\n    if (base_type is not None) and isinstance(obj, base_type):\n        return iter((obj,))\n\n    try:\n        return iter(obj)\n    except TypeError:\n        return iter((obj,))\n", "setuptools/_distutils/core.py": "\"\"\"distutils.core\n\nThe only module that needs to be imported to use the Distutils; provides\nthe 'setup' function (which is to be called from the setup script).  Also\nindirectly provides the Distribution and Command classes, although they are\nreally defined in distutils.dist and distutils.cmd.\n\"\"\"\n\nimport os\nimport sys\nimport tokenize\n\nfrom .cmd import Command\nfrom .config import PyPIRCCommand\nfrom .debug import DEBUG\n\n# Mainly import these so setup scripts can \"from distutils.core import\" them.\nfrom .dist import Distribution\nfrom .errors import (\n    CCompilerError,\n    DistutilsArgError,\n    DistutilsError,\n    DistutilsSetupError,\n)\nfrom .extension import Extension\n\n__all__ = ['Distribution', 'Command', 'PyPIRCCommand', 'Extension', 'setup']\n\n# This is a barebones help message generated displayed when the user\n# runs the setup script with no arguments at all.  More useful help\n# is generated with various --help options: global help, list commands,\n# and per-command help.\nUSAGE = \"\"\"\\\nusage: %(script)s [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]\n   or: %(script)s --help [cmd1 cmd2 ...]\n   or: %(script)s --help-commands\n   or: %(script)s cmd --help\n\"\"\"\n\n\ndef gen_usage(script_name):\n    script = os.path.basename(script_name)\n    return USAGE % locals()\n\n\n# Some mild magic to control the behaviour of 'setup()' from 'run_setup()'.\n_setup_stop_after = None\n_setup_distribution = None\n\n# Legal keyword arguments for the setup() function\nsetup_keywords = (\n    'distclass',\n    'script_name',\n    'script_args',\n    'options',\n    'name',\n    'version',\n    'author',\n    'author_email',\n    'maintainer',\n    'maintainer_email',\n    'url',\n    'license',\n    'description',\n    'long_description',\n    'keywords',\n    'platforms',\n    'classifiers',\n    'download_url',\n    'requires',\n    'provides',\n    'obsoletes',\n)\n\n# Legal keyword arguments for the Extension constructor\nextension_keywords = (\n    'name',\n    'sources',\n    'include_dirs',\n    'define_macros',\n    'undef_macros',\n    'library_dirs',\n    'libraries',\n    'runtime_library_dirs',\n    'extra_objects',\n    'extra_compile_args',\n    'extra_link_args',\n    'swig_opts',\n    'export_symbols',\n    'depends',\n    'language',\n)\n\n\ndef setup(**attrs):  # noqa: C901\n    \"\"\"The gateway to the Distutils: do everything your setup script needs\n    to do, in a highly flexible and user-driven way.  Briefly: create a\n    Distribution instance; find and parse config files; parse the command\n    line; run each Distutils command found there, customized by the options\n    supplied to 'setup()' (as keyword arguments), in config files, and on\n    the command line.\n\n    The Distribution instance might be an instance of a class supplied via\n    the 'distclass' keyword argument to 'setup'; if no such class is\n    supplied, then the Distribution class (in dist.py) is instantiated.\n    All other arguments to 'setup' (except for 'cmdclass') are used to set\n    attributes of the Distribution instance.\n\n    The 'cmdclass' argument, if supplied, is a dictionary mapping command\n    names to command classes.  Each command encountered on the command line\n    will be turned into a command class, which is in turn instantiated; any\n    class found in 'cmdclass' is used in place of the default, which is\n    (for command 'foo_bar') class 'foo_bar' in module\n    'distutils.command.foo_bar'.  The command class must provide a\n    'user_options' attribute which is a list of option specifiers for\n    'distutils.fancy_getopt'.  Any command-line options between the current\n    and the next command are used to set attributes of the current command\n    object.\n\n    When the entire command-line has been successfully parsed, calls the\n    'run()' method on each command object in turn.  This method will be\n    driven entirely by the Distribution object (which each command object\n    has a reference to, thanks to its constructor), and the\n    command-specific options that became attributes of each command\n    object.\n    \"\"\"\n\n    global _setup_stop_after, _setup_distribution\n\n    # Determine the distribution class -- either caller-supplied or\n    # our Distribution (see below).\n    klass = attrs.get('distclass')\n    if klass:\n        attrs.pop('distclass')\n    else:\n        klass = Distribution\n\n    if 'script_name' not in attrs:\n        attrs['script_name'] = os.path.basename(sys.argv[0])\n    if 'script_args' not in attrs:\n        attrs['script_args'] = sys.argv[1:]\n\n    # Create the Distribution instance, using the remaining arguments\n    # (ie. everything except distclass) to initialize it\n    try:\n        _setup_distribution = dist = klass(attrs)\n    except DistutilsSetupError as msg:\n        if 'name' not in attrs:\n            raise SystemExit(\"error in setup command: %s\" % msg)\n        else:\n            raise SystemExit(\"error in {} setup command: {}\".format(attrs['name'], msg))\n\n    if _setup_stop_after == \"init\":\n        return dist\n\n    # Find and parse the config file(s): they will override options from\n    # the setup script, but be overridden by the command line.\n    dist.parse_config_files()\n\n    if DEBUG:\n        print(\"options (after parsing config files):\")\n        dist.dump_option_dicts()\n\n    if _setup_stop_after == \"config\":\n        return dist\n\n    # Parse the command line and override config files; any\n    # command-line errors are the end user's fault, so turn them into\n    # SystemExit to suppress tracebacks.\n    try:\n        ok = dist.parse_command_line()\n    except DistutilsArgError as msg:\n        raise SystemExit(gen_usage(dist.script_name) + \"\\nerror: %s\" % msg)\n\n    if DEBUG:\n        print(\"options (after parsing command line):\")\n        dist.dump_option_dicts()\n\n    if _setup_stop_after == \"commandline\":\n        return dist\n\n    # And finally, run all the commands found on the command line.\n    if ok:\n        return run_commands(dist)\n\n    return dist\n\n\n# setup ()\n\n\ndef run_commands(dist):\n    \"\"\"Given a Distribution object run all the commands,\n    raising ``SystemExit`` errors in the case of failure.\n\n    This function assumes that either ``sys.argv`` or ``dist.script_args``\n    is already set accordingly.\n    \"\"\"\n    try:\n        dist.run_commands()\n    except KeyboardInterrupt:\n        raise SystemExit(\"interrupted\")\n    except OSError as exc:\n        if DEBUG:\n            sys.stderr.write(f\"error: {exc}\\n\")\n            raise\n        else:\n            raise SystemExit(f\"error: {exc}\")\n\n    except (DistutilsError, CCompilerError) as msg:\n        if DEBUG:\n            raise\n        else:\n            raise SystemExit(\"error: \" + str(msg))\n\n    return dist\n\n\ndef run_setup(script_name, script_args=None, stop_after=\"run\"):\n    \"\"\"Run a setup script in a somewhat controlled environment, and\n    return the Distribution instance that drives things.  This is useful\n    if you need to find out the distribution meta-data (passed as\n    keyword args from 'script' to 'setup()', or the contents of the\n    config files or command-line.\n\n    'script_name' is a file that will be read and run with 'exec()';\n    'sys.argv[0]' will be replaced with 'script' for the duration of the\n    call.  'script_args' is a list of strings; if supplied,\n    'sys.argv[1:]' will be replaced by 'script_args' for the duration of\n    the call.\n\n    'stop_after' tells 'setup()' when to stop processing; possible\n    values:\n      init\n        stop after the Distribution instance has been created and\n        populated with the keyword arguments to 'setup()'\n      config\n        stop after config files have been parsed (and their data\n        stored in the Distribution instance)\n      commandline\n        stop after the command-line ('sys.argv[1:]' or 'script_args')\n        have been parsed (and the data stored in the Distribution)\n      run [default]\n        stop after all commands have been run (the same as if 'setup()'\n        had been called in the usual way\n\n    Returns the Distribution instance, which provides all information\n    used to drive the Distutils.\n    \"\"\"\n    if stop_after not in ('init', 'config', 'commandline', 'run'):\n        raise ValueError(f\"invalid value for 'stop_after': {stop_after!r}\")\n\n    global _setup_stop_after, _setup_distribution\n    _setup_stop_after = stop_after\n\n    save_argv = sys.argv.copy()\n    g = {'__file__': script_name, '__name__': '__main__'}\n    try:\n        try:\n            sys.argv[0] = script_name\n            if script_args is not None:\n                sys.argv[1:] = script_args\n            # tokenize.open supports automatic encoding detection\n            with tokenize.open(script_name) as f:\n                code = f.read().replace(r'\\r\\n', r'\\n')\n                exec(code, g)\n        finally:\n            sys.argv = save_argv\n            _setup_stop_after = None\n    except SystemExit:\n        # Hmm, should we do something if exiting with a non-zero code\n        # (ie. error)?\n        pass\n\n    if _setup_distribution is None:\n        raise RuntimeError(\n            (\n                \"'distutils.core.setup()' was never called -- \"\n                \"perhaps '%s' is not a Distutils setup script?\"\n            )\n            % script_name\n        )\n\n    # I wonder if the setup script's namespace -- g and l -- would be of\n    # any interest to callers?\n    # print \"_setup_distribution:\", _setup_distribution\n    return _setup_distribution\n\n\n# run_setup ()\n", "setuptools/_distutils/dep_util.py": "import warnings\n\nfrom . import _modified\n\n\ndef __getattr__(name):\n    if name not in ['newer', 'newer_group', 'newer_pairwise']:\n        raise AttributeError(name)\n    warnings.warn(\n        \"dep_util is Deprecated. Use functions from setuptools instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return getattr(_modified, name)\n", "setuptools/_distutils/msvc9compiler.py": "\"\"\"distutils.msvc9compiler\n\nContains MSVCCompiler, an implementation of the abstract CCompiler class\nfor the Microsoft Visual Studio 2008.\n\nThe module is compatible with VS 2005 and VS 2008. You can find legacy support\nfor older versions of VS in distutils.msvccompiler.\n\"\"\"\n\n# Written by Perry Stoll\n# hacked by Robin Becker and Thomas Heller to do a better job of\n#   finding DevStudio (through the registry)\n# ported to VS2005 and VS 2008 by Christian Heimes\n\nimport os\nimport re\nimport subprocess\nimport sys\nimport warnings\nimport winreg\n\nfrom ._log import log\nfrom .ccompiler import CCompiler, gen_lib_options\nfrom .errors import (\n    CompileError,\n    DistutilsExecError,\n    DistutilsPlatformError,\n    LibError,\n    LinkError,\n)\nfrom .util import get_platform\n\nwarnings.warn(\n    \"msvc9compiler is deprecated and slated to be removed \"\n    \"in the future. Please discontinue use or file an issue \"\n    \"with pypa/distutils describing your use case.\",\n    DeprecationWarning,\n)\n\nRegOpenKeyEx = winreg.OpenKeyEx\nRegEnumKey = winreg.EnumKey\nRegEnumValue = winreg.EnumValue\nRegError = winreg.error\n\nHKEYS = (\n    winreg.HKEY_USERS,\n    winreg.HKEY_CURRENT_USER,\n    winreg.HKEY_LOCAL_MACHINE,\n    winreg.HKEY_CLASSES_ROOT,\n)\n\nNATIVE_WIN64 = sys.platform == 'win32' and sys.maxsize > 2**32\nif NATIVE_WIN64:\n    # Visual C++ is a 32-bit application, so we need to look in\n    # the corresponding registry branch, if we're running a\n    # 64-bit Python on Win64\n    VS_BASE = r\"Software\\Wow6432Node\\Microsoft\\VisualStudio\\%0.1f\"\n    WINSDK_BASE = r\"Software\\Wow6432Node\\Microsoft\\Microsoft SDKs\\Windows\"\n    NET_BASE = r\"Software\\Wow6432Node\\Microsoft\\.NETFramework\"\nelse:\n    VS_BASE = r\"Software\\Microsoft\\VisualStudio\\%0.1f\"\n    WINSDK_BASE = r\"Software\\Microsoft\\Microsoft SDKs\\Windows\"\n    NET_BASE = r\"Software\\Microsoft\\.NETFramework\"\n\n# A map keyed by get_platform() return values to values accepted by\n# 'vcvarsall.bat'.  Note a cross-compile may combine these (eg, 'x86_amd64' is\n# the param to cross-compile on x86 targeting amd64.)\nPLAT_TO_VCVARS = {\n    'win32': 'x86',\n    'win-amd64': 'amd64',\n}\n\n\nclass Reg:\n    \"\"\"Helper class to read values from the registry\"\"\"\n\n    def get_value(cls, path, key):\n        for base in HKEYS:\n            d = cls.read_values(base, path)\n            if d and key in d:\n                return d[key]\n        raise KeyError(key)\n\n    get_value = classmethod(get_value)\n\n    def read_keys(cls, base, key):\n        \"\"\"Return list of registry keys.\"\"\"\n        try:\n            handle = RegOpenKeyEx(base, key)\n        except RegError:\n            return None\n        L = []\n        i = 0\n        while True:\n            try:\n                k = RegEnumKey(handle, i)\n            except RegError:\n                break\n            L.append(k)\n            i += 1\n        return L\n\n    read_keys = classmethod(read_keys)\n\n    def read_values(cls, base, key):\n        \"\"\"Return dict of registry keys and values.\n\n        All names are converted to lowercase.\n        \"\"\"\n        try:\n            handle = RegOpenKeyEx(base, key)\n        except RegError:\n            return None\n        d = {}\n        i = 0\n        while True:\n            try:\n                name, value, type = RegEnumValue(handle, i)\n            except RegError:\n                break\n            name = name.lower()\n            d[cls.convert_mbcs(name)] = cls.convert_mbcs(value)\n            i += 1\n        return d\n\n    read_values = classmethod(read_values)\n\n    def convert_mbcs(s):\n        dec = getattr(s, \"decode\", None)\n        if dec is not None:\n            try:\n                s = dec(\"mbcs\")\n            except UnicodeError:\n                pass\n        return s\n\n    convert_mbcs = staticmethod(convert_mbcs)\n\n\nclass MacroExpander:\n    def __init__(self, version):\n        self.macros = {}\n        self.vsbase = VS_BASE % version\n        self.load_macros(version)\n\n    def set_macro(self, macro, path, key):\n        self.macros[\"$(%s)\" % macro] = Reg.get_value(path, key)\n\n    def load_macros(self, version):\n        self.set_macro(\"VCInstallDir\", self.vsbase + r\"\\Setup\\VC\", \"productdir\")\n        self.set_macro(\"VSInstallDir\", self.vsbase + r\"\\Setup\\VS\", \"productdir\")\n        self.set_macro(\"FrameworkDir\", NET_BASE, \"installroot\")\n        try:\n            if version >= 8.0:\n                self.set_macro(\"FrameworkSDKDir\", NET_BASE, \"sdkinstallrootv2.0\")\n            else:\n                raise KeyError(\"sdkinstallrootv2.0\")\n        except KeyError:\n            raise DistutilsPlatformError(\n                \"\"\"Python was built with Visual Studio 2008;\nextensions must be built with a compiler than can generate compatible binaries.\nVisual Studio 2008 was not found on this system. If you have Cygwin installed,\nyou can try compiling with MingW32, by passing \"-c mingw32\" to setup.py.\"\"\"\n            )\n\n        if version >= 9.0:\n            self.set_macro(\"FrameworkVersion\", self.vsbase, \"clr version\")\n            self.set_macro(\"WindowsSdkDir\", WINSDK_BASE, \"currentinstallfolder\")\n        else:\n            p = r\"Software\\Microsoft\\NET Framework Setup\\Product\"\n            for base in HKEYS:\n                try:\n                    h = RegOpenKeyEx(base, p)\n                except RegError:\n                    continue\n                key = RegEnumKey(h, 0)\n                d = Reg.get_value(base, rf\"{p}\\{key}\")\n                self.macros[\"$(FrameworkVersion)\"] = d[\"version\"]\n\n    def sub(self, s):\n        for k, v in self.macros.items():\n            s = s.replace(k, v)\n        return s\n\n\ndef get_build_version():\n    \"\"\"Return the version of MSVC that was used to build Python.\n\n    For Python 2.3 and up, the version number is included in\n    sys.version.  For earlier versions, assume the compiler is MSVC 6.\n    \"\"\"\n    prefix = \"MSC v.\"\n    i = sys.version.find(prefix)\n    if i == -1:\n        return 6\n    i = i + len(prefix)\n    s, rest = sys.version[i:].split(\" \", 1)\n    majorVersion = int(s[:-2]) - 6\n    if majorVersion >= 13:\n        # v13 was skipped and should be v14\n        majorVersion += 1\n    minorVersion = int(s[2:3]) / 10.0\n    # I don't think paths are affected by minor version in version 6\n    if majorVersion == 6:\n        minorVersion = 0\n    if majorVersion >= 6:\n        return majorVersion + minorVersion\n    # else we don't know what version of the compiler this is\n    return None\n\n\ndef normalize_and_reduce_paths(paths):\n    \"\"\"Return a list of normalized paths with duplicates removed.\n\n    The current order of paths is maintained.\n    \"\"\"\n    # Paths are normalized so things like:  /a and /a/ aren't both preserved.\n    reduced_paths = []\n    for p in paths:\n        np = os.path.normpath(p)\n        # XXX(nnorwitz): O(n**2), if reduced_paths gets long perhaps use a set.\n        if np not in reduced_paths:\n            reduced_paths.append(np)\n    return reduced_paths\n\n\ndef removeDuplicates(variable):\n    \"\"\"Remove duplicate values of an environment variable.\"\"\"\n    oldList = variable.split(os.pathsep)\n    newList = []\n    for i in oldList:\n        if i not in newList:\n            newList.append(i)\n    newVariable = os.pathsep.join(newList)\n    return newVariable\n\n\ndef find_vcvarsall(version):\n    \"\"\"Find the vcvarsall.bat file\n\n    At first it tries to find the productdir of VS 2008 in the registry. If\n    that fails it falls back to the VS90COMNTOOLS env var.\n    \"\"\"\n    vsbase = VS_BASE % version\n    try:\n        productdir = Reg.get_value(r\"%s\\Setup\\VC\" % vsbase, \"productdir\")\n    except KeyError:\n        log.debug(\"Unable to find productdir in registry\")\n        productdir = None\n\n    if not productdir or not os.path.isdir(productdir):\n        toolskey = \"VS%0.f0COMNTOOLS\" % version\n        toolsdir = os.environ.get(toolskey, None)\n\n        if toolsdir and os.path.isdir(toolsdir):\n            productdir = os.path.join(toolsdir, os.pardir, os.pardir, \"VC\")\n            productdir = os.path.abspath(productdir)\n            if not os.path.isdir(productdir):\n                log.debug(\"%s is not a valid directory\" % productdir)\n                return None\n        else:\n            log.debug(\"Env var %s is not set or invalid\" % toolskey)\n    if not productdir:\n        log.debug(\"No productdir found\")\n        return None\n    vcvarsall = os.path.join(productdir, \"vcvarsall.bat\")\n    if os.path.isfile(vcvarsall):\n        return vcvarsall\n    log.debug(\"Unable to find vcvarsall.bat\")\n    return None\n\n\ndef query_vcvarsall(version, arch=\"x86\"):\n    \"\"\"Launch vcvarsall.bat and read the settings from its environment\"\"\"\n    vcvarsall = find_vcvarsall(version)\n    interesting = {\"include\", \"lib\", \"libpath\", \"path\"}\n    result = {}\n\n    if vcvarsall is None:\n        raise DistutilsPlatformError(\"Unable to find vcvarsall.bat\")\n    log.debug(\"Calling 'vcvarsall.bat %s' (version=%s)\", arch, version)\n    popen = subprocess.Popen(\n        f'\"{vcvarsall}\" {arch} & set',\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n    try:\n        stdout, stderr = popen.communicate()\n        if popen.wait() != 0:\n            raise DistutilsPlatformError(stderr.decode(\"mbcs\"))\n\n        stdout = stdout.decode(\"mbcs\")\n        for line in stdout.split(\"\\n\"):\n            line = Reg.convert_mbcs(line)\n            if '=' not in line:\n                continue\n            line = line.strip()\n            key, value = line.split('=', 1)\n            key = key.lower()\n            if key in interesting:\n                if value.endswith(os.pathsep):\n                    value = value[:-1]\n                result[key] = removeDuplicates(value)\n\n    finally:\n        popen.stdout.close()\n        popen.stderr.close()\n\n    if len(result) != len(interesting):\n        raise ValueError(str(list(result.keys())))\n\n    return result\n\n\n# More globals\nVERSION = get_build_version()\n# MACROS = MacroExpander(VERSION)\n\n\nclass MSVCCompiler(CCompiler):\n    \"\"\"Concrete class that implements an interface to Microsoft Visual C++,\n    as defined by the CCompiler abstract class.\"\"\"\n\n    compiler_type = 'msvc'\n\n    # Just set this so CCompiler's constructor doesn't barf.  We currently\n    # don't use the 'set_executables()' bureaucracy provided by CCompiler,\n    # as it really isn't necessary for this sort of single-compiler class.\n    # Would be nice to have a consistent interface with UnixCCompiler,\n    # though, so it's worth thinking about.\n    executables = {}\n\n    # Private class data (need to distinguish C from C++ source for compiler)\n    _c_extensions = ['.c']\n    _cpp_extensions = ['.cc', '.cpp', '.cxx']\n    _rc_extensions = ['.rc']\n    _mc_extensions = ['.mc']\n\n    # Needed for the filename generation methods provided by the\n    # base class, CCompiler.\n    src_extensions = _c_extensions + _cpp_extensions + _rc_extensions + _mc_extensions\n    res_extension = '.res'\n    obj_extension = '.obj'\n    static_lib_extension = '.lib'\n    shared_lib_extension = '.dll'\n    static_lib_format = shared_lib_format = '%s%s'\n    exe_extension = '.exe'\n\n    def __init__(self, verbose=0, dry_run=0, force=0):\n        super().__init__(verbose, dry_run, force)\n        self.__version = VERSION\n        self.__root = r\"Software\\Microsoft\\VisualStudio\"\n        # self.__macros = MACROS\n        self.__paths = []\n        # target platform (.plat_name is consistent with 'bdist')\n        self.plat_name = None\n        self.__arch = None  # deprecated name\n        self.initialized = False\n\n    def initialize(self, plat_name=None):  # noqa: C901\n        # multi-init means we would need to check platform same each time...\n        assert not self.initialized, \"don't init multiple times\"\n        if self.__version < 8.0:\n            raise DistutilsPlatformError(\n                \"VC %0.1f is not supported by this module\" % self.__version\n            )\n        if plat_name is None:\n            plat_name = get_platform()\n        # sanity check for platforms to prevent obscure errors later.\n        ok_plats = 'win32', 'win-amd64'\n        if plat_name not in ok_plats:\n            raise DistutilsPlatformError(f\"--plat-name must be one of {ok_plats}\")\n\n        if (\n            \"DISTUTILS_USE_SDK\" in os.environ\n            and \"MSSdk\" in os.environ\n            and self.find_exe(\"cl.exe\")\n        ):\n            # Assume that the SDK set up everything alright; don't try to be\n            # smarter\n            self.cc = \"cl.exe\"\n            self.linker = \"link.exe\"\n            self.lib = \"lib.exe\"\n            self.rc = \"rc.exe\"\n            self.mc = \"mc.exe\"\n        else:\n            # On x86, 'vcvars32.bat amd64' creates an env that doesn't work;\n            # to cross compile, you use 'x86_amd64'.\n            # On AMD64, 'vcvars32.bat amd64' is a native build env; to cross\n            # compile use 'x86' (ie, it runs the x86 compiler directly)\n            if plat_name in (get_platform(), 'win32'):\n                # native build or cross-compile to win32\n                plat_spec = PLAT_TO_VCVARS[plat_name]\n            else:\n                # cross compile from win32 -> some 64bit\n                plat_spec = (\n                    PLAT_TO_VCVARS[get_platform()] + '_' + PLAT_TO_VCVARS[plat_name]\n                )\n\n            vc_env = query_vcvarsall(VERSION, plat_spec)\n\n            self.__paths = vc_env['path'].split(os.pathsep)\n            os.environ['lib'] = vc_env['lib']\n            os.environ['include'] = vc_env['include']\n\n            if len(self.__paths) == 0:\n                raise DistutilsPlatformError(\n                    \"Python was built with %s, \"\n                    \"and extensions need to be built with the same \"\n                    \"version of the compiler, but it isn't installed.\" % self.__product\n                )\n\n            self.cc = self.find_exe(\"cl.exe\")\n            self.linker = self.find_exe(\"link.exe\")\n            self.lib = self.find_exe(\"lib.exe\")\n            self.rc = self.find_exe(\"rc.exe\")  # resource compiler\n            self.mc = self.find_exe(\"mc.exe\")  # message compiler\n            # self.set_path_env_var('lib')\n            # self.set_path_env_var('include')\n\n        # extend the MSVC path with the current path\n        try:\n            for p in os.environ['path'].split(';'):\n                self.__paths.append(p)\n        except KeyError:\n            pass\n        self.__paths = normalize_and_reduce_paths(self.__paths)\n        os.environ['path'] = \";\".join(self.__paths)\n\n        self.preprocess_options = None\n        if self.__arch == \"x86\":\n            self.compile_options = ['/nologo', '/O2', '/MD', '/W3', '/DNDEBUG']\n            self.compile_options_debug = [\n                '/nologo',\n                '/Od',\n                '/MDd',\n                '/W3',\n                '/Z7',\n                '/D_DEBUG',\n            ]\n        else:\n            # Win64\n            self.compile_options = ['/nologo', '/O2', '/MD', '/W3', '/GS-', '/DNDEBUG']\n            self.compile_options_debug = [\n                '/nologo',\n                '/Od',\n                '/MDd',\n                '/W3',\n                '/GS-',\n                '/Z7',\n                '/D_DEBUG',\n            ]\n\n        self.ldflags_shared = ['/DLL', '/nologo', '/INCREMENTAL:NO']\n        if self.__version >= 7:\n            self.ldflags_shared_debug = ['/DLL', '/nologo', '/INCREMENTAL:no', '/DEBUG']\n        self.ldflags_static = ['/nologo']\n\n        self.initialized = True\n\n    # -- Worker methods ------------------------------------------------\n\n    def object_filenames(self, source_filenames, strip_dir=0, output_dir=''):\n        # Copied from ccompiler.py, extended to return .res as 'object'-file\n        # for .rc input file\n        if output_dir is None:\n            output_dir = ''\n        obj_names = []\n        for src_name in source_filenames:\n            (base, ext) = os.path.splitext(src_name)\n            base = os.path.splitdrive(base)[1]  # Chop off the drive\n            base = base[os.path.isabs(base) :]  # If abs, chop off leading /\n            if ext not in self.src_extensions:\n                # Better to raise an exception instead of silently continuing\n                # and later complain about sources and targets having\n                # different lengths\n                raise CompileError(\"Don't know how to compile %s\" % src_name)\n            if strip_dir:\n                base = os.path.basename(base)\n            if ext in self._rc_extensions:\n                obj_names.append(os.path.join(output_dir, base + self.res_extension))\n            elif ext in self._mc_extensions:\n                obj_names.append(os.path.join(output_dir, base + self.res_extension))\n            else:\n                obj_names.append(os.path.join(output_dir, base + self.obj_extension))\n        return obj_names\n\n    def compile(  # noqa: C901\n        self,\n        sources,\n        output_dir=None,\n        macros=None,\n        include_dirs=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        depends=None,\n    ):\n        if not self.initialized:\n            self.initialize()\n        compile_info = self._setup_compile(\n            output_dir, macros, include_dirs, sources, depends, extra_postargs\n        )\n        macros, objects, extra_postargs, pp_opts, build = compile_info\n\n        compile_opts = extra_preargs or []\n        compile_opts.append('/c')\n        if debug:\n            compile_opts.extend(self.compile_options_debug)\n        else:\n            compile_opts.extend(self.compile_options)\n\n        for obj in objects:\n            try:\n                src, ext = build[obj]\n            except KeyError:\n                continue\n            if debug:\n                # pass the full pathname to MSVC in debug mode,\n                # this allows the debugger to find the source file\n                # without asking the user to browse for it\n                src = os.path.abspath(src)\n\n            if ext in self._c_extensions:\n                input_opt = \"/Tc\" + src\n            elif ext in self._cpp_extensions:\n                input_opt = \"/Tp\" + src\n            elif ext in self._rc_extensions:\n                # compile .RC to .RES file\n                input_opt = src\n                output_opt = \"/fo\" + obj\n                try:\n                    self.spawn([self.rc] + pp_opts + [output_opt] + [input_opt])\n                except DistutilsExecError as msg:\n                    raise CompileError(msg)\n                continue\n            elif ext in self._mc_extensions:\n                # Compile .MC to .RC file to .RES file.\n                #   * '-h dir' specifies the directory for the\n                #     generated include file\n                #   * '-r dir' specifies the target directory of the\n                #     generated RC file and the binary message resource\n                #     it includes\n                #\n                # For now (since there are no options to change this),\n                # we use the source-directory for the include file and\n                # the build directory for the RC file and message\n                # resources. This works at least for win32all.\n                h_dir = os.path.dirname(src)\n                rc_dir = os.path.dirname(obj)\n                try:\n                    # first compile .MC to .RC and .H file\n                    self.spawn([self.mc] + ['-h', h_dir, '-r', rc_dir] + [src])\n                    base, _ = os.path.splitext(os.path.basename(src))\n                    rc_file = os.path.join(rc_dir, base + '.rc')\n                    # then compile .RC to .RES file\n                    self.spawn([self.rc] + [\"/fo\" + obj] + [rc_file])\n\n                except DistutilsExecError as msg:\n                    raise CompileError(msg)\n                continue\n            else:\n                # how to handle this file?\n                raise CompileError(f\"Don't know how to compile {src} to {obj}\")\n\n            output_opt = \"/Fo\" + obj\n            try:\n                self.spawn(\n                    [self.cc]\n                    + compile_opts\n                    + pp_opts\n                    + [input_opt, output_opt]\n                    + extra_postargs\n                )\n            except DistutilsExecError as msg:\n                raise CompileError(msg)\n\n        return objects\n\n    def create_static_lib(\n        self, objects, output_libname, output_dir=None, debug=0, target_lang=None\n    ):\n        if not self.initialized:\n            self.initialize()\n        (objects, output_dir) = self._fix_object_args(objects, output_dir)\n        output_filename = self.library_filename(output_libname, output_dir=output_dir)\n\n        if self._need_link(objects, output_filename):\n            lib_args = objects + ['/OUT:' + output_filename]\n            if debug:\n                pass  # XXX what goes here?\n            try:\n                self.spawn([self.lib] + lib_args)\n            except DistutilsExecError as msg:\n                raise LibError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    def link(  # noqa: C901\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        if not self.initialized:\n            self.initialize()\n        (objects, output_dir) = self._fix_object_args(objects, output_dir)\n        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)\n        (libraries, library_dirs, runtime_library_dirs) = fixed_args\n\n        if runtime_library_dirs:\n            self.warn(\n                \"I don't know what to do with 'runtime_library_dirs': \"\n                + str(runtime_library_dirs)\n            )\n\n        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)\n        if output_dir is not None:\n            output_filename = os.path.join(output_dir, output_filename)\n\n        if self._need_link(objects, output_filename):\n            if target_desc == CCompiler.EXECUTABLE:\n                if debug:\n                    ldflags = self.ldflags_shared_debug[1:]\n                else:\n                    ldflags = self.ldflags_shared[1:]\n            else:\n                if debug:\n                    ldflags = self.ldflags_shared_debug\n                else:\n                    ldflags = self.ldflags_shared\n\n            export_opts = []\n            for sym in export_symbols or []:\n                export_opts.append(\"/EXPORT:\" + sym)\n\n            ld_args = (\n                ldflags + lib_opts + export_opts + objects + ['/OUT:' + output_filename]\n            )\n\n            # The MSVC linker generates .lib and .exp files, which cannot be\n            # suppressed by any linker switches. The .lib files may even be\n            # needed! Make sure they are generated in the temporary build\n            # directory. Since they have different names for debug and release\n            # builds, they can go into the same directory.\n            build_temp = os.path.dirname(objects[0])\n            if export_symbols is not None:\n                (dll_name, dll_ext) = os.path.splitext(\n                    os.path.basename(output_filename)\n                )\n                implib_file = os.path.join(build_temp, self.library_filename(dll_name))\n                ld_args.append('/IMPLIB:' + implib_file)\n\n            self.manifest_setup_ldargs(output_filename, build_temp, ld_args)\n\n            if extra_preargs:\n                ld_args[:0] = extra_preargs\n            if extra_postargs:\n                ld_args.extend(extra_postargs)\n\n            self.mkpath(os.path.dirname(output_filename))\n            try:\n                self.spawn([self.linker] + ld_args)\n            except DistutilsExecError as msg:\n                raise LinkError(msg)\n\n            # embed the manifest\n            # XXX - this is somewhat fragile - if mt.exe fails, distutils\n            # will still consider the DLL up-to-date, but it will not have a\n            # manifest.  Maybe we should link to a temp file?  OTOH, that\n            # implies a build environment error that shouldn't go undetected.\n            mfinfo = self.manifest_get_embed_info(target_desc, ld_args)\n            if mfinfo is not None:\n                mffilename, mfid = mfinfo\n                out_arg = f'-outputresource:{output_filename};{mfid}'\n                try:\n                    self.spawn(['mt.exe', '-nologo', '-manifest', mffilename, out_arg])\n                except DistutilsExecError as msg:\n                    raise LinkError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    def manifest_setup_ldargs(self, output_filename, build_temp, ld_args):\n        # If we need a manifest at all, an embedded manifest is recommended.\n        # See MSDN article titled\n        # \"Understanding manifest generation for C/C++ programs\"\n        # (currently at https://learn.microsoft.com/en-us/cpp/build/understanding-manifest-generation-for-c-cpp-programs)\n        # Ask the linker to generate the manifest in the temp dir, so\n        # we can check it, and possibly embed it, later.\n        temp_manifest = os.path.join(\n            build_temp, os.path.basename(output_filename) + \".manifest\"\n        )\n        ld_args.append('/MANIFESTFILE:' + temp_manifest)\n\n    def manifest_get_embed_info(self, target_desc, ld_args):\n        # If a manifest should be embedded, return a tuple of\n        # (manifest_filename, resource_id).  Returns None if no manifest\n        # should be embedded.  See https://bugs.python.org/issue7833 for why\n        # we want to avoid any manifest for extension modules if we can)\n        for arg in ld_args:\n            if arg.startswith(\"/MANIFESTFILE:\"):\n                temp_manifest = arg.split(\":\", 1)[1]\n                break\n        else:\n            # no /MANIFESTFILE so nothing to do.\n            return None\n        if target_desc == CCompiler.EXECUTABLE:\n            # by default, executables always get the manifest with the\n            # CRT referenced.\n            mfid = 1\n        else:\n            # Extension modules try and avoid any manifest if possible.\n            mfid = 2\n            temp_manifest = self._remove_visual_c_ref(temp_manifest)\n        if temp_manifest is None:\n            return None\n        return temp_manifest, mfid\n\n    def _remove_visual_c_ref(self, manifest_file):\n        try:\n            # Remove references to the Visual C runtime, so they will\n            # fall through to the Visual C dependency of Python.exe.\n            # This way, when installed for a restricted user (e.g.\n            # runtimes are not in WinSxS folder, but in Python's own\n            # folder), the runtimes do not need to be in every folder\n            # with .pyd's.\n            # Returns either the filename of the modified manifest or\n            # None if no manifest should be embedded.\n            manifest_f = open(manifest_file)\n            try:\n                manifest_buf = manifest_f.read()\n            finally:\n                manifest_f.close()\n            pattern = re.compile(\n                r\"\"\"<assemblyIdentity.*?name=(\"|')Microsoft\\.\"\"\"\n                r\"\"\"VC\\d{2}\\.CRT(\"|').*?(/>|</assemblyIdentity>)\"\"\",\n                re.DOTALL,\n            )\n            manifest_buf = re.sub(pattern, \"\", manifest_buf)\n            pattern = r\"<dependentAssembly>\\s*</dependentAssembly>\"\n            manifest_buf = re.sub(pattern, \"\", manifest_buf)\n            # Now see if any other assemblies are referenced - if not, we\n            # don't want a manifest embedded.\n            pattern = re.compile(\n                r\"\"\"<assemblyIdentity.*?name=(?:\"|')(.+?)(?:\"|')\"\"\"\n                r\"\"\".*?(?:/>|</assemblyIdentity>)\"\"\",\n                re.DOTALL,\n            )\n            if re.search(pattern, manifest_buf) is None:\n                return None\n\n            manifest_f = open(manifest_file, 'w')\n            try:\n                manifest_f.write(manifest_buf)\n                return manifest_file\n            finally:\n                manifest_f.close()\n        except OSError:\n            pass\n\n    # -- Miscellaneous methods -----------------------------------------\n    # These are all used by the 'gen_lib_options() function, in\n    # ccompiler.py.\n\n    def library_dir_option(self, dir):\n        return \"/LIBPATH:\" + dir\n\n    def runtime_library_dir_option(self, dir):\n        raise DistutilsPlatformError(\n            \"don't know how to set runtime library search path for MSVC++\"\n        )\n\n    def library_option(self, lib):\n        return self.library_filename(lib)\n\n    def find_library_file(self, dirs, lib, debug=0):\n        # Prefer a debugging library if found (and requested), but deal\n        # with it if we don't have one.\n        if debug:\n            try_names = [lib + \"_d\", lib]\n        else:\n            try_names = [lib]\n        for dir in dirs:\n            for name in try_names:\n                libfile = os.path.join(dir, self.library_filename(name))\n                if os.path.exists(libfile):\n                    return libfile\n        else:\n            # Oops, didn't find it in *any* of 'dirs'\n            return None\n\n    # Helper methods for using the MSVC registry settings\n\n    def find_exe(self, exe):\n        \"\"\"Return path to an MSVC executable program.\n\n        Tries to find the program in several places: first, one of the\n        MSVC program search paths from the registry; next, the directories\n        in the PATH environment variable.  If any of those work, return an\n        absolute path that is known to exist.  If none of them work, just\n        return the original program name, 'exe'.\n        \"\"\"\n        for p in self.__paths:\n            fn = os.path.join(os.path.abspath(p), exe)\n            if os.path.isfile(fn):\n                return fn\n\n        # didn't find it; try existing path\n        for p in os.environ['Path'].split(';'):\n            fn = os.path.join(os.path.abspath(p), exe)\n            if os.path.isfile(fn):\n                return fn\n\n        return exe\n", "setuptools/_distutils/dist.py": "\"\"\"distutils.dist\n\nProvides the Distribution class, which represents the module distribution\nbeing built/installed/distributed.\n\"\"\"\n\nimport contextlib\nimport logging\nimport os\nimport pathlib\nimport re\nimport sys\nfrom collections.abc import Iterable\nfrom email import message_from_file\n\ntry:\n    import warnings\nexcept ImportError:\n    warnings = None\n\nfrom ._log import log\nfrom .debug import DEBUG\nfrom .errors import (\n    DistutilsArgError,\n    DistutilsClassError,\n    DistutilsModuleError,\n    DistutilsOptionError,\n)\nfrom .fancy_getopt import FancyGetopt, translate_longopt\nfrom .util import check_environ, rfc822_escape, strtobool\n\n# Regex to define acceptable Distutils command names.  This is not *quite*\n# the same as a Python NAME -- I don't allow leading underscores.  The fact\n# that they're very similar is no coincidence; the default naming scheme is\n# to look for a Python module named after the command.\ncommand_re = re.compile(r'^[a-zA-Z]([a-zA-Z0-9_]*)$')\n\n\ndef _ensure_list(value, fieldname):\n    if isinstance(value, str):\n        # a string containing comma separated values is okay.  It will\n        # be converted to a list by Distribution.finalize_options().\n        pass\n    elif not isinstance(value, list):\n        # passing a tuple or an iterator perhaps, warn and convert\n        typename = type(value).__name__\n        msg = \"Warning: '{fieldname}' should be a list, got type '{typename}'\"\n        msg = msg.format(**locals())\n        log.warning(msg)\n        value = list(value)\n    return value\n\n\nclass Distribution:\n    \"\"\"The core of the Distutils.  Most of the work hiding behind 'setup'\n    is really done within a Distribution instance, which farms the work out\n    to the Distutils commands specified on the command line.\n\n    Setup scripts will almost never instantiate Distribution directly,\n    unless the 'setup()' function is totally inadequate to their needs.\n    However, it is conceivable that a setup script might wish to subclass\n    Distribution for some specialized purpose, and then pass the subclass\n    to 'setup()' as the 'distclass' keyword argument.  If so, it is\n    necessary to respect the expectations that 'setup' has of Distribution.\n    See the code for 'setup()', in core.py, for details.\n    \"\"\"\n\n    # 'global_options' describes the command-line options that may be\n    # supplied to the setup script prior to any actual commands.\n    # Eg. \"./setup.py -n\" or \"./setup.py --quiet\" both take advantage of\n    # these global options.  This list should be kept to a bare minimum,\n    # since every global option is also valid as a command option -- and we\n    # don't want to pollute the commands with too many options that they\n    # have minimal control over.\n    # The fourth entry for verbose means that it can be repeated.\n    global_options = [\n        ('verbose', 'v', \"run verbosely (default)\", 1),\n        ('quiet', 'q', \"run quietly (turns verbosity off)\"),\n        ('dry-run', 'n', \"don't actually do anything\"),\n        ('help', 'h', \"show detailed help message\"),\n        ('no-user-cfg', None, 'ignore pydistutils.cfg in your home directory'),\n    ]\n\n    # 'common_usage' is a short (2-3 line) string describing the common\n    # usage of the setup script.\n    common_usage = \"\"\"\\\nCommon commands: (see '--help-commands' for more)\n\n  setup.py build      will build the package underneath 'build/'\n  setup.py install    will install the package\n\"\"\"\n\n    # options that are not propagated to the commands\n    display_options = [\n        ('help-commands', None, \"list all available commands\"),\n        ('name', None, \"print package name\"),\n        ('version', 'V', \"print package version\"),\n        ('fullname', None, \"print <package name>-<version>\"),\n        ('author', None, \"print the author's name\"),\n        ('author-email', None, \"print the author's email address\"),\n        ('maintainer', None, \"print the maintainer's name\"),\n        ('maintainer-email', None, \"print the maintainer's email address\"),\n        ('contact', None, \"print the maintainer's name if known, else the author's\"),\n        (\n            'contact-email',\n            None,\n            \"print the maintainer's email address if known, else the author's\",\n        ),\n        ('url', None, \"print the URL for this package\"),\n        ('license', None, \"print the license of the package\"),\n        ('licence', None, \"alias for --license\"),\n        ('description', None, \"print the package description\"),\n        ('long-description', None, \"print the long package description\"),\n        ('platforms', None, \"print the list of platforms\"),\n        ('classifiers', None, \"print the list of classifiers\"),\n        ('keywords', None, \"print the list of keywords\"),\n        ('provides', None, \"print the list of packages/modules provided\"),\n        ('requires', None, \"print the list of packages/modules required\"),\n        ('obsoletes', None, \"print the list of packages/modules made obsolete\"),\n    ]\n    display_option_names = [translate_longopt(x[0]) for x in display_options]\n\n    # negative options are options that exclude other options\n    negative_opt = {'quiet': 'verbose'}\n\n    # -- Creation/initialization methods -------------------------------\n\n    def __init__(self, attrs=None):  # noqa: C901\n        \"\"\"Construct a new Distribution instance: initialize all the\n        attributes of a Distribution, and then use 'attrs' (a dictionary\n        mapping attribute names to values) to assign some of those\n        attributes their \"real\" values.  (Any attributes not mentioned in\n        'attrs' will be assigned to some null value: 0, None, an empty list\n        or dictionary, etc.)  Most importantly, initialize the\n        'command_obj' attribute to the empty dictionary; this will be\n        filled in with real command objects by 'parse_command_line()'.\n        \"\"\"\n\n        # Default values for our command-line options\n        self.verbose = 1\n        self.dry_run = 0\n        self.help = 0\n        for attr in self.display_option_names:\n            setattr(self, attr, 0)\n\n        # Store the distribution meta-data (name, version, author, and so\n        # forth) in a separate object -- we're getting to have enough\n        # information here (and enough command-line options) that it's\n        # worth it.  Also delegate 'get_XXX()' methods to the 'metadata'\n        # object in a sneaky and underhanded (but efficient!) way.\n        self.metadata = DistributionMetadata()\n        for basename in self.metadata._METHOD_BASENAMES:\n            method_name = \"get_\" + basename\n            setattr(self, method_name, getattr(self.metadata, method_name))\n\n        # 'cmdclass' maps command names to class objects, so we\n        # can 1) quickly figure out which class to instantiate when\n        # we need to create a new command object, and 2) have a way\n        # for the setup script to override command classes\n        self.cmdclass = {}\n\n        # 'command_packages' is a list of packages in which commands\n        # are searched for.  The factory for command 'foo' is expected\n        # to be named 'foo' in the module 'foo' in one of the packages\n        # named here.  This list is searched from the left; an error\n        # is raised if no named package provides the command being\n        # searched for.  (Always access using get_command_packages().)\n        self.command_packages = None\n\n        # 'script_name' and 'script_args' are usually set to sys.argv[0]\n        # and sys.argv[1:], but they can be overridden when the caller is\n        # not necessarily a setup script run from the command-line.\n        self.script_name = None\n        self.script_args = None\n\n        # 'command_options' is where we store command options between\n        # parsing them (from config files, the command-line, etc.) and when\n        # they are actually needed -- ie. when the command in question is\n        # instantiated.  It is a dictionary of dictionaries of 2-tuples:\n        #   command_options = { command_name : { option : (source, value) } }\n        self.command_options = {}\n\n        # 'dist_files' is the list of (command, pyversion, file) that\n        # have been created by any dist commands run so far. This is\n        # filled regardless of whether the run is dry or not. pyversion\n        # gives sysconfig.get_python_version() if the dist file is\n        # specific to a Python version, 'any' if it is good for all\n        # Python versions on the target platform, and '' for a source\n        # file. pyversion should not be used to specify minimum or\n        # maximum required Python versions; use the metainfo for that\n        # instead.\n        self.dist_files = []\n\n        # These options are really the business of various commands, rather\n        # than of the Distribution itself.  We provide aliases for them in\n        # Distribution as a convenience to the developer.\n        self.packages = None\n        self.package_data = {}\n        self.package_dir = None\n        self.py_modules = None\n        self.libraries = None\n        self.headers = None\n        self.ext_modules = None\n        self.ext_package = None\n        self.include_dirs = None\n        self.extra_path = None\n        self.scripts = None\n        self.data_files = None\n        self.password = ''\n\n        # And now initialize bookkeeping stuff that can't be supplied by\n        # the caller at all.  'command_obj' maps command names to\n        # Command instances -- that's how we enforce that every command\n        # class is a singleton.\n        self.command_obj = {}\n\n        # 'have_run' maps command names to boolean values; it keeps track\n        # of whether we have actually run a particular command, to make it\n        # cheap to \"run\" a command whenever we think we might need to -- if\n        # it's already been done, no need for expensive filesystem\n        # operations, we just check the 'have_run' dictionary and carry on.\n        # It's only safe to query 'have_run' for a command class that has\n        # been instantiated -- a false value will be inserted when the\n        # command object is created, and replaced with a true value when\n        # the command is successfully run.  Thus it's probably best to use\n        # '.get()' rather than a straight lookup.\n        self.have_run = {}\n\n        # Now we'll use the attrs dictionary (ultimately, keyword args from\n        # the setup script) to possibly override any or all of these\n        # distribution options.\n\n        if attrs:\n            # Pull out the set of command options and work on them\n            # specifically.  Note that this order guarantees that aliased\n            # command options will override any supplied redundantly\n            # through the general options dictionary.\n            options = attrs.get('options')\n            if options is not None:\n                del attrs['options']\n                for command, cmd_options in options.items():\n                    opt_dict = self.get_option_dict(command)\n                    for opt, val in cmd_options.items():\n                        opt_dict[opt] = (\"setup script\", val)\n\n            if 'licence' in attrs:\n                attrs['license'] = attrs['licence']\n                del attrs['licence']\n                msg = \"'licence' distribution option is deprecated; use 'license'\"\n                if warnings is not None:\n                    warnings.warn(msg)\n                else:\n                    sys.stderr.write(msg + \"\\n\")\n\n            # Now work on the rest of the attributes.  Any attribute that's\n            # not already defined is invalid!\n            for key, val in attrs.items():\n                if hasattr(self.metadata, \"set_\" + key):\n                    getattr(self.metadata, \"set_\" + key)(val)\n                elif hasattr(self.metadata, key):\n                    setattr(self.metadata, key, val)\n                elif hasattr(self, key):\n                    setattr(self, key, val)\n                else:\n                    msg = \"Unknown distribution option: %s\" % repr(key)\n                    warnings.warn(msg)\n\n        # no-user-cfg is handled before other command line args\n        # because other args override the config files, and this\n        # one is needed before we can load the config files.\n        # If attrs['script_args'] wasn't passed, assume false.\n        #\n        # This also make sure we just look at the global options\n        self.want_user_cfg = True\n\n        if self.script_args is not None:\n            for arg in self.script_args:\n                if not arg.startswith('-'):\n                    break\n                if arg == '--no-user-cfg':\n                    self.want_user_cfg = False\n                    break\n\n        self.finalize_options()\n\n    def get_option_dict(self, command):\n        \"\"\"Get the option dictionary for a given command.  If that\n        command's option dictionary hasn't been created yet, then create it\n        and return the new dictionary; otherwise, return the existing\n        option dictionary.\n        \"\"\"\n        dict = self.command_options.get(command)\n        if dict is None:\n            dict = self.command_options[command] = {}\n        return dict\n\n    def dump_option_dicts(self, header=None, commands=None, indent=\"\"):\n        from pprint import pformat\n\n        if commands is None:  # dump all command option dicts\n            commands = sorted(self.command_options.keys())\n\n        if header is not None:\n            self.announce(indent + header)\n            indent = indent + \"  \"\n\n        if not commands:\n            self.announce(indent + \"no commands known yet\")\n            return\n\n        for cmd_name in commands:\n            opt_dict = self.command_options.get(cmd_name)\n            if opt_dict is None:\n                self.announce(indent + \"no option dict for '%s' command\" % cmd_name)\n            else:\n                self.announce(indent + \"option dict for '%s' command:\" % cmd_name)\n                out = pformat(opt_dict)\n                for line in out.split('\\n'):\n                    self.announce(indent + \"  \" + line)\n\n    # -- Config file finding/parsing methods ---------------------------\n\n    def find_config_files(self):\n        \"\"\"Find as many configuration files as should be processed for this\n        platform, and return a list of filenames in the order in which they\n        should be parsed.  The filenames returned are guaranteed to exist\n        (modulo nasty race conditions).\n\n        There are multiple possible config files:\n        - distutils.cfg in the Distutils installation directory (i.e.\n          where the top-level Distutils __inst__.py file lives)\n        - a file in the user's home directory named .pydistutils.cfg\n          on Unix and pydistutils.cfg on Windows/Mac; may be disabled\n          with the ``--no-user-cfg`` option\n        - setup.cfg in the current directory\n        - a file named by an environment variable\n        \"\"\"\n        check_environ()\n        files = [str(path) for path in self._gen_paths() if os.path.isfile(path)]\n\n        if DEBUG:\n            self.announce(\"using config files: %s\" % ', '.join(files))\n\n        return files\n\n    def _gen_paths(self):\n        # The system-wide Distutils config file\n        sys_dir = pathlib.Path(sys.modules['distutils'].__file__).parent\n        yield sys_dir / \"distutils.cfg\"\n\n        # The per-user config file\n        prefix = '.' * (os.name == 'posix')\n        filename = prefix + 'pydistutils.cfg'\n        if self.want_user_cfg:\n            yield pathlib.Path('~').expanduser() / filename\n\n        # All platforms support local setup.cfg\n        yield pathlib.Path('setup.cfg')\n\n        # Additional config indicated in the environment\n        with contextlib.suppress(TypeError):\n            yield pathlib.Path(os.getenv(\"DIST_EXTRA_CONFIG\"))\n\n    def parse_config_files(self, filenames=None):  # noqa: C901\n        from configparser import ConfigParser\n\n        # Ignore install directory options if we have a venv\n        if sys.prefix != sys.base_prefix:\n            ignore_options = [\n                'install-base',\n                'install-platbase',\n                'install-lib',\n                'install-platlib',\n                'install-purelib',\n                'install-headers',\n                'install-scripts',\n                'install-data',\n                'prefix',\n                'exec-prefix',\n                'home',\n                'user',\n                'root',\n            ]\n        else:\n            ignore_options = []\n\n        ignore_options = frozenset(ignore_options)\n\n        if filenames is None:\n            filenames = self.find_config_files()\n\n        if DEBUG:\n            self.announce(\"Distribution.parse_config_files():\")\n\n        parser = ConfigParser()\n        for filename in filenames:\n            if DEBUG:\n                self.announce(\"  reading %s\" % filename)\n            parser.read(filename, encoding='utf-8')\n            for section in parser.sections():\n                options = parser.options(section)\n                opt_dict = self.get_option_dict(section)\n\n                for opt in options:\n                    if opt != '__name__' and opt not in ignore_options:\n                        val = parser.get(section, opt)\n                        opt = opt.replace('-', '_')\n                        opt_dict[opt] = (filename, val)\n\n            # Make the ConfigParser forget everything (so we retain\n            # the original filenames that options come from)\n            parser.__init__()\n\n        # If there was a \"global\" section in the config file, use it\n        # to set Distribution options.\n\n        if 'global' in self.command_options:\n            for opt, (_src, val) in self.command_options['global'].items():\n                alias = self.negative_opt.get(opt)\n                try:\n                    if alias:\n                        setattr(self, alias, not strtobool(val))\n                    elif opt in ('verbose', 'dry_run'):  # ugh!\n                        setattr(self, opt, strtobool(val))\n                    else:\n                        setattr(self, opt, val)\n                except ValueError as msg:\n                    raise DistutilsOptionError(msg)\n\n    # -- Command-line parsing methods ----------------------------------\n\n    def parse_command_line(self):\n        \"\"\"Parse the setup script's command line, taken from the\n        'script_args' instance attribute (which defaults to 'sys.argv[1:]'\n        -- see 'setup()' in core.py).  This list is first processed for\n        \"global options\" -- options that set attributes of the Distribution\n        instance.  Then, it is alternately scanned for Distutils commands\n        and options for that command.  Each new command terminates the\n        options for the previous command.  The allowed options for a\n        command are determined by the 'user_options' attribute of the\n        command class -- thus, we have to be able to load command classes\n        in order to parse the command line.  Any error in that 'options'\n        attribute raises DistutilsGetoptError; any error on the\n        command-line raises DistutilsArgError.  If no Distutils commands\n        were found on the command line, raises DistutilsArgError.  Return\n        true if command-line was successfully parsed and we should carry\n        on with executing commands; false if no errors but we shouldn't\n        execute commands (currently, this only happens if user asks for\n        help).\n        \"\"\"\n        #\n        # We now have enough information to show the Macintosh dialog\n        # that allows the user to interactively specify the \"command line\".\n        #\n        toplevel_options = self._get_toplevel_options()\n\n        # We have to parse the command line a bit at a time -- global\n        # options, then the first command, then its options, and so on --\n        # because each command will be handled by a different class, and\n        # the options that are valid for a particular class aren't known\n        # until we have loaded the command class, which doesn't happen\n        # until we know what the command is.\n\n        self.commands = []\n        parser = FancyGetopt(toplevel_options + self.display_options)\n        parser.set_negative_aliases(self.negative_opt)\n        parser.set_aliases({'licence': 'license'})\n        args = parser.getopt(args=self.script_args, object=self)\n        option_order = parser.get_option_order()\n        logging.getLogger().setLevel(logging.WARN - 10 * self.verbose)\n\n        # for display options we return immediately\n        if self.handle_display_options(option_order):\n            return\n        while args:\n            args = self._parse_command_opts(parser, args)\n            if args is None:  # user asked for help (and got it)\n                return\n\n        # Handle the cases of --help as a \"global\" option, ie.\n        # \"setup.py --help\" and \"setup.py --help command ...\".  For the\n        # former, we show global options (--verbose, --dry-run, etc.)\n        # and display-only options (--name, --version, etc.); for the\n        # latter, we omit the display-only options and show help for\n        # each command listed on the command line.\n        if self.help:\n            self._show_help(\n                parser, display_options=len(self.commands) == 0, commands=self.commands\n            )\n            return\n\n        # Oops, no commands found -- an end-user error\n        if not self.commands:\n            raise DistutilsArgError(\"no commands supplied\")\n\n        # All is well: return true\n        return True\n\n    def _get_toplevel_options(self):\n        \"\"\"Return the non-display options recognized at the top level.\n\n        This includes options that are recognized *only* at the top\n        level as well as options recognized for commands.\n        \"\"\"\n        return self.global_options + [\n            (\n                \"command-packages=\",\n                None,\n                \"list of packages that provide distutils commands\",\n            ),\n        ]\n\n    def _parse_command_opts(self, parser, args):  # noqa: C901\n        \"\"\"Parse the command-line options for a single command.\n        'parser' must be a FancyGetopt instance; 'args' must be the list\n        of arguments, starting with the current command (whose options\n        we are about to parse).  Returns a new version of 'args' with\n        the next command at the front of the list; will be the empty\n        list if there are no more commands on the command line.  Returns\n        None if the user asked for help on this command.\n        \"\"\"\n        # late import because of mutual dependence between these modules\n        from distutils.cmd import Command\n\n        # Pull the current command from the head of the command line\n        command = args[0]\n        if not command_re.match(command):\n            raise SystemExit(\"invalid command name '%s'\" % command)\n        self.commands.append(command)\n\n        # Dig up the command class that implements this command, so we\n        # 1) know that it's a valid command, and 2) know which options\n        # it takes.\n        try:\n            cmd_class = self.get_command_class(command)\n        except DistutilsModuleError as msg:\n            raise DistutilsArgError(msg)\n\n        # Require that the command class be derived from Command -- want\n        # to be sure that the basic \"command\" interface is implemented.\n        if not issubclass(cmd_class, Command):\n            raise DistutilsClassError(\n                \"command class %s must subclass Command\" % cmd_class\n            )\n\n        # Also make sure that the command object provides a list of its\n        # known options.\n        if not (\n            hasattr(cmd_class, 'user_options')\n            and isinstance(cmd_class.user_options, list)\n        ):\n            msg = (\n                \"command class %s must provide \"\n                \"'user_options' attribute (a list of tuples)\"\n            )\n            raise DistutilsClassError(msg % cmd_class)\n\n        # If the command class has a list of negative alias options,\n        # merge it in with the global negative aliases.\n        negative_opt = self.negative_opt\n        if hasattr(cmd_class, 'negative_opt'):\n            negative_opt = negative_opt.copy()\n            negative_opt.update(cmd_class.negative_opt)\n\n        # Check for help_options in command class.  They have a different\n        # format (tuple of four) so we need to preprocess them here.\n        if hasattr(cmd_class, 'help_options') and isinstance(\n            cmd_class.help_options, list\n        ):\n            help_options = fix_help_options(cmd_class.help_options)\n        else:\n            help_options = []\n\n        # All commands support the global options too, just by adding\n        # in 'global_options'.\n        parser.set_option_table(\n            self.global_options + cmd_class.user_options + help_options\n        )\n        parser.set_negative_aliases(negative_opt)\n        (args, opts) = parser.getopt(args[1:])\n        if hasattr(opts, 'help') and opts.help:\n            self._show_help(parser, display_options=0, commands=[cmd_class])\n            return\n\n        if hasattr(cmd_class, 'help_options') and isinstance(\n            cmd_class.help_options, list\n        ):\n            help_option_found = 0\n            for help_option, _short, _desc, func in cmd_class.help_options:\n                if hasattr(opts, parser.get_attr_name(help_option)):\n                    help_option_found = 1\n                    if callable(func):\n                        func()\n                    else:\n                        raise DistutilsClassError(\n                            f\"invalid help function {func!r} for help option '{help_option}': \"\n                            \"must be a callable object (function, etc.)\"\n                        )\n\n            if help_option_found:\n                return\n\n        # Put the options from the command-line into their official\n        # holding pen, the 'command_options' dictionary.\n        opt_dict = self.get_option_dict(command)\n        for name, value in vars(opts).items():\n            opt_dict[name] = (\"command line\", value)\n\n        return args\n\n    def finalize_options(self):\n        \"\"\"Set final values for all the options on the Distribution\n        instance, analogous to the .finalize_options() method of Command\n        objects.\n        \"\"\"\n        for attr in ('keywords', 'platforms'):\n            value = getattr(self.metadata, attr)\n            if value is None:\n                continue\n            if isinstance(value, str):\n                value = [elm.strip() for elm in value.split(',')]\n                setattr(self.metadata, attr, value)\n\n    def _show_help(\n        self, parser, global_options=1, display_options=1, commands: Iterable = ()\n    ):\n        \"\"\"Show help for the setup script command-line in the form of\n        several lists of command-line options.  'parser' should be a\n        FancyGetopt instance; do not expect it to be returned in the\n        same state, as its option table will be reset to make it\n        generate the correct help text.\n\n        If 'global_options' is true, lists the global options:\n        --verbose, --dry-run, etc.  If 'display_options' is true, lists\n        the \"display-only\" options: --name, --version, etc.  Finally,\n        lists per-command help for every command name or command class\n        in 'commands'.\n        \"\"\"\n        # late import because of mutual dependence between these modules\n        from distutils.cmd import Command\n        from distutils.core import gen_usage\n\n        if global_options:\n            if display_options:\n                options = self._get_toplevel_options()\n            else:\n                options = self.global_options\n            parser.set_option_table(options)\n            parser.print_help(self.common_usage + \"\\nGlobal options:\")\n            print()\n\n        if display_options:\n            parser.set_option_table(self.display_options)\n            parser.print_help(\n                \"Information display options (just display \"\n                + \"information, ignore any commands)\"\n            )\n            print()\n\n        for command in self.commands:\n            if isinstance(command, type) and issubclass(command, Command):\n                klass = command\n            else:\n                klass = self.get_command_class(command)\n            if hasattr(klass, 'help_options') and isinstance(klass.help_options, list):\n                parser.set_option_table(\n                    klass.user_options + fix_help_options(klass.help_options)\n                )\n            else:\n                parser.set_option_table(klass.user_options)\n            parser.print_help(\"Options for '%s' command:\" % klass.__name__)\n            print()\n\n        print(gen_usage(self.script_name))\n\n    def handle_display_options(self, option_order):\n        \"\"\"If there were any non-global \"display-only\" options\n        (--help-commands or the metadata display options) on the command\n        line, display the requested info and return true; else return\n        false.\n        \"\"\"\n        from distutils.core import gen_usage\n\n        # User just wants a list of commands -- we'll print it out and stop\n        # processing now (ie. if they ran \"setup --help-commands foo bar\",\n        # we ignore \"foo bar\").\n        if self.help_commands:\n            self.print_commands()\n            print()\n            print(gen_usage(self.script_name))\n            return 1\n\n        # If user supplied any of the \"display metadata\" options, then\n        # display that metadata in the order in which the user supplied the\n        # metadata options.\n        any_display_options = 0\n        is_display_option = {}\n        for option in self.display_options:\n            is_display_option[option[0]] = 1\n\n        for opt, val in option_order:\n            if val and is_display_option.get(opt):\n                opt = translate_longopt(opt)\n                value = getattr(self.metadata, \"get_\" + opt)()\n                if opt in ('keywords', 'platforms'):\n                    print(','.join(value))\n                elif opt in ('classifiers', 'provides', 'requires', 'obsoletes'):\n                    print('\\n'.join(value))\n                else:\n                    print(value)\n                any_display_options = 1\n\n        return any_display_options\n\n    def print_command_list(self, commands, header, max_length):\n        \"\"\"Print a subset of the list of all commands -- used by\n        'print_commands()'.\n        \"\"\"\n        print(header + \":\")\n\n        for cmd in commands:\n            klass = self.cmdclass.get(cmd)\n            if not klass:\n                klass = self.get_command_class(cmd)\n            try:\n                description = klass.description\n            except AttributeError:\n                description = \"(no description available)\"\n\n            print(\"  %-*s  %s\" % (max_length, cmd, description))\n\n    def print_commands(self):\n        \"\"\"Print out a help message listing all available commands with a\n        description of each.  The list is divided into \"standard commands\"\n        (listed in distutils.command.__all__) and \"extra commands\"\n        (mentioned in self.cmdclass, but not a standard command).  The\n        descriptions come from the command class attribute\n        'description'.\n        \"\"\"\n        import distutils.command\n\n        std_commands = distutils.command.__all__\n        is_std = {}\n        for cmd in std_commands:\n            is_std[cmd] = 1\n\n        extra_commands = []\n        for cmd in self.cmdclass.keys():\n            if not is_std.get(cmd):\n                extra_commands.append(cmd)\n\n        max_length = 0\n        for cmd in std_commands + extra_commands:\n            if len(cmd) > max_length:\n                max_length = len(cmd)\n\n        self.print_command_list(std_commands, \"Standard commands\", max_length)\n        if extra_commands:\n            print()\n            self.print_command_list(extra_commands, \"Extra commands\", max_length)\n\n    def get_command_list(self):\n        \"\"\"Get a list of (command, description) tuples.\n        The list is divided into \"standard commands\" (listed in\n        distutils.command.__all__) and \"extra commands\" (mentioned in\n        self.cmdclass, but not a standard command).  The descriptions come\n        from the command class attribute 'description'.\n        \"\"\"\n        # Currently this is only used on Mac OS, for the Mac-only GUI\n        # Distutils interface (by Jack Jansen)\n        import distutils.command\n\n        std_commands = distutils.command.__all__\n        is_std = {}\n        for cmd in std_commands:\n            is_std[cmd] = 1\n\n        extra_commands = []\n        for cmd in self.cmdclass.keys():\n            if not is_std.get(cmd):\n                extra_commands.append(cmd)\n\n        rv = []\n        for cmd in std_commands + extra_commands:\n            klass = self.cmdclass.get(cmd)\n            if not klass:\n                klass = self.get_command_class(cmd)\n            try:\n                description = klass.description\n            except AttributeError:\n                description = \"(no description available)\"\n            rv.append((cmd, description))\n        return rv\n\n    # -- Command class/object methods ----------------------------------\n\n    def get_command_packages(self):\n        \"\"\"Return a list of packages from which commands are loaded.\"\"\"\n        pkgs = self.command_packages\n        if not isinstance(pkgs, list):\n            if pkgs is None:\n                pkgs = ''\n            pkgs = [pkg.strip() for pkg in pkgs.split(',') if pkg != '']\n            if \"distutils.command\" not in pkgs:\n                pkgs.insert(0, \"distutils.command\")\n            self.command_packages = pkgs\n        return pkgs\n\n    def get_command_class(self, command):\n        \"\"\"Return the class that implements the Distutils command named by\n        'command'.  First we check the 'cmdclass' dictionary; if the\n        command is mentioned there, we fetch the class object from the\n        dictionary and return it.  Otherwise we load the command module\n        (\"distutils.command.\" + command) and fetch the command class from\n        the module.  The loaded class is also stored in 'cmdclass'\n        to speed future calls to 'get_command_class()'.\n\n        Raises DistutilsModuleError if the expected module could not be\n        found, or if that module does not define the expected class.\n        \"\"\"\n        klass = self.cmdclass.get(command)\n        if klass:\n            return klass\n\n        for pkgname in self.get_command_packages():\n            module_name = f\"{pkgname}.{command}\"\n            klass_name = command\n\n            try:\n                __import__(module_name)\n                module = sys.modules[module_name]\n            except ImportError:\n                continue\n\n            try:\n                klass = getattr(module, klass_name)\n            except AttributeError:\n                raise DistutilsModuleError(\n                    f\"invalid command '{command}' (no class '{klass_name}' in module '{module_name}')\"\n                )\n\n            self.cmdclass[command] = klass\n            return klass\n\n        raise DistutilsModuleError(\"invalid command '%s'\" % command)\n\n    def get_command_obj(self, command, create=1):\n        \"\"\"Return the command object for 'command'.  Normally this object\n        is cached on a previous call to 'get_command_obj()'; if no command\n        object for 'command' is in the cache, then we either create and\n        return it (if 'create' is true) or return None.\n        \"\"\"\n        cmd_obj = self.command_obj.get(command)\n        if not cmd_obj and create:\n            if DEBUG:\n                self.announce(\n                    \"Distribution.get_command_obj(): \"\n                    \"creating '%s' command object\" % command\n                )\n\n            klass = self.get_command_class(command)\n            cmd_obj = self.command_obj[command] = klass(self)\n            self.have_run[command] = 0\n\n            # Set any options that were supplied in config files\n            # or on the command line.  (NB. support for error\n            # reporting is lame here: any errors aren't reported\n            # until 'finalize_options()' is called, which means\n            # we won't report the source of the error.)\n            options = self.command_options.get(command)\n            if options:\n                self._set_command_options(cmd_obj, options)\n\n        return cmd_obj\n\n    def _set_command_options(self, command_obj, option_dict=None):  # noqa: C901\n        \"\"\"Set the options for 'command_obj' from 'option_dict'.  Basically\n        this means copying elements of a dictionary ('option_dict') to\n        attributes of an instance ('command').\n\n        'command_obj' must be a Command instance.  If 'option_dict' is not\n        supplied, uses the standard option dictionary for this command\n        (from 'self.command_options').\n        \"\"\"\n        command_name = command_obj.get_command_name()\n        if option_dict is None:\n            option_dict = self.get_option_dict(command_name)\n\n        if DEBUG:\n            self.announce(\"  setting options for '%s' command:\" % command_name)\n        for option, (source, value) in option_dict.items():\n            if DEBUG:\n                self.announce(f\"    {option} = {value} (from {source})\")\n            try:\n                bool_opts = [translate_longopt(o) for o in command_obj.boolean_options]\n            except AttributeError:\n                bool_opts = []\n            try:\n                neg_opt = command_obj.negative_opt\n            except AttributeError:\n                neg_opt = {}\n\n            try:\n                is_string = isinstance(value, str)\n                if option in neg_opt and is_string:\n                    setattr(command_obj, neg_opt[option], not strtobool(value))\n                elif option in bool_opts and is_string:\n                    setattr(command_obj, option, strtobool(value))\n                elif hasattr(command_obj, option):\n                    setattr(command_obj, option, value)\n                else:\n                    raise DistutilsOptionError(\n                        f\"error in {source}: command '{command_name}' has no such option '{option}'\"\n                    )\n            except ValueError as msg:\n                raise DistutilsOptionError(msg)\n\n    def reinitialize_command(self, command, reinit_subcommands=0):\n        \"\"\"Reinitializes a command to the state it was in when first\n        returned by 'get_command_obj()': ie., initialized but not yet\n        finalized.  This provides the opportunity to sneak option\n        values in programmatically, overriding or supplementing\n        user-supplied values from the config files and command line.\n        You'll have to re-finalize the command object (by calling\n        'finalize_options()' or 'ensure_finalized()') before using it for\n        real.\n\n        'command' should be a command name (string) or command object.  If\n        'reinit_subcommands' is true, also reinitializes the command's\n        sub-commands, as declared by the 'sub_commands' class attribute (if\n        it has one).  See the \"install\" command for an example.  Only\n        reinitializes the sub-commands that actually matter, ie. those\n        whose test predicates return true.\n\n        Returns the reinitialized command object.\n        \"\"\"\n        from distutils.cmd import Command\n\n        if not isinstance(command, Command):\n            command_name = command\n            command = self.get_command_obj(command_name)\n        else:\n            command_name = command.get_command_name()\n\n        if not command.finalized:\n            return command\n        command.initialize_options()\n        command.finalized = 0\n        self.have_run[command_name] = 0\n        self._set_command_options(command)\n\n        if reinit_subcommands:\n            for sub in command.get_sub_commands():\n                self.reinitialize_command(sub, reinit_subcommands)\n\n        return command\n\n    # -- Methods that operate on the Distribution ----------------------\n\n    def announce(self, msg, level=logging.INFO):\n        log.log(level, msg)\n\n    def run_commands(self):\n        \"\"\"Run each command that was seen on the setup script command line.\n        Uses the list of commands found and cache of command objects\n        created by 'get_command_obj()'.\n        \"\"\"\n        for cmd in self.commands:\n            self.run_command(cmd)\n\n    # -- Methods that operate on its Commands --------------------------\n\n    def run_command(self, command):\n        \"\"\"Do whatever it takes to run a command (including nothing at all,\n        if the command has already been run).  Specifically: if we have\n        already created and run the command named by 'command', return\n        silently without doing anything.  If the command named by 'command'\n        doesn't even have a command object yet, create one.  Then invoke\n        'run()' on that command object (or an existing one).\n        \"\"\"\n        # Already been here, done that? then return silently.\n        if self.have_run.get(command):\n            return\n\n        log.info(\"running %s\", command)\n        cmd_obj = self.get_command_obj(command)\n        cmd_obj.ensure_finalized()\n        cmd_obj.run()\n        self.have_run[command] = 1\n\n    # -- Distribution query methods ------------------------------------\n\n    def has_pure_modules(self):\n        return len(self.packages or self.py_modules or []) > 0\n\n    def has_ext_modules(self):\n        return self.ext_modules and len(self.ext_modules) > 0\n\n    def has_c_libraries(self):\n        return self.libraries and len(self.libraries) > 0\n\n    def has_modules(self):\n        return self.has_pure_modules() or self.has_ext_modules()\n\n    def has_headers(self):\n        return self.headers and len(self.headers) > 0\n\n    def has_scripts(self):\n        return self.scripts and len(self.scripts) > 0\n\n    def has_data_files(self):\n        return self.data_files and len(self.data_files) > 0\n\n    def is_pure(self):\n        return (\n            self.has_pure_modules()\n            and not self.has_ext_modules()\n            and not self.has_c_libraries()\n        )\n\n    # -- Metadata query methods ----------------------------------------\n\n    # If you're looking for 'get_name()', 'get_version()', and so forth,\n    # they are defined in a sneaky way: the constructor binds self.get_XXX\n    # to self.metadata.get_XXX.  The actual code is in the\n    # DistributionMetadata class, below.\n\n\nclass DistributionMetadata:\n    \"\"\"Dummy class to hold the distribution meta-data: name, version,\n    author, and so forth.\n    \"\"\"\n\n    _METHOD_BASENAMES = (\n        \"name\",\n        \"version\",\n        \"author\",\n        \"author_email\",\n        \"maintainer\",\n        \"maintainer_email\",\n        \"url\",\n        \"license\",\n        \"description\",\n        \"long_description\",\n        \"keywords\",\n        \"platforms\",\n        \"fullname\",\n        \"contact\",\n        \"contact_email\",\n        \"classifiers\",\n        \"download_url\",\n        # PEP 314\n        \"provides\",\n        \"requires\",\n        \"obsoletes\",\n    )\n\n    def __init__(self, path=None):\n        if path is not None:\n            self.read_pkg_file(open(path))\n        else:\n            self.name = None\n            self.version = None\n            self.author = None\n            self.author_email = None\n            self.maintainer = None\n            self.maintainer_email = None\n            self.url = None\n            self.license = None\n            self.description = None\n            self.long_description = None\n            self.keywords = None\n            self.platforms = None\n            self.classifiers = None\n            self.download_url = None\n            # PEP 314\n            self.provides = None\n            self.requires = None\n            self.obsoletes = None\n\n    def read_pkg_file(self, file):\n        \"\"\"Reads the metadata values from a file object.\"\"\"\n        msg = message_from_file(file)\n\n        def _read_field(name):\n            value = msg[name]\n            if value and value != \"UNKNOWN\":\n                return value\n\n        def _read_list(name):\n            values = msg.get_all(name, None)\n            if values == []:\n                return None\n            return values\n\n        metadata_version = msg['metadata-version']\n        self.name = _read_field('name')\n        self.version = _read_field('version')\n        self.description = _read_field('summary')\n        # we are filling author only.\n        self.author = _read_field('author')\n        self.maintainer = None\n        self.author_email = _read_field('author-email')\n        self.maintainer_email = None\n        self.url = _read_field('home-page')\n        self.license = _read_field('license')\n\n        if 'download-url' in msg:\n            self.download_url = _read_field('download-url')\n        else:\n            self.download_url = None\n\n        self.long_description = _read_field('description')\n        self.description = _read_field('summary')\n\n        if 'keywords' in msg:\n            self.keywords = _read_field('keywords').split(',')\n\n        self.platforms = _read_list('platform')\n        self.classifiers = _read_list('classifier')\n\n        # PEP 314 - these fields only exist in 1.1\n        if metadata_version == '1.1':\n            self.requires = _read_list('requires')\n            self.provides = _read_list('provides')\n            self.obsoletes = _read_list('obsoletes')\n        else:\n            self.requires = None\n            self.provides = None\n            self.obsoletes = None\n\n    def write_pkg_info(self, base_dir):\n        \"\"\"Write the PKG-INFO file into the release tree.\"\"\"\n        with open(\n            os.path.join(base_dir, 'PKG-INFO'), 'w', encoding='UTF-8'\n        ) as pkg_info:\n            self.write_pkg_file(pkg_info)\n\n    def write_pkg_file(self, file):\n        \"\"\"Write the PKG-INFO format data to a file object.\"\"\"\n        version = '1.0'\n        if (\n            self.provides\n            or self.requires\n            or self.obsoletes\n            or self.classifiers\n            or self.download_url\n        ):\n            version = '1.1'\n\n        # required fields\n        file.write('Metadata-Version: %s\\n' % version)\n        file.write('Name: %s\\n' % self.get_name())\n        file.write('Version: %s\\n' % self.get_version())\n\n        def maybe_write(header, val):\n            if val:\n                file.write(f\"{header}: {val}\\n\")\n\n        # optional fields\n        maybe_write(\"Summary\", self.get_description())\n        maybe_write(\"Home-page\", self.get_url())\n        maybe_write(\"Author\", self.get_contact())\n        maybe_write(\"Author-email\", self.get_contact_email())\n        maybe_write(\"License\", self.get_license())\n        maybe_write(\"Download-URL\", self.download_url)\n        maybe_write(\"Description\", rfc822_escape(self.get_long_description() or \"\"))\n        maybe_write(\"Keywords\", \",\".join(self.get_keywords()))\n\n        self._write_list(file, 'Platform', self.get_platforms())\n        self._write_list(file, 'Classifier', self.get_classifiers())\n\n        # PEP 314\n        self._write_list(file, 'Requires', self.get_requires())\n        self._write_list(file, 'Provides', self.get_provides())\n        self._write_list(file, 'Obsoletes', self.get_obsoletes())\n\n    def _write_list(self, file, name, values):\n        values = values or []\n        for value in values:\n            file.write(f'{name}: {value}\\n')\n\n    # -- Metadata query methods ----------------------------------------\n\n    def get_name(self):\n        return self.name or \"UNKNOWN\"\n\n    def get_version(self):\n        return self.version or \"0.0.0\"\n\n    def get_fullname(self):\n        return f\"{self.get_name()}-{self.get_version()}\"\n\n    def get_author(self):\n        return self.author\n\n    def get_author_email(self):\n        return self.author_email\n\n    def get_maintainer(self):\n        return self.maintainer\n\n    def get_maintainer_email(self):\n        return self.maintainer_email\n\n    def get_contact(self):\n        return self.maintainer or self.author\n\n    def get_contact_email(self):\n        return self.maintainer_email or self.author_email\n\n    def get_url(self):\n        return self.url\n\n    def get_license(self):\n        return self.license\n\n    get_licence = get_license\n\n    def get_description(self):\n        return self.description\n\n    def get_long_description(self):\n        return self.long_description\n\n    def get_keywords(self):\n        return self.keywords or []\n\n    def set_keywords(self, value):\n        self.keywords = _ensure_list(value, 'keywords')\n\n    def get_platforms(self):\n        return self.platforms\n\n    def set_platforms(self, value):\n        self.platforms = _ensure_list(value, 'platforms')\n\n    def get_classifiers(self):\n        return self.classifiers or []\n\n    def set_classifiers(self, value):\n        self.classifiers = _ensure_list(value, 'classifiers')\n\n    def get_download_url(self):\n        return self.download_url\n\n    # PEP 314\n    def get_requires(self):\n        return self.requires or []\n\n    def set_requires(self, value):\n        import distutils.versionpredicate\n\n        for v in value:\n            distutils.versionpredicate.VersionPredicate(v)\n        self.requires = list(value)\n\n    def get_provides(self):\n        return self.provides or []\n\n    def set_provides(self, value):\n        value = [v.strip() for v in value]\n        for v in value:\n            import distutils.versionpredicate\n\n            distutils.versionpredicate.split_provision(v)\n        self.provides = value\n\n    def get_obsoletes(self):\n        return self.obsoletes or []\n\n    def set_obsoletes(self, value):\n        import distutils.versionpredicate\n\n        for v in value:\n            distutils.versionpredicate.VersionPredicate(v)\n        self.obsoletes = list(value)\n\n\ndef fix_help_options(options):\n    \"\"\"Convert a 4-tuple 'help_options' list as found in various command\n    classes to the 3-tuple form required by FancyGetopt.\n    \"\"\"\n    new_options = []\n    for help_tuple in options:\n        new_options.append(help_tuple[0:3])\n    return new_options\n", "setuptools/_distutils/extension.py": "\"\"\"distutils.extension\n\nProvides the Extension class, used to describe C/C++ extension\nmodules in setup scripts.\"\"\"\n\nimport os\nimport warnings\n\n# This class is really only used by the \"build_ext\" command, so it might\n# make sense to put it in distutils.command.build_ext.  However, that\n# module is already big enough, and I want to make this class a bit more\n# complex to simplify some common cases (\"foo\" module in \"foo.c\") and do\n# better error-checking (\"foo.c\" actually exists).\n#\n# Also, putting this in build_ext.py means every setup script would have to\n# import that large-ish module (indirectly, through distutils.core) in\n# order to do anything.\n\n\nclass Extension:\n    \"\"\"Just a collection of attributes that describes an extension\n    module and everything needed to build it (hopefully in a portable\n    way, but there are hooks that let you be as unportable as you need).\n\n    Instance attributes:\n      name : string\n        the full name of the extension, including any packages -- ie.\n        *not* a filename or pathname, but Python dotted name\n      sources : [string]\n        list of source filenames, relative to the distribution root\n        (where the setup script lives), in Unix form (slash-separated)\n        for portability.  Source files may be C, C++, SWIG (.i),\n        platform-specific resource files, or whatever else is recognized\n        by the \"build_ext\" command as source for a Python extension.\n      include_dirs : [string]\n        list of directories to search for C/C++ header files (in Unix\n        form for portability)\n      define_macros : [(name : string, value : string|None)]\n        list of macros to define; each macro is defined using a 2-tuple,\n        where 'value' is either the string to define it to or None to\n        define it without a particular value (equivalent of \"#define\n        FOO\" in source or -DFOO on Unix C compiler command line)\n      undef_macros : [string]\n        list of macros to undefine explicitly\n      library_dirs : [string]\n        list of directories to search for C/C++ libraries at link time\n      libraries : [string]\n        list of library names (not filenames or paths) to link against\n      runtime_library_dirs : [string]\n        list of directories to search for C/C++ libraries at run time\n        (for shared extensions, this is when the extension is loaded)\n      extra_objects : [string]\n        list of extra files to link with (eg. object files not implied\n        by 'sources', static library that must be explicitly specified,\n        binary resource files, etc.)\n      extra_compile_args : [string]\n        any extra platform- and compiler-specific information to use\n        when compiling the source files in 'sources'.  For platforms and\n        compilers where \"command line\" makes sense, this is typically a\n        list of command-line arguments, but for other platforms it could\n        be anything.\n      extra_link_args : [string]\n        any extra platform- and compiler-specific information to use\n        when linking object files together to create the extension (or\n        to create a new static Python interpreter).  Similar\n        interpretation as for 'extra_compile_args'.\n      export_symbols : [string]\n        list of symbols to be exported from a shared extension.  Not\n        used on all platforms, and not generally necessary for Python\n        extensions, which typically export exactly one symbol: \"init\" +\n        extension_name.\n      swig_opts : [string]\n        any extra options to pass to SWIG if a source file has the .i\n        extension.\n      depends : [string]\n        list of files that the extension depends on\n      language : string\n        extension language (i.e. \"c\", \"c++\", \"objc\"). Will be detected\n        from the source extensions if not provided.\n      optional : boolean\n        specifies that a build failure in the extension should not abort the\n        build process, but simply not install the failing extension.\n    \"\"\"\n\n    # When adding arguments to this constructor, be sure to update\n    # setup_keywords in core.py.\n    def __init__(\n        self,\n        name,\n        sources,\n        include_dirs=None,\n        define_macros=None,\n        undef_macros=None,\n        library_dirs=None,\n        libraries=None,\n        runtime_library_dirs=None,\n        extra_objects=None,\n        extra_compile_args=None,\n        extra_link_args=None,\n        export_symbols=None,\n        swig_opts=None,\n        depends=None,\n        language=None,\n        optional=None,\n        **kw,  # To catch unknown keywords\n    ):\n        if not isinstance(name, str):\n            raise AssertionError(\"'name' must be a string\")\n        if not (isinstance(sources, list) and all(isinstance(v, str) for v in sources)):\n            raise AssertionError(\"'sources' must be a list of strings\")\n\n        self.name = name\n        self.sources = sources\n        self.include_dirs = include_dirs or []\n        self.define_macros = define_macros or []\n        self.undef_macros = undef_macros or []\n        self.library_dirs = library_dirs or []\n        self.libraries = libraries or []\n        self.runtime_library_dirs = runtime_library_dirs or []\n        self.extra_objects = extra_objects or []\n        self.extra_compile_args = extra_compile_args or []\n        self.extra_link_args = extra_link_args or []\n        self.export_symbols = export_symbols or []\n        self.swig_opts = swig_opts or []\n        self.depends = depends or []\n        self.language = language\n        self.optional = optional\n\n        # If there are unknown keyword options, warn about them\n        if len(kw) > 0:\n            options = [repr(option) for option in kw]\n            options = ', '.join(sorted(options))\n            msg = \"Unknown Extension options: %s\" % options\n            warnings.warn(msg)\n\n    def __repr__(self):\n        return f'<{self.__class__.__module__}.{self.__class__.__qualname__}({self.name!r}) at {id(self):#x}>'\n\n\ndef read_setup_file(filename):  # noqa: C901\n    \"\"\"Reads a Setup file and returns Extension instances.\"\"\"\n    from distutils.sysconfig import _variable_rx, expand_makefile_vars, parse_makefile\n    from distutils.text_file import TextFile\n    from distutils.util import split_quoted\n\n    # First pass over the file to gather \"VAR = VALUE\" assignments.\n    vars = parse_makefile(filename)\n\n    # Second pass to gobble up the real content: lines of the form\n    #   <module> ... [<sourcefile> ...] [<cpparg> ...] [<library> ...]\n    file = TextFile(\n        filename,\n        strip_comments=1,\n        skip_blanks=1,\n        join_lines=1,\n        lstrip_ws=1,\n        rstrip_ws=1,\n    )\n    try:\n        extensions = []\n\n        while True:\n            line = file.readline()\n            if line is None:  # eof\n                break\n            if _variable_rx.match(line):  # VAR=VALUE, handled in first pass\n                continue\n\n            if line[0] == line[-1] == \"*\":\n                file.warn(\"'%s' lines not handled yet\" % line)\n                continue\n\n            line = expand_makefile_vars(line, vars)\n            words = split_quoted(line)\n\n            # NB. this parses a slightly different syntax than the old\n            # makesetup script: here, there must be exactly one extension per\n            # line, and it must be the first word of the line.  I have no idea\n            # why the old syntax supported multiple extensions per line, as\n            # they all wind up being the same.\n\n            module = words[0]\n            ext = Extension(module, [])\n            append_next_word = None\n\n            for word in words[1:]:\n                if append_next_word is not None:\n                    append_next_word.append(word)\n                    append_next_word = None\n                    continue\n\n                suffix = os.path.splitext(word)[1]\n                switch = word[0:2]\n                value = word[2:]\n\n                if suffix in (\".c\", \".cc\", \".cpp\", \".cxx\", \".c++\", \".m\", \".mm\"):\n                    # hmm, should we do something about C vs. C++ sources?\n                    # or leave it up to the CCompiler implementation to\n                    # worry about?\n                    ext.sources.append(word)\n                elif switch == \"-I\":\n                    ext.include_dirs.append(value)\n                elif switch == \"-D\":\n                    equals = value.find(\"=\")\n                    if equals == -1:  # bare \"-DFOO\" -- no value\n                        ext.define_macros.append((value, None))\n                    else:  # \"-DFOO=blah\"\n                        ext.define_macros.append((value[0:equals], value[equals + 2 :]))\n                elif switch == \"-U\":\n                    ext.undef_macros.append(value)\n                elif switch == \"-C\":  # only here 'cause makesetup has it!\n                    ext.extra_compile_args.append(word)\n                elif switch == \"-l\":\n                    ext.libraries.append(value)\n                elif switch == \"-L\":\n                    ext.library_dirs.append(value)\n                elif switch == \"-R\":\n                    ext.runtime_library_dirs.append(value)\n                elif word == \"-rpath\":\n                    append_next_word = ext.runtime_library_dirs\n                elif word == \"-Xlinker\":\n                    append_next_word = ext.extra_link_args\n                elif word == \"-Xcompiler\":\n                    append_next_word = ext.extra_compile_args\n                elif switch == \"-u\":\n                    ext.extra_link_args.append(word)\n                    if not value:\n                        append_next_word = ext.extra_link_args\n                elif suffix in (\".a\", \".so\", \".sl\", \".o\", \".dylib\"):\n                    # NB. a really faithful emulation of makesetup would\n                    # append a .o file to extra_objects only if it\n                    # had a slash in it; otherwise, it would s/.o/.c/\n                    # and append it to sources.  Hmmmm.\n                    ext.extra_objects.append(word)\n                else:\n                    file.warn(\"unrecognized argument '%s'\" % word)\n\n            extensions.append(ext)\n    finally:\n        file.close()\n\n    return extensions\n", "setuptools/_distutils/version.py": "#\n# distutils/version.py\n#\n# Implements multiple version numbering conventions for the\n# Python Module Distribution Utilities.\n#\n# $Id$\n#\n\n\"\"\"Provides classes to represent module version numbers (one class for\neach style of version numbering).  There are currently two such classes\nimplemented: StrictVersion and LooseVersion.\n\nEvery version number class implements the following interface:\n  * the 'parse' method takes a string and parses it to some internal\n    representation; if the string is an invalid version number,\n    'parse' raises a ValueError exception\n  * the class constructor takes an optional string argument which,\n    if supplied, is passed to 'parse'\n  * __str__ reconstructs the string that was passed to 'parse' (or\n    an equivalent string -- ie. one that will generate an equivalent\n    version number instance)\n  * __repr__ generates Python code to recreate the version number instance\n  * _cmp compares the current instance with either another instance\n    of the same class or a string (which will be parsed to an instance\n    of the same class, thus must follow the same rules)\n\"\"\"\n\nimport contextlib\nimport re\nimport warnings\n\n\n@contextlib.contextmanager\ndef suppress_known_deprecation():\n    with warnings.catch_warnings(record=True) as ctx:\n        warnings.filterwarnings(\n            action='default',\n            category=DeprecationWarning,\n            message=\"distutils Version classes are deprecated.\",\n        )\n        yield ctx\n\n\nclass Version:\n    \"\"\"Abstract base class for version numbering classes.  Just provides\n    constructor (__init__) and reproducer (__repr__), because those\n    seem to be the same for all version numbering classes; and route\n    rich comparisons to _cmp.\n    \"\"\"\n\n    def __init__(self, vstring=None):\n        if vstring:\n            self.parse(vstring)\n        warnings.warn(\n            \"distutils Version classes are deprecated. \"\n            \"Use packaging.version instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__} ('{str(self)}')\"\n\n    def __eq__(self, other):\n        c = self._cmp(other)\n        if c is NotImplemented:\n            return c\n        return c == 0\n\n    def __lt__(self, other):\n        c = self._cmp(other)\n        if c is NotImplemented:\n            return c\n        return c < 0\n\n    def __le__(self, other):\n        c = self._cmp(other)\n        if c is NotImplemented:\n            return c\n        return c <= 0\n\n    def __gt__(self, other):\n        c = self._cmp(other)\n        if c is NotImplemented:\n            return c\n        return c > 0\n\n    def __ge__(self, other):\n        c = self._cmp(other)\n        if c is NotImplemented:\n            return c\n        return c >= 0\n\n\n# Interface for version-number classes -- must be implemented\n# by the following classes (the concrete ones -- Version should\n# be treated as an abstract class).\n#    __init__ (string) - create and take same action as 'parse'\n#                        (string parameter is optional)\n#    parse (string)    - convert a string representation to whatever\n#                        internal representation is appropriate for\n#                        this style of version numbering\n#    __str__ (self)    - convert back to a string; should be very similar\n#                        (if not identical to) the string supplied to parse\n#    __repr__ (self)   - generate Python code to recreate\n#                        the instance\n#    _cmp (self, other) - compare two version numbers ('other' may\n#                        be an unparsed version string, or another\n#                        instance of your version class)\n\n\nclass StrictVersion(Version):\n    \"\"\"Version numbering for anal retentives and software idealists.\n    Implements the standard interface for version number classes as\n    described above.  A version number consists of two or three\n    dot-separated numeric components, with an optional \"pre-release\" tag\n    on the end.  The pre-release tag consists of the letter 'a' or 'b'\n    followed by a number.  If the numeric components of two version\n    numbers are equal, then one with a pre-release tag will always\n    be deemed earlier (lesser) than one without.\n\n    The following are valid version numbers (shown in the order that\n    would be obtained by sorting according to the supplied cmp function):\n\n        0.4       0.4.0  (these two are equivalent)\n        0.4.1\n        0.5a1\n        0.5b3\n        0.5\n        0.9.6\n        1.0\n        1.0.4a3\n        1.0.4b1\n        1.0.4\n\n    The following are examples of invalid version numbers:\n\n        1\n        2.7.2.2\n        1.3.a4\n        1.3pl1\n        1.3c4\n\n    The rationale for this version numbering system will be explained\n    in the distutils documentation.\n    \"\"\"\n\n    version_re = re.compile(\n        r'^(\\d+) \\. (\\d+) (\\. (\\d+))? ([ab](\\d+))?$', re.VERBOSE | re.ASCII\n    )\n\n    def parse(self, vstring):\n        match = self.version_re.match(vstring)\n        if not match:\n            raise ValueError(\"invalid version number '%s'\" % vstring)\n\n        (major, minor, patch, prerelease, prerelease_num) = match.group(1, 2, 4, 5, 6)\n\n        if patch:\n            self.version = tuple(map(int, [major, minor, patch]))\n        else:\n            self.version = tuple(map(int, [major, minor])) + (0,)\n\n        if prerelease:\n            self.prerelease = (prerelease[0], int(prerelease_num))\n        else:\n            self.prerelease = None\n\n    def __str__(self):\n        if self.version[2] == 0:\n            vstring = '.'.join(map(str, self.version[0:2]))\n        else:\n            vstring = '.'.join(map(str, self.version))\n\n        if self.prerelease:\n            vstring = vstring + self.prerelease[0] + str(self.prerelease[1])\n\n        return vstring\n\n    def _cmp(self, other):\n        if isinstance(other, str):\n            with suppress_known_deprecation():\n                other = StrictVersion(other)\n        elif not isinstance(other, StrictVersion):\n            return NotImplemented\n\n        if self.version == other.version:\n            # versions match; pre-release drives the comparison\n            return self._cmp_prerelease(other)\n\n        return -1 if self.version < other.version else 1\n\n    def _cmp_prerelease(self, other):\n        \"\"\"\n        case 1: self has prerelease, other doesn't; other is greater\n        case 2: self doesn't have prerelease, other does: self is greater\n        case 3: both or neither have prerelease: compare them!\n        \"\"\"\n        if self.prerelease and not other.prerelease:\n            return -1\n        elif not self.prerelease and other.prerelease:\n            return 1\n\n        if self.prerelease == other.prerelease:\n            return 0\n        elif self.prerelease < other.prerelease:\n            return -1\n        else:\n            return 1\n\n\n# end class StrictVersion\n\n\n# The rules according to Greg Stein:\n# 1) a version number has 1 or more numbers separated by a period or by\n#    sequences of letters. If only periods, then these are compared\n#    left-to-right to determine an ordering.\n# 2) sequences of letters are part of the tuple for comparison and are\n#    compared lexicographically\n# 3) recognize the numeric components may have leading zeroes\n#\n# The LooseVersion class below implements these rules: a version number\n# string is split up into a tuple of integer and string components, and\n# comparison is a simple tuple comparison.  This means that version\n# numbers behave in a predictable and obvious way, but a way that might\n# not necessarily be how people *want* version numbers to behave.  There\n# wouldn't be a problem if people could stick to purely numeric version\n# numbers: just split on period and compare the numbers as tuples.\n# However, people insist on putting letters into their version numbers;\n# the most common purpose seems to be:\n#   - indicating a \"pre-release\" version\n#     ('alpha', 'beta', 'a', 'b', 'pre', 'p')\n#   - indicating a post-release patch ('p', 'pl', 'patch')\n# but of course this can't cover all version number schemes, and there's\n# no way to know what a programmer means without asking him.\n#\n# The problem is what to do with letters (and other non-numeric\n# characters) in a version number.  The current implementation does the\n# obvious and predictable thing: keep them as strings and compare\n# lexically within a tuple comparison.  This has the desired effect if\n# an appended letter sequence implies something \"post-release\":\n# eg. \"0.99\" < \"0.99pl14\" < \"1.0\", and \"5.001\" < \"5.001m\" < \"5.002\".\n#\n# However, if letters in a version number imply a pre-release version,\n# the \"obvious\" thing isn't correct.  Eg. you would expect that\n# \"1.5.1\" < \"1.5.2a2\" < \"1.5.2\", but under the tuple/lexical comparison\n# implemented here, this just isn't so.\n#\n# Two possible solutions come to mind.  The first is to tie the\n# comparison algorithm to a particular set of semantic rules, as has\n# been done in the StrictVersion class above.  This works great as long\n# as everyone can go along with bondage and discipline.  Hopefully a\n# (large) subset of Python module programmers will agree that the\n# particular flavour of bondage and discipline provided by StrictVersion\n# provides enough benefit to be worth using, and will submit their\n# version numbering scheme to its domination.  The free-thinking\n# anarchists in the lot will never give in, though, and something needs\n# to be done to accommodate them.\n#\n# Perhaps a \"moderately strict\" version class could be implemented that\n# lets almost anything slide (syntactically), and makes some heuristic\n# assumptions about non-digits in version number strings.  This could\n# sink into special-case-hell, though; if I was as talented and\n# idiosyncratic as Larry Wall, I'd go ahead and implement a class that\n# somehow knows that \"1.2.1\" < \"1.2.2a2\" < \"1.2.2\" < \"1.2.2pl3\", and is\n# just as happy dealing with things like \"2g6\" and \"1.13++\".  I don't\n# think I'm smart enough to do it right though.\n#\n# In any case, I've coded the test suite for this module (see\n# ../test/test_version.py) specifically to fail on things like comparing\n# \"1.2a2\" and \"1.2\".  That's not because the *code* is doing anything\n# wrong, it's because the simple, obvious design doesn't match my\n# complicated, hairy expectations for real-world version numbers.  It\n# would be a snap to fix the test suite to say, \"Yep, LooseVersion does\n# the Right Thing\" (ie. the code matches the conception).  But I'd rather\n# have a conception that matches common notions about version numbers.\n\n\nclass LooseVersion(Version):\n    \"\"\"Version numbering for anarchists and software realists.\n    Implements the standard interface for version number classes as\n    described above.  A version number consists of a series of numbers,\n    separated by either periods or strings of letters.  When comparing\n    version numbers, the numeric components will be compared\n    numerically, and the alphabetic components lexically.  The following\n    are all valid version numbers, in no particular order:\n\n        1.5.1\n        1.5.2b2\n        161\n        3.10a\n        8.02\n        3.4j\n        1996.07.12\n        3.2.pl0\n        3.1.1.6\n        2g6\n        11g\n        0.960923\n        2.2beta29\n        1.13++\n        5.5.kw\n        2.0b1pl0\n\n    In fact, there is no such thing as an invalid version number under\n    this scheme; the rules for comparison are simple and predictable,\n    but may not always give the results you want (for some definition\n    of \"want\").\n    \"\"\"\n\n    component_re = re.compile(r'(\\d+ | [a-z]+ | \\.)', re.VERBOSE)\n\n    def parse(self, vstring):\n        # I've given up on thinking I can reconstruct the version string\n        # from the parsed tuple -- so I just store the string here for\n        # use by __str__\n        self.vstring = vstring\n        components = [x for x in self.component_re.split(vstring) if x and x != '.']\n        for i, obj in enumerate(components):\n            try:\n                components[i] = int(obj)\n            except ValueError:\n                pass\n\n        self.version = components\n\n    def __str__(self):\n        return self.vstring\n\n    def __repr__(self):\n        return \"LooseVersion ('%s')\" % str(self)\n\n    def _cmp(self, other):\n        if isinstance(other, str):\n            other = LooseVersion(other)\n        elif not isinstance(other, LooseVersion):\n            return NotImplemented\n\n        if self.version == other.version:\n            return 0\n        if self.version < other.version:\n            return -1\n        if self.version > other.version:\n            return 1\n\n\n# end class LooseVersion\n", "setuptools/_distutils/util.py": "\"\"\"distutils.util\n\nMiscellaneous utility functions -- anything that doesn't fit into\none of the other *util.py modules.\n\"\"\"\n\nimport functools\nimport importlib.util\nimport os\nimport re\nimport string\nimport subprocess\nimport sys\nimport sysconfig\n\nfrom ._log import log\nfrom ._modified import newer\nfrom .errors import DistutilsByteCompileError, DistutilsPlatformError\nfrom .spawn import spawn\n\n\ndef get_host_platform():\n    \"\"\"\n    Return a string that identifies the current platform. Use this\n    function to distinguish platform-specific build directories and\n    platform-specific built distributions.\n    \"\"\"\n\n    # This function initially exposed platforms as defined in Python 3.9\n    # even with older Python versions when distutils was split out.\n    # Now it delegates to stdlib sysconfig, but maintains compatibility.\n\n    if sys.version_info < (3, 9):\n        if os.name == \"posix\" and hasattr(os, 'uname'):\n            osname, host, release, version, machine = os.uname()\n            if osname[:3] == \"aix\":\n                from .py38compat import aix_platform\n\n                return aix_platform(osname, version, release)\n\n    return sysconfig.get_platform()\n\n\ndef get_platform():\n    if os.name == 'nt':\n        TARGET_TO_PLAT = {\n            'x86': 'win32',\n            'x64': 'win-amd64',\n            'arm': 'win-arm32',\n            'arm64': 'win-arm64',\n        }\n        target = os.environ.get('VSCMD_ARG_TGT_ARCH')\n        return TARGET_TO_PLAT.get(target) or get_host_platform()\n    return get_host_platform()\n\n\nif sys.platform == 'darwin':\n    _syscfg_macosx_ver = None  # cache the version pulled from sysconfig\nMACOSX_VERSION_VAR = 'MACOSX_DEPLOYMENT_TARGET'\n\n\ndef _clear_cached_macosx_ver():\n    \"\"\"For testing only. Do not call.\"\"\"\n    global _syscfg_macosx_ver\n    _syscfg_macosx_ver = None\n\n\ndef get_macosx_target_ver_from_syscfg():\n    \"\"\"Get the version of macOS latched in the Python interpreter configuration.\n    Returns the version as a string or None if can't obtain one. Cached.\"\"\"\n    global _syscfg_macosx_ver\n    if _syscfg_macosx_ver is None:\n        from distutils import sysconfig\n\n        ver = sysconfig.get_config_var(MACOSX_VERSION_VAR) or ''\n        if ver:\n            _syscfg_macosx_ver = ver\n    return _syscfg_macosx_ver\n\n\ndef get_macosx_target_ver():\n    \"\"\"Return the version of macOS for which we are building.\n\n    The target version defaults to the version in sysconfig latched at time\n    the Python interpreter was built, unless overridden by an environment\n    variable. If neither source has a value, then None is returned\"\"\"\n\n    syscfg_ver = get_macosx_target_ver_from_syscfg()\n    env_ver = os.environ.get(MACOSX_VERSION_VAR)\n\n    if env_ver:\n        # Validate overridden version against sysconfig version, if have both.\n        # Ensure that the deployment target of the build process is not less\n        # than 10.3 if the interpreter was built for 10.3 or later.  This\n        # ensures extension modules are built with correct compatibility\n        # values, specifically LDSHARED which can use\n        # '-undefined dynamic_lookup' which only works on >= 10.3.\n        if (\n            syscfg_ver\n            and split_version(syscfg_ver) >= [10, 3]\n            and split_version(env_ver) < [10, 3]\n        ):\n            my_msg = (\n                '$' + MACOSX_VERSION_VAR + ' mismatch: '\n                f'now \"{env_ver}\" but \"{syscfg_ver}\" during configure; '\n                'must use 10.3 or later'\n            )\n            raise DistutilsPlatformError(my_msg)\n        return env_ver\n    return syscfg_ver\n\n\ndef split_version(s):\n    \"\"\"Convert a dot-separated string into a list of numbers for comparisons\"\"\"\n    return [int(n) for n in s.split('.')]\n\n\ndef convert_path(pathname):\n    \"\"\"Return 'pathname' as a name that will work on the native filesystem,\n    i.e. split it on '/' and put it back together again using the current\n    directory separator.  Needed because filenames in the setup script are\n    always supplied in Unix style, and have to be converted to the local\n    convention before we can actually use them in the filesystem.  Raises\n    ValueError on non-Unix-ish systems if 'pathname' either starts or\n    ends with a slash.\n    \"\"\"\n    if os.sep == '/':\n        return pathname\n    if not pathname:\n        return pathname\n    if pathname[0] == '/':\n        raise ValueError(\"path '%s' cannot be absolute\" % pathname)\n    if pathname[-1] == '/':\n        raise ValueError(\"path '%s' cannot end with '/'\" % pathname)\n\n    paths = pathname.split('/')\n    while '.' in paths:\n        paths.remove('.')\n    if not paths:\n        return os.curdir\n    return os.path.join(*paths)\n\n\n# convert_path ()\n\n\ndef change_root(new_root, pathname):\n    \"\"\"Return 'pathname' with 'new_root' prepended.  If 'pathname' is\n    relative, this is equivalent to \"os.path.join(new_root,pathname)\".\n    Otherwise, it requires making 'pathname' relative and then joining the\n    two, which is tricky on DOS/Windows and Mac OS.\n    \"\"\"\n    if os.name == 'posix':\n        if not os.path.isabs(pathname):\n            return os.path.join(new_root, pathname)\n        else:\n            return os.path.join(new_root, pathname[1:])\n\n    elif os.name == 'nt':\n        (drive, path) = os.path.splitdrive(pathname)\n        if path[0] == '\\\\':\n            path = path[1:]\n        return os.path.join(new_root, path)\n\n    raise DistutilsPlatformError(f\"nothing known about platform '{os.name}'\")\n\n\n@functools.lru_cache\ndef check_environ():\n    \"\"\"Ensure that 'os.environ' has all the environment variables we\n    guarantee that users can use in config files, command-line options,\n    etc.  Currently this includes:\n      HOME - user's home directory (Unix only)\n      PLAT - description of the current platform, including hardware\n             and OS (see 'get_platform()')\n    \"\"\"\n    if os.name == 'posix' and 'HOME' not in os.environ:\n        try:\n            import pwd\n\n            os.environ['HOME'] = pwd.getpwuid(os.getuid())[5]\n        except (ImportError, KeyError):\n            # bpo-10496: if the current user identifier doesn't exist in the\n            # password database, do nothing\n            pass\n\n    if 'PLAT' not in os.environ:\n        os.environ['PLAT'] = get_platform()\n\n\ndef subst_vars(s, local_vars):\n    \"\"\"\n    Perform variable substitution on 'string'.\n    Variables are indicated by format-style braces (\"{var}\").\n    Variable is substituted by the value found in the 'local_vars'\n    dictionary or in 'os.environ' if it's not in 'local_vars'.\n    'os.environ' is first checked/augmented to guarantee that it contains\n    certain values: see 'check_environ()'.  Raise ValueError for any\n    variables not found in either 'local_vars' or 'os.environ'.\n    \"\"\"\n    check_environ()\n    lookup = dict(os.environ)\n    lookup.update((name, str(value)) for name, value in local_vars.items())\n    try:\n        return _subst_compat(s).format_map(lookup)\n    except KeyError as var:\n        raise ValueError(f\"invalid variable {var}\")\n\n\ndef _subst_compat(s):\n    \"\"\"\n    Replace shell/Perl-style variable substitution with\n    format-style. For compatibility.\n    \"\"\"\n\n    def _subst(match):\n        return f'{{{match.group(1)}}}'\n\n    repl = re.sub(r'\\$([a-zA-Z_][a-zA-Z_0-9]*)', _subst, s)\n    if repl != s:\n        import warnings\n\n        warnings.warn(\n            \"shell/Perl-style substitutions are deprecated\",\n            DeprecationWarning,\n        )\n    return repl\n\n\ndef grok_environment_error(exc, prefix=\"error: \"):\n    # Function kept for backward compatibility.\n    # Used to try clever things with EnvironmentErrors,\n    # but nowadays str(exception) produces good messages.\n    return prefix + str(exc)\n\n\n# Needed by 'split_quoted()'\n_wordchars_re = _squote_re = _dquote_re = None\n\n\ndef _init_regex():\n    global _wordchars_re, _squote_re, _dquote_re\n    _wordchars_re = re.compile(r'[^\\\\\\'\\\"%s ]*' % string.whitespace)\n    _squote_re = re.compile(r\"'(?:[^'\\\\]|\\\\.)*'\")\n    _dquote_re = re.compile(r'\"(?:[^\"\\\\]|\\\\.)*\"')\n\n\ndef split_quoted(s):\n    \"\"\"Split a string up according to Unix shell-like rules for quotes and\n    backslashes.  In short: words are delimited by spaces, as long as those\n    spaces are not escaped by a backslash, or inside a quoted string.\n    Single and double quotes are equivalent, and the quote characters can\n    be backslash-escaped.  The backslash is stripped from any two-character\n    escape sequence, leaving only the escaped character.  The quote\n    characters are stripped from any quoted string.  Returns a list of\n    words.\n    \"\"\"\n\n    # This is a nice algorithm for splitting up a single string, since it\n    # doesn't require character-by-character examination.  It was a little\n    # bit of a brain-bender to get it working right, though...\n    if _wordchars_re is None:\n        _init_regex()\n\n    s = s.strip()\n    words = []\n    pos = 0\n\n    while s:\n        m = _wordchars_re.match(s, pos)\n        end = m.end()\n        if end == len(s):\n            words.append(s[:end])\n            break\n\n        if s[end] in string.whitespace:\n            # unescaped, unquoted whitespace: now\n            # we definitely have a word delimiter\n            words.append(s[:end])\n            s = s[end:].lstrip()\n            pos = 0\n\n        elif s[end] == '\\\\':\n            # preserve whatever is being escaped;\n            # will become part of the current word\n            s = s[:end] + s[end + 1 :]\n            pos = end + 1\n\n        else:\n            if s[end] == \"'\":  # slurp singly-quoted string\n                m = _squote_re.match(s, end)\n            elif s[end] == '\"':  # slurp doubly-quoted string\n                m = _dquote_re.match(s, end)\n            else:\n                raise RuntimeError(\"this can't happen (bad char '%c')\" % s[end])\n\n            if m is None:\n                raise ValueError(\"bad string (mismatched %s quotes?)\" % s[end])\n\n            (beg, end) = m.span()\n            s = s[:beg] + s[beg + 1 : end - 1] + s[end:]\n            pos = m.end() - 2\n\n        if pos >= len(s):\n            words.append(s)\n            break\n\n    return words\n\n\n# split_quoted ()\n\n\ndef execute(func, args, msg=None, verbose=0, dry_run=0):\n    \"\"\"Perform some action that affects the outside world (eg.  by\n    writing to the filesystem).  Such actions are special because they\n    are disabled by the 'dry_run' flag.  This method takes care of all\n    that bureaucracy for you; all you have to do is supply the\n    function to call and an argument tuple for it (to embody the\n    \"external action\" being performed), and an optional message to\n    print.\n    \"\"\"\n    if msg is None:\n        msg = f\"{func.__name__}{args!r}\"\n        if msg[-2:] == ',)':  # correct for singleton tuple\n            msg = msg[0:-2] + ')'\n\n    log.info(msg)\n    if not dry_run:\n        func(*args)\n\n\ndef strtobool(val):\n    \"\"\"Convert a string representation of truth to true (1) or false (0).\n\n    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values\n    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if\n    'val' is anything else.\n    \"\"\"\n    val = val.lower()\n    if val in ('y', 'yes', 't', 'true', 'on', '1'):\n        return 1\n    elif val in ('n', 'no', 'f', 'false', 'off', '0'):\n        return 0\n    else:\n        raise ValueError(f\"invalid truth value {val!r}\")\n\n\ndef byte_compile(  # noqa: C901\n    py_files,\n    optimize=0,\n    force=0,\n    prefix=None,\n    base_dir=None,\n    verbose=1,\n    dry_run=0,\n    direct=None,\n):\n    \"\"\"Byte-compile a collection of Python source files to .pyc\n    files in a __pycache__ subdirectory.  'py_files' is a list\n    of files to compile; any files that don't end in \".py\" are silently\n    skipped.  'optimize' must be one of the following:\n      0 - don't optimize\n      1 - normal optimization (like \"python -O\")\n      2 - extra optimization (like \"python -OO\")\n    If 'force' is true, all files are recompiled regardless of\n    timestamps.\n\n    The source filename encoded in each bytecode file defaults to the\n    filenames listed in 'py_files'; you can modify these with 'prefix' and\n    'basedir'.  'prefix' is a string that will be stripped off of each\n    source filename, and 'base_dir' is a directory name that will be\n    prepended (after 'prefix' is stripped).  You can supply either or both\n    (or neither) of 'prefix' and 'base_dir', as you wish.\n\n    If 'dry_run' is true, doesn't actually do anything that would\n    affect the filesystem.\n\n    Byte-compilation is either done directly in this interpreter process\n    with the standard py_compile module, or indirectly by writing a\n    temporary script and executing it.  Normally, you should let\n    'byte_compile()' figure out to use direct compilation or not (see\n    the source for details).  The 'direct' flag is used by the script\n    generated in indirect mode; unless you know what you're doing, leave\n    it set to None.\n    \"\"\"\n\n    # nothing is done if sys.dont_write_bytecode is True\n    if sys.dont_write_bytecode:\n        raise DistutilsByteCompileError('byte-compiling is disabled.')\n\n    # First, if the caller didn't force us into direct or indirect mode,\n    # figure out which mode we should be in.  We take a conservative\n    # approach: choose direct mode *only* if the current interpreter is\n    # in debug mode and optimize is 0.  If we're not in debug mode (-O\n    # or -OO), we don't know which level of optimization this\n    # interpreter is running with, so we can't do direct\n    # byte-compilation and be certain that it's the right thing.  Thus,\n    # always compile indirectly if the current interpreter is in either\n    # optimize mode, or if either optimization level was requested by\n    # the caller.\n    if direct is None:\n        direct = __debug__ and optimize == 0\n\n    # \"Indirect\" byte-compilation: write a temporary script and then\n    # run it with the appropriate flags.\n    if not direct:\n        try:\n            from tempfile import mkstemp\n\n            (script_fd, script_name) = mkstemp(\".py\")\n        except ImportError:\n            from tempfile import mktemp\n\n            (script_fd, script_name) = None, mktemp(\".py\")\n        log.info(\"writing byte-compilation script '%s'\", script_name)\n        if not dry_run:\n            if script_fd is not None:\n                script = os.fdopen(script_fd, \"w\", encoding='utf-8')\n            else:  # pragma: no cover\n                script = open(script_name, \"w\", encoding='utf-8')\n\n            with script:\n                script.write(\n                    \"\"\"\\\nfrom distutils.util import byte_compile\nfiles = [\n\"\"\"\n                )\n\n                # XXX would be nice to write absolute filenames, just for\n                # safety's sake (script should be more robust in the face of\n                # chdir'ing before running it).  But this requires abspath'ing\n                # 'prefix' as well, and that breaks the hack in build_lib's\n                # 'byte_compile()' method that carefully tacks on a trailing\n                # slash (os.sep really) to make sure the prefix here is \"just\n                # right\".  This whole prefix business is rather delicate -- the\n                # problem is that it's really a directory, but I'm treating it\n                # as a dumb string, so trailing slashes and so forth matter.\n\n                script.write(\",\\n\".join(map(repr, py_files)) + \"]\\n\")\n                script.write(\n                    f\"\"\"\nbyte_compile(files, optimize={optimize!r}, force={force!r},\n             prefix={prefix!r}, base_dir={base_dir!r},\n             verbose={verbose!r}, dry_run=0,\n             direct=1)\n\"\"\"\n                )\n\n        cmd = [sys.executable]\n        cmd.extend(subprocess._optim_args_from_interpreter_flags())\n        cmd.append(script_name)\n        spawn(cmd, dry_run=dry_run)\n        execute(os.remove, (script_name,), \"removing %s\" % script_name, dry_run=dry_run)\n\n    # \"Direct\" byte-compilation: use the py_compile module to compile\n    # right here, right now.  Note that the script generated in indirect\n    # mode simply calls 'byte_compile()' in direct mode, a weird sort of\n    # cross-process recursion.  Hey, it works!\n    else:\n        from py_compile import compile\n\n        for file in py_files:\n            if file[-3:] != \".py\":\n                # This lets us be lazy and not filter filenames in\n                # the \"install_lib\" command.\n                continue\n\n            # Terminology from the py_compile module:\n            #   cfile - byte-compiled file\n            #   dfile - purported source filename (same as 'file' by default)\n            if optimize >= 0:\n                opt = '' if optimize == 0 else optimize\n                cfile = importlib.util.cache_from_source(file, optimization=opt)\n            else:\n                cfile = importlib.util.cache_from_source(file)\n            dfile = file\n            if prefix:\n                if file[: len(prefix)] != prefix:\n                    raise ValueError(\n                        f\"invalid prefix: filename {file!r} doesn't start with {prefix!r}\"\n                    )\n                dfile = dfile[len(prefix) :]\n            if base_dir:\n                dfile = os.path.join(base_dir, dfile)\n\n            cfile_base = os.path.basename(cfile)\n            if direct:\n                if force or newer(file, cfile):\n                    log.info(\"byte-compiling %s to %s\", file, cfile_base)\n                    if not dry_run:\n                        compile(file, cfile, dfile)\n                else:\n                    log.debug(\"skipping byte-compilation of %s to %s\", file, cfile_base)\n\n\ndef rfc822_escape(header):\n    \"\"\"Return a version of the string escaped for inclusion in an\n    RFC-822 header, by ensuring there are 8 spaces space after each newline.\n    \"\"\"\n    indent = 8 * \" \"\n    lines = header.splitlines(keepends=True)\n\n    # Emulate the behaviour of `str.split`\n    # (the terminal line break in `splitlines` does not result in an extra line):\n    ends_in_newline = lines and lines[-1].splitlines()[0] != lines[-1]\n    suffix = indent if ends_in_newline else \"\"\n\n    return indent.join(lines) + suffix\n", "setuptools/_distutils/msvccompiler.py": "\"\"\"distutils.msvccompiler\n\nContains MSVCCompiler, an implementation of the abstract CCompiler class\nfor the Microsoft Visual Studio.\n\"\"\"\n\n# Written by Perry Stoll\n# hacked by Robin Becker and Thomas Heller to do a better job of\n#   finding DevStudio (through the registry)\n\nimport os\nimport sys\nimport warnings\n\nfrom ._log import log\nfrom .ccompiler import CCompiler, gen_lib_options\nfrom .errors import (\n    CompileError,\n    DistutilsExecError,\n    DistutilsPlatformError,\n    LibError,\n    LinkError,\n)\n\n_can_read_reg = False\ntry:\n    import winreg\n\n    _can_read_reg = True\n    hkey_mod = winreg\n\n    RegOpenKeyEx = winreg.OpenKeyEx\n    RegEnumKey = winreg.EnumKey\n    RegEnumValue = winreg.EnumValue\n    RegError = winreg.error\n\nexcept ImportError:\n    try:\n        import win32api\n        import win32con\n\n        _can_read_reg = True\n        hkey_mod = win32con\n\n        RegOpenKeyEx = win32api.RegOpenKeyEx\n        RegEnumKey = win32api.RegEnumKey\n        RegEnumValue = win32api.RegEnumValue\n        RegError = win32api.error\n    except ImportError:\n        log.info(\n            \"Warning: Can't read registry to find the \"\n            \"necessary compiler setting\\n\"\n            \"Make sure that Python modules winreg, \"\n            \"win32api or win32con are installed.\"\n        )\n        pass\n\nif _can_read_reg:\n    HKEYS = (\n        hkey_mod.HKEY_USERS,\n        hkey_mod.HKEY_CURRENT_USER,\n        hkey_mod.HKEY_LOCAL_MACHINE,\n        hkey_mod.HKEY_CLASSES_ROOT,\n    )\n\n\nwarnings.warn(\n    \"msvccompiler is deprecated and slated to be removed \"\n    \"in the future. Please discontinue use or file an issue \"\n    \"with pypa/distutils describing your use case.\",\n    DeprecationWarning,\n)\n\n\ndef read_keys(base, key):\n    \"\"\"Return list of registry keys.\"\"\"\n    try:\n        handle = RegOpenKeyEx(base, key)\n    except RegError:\n        return None\n    L = []\n    i = 0\n    while True:\n        try:\n            k = RegEnumKey(handle, i)\n        except RegError:\n            break\n        L.append(k)\n        i += 1\n    return L\n\n\ndef read_values(base, key):\n    \"\"\"Return dict of registry keys and values.\n\n    All names are converted to lowercase.\n    \"\"\"\n    try:\n        handle = RegOpenKeyEx(base, key)\n    except RegError:\n        return None\n    d = {}\n    i = 0\n    while True:\n        try:\n            name, value, type = RegEnumValue(handle, i)\n        except RegError:\n            break\n        name = name.lower()\n        d[convert_mbcs(name)] = convert_mbcs(value)\n        i += 1\n    return d\n\n\ndef convert_mbcs(s):\n    dec = getattr(s, \"decode\", None)\n    if dec is not None:\n        try:\n            s = dec(\"mbcs\")\n        except UnicodeError:\n            pass\n    return s\n\n\nclass MacroExpander:\n    def __init__(self, version):\n        self.macros = {}\n        self.load_macros(version)\n\n    def set_macro(self, macro, path, key):\n        for base in HKEYS:\n            d = read_values(base, path)\n            if d:\n                self.macros[\"$(%s)\" % macro] = d[key]\n                break\n\n    def load_macros(self, version):\n        vsbase = r\"Software\\Microsoft\\VisualStudio\\%0.1f\" % version\n        self.set_macro(\"VCInstallDir\", vsbase + r\"\\Setup\\VC\", \"productdir\")\n        self.set_macro(\"VSInstallDir\", vsbase + r\"\\Setup\\VS\", \"productdir\")\n        net = r\"Software\\Microsoft\\.NETFramework\"\n        self.set_macro(\"FrameworkDir\", net, \"installroot\")\n        try:\n            if version > 7.0:\n                self.set_macro(\"FrameworkSDKDir\", net, \"sdkinstallrootv1.1\")\n            else:\n                self.set_macro(\"FrameworkSDKDir\", net, \"sdkinstallroot\")\n        except KeyError:\n            raise DistutilsPlatformError(\n                \"\"\"Python was built with Visual Studio 2003;\nextensions must be built with a compiler than can generate compatible binaries.\nVisual Studio 2003 was not found on this system. If you have Cygwin installed,\nyou can try compiling with MingW32, by passing \"-c mingw32\" to setup.py.\"\"\"\n            )\n\n        p = r\"Software\\Microsoft\\NET Framework Setup\\Product\"\n        for base in HKEYS:\n            try:\n                h = RegOpenKeyEx(base, p)\n            except RegError:\n                continue\n            key = RegEnumKey(h, 0)\n            d = read_values(base, rf\"{p}\\{key}\")\n            self.macros[\"$(FrameworkVersion)\"] = d[\"version\"]\n\n    def sub(self, s):\n        for k, v in self.macros.items():\n            s = s.replace(k, v)\n        return s\n\n\ndef get_build_version():\n    \"\"\"Return the version of MSVC that was used to build Python.\n\n    For Python 2.3 and up, the version number is included in\n    sys.version.  For earlier versions, assume the compiler is MSVC 6.\n    \"\"\"\n    prefix = \"MSC v.\"\n    i = sys.version.find(prefix)\n    if i == -1:\n        return 6\n    i = i + len(prefix)\n    s, rest = sys.version[i:].split(\" \", 1)\n    majorVersion = int(s[:-2]) - 6\n    if majorVersion >= 13:\n        # v13 was skipped and should be v14\n        majorVersion += 1\n    minorVersion = int(s[2:3]) / 10.0\n    # I don't think paths are affected by minor version in version 6\n    if majorVersion == 6:\n        minorVersion = 0\n    if majorVersion >= 6:\n        return majorVersion + minorVersion\n    # else we don't know what version of the compiler this is\n    return None\n\n\ndef get_build_architecture():\n    \"\"\"Return the processor architecture.\n\n    Possible results are \"Intel\" or \"AMD64\".\n    \"\"\"\n\n    prefix = \" bit (\"\n    i = sys.version.find(prefix)\n    if i == -1:\n        return \"Intel\"\n    j = sys.version.find(\")\", i)\n    return sys.version[i + len(prefix) : j]\n\n\ndef normalize_and_reduce_paths(paths):\n    \"\"\"Return a list of normalized paths with duplicates removed.\n\n    The current order of paths is maintained.\n    \"\"\"\n    # Paths are normalized so things like:  /a and /a/ aren't both preserved.\n    reduced_paths = []\n    for p in paths:\n        np = os.path.normpath(p)\n        # XXX(nnorwitz): O(n**2), if reduced_paths gets long perhaps use a set.\n        if np not in reduced_paths:\n            reduced_paths.append(np)\n    return reduced_paths\n\n\nclass MSVCCompiler(CCompiler):\n    \"\"\"Concrete class that implements an interface to Microsoft Visual C++,\n    as defined by the CCompiler abstract class.\"\"\"\n\n    compiler_type = 'msvc'\n\n    # Just set this so CCompiler's constructor doesn't barf.  We currently\n    # don't use the 'set_executables()' bureaucracy provided by CCompiler,\n    # as it really isn't necessary for this sort of single-compiler class.\n    # Would be nice to have a consistent interface with UnixCCompiler,\n    # though, so it's worth thinking about.\n    executables = {}\n\n    # Private class data (need to distinguish C from C++ source for compiler)\n    _c_extensions = ['.c']\n    _cpp_extensions = ['.cc', '.cpp', '.cxx']\n    _rc_extensions = ['.rc']\n    _mc_extensions = ['.mc']\n\n    # Needed for the filename generation methods provided by the\n    # base class, CCompiler.\n    src_extensions = _c_extensions + _cpp_extensions + _rc_extensions + _mc_extensions\n    res_extension = '.res'\n    obj_extension = '.obj'\n    static_lib_extension = '.lib'\n    shared_lib_extension = '.dll'\n    static_lib_format = shared_lib_format = '%s%s'\n    exe_extension = '.exe'\n\n    def __init__(self, verbose=0, dry_run=0, force=0):\n        super().__init__(verbose, dry_run, force)\n        self.__version = get_build_version()\n        self.__arch = get_build_architecture()\n        if self.__arch == \"Intel\":\n            # x86\n            if self.__version >= 7:\n                self.__root = r\"Software\\Microsoft\\VisualStudio\"\n                self.__macros = MacroExpander(self.__version)\n            else:\n                self.__root = r\"Software\\Microsoft\\Devstudio\"\n            self.__product = \"Visual Studio version %s\" % self.__version\n        else:\n            # Win64. Assume this was built with the platform SDK\n            self.__product = \"Microsoft SDK compiler %s\" % (self.__version + 6)\n\n        self.initialized = False\n\n    def initialize(self):\n        self.__paths = []\n        if (\n            \"DISTUTILS_USE_SDK\" in os.environ\n            and \"MSSdk\" in os.environ\n            and self.find_exe(\"cl.exe\")\n        ):\n            # Assume that the SDK set up everything alright; don't try to be\n            # smarter\n            self.cc = \"cl.exe\"\n            self.linker = \"link.exe\"\n            self.lib = \"lib.exe\"\n            self.rc = \"rc.exe\"\n            self.mc = \"mc.exe\"\n        else:\n            self.__paths = self.get_msvc_paths(\"path\")\n\n            if len(self.__paths) == 0:\n                raise DistutilsPlatformError(\n                    \"Python was built with %s, \"\n                    \"and extensions need to be built with the same \"\n                    \"version of the compiler, but it isn't installed.\" % self.__product\n                )\n\n            self.cc = self.find_exe(\"cl.exe\")\n            self.linker = self.find_exe(\"link.exe\")\n            self.lib = self.find_exe(\"lib.exe\")\n            self.rc = self.find_exe(\"rc.exe\")  # resource compiler\n            self.mc = self.find_exe(\"mc.exe\")  # message compiler\n            self.set_path_env_var('lib')\n            self.set_path_env_var('include')\n\n        # extend the MSVC path with the current path\n        try:\n            for p in os.environ['path'].split(';'):\n                self.__paths.append(p)\n        except KeyError:\n            pass\n        self.__paths = normalize_and_reduce_paths(self.__paths)\n        os.environ['path'] = \";\".join(self.__paths)\n\n        self.preprocess_options = None\n        if self.__arch == \"Intel\":\n            self.compile_options = ['/nologo', '/O2', '/MD', '/W3', '/GX', '/DNDEBUG']\n            self.compile_options_debug = [\n                '/nologo',\n                '/Od',\n                '/MDd',\n                '/W3',\n                '/GX',\n                '/Z7',\n                '/D_DEBUG',\n            ]\n        else:\n            # Win64\n            self.compile_options = ['/nologo', '/O2', '/MD', '/W3', '/GS-', '/DNDEBUG']\n            self.compile_options_debug = [\n                '/nologo',\n                '/Od',\n                '/MDd',\n                '/W3',\n                '/GS-',\n                '/Z7',\n                '/D_DEBUG',\n            ]\n\n        self.ldflags_shared = ['/DLL', '/nologo', '/INCREMENTAL:NO']\n        if self.__version >= 7:\n            self.ldflags_shared_debug = ['/DLL', '/nologo', '/INCREMENTAL:no', '/DEBUG']\n        else:\n            self.ldflags_shared_debug = [\n                '/DLL',\n                '/nologo',\n                '/INCREMENTAL:no',\n                '/pdb:None',\n                '/DEBUG',\n            ]\n        self.ldflags_static = ['/nologo']\n\n        self.initialized = True\n\n    # -- Worker methods ------------------------------------------------\n\n    def object_filenames(self, source_filenames, strip_dir=0, output_dir=''):\n        # Copied from ccompiler.py, extended to return .res as 'object'-file\n        # for .rc input file\n        if output_dir is None:\n            output_dir = ''\n        obj_names = []\n        for src_name in source_filenames:\n            (base, ext) = os.path.splitext(src_name)\n            base = os.path.splitdrive(base)[1]  # Chop off the drive\n            base = base[os.path.isabs(base) :]  # If abs, chop off leading /\n            if ext not in self.src_extensions:\n                # Better to raise an exception instead of silently continuing\n                # and later complain about sources and targets having\n                # different lengths\n                raise CompileError(\"Don't know how to compile %s\" % src_name)\n            if strip_dir:\n                base = os.path.basename(base)\n            if ext in self._rc_extensions:\n                obj_names.append(os.path.join(output_dir, base + self.res_extension))\n            elif ext in self._mc_extensions:\n                obj_names.append(os.path.join(output_dir, base + self.res_extension))\n            else:\n                obj_names.append(os.path.join(output_dir, base + self.obj_extension))\n        return obj_names\n\n    def compile(  # noqa: C901\n        self,\n        sources,\n        output_dir=None,\n        macros=None,\n        include_dirs=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        depends=None,\n    ):\n        if not self.initialized:\n            self.initialize()\n        compile_info = self._setup_compile(\n            output_dir, macros, include_dirs, sources, depends, extra_postargs\n        )\n        macros, objects, extra_postargs, pp_opts, build = compile_info\n\n        compile_opts = extra_preargs or []\n        compile_opts.append('/c')\n        if debug:\n            compile_opts.extend(self.compile_options_debug)\n        else:\n            compile_opts.extend(self.compile_options)\n\n        for obj in objects:\n            try:\n                src, ext = build[obj]\n            except KeyError:\n                continue\n            if debug:\n                # pass the full pathname to MSVC in debug mode,\n                # this allows the debugger to find the source file\n                # without asking the user to browse for it\n                src = os.path.abspath(src)\n\n            if ext in self._c_extensions:\n                input_opt = \"/Tc\" + src\n            elif ext in self._cpp_extensions:\n                input_opt = \"/Tp\" + src\n            elif ext in self._rc_extensions:\n                # compile .RC to .RES file\n                input_opt = src\n                output_opt = \"/fo\" + obj\n                try:\n                    self.spawn([self.rc] + pp_opts + [output_opt] + [input_opt])\n                except DistutilsExecError as msg:\n                    raise CompileError(msg)\n                continue\n            elif ext in self._mc_extensions:\n                # Compile .MC to .RC file to .RES file.\n                #   * '-h dir' specifies the directory for the\n                #     generated include file\n                #   * '-r dir' specifies the target directory of the\n                #     generated RC file and the binary message resource\n                #     it includes\n                #\n                # For now (since there are no options to change this),\n                # we use the source-directory for the include file and\n                # the build directory for the RC file and message\n                # resources. This works at least for win32all.\n                h_dir = os.path.dirname(src)\n                rc_dir = os.path.dirname(obj)\n                try:\n                    # first compile .MC to .RC and .H file\n                    self.spawn([self.mc] + ['-h', h_dir, '-r', rc_dir] + [src])\n                    base, _ = os.path.splitext(os.path.basename(src))\n                    rc_file = os.path.join(rc_dir, base + '.rc')\n                    # then compile .RC to .RES file\n                    self.spawn([self.rc] + [\"/fo\" + obj] + [rc_file])\n\n                except DistutilsExecError as msg:\n                    raise CompileError(msg)\n                continue\n            else:\n                # how to handle this file?\n                raise CompileError(f\"Don't know how to compile {src} to {obj}\")\n\n            output_opt = \"/Fo\" + obj\n            try:\n                self.spawn(\n                    [self.cc]\n                    + compile_opts\n                    + pp_opts\n                    + [input_opt, output_opt]\n                    + extra_postargs\n                )\n            except DistutilsExecError as msg:\n                raise CompileError(msg)\n\n        return objects\n\n    def create_static_lib(\n        self, objects, output_libname, output_dir=None, debug=0, target_lang=None\n    ):\n        if not self.initialized:\n            self.initialize()\n        (objects, output_dir) = self._fix_object_args(objects, output_dir)\n        output_filename = self.library_filename(output_libname, output_dir=output_dir)\n\n        if self._need_link(objects, output_filename):\n            lib_args = objects + ['/OUT:' + output_filename]\n            if debug:\n                pass  # XXX what goes here?\n            try:\n                self.spawn([self.lib] + lib_args)\n            except DistutilsExecError as msg:\n                raise LibError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    def link(  # noqa: C901\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        if not self.initialized:\n            self.initialize()\n        (objects, output_dir) = self._fix_object_args(objects, output_dir)\n        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)\n        (libraries, library_dirs, runtime_library_dirs) = fixed_args\n\n        if runtime_library_dirs:\n            self.warn(\n                \"I don't know what to do with 'runtime_library_dirs': \"\n                + str(runtime_library_dirs)\n            )\n\n        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)\n        if output_dir is not None:\n            output_filename = os.path.join(output_dir, output_filename)\n\n        if self._need_link(objects, output_filename):\n            if target_desc == CCompiler.EXECUTABLE:\n                if debug:\n                    ldflags = self.ldflags_shared_debug[1:]\n                else:\n                    ldflags = self.ldflags_shared[1:]\n            else:\n                if debug:\n                    ldflags = self.ldflags_shared_debug\n                else:\n                    ldflags = self.ldflags_shared\n\n            export_opts = []\n            for sym in export_symbols or []:\n                export_opts.append(\"/EXPORT:\" + sym)\n\n            ld_args = (\n                ldflags + lib_opts + export_opts + objects + ['/OUT:' + output_filename]\n            )\n\n            # The MSVC linker generates .lib and .exp files, which cannot be\n            # suppressed by any linker switches. The .lib files may even be\n            # needed! Make sure they are generated in the temporary build\n            # directory. Since they have different names for debug and release\n            # builds, they can go into the same directory.\n            if export_symbols is not None:\n                (dll_name, dll_ext) = os.path.splitext(\n                    os.path.basename(output_filename)\n                )\n                implib_file = os.path.join(\n                    os.path.dirname(objects[0]), self.library_filename(dll_name)\n                )\n                ld_args.append('/IMPLIB:' + implib_file)\n\n            if extra_preargs:\n                ld_args[:0] = extra_preargs\n            if extra_postargs:\n                ld_args.extend(extra_postargs)\n\n            self.mkpath(os.path.dirname(output_filename))\n            try:\n                self.spawn([self.linker] + ld_args)\n            except DistutilsExecError as msg:\n                raise LinkError(msg)\n\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    # -- Miscellaneous methods -----------------------------------------\n    # These are all used by the 'gen_lib_options() function, in\n    # ccompiler.py.\n\n    def library_dir_option(self, dir):\n        return \"/LIBPATH:\" + dir\n\n    def runtime_library_dir_option(self, dir):\n        raise DistutilsPlatformError(\n            \"don't know how to set runtime library search path for MSVC++\"\n        )\n\n    def library_option(self, lib):\n        return self.library_filename(lib)\n\n    def find_library_file(self, dirs, lib, debug=0):\n        # Prefer a debugging library if found (and requested), but deal\n        # with it if we don't have one.\n        if debug:\n            try_names = [lib + \"_d\", lib]\n        else:\n            try_names = [lib]\n        for dir in dirs:\n            for name in try_names:\n                libfile = os.path.join(dir, self.library_filename(name))\n                if os.path.exists(libfile):\n                    return libfile\n        else:\n            # Oops, didn't find it in *any* of 'dirs'\n            return None\n\n    # Helper methods for using the MSVC registry settings\n\n    def find_exe(self, exe):\n        \"\"\"Return path to an MSVC executable program.\n\n        Tries to find the program in several places: first, one of the\n        MSVC program search paths from the registry; next, the directories\n        in the PATH environment variable.  If any of those work, return an\n        absolute path that is known to exist.  If none of them work, just\n        return the original program name, 'exe'.\n        \"\"\"\n        for p in self.__paths:\n            fn = os.path.join(os.path.abspath(p), exe)\n            if os.path.isfile(fn):\n                return fn\n\n        # didn't find it; try existing path\n        for p in os.environ['Path'].split(';'):\n            fn = os.path.join(os.path.abspath(p), exe)\n            if os.path.isfile(fn):\n                return fn\n\n        return exe\n\n    def get_msvc_paths(self, path, platform='x86'):\n        \"\"\"Get a list of devstudio directories (include, lib or path).\n\n        Return a list of strings.  The list will be empty if unable to\n        access the registry or appropriate registry keys not found.\n        \"\"\"\n        if not _can_read_reg:\n            return []\n\n        path = path + \" dirs\"\n        if self.__version >= 7:\n            key = rf\"{self.__root}\\{self.__version:0.1f}\\VC\\VC_OBJECTS_PLATFORM_INFO\\Win32\\Directories\"\n        else:\n            key = (\n                rf\"{self.__root}\\6.0\\Build System\\Components\\Platforms\"\n                rf\"\\Win32 ({platform})\\Directories\"\n            )\n\n        for base in HKEYS:\n            d = read_values(base, key)\n            if d:\n                if self.__version >= 7:\n                    return self.__macros.sub(d[path]).split(\";\")\n                else:\n                    return d[path].split(\";\")\n        # MSVC 6 seems to create the registry entries we need only when\n        # the GUI is run.\n        if self.__version == 6:\n            for base in HKEYS:\n                if read_values(base, r\"%s\\6.0\" % self.__root) is not None:\n                    self.warn(\n                        \"It seems you have Visual Studio 6 installed, \"\n                        \"but the expected registry settings are not present.\\n\"\n                        \"You must at least run the Visual Studio GUI once \"\n                        \"so that these entries are created.\"\n                    )\n                    break\n        return []\n\n    def set_path_env_var(self, name):\n        \"\"\"Set environment variable 'name' to an MSVC path type value.\n\n        This is equivalent to a SET command prior to execution of spawned\n        commands.\n        \"\"\"\n\n        if name == \"lib\":\n            p = self.get_msvc_paths(\"library\")\n        else:\n            p = self.get_msvc_paths(name)\n        if p:\n            os.environ[name] = ';'.join(p)\n\n\nif get_build_version() >= 8.0:\n    log.debug(\"Importing new compiler from distutils.msvc9compiler\")\n    OldMSVCCompiler = MSVCCompiler\n    # get_build_architecture not really relevant now we support cross-compile\n    from distutils.msvc9compiler import (\n        MacroExpander,  # noqa: F811\n        MSVCCompiler,\n    )\n", "setuptools/_distutils/unixccompiler.py": "\"\"\"distutils.unixccompiler\n\nContains the UnixCCompiler class, a subclass of CCompiler that handles\nthe \"typical\" Unix-style command-line C compiler:\n  * macros defined with -Dname[=value]\n  * macros undefined with -Uname\n  * include search directories specified with -Idir\n  * libraries specified with -lllib\n  * library search directories specified with -Ldir\n  * compile handled by 'cc' (or similar) executable with -c option:\n    compiles .c to .o\n  * link static library handled by 'ar' command (possibly with 'ranlib')\n  * link shared library handled by 'cc -shared'\n\"\"\"\n\nfrom __future__ import annotations\n\nimport itertools\nimport os\nimport re\nimport shlex\nimport sys\n\nfrom . import sysconfig\nfrom .compat import consolidate_linker_args\nfrom ._log import log\nfrom ._macos_compat import compiler_fixup\nfrom ._modified import newer\nfrom .ccompiler import CCompiler, gen_lib_options, gen_preprocess_options\nfrom .errors import CompileError, DistutilsExecError, LibError, LinkError\n\n# XXX Things not currently handled:\n#   * optimization/debug/warning flags; we just use whatever's in Python's\n#     Makefile and live with it.  Is this adequate?  If not, we might\n#     have to have a bunch of subclasses GNUCCompiler, SGICCompiler,\n#     SunCCompiler, and I suspect down that road lies madness.\n#   * even if we don't know a warning flag from an optimization flag,\n#     we need some way for outsiders to feed preprocessor/compiler/linker\n#     flags in to us -- eg. a sysadmin might want to mandate certain flags\n#     via a site config file, or a user might want to set something for\n#     compiling this module distribution only via the setup.py command\n#     line, whatever.  As long as these options come from something on the\n#     current system, they can be as system-dependent as they like, and we\n#     should just happily stuff them into the preprocessor/compiler/linker\n#     options and carry on.\n\n\ndef _split_env(cmd):\n    \"\"\"\n    For macOS, split command into 'env' portion (if any)\n    and the rest of the linker command.\n\n    >>> _split_env(['a', 'b', 'c'])\n    ([], ['a', 'b', 'c'])\n    >>> _split_env(['/usr/bin/env', 'A=3', 'gcc'])\n    (['/usr/bin/env', 'A=3'], ['gcc'])\n    \"\"\"\n    pivot = 0\n    if os.path.basename(cmd[0]) == \"env\":\n        pivot = 1\n        while '=' in cmd[pivot]:\n            pivot += 1\n    return cmd[:pivot], cmd[pivot:]\n\n\ndef _split_aix(cmd):\n    \"\"\"\n    AIX platforms prefix the compiler with the ld_so_aix\n    script, so split that from the linker command.\n\n    >>> _split_aix(['a', 'b', 'c'])\n    ([], ['a', 'b', 'c'])\n    >>> _split_aix(['/bin/foo/ld_so_aix', 'gcc'])\n    (['/bin/foo/ld_so_aix'], ['gcc'])\n    \"\"\"\n    pivot = os.path.basename(cmd[0]) == 'ld_so_aix'\n    return cmd[:pivot], cmd[pivot:]\n\n\ndef _linker_params(linker_cmd, compiler_cmd):\n    \"\"\"\n    The linker command usually begins with the compiler\n    command (possibly multiple elements), followed by zero or more\n    params for shared library building.\n\n    If the LDSHARED env variable overrides the linker command,\n    however, the commands may not match.\n\n    Return the best guess of the linker parameters by stripping\n    the linker command. If the compiler command does not\n    match the linker command, assume the linker command is\n    just the first element.\n\n    >>> _linker_params('gcc foo bar'.split(), ['gcc'])\n    ['foo', 'bar']\n    >>> _linker_params('gcc foo bar'.split(), ['other'])\n    ['foo', 'bar']\n    >>> _linker_params('ccache gcc foo bar'.split(), 'ccache gcc'.split())\n    ['foo', 'bar']\n    >>> _linker_params(['gcc'], ['gcc'])\n    []\n    \"\"\"\n    c_len = len(compiler_cmd)\n    pivot = c_len if linker_cmd[:c_len] == compiler_cmd else 1\n    return linker_cmd[pivot:]\n\n\nclass UnixCCompiler(CCompiler):\n    compiler_type = 'unix'\n\n    # These are used by CCompiler in two places: the constructor sets\n    # instance attributes 'preprocessor', 'compiler', etc. from them, and\n    # 'set_executable()' allows any of these to be set.  The defaults here\n    # are pretty generic; they will probably have to be set by an outsider\n    # (eg. using information discovered by the sysconfig about building\n    # Python extensions).\n    executables = {\n        'preprocessor': None,\n        'compiler': [\"cc\"],\n        'compiler_so': [\"cc\"],\n        'compiler_cxx': [\"cc\"],\n        'linker_so': [\"cc\", \"-shared\"],\n        'linker_exe': [\"cc\"],\n        'archiver': [\"ar\", \"-cr\"],\n        'ranlib': None,\n    }\n\n    if sys.platform[:6] == \"darwin\":\n        executables['ranlib'] = [\"ranlib\"]\n\n    # Needed for the filename generation methods provided by the base\n    # class, CCompiler.  NB. whoever instantiates/uses a particular\n    # UnixCCompiler instance should set 'shared_lib_ext' -- we set a\n    # reasonable common default here, but it's not necessarily used on all\n    # Unices!\n\n    src_extensions = [\".c\", \".C\", \".cc\", \".cxx\", \".cpp\", \".m\"]\n    obj_extension = \".o\"\n    static_lib_extension = \".a\"\n    shared_lib_extension = \".so\"\n    dylib_lib_extension = \".dylib\"\n    xcode_stub_lib_extension = \".tbd\"\n    static_lib_format = shared_lib_format = dylib_lib_format = \"lib%s%s\"\n    xcode_stub_lib_format = dylib_lib_format\n    if sys.platform == \"cygwin\":\n        exe_extension = \".exe\"\n\n    def preprocess(\n        self,\n        source,\n        output_file=None,\n        macros=None,\n        include_dirs=None,\n        extra_preargs=None,\n        extra_postargs=None,\n    ):\n        fixed_args = self._fix_compile_args(None, macros, include_dirs)\n        ignore, macros, include_dirs = fixed_args\n        pp_opts = gen_preprocess_options(macros, include_dirs)\n        pp_args = self.preprocessor + pp_opts\n        if output_file:\n            pp_args.extend(['-o', output_file])\n        if extra_preargs:\n            pp_args[:0] = extra_preargs\n        if extra_postargs:\n            pp_args.extend(extra_postargs)\n        pp_args.append(source)\n\n        # reasons to preprocess:\n        # - force is indicated\n        # - output is directed to stdout\n        # - source file is newer than the target\n        preprocess = self.force or output_file is None or newer(source, output_file)\n        if not preprocess:\n            return\n\n        if output_file:\n            self.mkpath(os.path.dirname(output_file))\n\n        try:\n            self.spawn(pp_args)\n        except DistutilsExecError as msg:\n            raise CompileError(msg)\n\n    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        compiler_so = compiler_fixup(self.compiler_so, cc_args + extra_postargs)\n        try:\n            self.spawn(compiler_so + cc_args + [src, '-o', obj] + extra_postargs)\n        except DistutilsExecError as msg:\n            raise CompileError(msg)\n\n    def create_static_lib(\n        self, objects, output_libname, output_dir=None, debug=0, target_lang=None\n    ):\n        objects, output_dir = self._fix_object_args(objects, output_dir)\n\n        output_filename = self.library_filename(output_libname, output_dir=output_dir)\n\n        if self._need_link(objects, output_filename):\n            self.mkpath(os.path.dirname(output_filename))\n            self.spawn(self.archiver + [output_filename] + objects + self.objects)\n\n            # Not many Unices required ranlib anymore -- SunOS 4.x is, I\n            # think the only major Unix that does.  Maybe we need some\n            # platform intelligence here to skip ranlib if it's not\n            # needed -- or maybe Python's configure script took care of\n            # it for us, hence the check for leading colon.\n            if self.ranlib:\n                try:\n                    self.spawn(self.ranlib + [output_filename])\n                except DistutilsExecError as msg:\n                    raise LibError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    def link(\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        objects, output_dir = self._fix_object_args(objects, output_dir)\n        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)\n        libraries, library_dirs, runtime_library_dirs = fixed_args\n\n        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)\n        if not isinstance(output_dir, (str, type(None))):\n            raise TypeError(\"'output_dir' must be a string or None\")\n        if output_dir is not None:\n            output_filename = os.path.join(output_dir, output_filename)\n\n        if self._need_link(objects, output_filename):\n            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]\n            if debug:\n                ld_args[:0] = ['-g']\n            if extra_preargs:\n                ld_args[:0] = extra_preargs\n            if extra_postargs:\n                ld_args.extend(extra_postargs)\n            self.mkpath(os.path.dirname(output_filename))\n            try:\n                # Select a linker based on context: linker_exe when\n                # building an executable or linker_so (with shared options)\n                # when building a shared library.\n                building_exe = target_desc == CCompiler.EXECUTABLE\n                linker = (self.linker_exe if building_exe else self.linker_so)[:]\n\n                if target_lang == \"c++\" and self.compiler_cxx:\n                    env, linker_ne = _split_env(linker)\n                    aix, linker_na = _split_aix(linker_ne)\n                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)\n                    _, linker_exe_ne = _split_env(self.linker_exe)\n\n                    params = _linker_params(linker_na, linker_exe_ne)\n                    linker = env + aix + compiler_cxx_ne + params\n\n                linker = compiler_fixup(linker, ld_args)\n\n                self.spawn(linker + ld_args)\n            except DistutilsExecError as msg:\n                raise LinkError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    # -- Miscellaneous methods -----------------------------------------\n    # These are all used by the 'gen_lib_options() function, in\n    # ccompiler.py.\n\n    def library_dir_option(self, dir):\n        return \"-L\" + dir\n\n    def _is_gcc(self):\n        cc_var = sysconfig.get_config_var(\"CC\")\n        compiler = os.path.basename(shlex.split(cc_var)[0])\n        return \"gcc\" in compiler or \"g++\" in compiler\n\n    def runtime_library_dir_option(self, dir: str) -> str | list[str]:\n        # XXX Hackish, at the very least.  See Python bug #445902:\n        # https://bugs.python.org/issue445902\n        # Linkers on different platforms need different options to\n        # specify that directories need to be added to the list of\n        # directories searched for dependencies when a dynamic library\n        # is sought.  GCC on GNU systems (Linux, FreeBSD, ...) has to\n        # be told to pass the -R option through to the linker, whereas\n        # other compilers and gcc on other systems just know this.\n        # Other compilers may need something slightly different.  At\n        # this time, there's no way to determine this information from\n        # the configuration data stored in the Python installation, so\n        # we use this hack.\n        if sys.platform[:6] == \"darwin\":\n            from distutils.util import get_macosx_target_ver, split_version\n\n            macosx_target_ver = get_macosx_target_ver()\n            if macosx_target_ver and split_version(macosx_target_ver) >= [10, 5]:\n                return \"-Wl,-rpath,\" + dir\n            else:  # no support for -rpath on earlier macOS versions\n                return \"-L\" + dir\n        elif sys.platform[:7] == \"freebsd\":\n            return \"-Wl,-rpath=\" + dir\n        elif sys.platform[:5] == \"hp-ux\":\n            return [\n                \"-Wl,+s\" if self._is_gcc() else \"+s\",\n                \"-L\" + dir,\n            ]\n\n        # For all compilers, `-Wl` is the presumed way to pass a\n        # compiler option to the linker\n        if sysconfig.get_config_var(\"GNULD\") == \"yes\":\n            return consolidate_linker_args([\n                # Force RUNPATH instead of RPATH\n                \"-Wl,--enable-new-dtags\",\n                \"-Wl,-rpath,\" + dir,\n            ])\n        else:\n            return \"-Wl,-R\" + dir\n\n    def library_option(self, lib):\n        return \"-l\" + lib\n\n    @staticmethod\n    def _library_root(dir):\n        \"\"\"\n        macOS users can specify an alternate SDK using'-isysroot'.\n        Calculate the SDK root if it is specified.\n\n        Note that, as of Xcode 7, Apple SDKs may contain textual stub\n        libraries with .tbd extensions rather than the normal .dylib\n        shared libraries installed in /.  The Apple compiler tool\n        chain handles this transparently but it can cause problems\n        for programs that are being built with an SDK and searching\n        for specific libraries.  Callers of find_library_file need to\n        keep in mind that the base filename of the returned SDK library\n        file might have a different extension from that of the library\n        file installed on the running system, for example:\n          /Applications/Xcode.app/Contents/Developer/Platforms/\n              MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/\n              usr/lib/libedit.tbd\n        vs\n          /usr/lib/libedit.dylib\n        \"\"\"\n        cflags = sysconfig.get_config_var('CFLAGS')\n        match = re.search(r'-isysroot\\s*(\\S+)', cflags)\n\n        apply_root = (\n            sys.platform == 'darwin'\n            and match\n            and (\n                dir.startswith('/System/')\n                or (dir.startswith('/usr/') and not dir.startswith('/usr/local/'))\n            )\n        )\n\n        return os.path.join(match.group(1), dir[1:]) if apply_root else dir\n\n    def find_library_file(self, dirs, lib, debug=0):\n        r\"\"\"\n        Second-guess the linker with not much hard\n        data to go on: GCC seems to prefer the shared library, so\n        assume that *all* Unix C compilers do,\n        ignoring even GCC's \"-static\" option.\n\n        >>> compiler = UnixCCompiler()\n        >>> compiler._library_root = lambda dir: dir\n        >>> monkeypatch = getfixture('monkeypatch')\n        >>> monkeypatch.setattr(os.path, 'exists', lambda d: 'existing' in d)\n        >>> dirs = ('/foo/bar/missing', '/foo/bar/existing')\n        >>> compiler.find_library_file(dirs, 'abc').replace('\\\\', '/')\n        '/foo/bar/existing/libabc.dylib'\n        >>> compiler.find_library_file(reversed(dirs), 'abc').replace('\\\\', '/')\n        '/foo/bar/existing/libabc.dylib'\n        >>> monkeypatch.setattr(os.path, 'exists',\n        ...     lambda d: 'existing' in d and '.a' in d)\n        >>> compiler.find_library_file(dirs, 'abc').replace('\\\\', '/')\n        '/foo/bar/existing/libabc.a'\n        >>> compiler.find_library_file(reversed(dirs), 'abc').replace('\\\\', '/')\n        '/foo/bar/existing/libabc.a'\n        \"\"\"\n        lib_names = (\n            self.library_filename(lib, lib_type=type)\n            for type in 'dylib xcode_stub shared static'.split()\n        )\n\n        roots = map(self._library_root, dirs)\n\n        searched = itertools.starmap(os.path.join, itertools.product(roots, lib_names))\n\n        found = filter(os.path.exists, searched)\n\n        # Return None if it could not be found in any dir.\n        return next(found, None)\n", "setuptools/_distutils/spawn.py": "\"\"\"distutils.spawn\n\nProvides the 'spawn()' function, a front-end to various platform-\nspecific functions for launching another program in a sub-process.\nAlso provides the 'find_executable()' to search the path for a given\nexecutable name.\n\"\"\"\n\nimport os\nimport subprocess\nimport sys\n\nfrom ._log import log\nfrom .debug import DEBUG\nfrom .errors import DistutilsExecError\n\n\ndef spawn(cmd, search_path=1, verbose=0, dry_run=0, env=None):  # noqa: C901\n    \"\"\"Run another program, specified as a command list 'cmd', in a new process.\n\n    'cmd' is just the argument list for the new process, ie.\n    cmd[0] is the program to run and cmd[1:] are the rest of its arguments.\n    There is no way to run a program with a name different from that of its\n    executable.\n\n    If 'search_path' is true (the default), the system's executable\n    search path will be used to find the program; otherwise, cmd[0]\n    must be the exact path to the executable.  If 'dry_run' is true,\n    the command will not actually be run.\n\n    Raise DistutilsExecError if running the program fails in any way; just\n    return on success.\n    \"\"\"\n    # cmd is documented as a list, but just in case some code passes a tuple\n    # in, protect our %-formatting code against horrible death\n    cmd = list(cmd)\n\n    log.info(subprocess.list2cmdline(cmd))\n    if dry_run:\n        return\n\n    if search_path:\n        executable = find_executable(cmd[0])\n        if executable is not None:\n            cmd[0] = executable\n\n    env = env if env is not None else dict(os.environ)\n\n    if sys.platform == 'darwin':\n        from distutils.util import MACOSX_VERSION_VAR, get_macosx_target_ver\n\n        macosx_target_ver = get_macosx_target_ver()\n        if macosx_target_ver:\n            env[MACOSX_VERSION_VAR] = macosx_target_ver\n\n    try:\n        proc = subprocess.Popen(cmd, env=env)\n        proc.wait()\n        exitcode = proc.returncode\n    except OSError as exc:\n        if not DEBUG:\n            cmd = cmd[0]\n        raise DistutilsExecError(f\"command {cmd!r} failed: {exc.args[-1]}\") from exc\n\n    if exitcode:\n        if not DEBUG:\n            cmd = cmd[0]\n        raise DistutilsExecError(f\"command {cmd!r} failed with exit code {exitcode}\")\n\n\ndef find_executable(executable, path=None):\n    \"\"\"Tries to find 'executable' in the directories listed in 'path'.\n\n    A string listing directories separated by 'os.pathsep'; defaults to\n    os.environ['PATH'].  Returns the complete filename or None if not found.\n    \"\"\"\n    _, ext = os.path.splitext(executable)\n    if (sys.platform == 'win32') and (ext != '.exe'):\n        executable = executable + '.exe'\n\n    if os.path.isfile(executable):\n        return executable\n\n    if path is None:\n        path = os.environ.get('PATH', None)\n        if path is None:\n            try:\n                path = os.confstr(\"CS_PATH\")\n            except (AttributeError, ValueError):\n                # os.confstr() or CS_PATH is not available\n                path = os.defpath\n        # bpo-35755: Don't use os.defpath if the PATH environment variable is\n        # set to an empty string\n\n    # PATH='' doesn't match, whereas PATH=':' looks in the current directory\n    if not path:\n        return None\n\n    paths = path.split(os.pathsep)\n    for p in paths:\n        f = os.path.join(p, executable)\n        if os.path.isfile(f):\n            # the file exists, we have a shot at spawn working\n            return f\n    return None\n", "setuptools/_distutils/py39compat.py": "import functools\nimport itertools\nimport platform\nimport sys\n\n\ndef add_ext_suffix_39(vars):\n    \"\"\"\n    Ensure vars contains 'EXT_SUFFIX'. pypa/distutils#130\n    \"\"\"\n    import _imp\n\n    ext_suffix = _imp.extension_suffixes()[0]\n    vars.update(\n        EXT_SUFFIX=ext_suffix,\n        # sysconfig sets SO to match EXT_SUFFIX, so maintain\n        # that expectation.\n        # https://github.com/python/cpython/blob/785cc6770588de087d09e89a69110af2542be208/Lib/sysconfig.py#L671-L673\n        SO=ext_suffix,\n    )\n\n\nneeds_ext_suffix = sys.version_info < (3, 10) and platform.system() == 'Windows'\nadd_ext_suffix = add_ext_suffix_39 if needs_ext_suffix else lambda vars: None\n\n\n# from more_itertools\nclass UnequalIterablesError(ValueError):\n    def __init__(self, details=None):\n        msg = 'Iterables have different lengths'\n        if details is not None:\n            msg += (': index 0 has length {}; index {} has length {}').format(*details)\n\n        super().__init__(msg)\n\n\n# from more_itertools\ndef _zip_equal_generator(iterables):\n    _marker = object()\n    for combo in itertools.zip_longest(*iterables, fillvalue=_marker):\n        for val in combo:\n            if val is _marker:\n                raise UnequalIterablesError()\n        yield combo\n\n\n# from more_itertools\ndef _zip_equal(*iterables):\n    # Check whether the iterables are all the same size.\n    try:\n        first_size = len(iterables[0])\n        for i, it in enumerate(iterables[1:], 1):\n            size = len(it)\n            if size != first_size:\n                raise UnequalIterablesError(details=(first_size, i, size))\n        # All sizes are equal, we can use the built-in zip.\n        return zip(*iterables)\n    # If any one of the iterables didn't have a length, start reading\n    # them until one runs out.\n    except TypeError:\n        return _zip_equal_generator(iterables)\n\n\nzip_strict = (\n    _zip_equal if sys.version_info < (3, 10) else functools.partial(zip, strict=True)\n)\n", "setuptools/_distutils/ccompiler.py": "\"\"\"distutils.ccompiler\n\nContains CCompiler, an abstract base class that defines the interface\nfor the Distutils compiler abstraction model.\"\"\"\n\nimport os\nimport re\nimport sys\nimport warnings\n\nfrom ._itertools import always_iterable\nfrom ._log import log\nfrom ._modified import newer_group\nfrom .dir_util import mkpath\nfrom .errors import (\n    CompileError,\n    DistutilsModuleError,\n    DistutilsPlatformError,\n    LinkError,\n    UnknownFileError,\n)\nfrom .file_util import move_file\nfrom .spawn import spawn\nfrom .util import execute, split_quoted\n\n\nclass CCompiler:\n    \"\"\"Abstract base class to define the interface that must be implemented\n    by real compiler classes.  Also has some utility methods used by\n    several compiler classes.\n\n    The basic idea behind a compiler abstraction class is that each\n    instance can be used for all the compile/link steps in building a\n    single project.  Thus, attributes common to all of those compile and\n    link steps -- include directories, macros to define, libraries to link\n    against, etc. -- are attributes of the compiler instance.  To allow for\n    variability in how individual files are treated, most of those\n    attributes may be varied on a per-compilation or per-link basis.\n    \"\"\"\n\n    # 'compiler_type' is a class attribute that identifies this class.  It\n    # keeps code that wants to know what kind of compiler it's dealing with\n    # from having to import all possible compiler classes just to do an\n    # 'isinstance'.  In concrete CCompiler subclasses, 'compiler_type'\n    # should really, really be one of the keys of the 'compiler_class'\n    # dictionary (see below -- used by the 'new_compiler()' factory\n    # function) -- authors of new compiler interface classes are\n    # responsible for updating 'compiler_class'!\n    compiler_type = None\n\n    # XXX things not handled by this compiler abstraction model:\n    #   * client can't provide additional options for a compiler,\n    #     e.g. warning, optimization, debugging flags.  Perhaps this\n    #     should be the domain of concrete compiler abstraction classes\n    #     (UnixCCompiler, MSVCCompiler, etc.) -- or perhaps the base\n    #     class should have methods for the common ones.\n    #   * can't completely override the include or library searchg\n    #     path, ie. no \"cc -I -Idir1 -Idir2\" or \"cc -L -Ldir1 -Ldir2\".\n    #     I'm not sure how widely supported this is even by Unix\n    #     compilers, much less on other platforms.  And I'm even less\n    #     sure how useful it is; maybe for cross-compiling, but\n    #     support for that is a ways off.  (And anyways, cross\n    #     compilers probably have a dedicated binary with the\n    #     right paths compiled in.  I hope.)\n    #   * can't do really freaky things with the library list/library\n    #     dirs, e.g. \"-Ldir1 -lfoo -Ldir2 -lfoo\" to link against\n    #     different versions of libfoo.a in different locations.  I\n    #     think this is useless without the ability to null out the\n    #     library search path anyways.\n\n    # Subclasses that rely on the standard filename generation methods\n    # implemented below should override these; see the comment near\n    # those methods ('object_filenames()' et. al.) for details:\n    src_extensions = None  # list of strings\n    obj_extension = None  # string\n    static_lib_extension = None\n    shared_lib_extension = None  # string\n    static_lib_format = None  # format string\n    shared_lib_format = None  # prob. same as static_lib_format\n    exe_extension = None  # string\n\n    # Default language settings. language_map is used to detect a source\n    # file or Extension target language, checking source filenames.\n    # language_order is used to detect the language precedence, when deciding\n    # what language to use when mixing source types. For example, if some\n    # extension has two files with \".c\" extension, and one with \".cpp\", it\n    # is still linked as c++.\n    language_map = {\n        \".c\": \"c\",\n        \".cc\": \"c++\",\n        \".cpp\": \"c++\",\n        \".cxx\": \"c++\",\n        \".m\": \"objc\",\n    }\n    language_order = [\"c++\", \"objc\", \"c\"]\n\n    include_dirs = []\n    \"\"\"\n    include dirs specific to this compiler class\n    \"\"\"\n\n    library_dirs = []\n    \"\"\"\n    library dirs specific to this compiler class\n    \"\"\"\n\n    def __init__(self, verbose=0, dry_run=0, force=0):\n        self.dry_run = dry_run\n        self.force = force\n        self.verbose = verbose\n\n        # 'output_dir': a common output directory for object, library,\n        # shared object, and shared library files\n        self.output_dir = None\n\n        # 'macros': a list of macro definitions (or undefinitions).  A\n        # macro definition is a 2-tuple (name, value), where the value is\n        # either a string or None (no explicit value).  A macro\n        # undefinition is a 1-tuple (name,).\n        self.macros = []\n\n        # 'include_dirs': a list of directories to search for include files\n        self.include_dirs = []\n\n        # 'libraries': a list of libraries to include in any link\n        # (library names, not filenames: eg. \"foo\" not \"libfoo.a\")\n        self.libraries = []\n\n        # 'library_dirs': a list of directories to search for libraries\n        self.library_dirs = []\n\n        # 'runtime_library_dirs': a list of directories to search for\n        # shared libraries/objects at runtime\n        self.runtime_library_dirs = []\n\n        # 'objects': a list of object files (or similar, such as explicitly\n        # named library files) to include on any link\n        self.objects = []\n\n        for key in self.executables.keys():\n            self.set_executable(key, self.executables[key])\n\n    def set_executables(self, **kwargs):\n        \"\"\"Define the executables (and options for them) that will be run\n        to perform the various stages of compilation.  The exact set of\n        executables that may be specified here depends on the compiler\n        class (via the 'executables' class attribute), but most will have:\n          compiler      the C/C++ compiler\n          linker_so     linker used to create shared objects and libraries\n          linker_exe    linker used to create binary executables\n          archiver      static library creator\n\n        On platforms with a command-line (Unix, DOS/Windows), each of these\n        is a string that will be split into executable name and (optional)\n        list of arguments.  (Splitting the string is done similarly to how\n        Unix shells operate: words are delimited by spaces, but quotes and\n        backslashes can override this.  See\n        'distutils.util.split_quoted()'.)\n        \"\"\"\n\n        # Note that some CCompiler implementation classes will define class\n        # attributes 'cpp', 'cc', etc. with hard-coded executable names;\n        # this is appropriate when a compiler class is for exactly one\n        # compiler/OS combination (eg. MSVCCompiler).  Other compiler\n        # classes (UnixCCompiler, in particular) are driven by information\n        # discovered at run-time, since there are many different ways to do\n        # basically the same things with Unix C compilers.\n\n        for key in kwargs:\n            if key not in self.executables:\n                raise ValueError(\n                    f\"unknown executable '{key}' for class {self.__class__.__name__}\"\n                )\n            self.set_executable(key, kwargs[key])\n\n    def set_executable(self, key, value):\n        if isinstance(value, str):\n            setattr(self, key, split_quoted(value))\n        else:\n            setattr(self, key, value)\n\n    def _find_macro(self, name):\n        i = 0\n        for defn in self.macros:\n            if defn[0] == name:\n                return i\n            i += 1\n        return None\n\n    def _check_macro_definitions(self, definitions):\n        \"\"\"Ensures that every element of 'definitions' is a valid macro\n        definition, ie. either (name,value) 2-tuple or a (name,) tuple.  Do\n        nothing if all definitions are OK, raise TypeError otherwise.\n        \"\"\"\n        for defn in definitions:\n            if not (\n                isinstance(defn, tuple)\n                and (\n                    len(defn) in (1, 2)\n                    and (isinstance(defn[1], str) or defn[1] is None)\n                )\n                and isinstance(defn[0], str)\n            ):\n                raise TypeError(\n                    (\"invalid macro definition '%s': \" % defn)\n                    + \"must be tuple (string,), (string, string), or \"\n                    + \"(string, None)\"\n                )\n\n    # -- Bookkeeping methods -------------------------------------------\n\n    def define_macro(self, name, value=None):\n        \"\"\"Define a preprocessor macro for all compilations driven by this\n        compiler object.  The optional parameter 'value' should be a\n        string; if it is not supplied, then the macro will be defined\n        without an explicit value and the exact outcome depends on the\n        compiler used (XXX true? does ANSI say anything about this?)\n        \"\"\"\n        # Delete from the list of macro definitions/undefinitions if\n        # already there (so that this one will take precedence).\n        i = self._find_macro(name)\n        if i is not None:\n            del self.macros[i]\n\n        self.macros.append((name, value))\n\n    def undefine_macro(self, name):\n        \"\"\"Undefine a preprocessor macro for all compilations driven by\n        this compiler object.  If the same macro is defined by\n        'define_macro()' and undefined by 'undefine_macro()' the last call\n        takes precedence (including multiple redefinitions or\n        undefinitions).  If the macro is redefined/undefined on a\n        per-compilation basis (ie. in the call to 'compile()'), then that\n        takes precedence.\n        \"\"\"\n        # Delete from the list of macro definitions/undefinitions if\n        # already there (so that this one will take precedence).\n        i = self._find_macro(name)\n        if i is not None:\n            del self.macros[i]\n\n        undefn = (name,)\n        self.macros.append(undefn)\n\n    def add_include_dir(self, dir):\n        \"\"\"Add 'dir' to the list of directories that will be searched for\n        header files.  The compiler is instructed to search directories in\n        the order in which they are supplied by successive calls to\n        'add_include_dir()'.\n        \"\"\"\n        self.include_dirs.append(dir)\n\n    def set_include_dirs(self, dirs):\n        \"\"\"Set the list of directories that will be searched to 'dirs' (a\n        list of strings).  Overrides any preceding calls to\n        'add_include_dir()'; subsequence calls to 'add_include_dir()' add\n        to the list passed to 'set_include_dirs()'.  This does not affect\n        any list of standard include directories that the compiler may\n        search by default.\n        \"\"\"\n        self.include_dirs = dirs[:]\n\n    def add_library(self, libname):\n        \"\"\"Add 'libname' to the list of libraries that will be included in\n        all links driven by this compiler object.  Note that 'libname'\n        should *not* be the name of a file containing a library, but the\n        name of the library itself: the actual filename will be inferred by\n        the linker, the compiler, or the compiler class (depending on the\n        platform).\n\n        The linker will be instructed to link against libraries in the\n        order they were supplied to 'add_library()' and/or\n        'set_libraries()'.  It is perfectly valid to duplicate library\n        names; the linker will be instructed to link against libraries as\n        many times as they are mentioned.\n        \"\"\"\n        self.libraries.append(libname)\n\n    def set_libraries(self, libnames):\n        \"\"\"Set the list of libraries to be included in all links driven by\n        this compiler object to 'libnames' (a list of strings).  This does\n        not affect any standard system libraries that the linker may\n        include by default.\n        \"\"\"\n        self.libraries = libnames[:]\n\n    def add_library_dir(self, dir):\n        \"\"\"Add 'dir' to the list of directories that will be searched for\n        libraries specified to 'add_library()' and 'set_libraries()'.  The\n        linker will be instructed to search for libraries in the order they\n        are supplied to 'add_library_dir()' and/or 'set_library_dirs()'.\n        \"\"\"\n        self.library_dirs.append(dir)\n\n    def set_library_dirs(self, dirs):\n        \"\"\"Set the list of library search directories to 'dirs' (a list of\n        strings).  This does not affect any standard library search path\n        that the linker may search by default.\n        \"\"\"\n        self.library_dirs = dirs[:]\n\n    def add_runtime_library_dir(self, dir):\n        \"\"\"Add 'dir' to the list of directories that will be searched for\n        shared libraries at runtime.\n        \"\"\"\n        self.runtime_library_dirs.append(dir)\n\n    def set_runtime_library_dirs(self, dirs):\n        \"\"\"Set the list of directories to search for shared libraries at\n        runtime to 'dirs' (a list of strings).  This does not affect any\n        standard search path that the runtime linker may search by\n        default.\n        \"\"\"\n        self.runtime_library_dirs = dirs[:]\n\n    def add_link_object(self, object):\n        \"\"\"Add 'object' to the list of object files (or analogues, such as\n        explicitly named library files or the output of \"resource\n        compilers\") to be included in every link driven by this compiler\n        object.\n        \"\"\"\n        self.objects.append(object)\n\n    def set_link_objects(self, objects):\n        \"\"\"Set the list of object files (or analogues) to be included in\n        every link to 'objects'.  This does not affect any standard object\n        files that the linker may include by default (such as system\n        libraries).\n        \"\"\"\n        self.objects = objects[:]\n\n    # -- Private utility methods --------------------------------------\n    # (here for the convenience of subclasses)\n\n    # Helper method to prep compiler in subclass compile() methods\n\n    def _setup_compile(self, outdir, macros, incdirs, sources, depends, extra):\n        \"\"\"Process arguments and decide which source files to compile.\"\"\"\n        outdir, macros, incdirs = self._fix_compile_args(outdir, macros, incdirs)\n\n        if extra is None:\n            extra = []\n\n        # Get the list of expected output (object) files\n        objects = self.object_filenames(sources, strip_dir=0, output_dir=outdir)\n        assert len(objects) == len(sources)\n\n        pp_opts = gen_preprocess_options(macros, incdirs)\n\n        build = {}\n        for i in range(len(sources)):\n            src = sources[i]\n            obj = objects[i]\n            ext = os.path.splitext(src)[1]\n            self.mkpath(os.path.dirname(obj))\n            build[obj] = (src, ext)\n\n        return macros, objects, extra, pp_opts, build\n\n    def _get_cc_args(self, pp_opts, debug, before):\n        # works for unixccompiler, cygwinccompiler\n        cc_args = pp_opts + ['-c']\n        if debug:\n            cc_args[:0] = ['-g']\n        if before:\n            cc_args[:0] = before\n        return cc_args\n\n    def _fix_compile_args(self, output_dir, macros, include_dirs):\n        \"\"\"Typecheck and fix-up some of the arguments to the 'compile()'\n        method, and return fixed-up values.  Specifically: if 'output_dir'\n        is None, replaces it with 'self.output_dir'; ensures that 'macros'\n        is a list, and augments it with 'self.macros'; ensures that\n        'include_dirs' is a list, and augments it with 'self.include_dirs'.\n        Guarantees that the returned values are of the correct type,\n        i.e. for 'output_dir' either string or None, and for 'macros' and\n        'include_dirs' either list or None.\n        \"\"\"\n        if output_dir is None:\n            output_dir = self.output_dir\n        elif not isinstance(output_dir, str):\n            raise TypeError(\"'output_dir' must be a string or None\")\n\n        if macros is None:\n            macros = list(self.macros)\n        elif isinstance(macros, list):\n            macros = macros + (self.macros or [])\n        else:\n            raise TypeError(\"'macros' (if supplied) must be a list of tuples\")\n\n        if include_dirs is None:\n            include_dirs = list(self.include_dirs)\n        elif isinstance(include_dirs, (list, tuple)):\n            include_dirs = list(include_dirs) + (self.include_dirs or [])\n        else:\n            raise TypeError(\"'include_dirs' (if supplied) must be a list of strings\")\n\n        # add include dirs for class\n        include_dirs += self.__class__.include_dirs\n\n        return output_dir, macros, include_dirs\n\n    def _prep_compile(self, sources, output_dir, depends=None):\n        \"\"\"Decide which source files must be recompiled.\n\n        Determine the list of object files corresponding to 'sources',\n        and figure out which ones really need to be recompiled.\n        Return a list of all object files and a dictionary telling\n        which source files can be skipped.\n        \"\"\"\n        # Get the list of expected output (object) files\n        objects = self.object_filenames(sources, output_dir=output_dir)\n        assert len(objects) == len(sources)\n\n        # Return an empty dict for the \"which source files can be skipped\"\n        # return value to preserve API compatibility.\n        return objects, {}\n\n    def _fix_object_args(self, objects, output_dir):\n        \"\"\"Typecheck and fix up some arguments supplied to various methods.\n        Specifically: ensure that 'objects' is a list; if output_dir is\n        None, replace with self.output_dir.  Return fixed versions of\n        'objects' and 'output_dir'.\n        \"\"\"\n        if not isinstance(objects, (list, tuple)):\n            raise TypeError(\"'objects' must be a list or tuple of strings\")\n        objects = list(objects)\n\n        if output_dir is None:\n            output_dir = self.output_dir\n        elif not isinstance(output_dir, str):\n            raise TypeError(\"'output_dir' must be a string or None\")\n\n        return (objects, output_dir)\n\n    def _fix_lib_args(self, libraries, library_dirs, runtime_library_dirs):\n        \"\"\"Typecheck and fix up some of the arguments supplied to the\n        'link_*' methods.  Specifically: ensure that all arguments are\n        lists, and augment them with their permanent versions\n        (eg. 'self.libraries' augments 'libraries').  Return a tuple with\n        fixed versions of all arguments.\n        \"\"\"\n        if libraries is None:\n            libraries = list(self.libraries)\n        elif isinstance(libraries, (list, tuple)):\n            libraries = list(libraries) + (self.libraries or [])\n        else:\n            raise TypeError(\"'libraries' (if supplied) must be a list of strings\")\n\n        if library_dirs is None:\n            library_dirs = list(self.library_dirs)\n        elif isinstance(library_dirs, (list, tuple)):\n            library_dirs = list(library_dirs) + (self.library_dirs or [])\n        else:\n            raise TypeError(\"'library_dirs' (if supplied) must be a list of strings\")\n\n        # add library dirs for class\n        library_dirs += self.__class__.library_dirs\n\n        if runtime_library_dirs is None:\n            runtime_library_dirs = list(self.runtime_library_dirs)\n        elif isinstance(runtime_library_dirs, (list, tuple)):\n            runtime_library_dirs = list(runtime_library_dirs) + (\n                self.runtime_library_dirs or []\n            )\n        else:\n            raise TypeError(\n                \"'runtime_library_dirs' (if supplied) must be a list of strings\"\n            )\n\n        return (libraries, library_dirs, runtime_library_dirs)\n\n    def _need_link(self, objects, output_file):\n        \"\"\"Return true if we need to relink the files listed in 'objects'\n        to recreate 'output_file'.\n        \"\"\"\n        if self.force:\n            return True\n        else:\n            if self.dry_run:\n                newer = newer_group(objects, output_file, missing='newer')\n            else:\n                newer = newer_group(objects, output_file)\n            return newer\n\n    def detect_language(self, sources):\n        \"\"\"Detect the language of a given file, or list of files. Uses\n        language_map, and language_order to do the job.\n        \"\"\"\n        if not isinstance(sources, list):\n            sources = [sources]\n        lang = None\n        index = len(self.language_order)\n        for source in sources:\n            base, ext = os.path.splitext(source)\n            extlang = self.language_map.get(ext)\n            try:\n                extindex = self.language_order.index(extlang)\n                if extindex < index:\n                    lang = extlang\n                    index = extindex\n            except ValueError:\n                pass\n        return lang\n\n    # -- Worker methods ------------------------------------------------\n    # (must be implemented by subclasses)\n\n    def preprocess(\n        self,\n        source,\n        output_file=None,\n        macros=None,\n        include_dirs=None,\n        extra_preargs=None,\n        extra_postargs=None,\n    ):\n        \"\"\"Preprocess a single C/C++ source file, named in 'source'.\n        Output will be written to file named 'output_file', or stdout if\n        'output_file' not supplied.  'macros' is a list of macro\n        definitions as for 'compile()', which will augment the macros set\n        with 'define_macro()' and 'undefine_macro()'.  'include_dirs' is a\n        list of directory names that will be added to the default list.\n\n        Raises PreprocessError on failure.\n        \"\"\"\n        pass\n\n    def compile(\n        self,\n        sources,\n        output_dir=None,\n        macros=None,\n        include_dirs=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        depends=None,\n    ):\n        \"\"\"Compile one or more source files.\n\n        'sources' must be a list of filenames, most likely C/C++\n        files, but in reality anything that can be handled by a\n        particular compiler and compiler class (eg. MSVCCompiler can\n        handle resource files in 'sources').  Return a list of object\n        filenames, one per source filename in 'sources'.  Depending on\n        the implementation, not all source files will necessarily be\n        compiled, but all corresponding object filenames will be\n        returned.\n\n        If 'output_dir' is given, object files will be put under it, while\n        retaining their original path component.  That is, \"foo/bar.c\"\n        normally compiles to \"foo/bar.o\" (for a Unix implementation); if\n        'output_dir' is \"build\", then it would compile to\n        \"build/foo/bar.o\".\n\n        'macros', if given, must be a list of macro definitions.  A macro\n        definition is either a (name, value) 2-tuple or a (name,) 1-tuple.\n        The former defines a macro; if the value is None, the macro is\n        defined without an explicit value.  The 1-tuple case undefines a\n        macro.  Later definitions/redefinitions/ undefinitions take\n        precedence.\n\n        'include_dirs', if given, must be a list of strings, the\n        directories to add to the default include file search path for this\n        compilation only.\n\n        'debug' is a boolean; if true, the compiler will be instructed to\n        output debug symbols in (or alongside) the object file(s).\n\n        'extra_preargs' and 'extra_postargs' are implementation- dependent.\n        On platforms that have the notion of a command-line (e.g. Unix,\n        DOS/Windows), they are most likely lists of strings: extra\n        command-line arguments to prepend/append to the compiler command\n        line.  On other platforms, consult the implementation class\n        documentation.  In any event, they are intended as an escape hatch\n        for those occasions when the abstract compiler framework doesn't\n        cut the mustard.\n\n        'depends', if given, is a list of filenames that all targets\n        depend on.  If a source file is older than any file in\n        depends, then the source file will be recompiled.  This\n        supports dependency tracking, but only at a coarse\n        granularity.\n\n        Raises CompileError on failure.\n        \"\"\"\n        # A concrete compiler class can either override this method\n        # entirely or implement _compile().\n        macros, objects, extra_postargs, pp_opts, build = self._setup_compile(\n            output_dir, macros, include_dirs, sources, depends, extra_postargs\n        )\n        cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)\n\n        for obj in objects:\n            try:\n                src, ext = build[obj]\n            except KeyError:\n                continue\n            self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n\n        # Return *all* object filenames, not just the ones we just built.\n        return objects\n\n    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile 'src' to product 'obj'.\"\"\"\n        # A concrete compiler class that does not override compile()\n        # should implement _compile().\n        pass\n\n    def create_static_lib(\n        self, objects, output_libname, output_dir=None, debug=0, target_lang=None\n    ):\n        \"\"\"Link a bunch of stuff together to create a static library file.\n        The \"bunch of stuff\" consists of the list of object files supplied\n        as 'objects', the extra object files supplied to\n        'add_link_object()' and/or 'set_link_objects()', the libraries\n        supplied to 'add_library()' and/or 'set_libraries()', and the\n        libraries supplied as 'libraries' (if any).\n\n        'output_libname' should be a library name, not a filename; the\n        filename will be inferred from the library name.  'output_dir' is\n        the directory where the library file will be put.\n\n        'debug' is a boolean; if true, debugging information will be\n        included in the library (note that on most platforms, it is the\n        compile step where this matters: the 'debug' flag is included here\n        just for consistency).\n\n        'target_lang' is the target language for which the given objects\n        are being compiled. This allows specific linkage time treatment of\n        certain languages.\n\n        Raises LibError on failure.\n        \"\"\"\n        pass\n\n    # values for target_desc parameter in link()\n    SHARED_OBJECT = \"shared_object\"\n    SHARED_LIBRARY = \"shared_library\"\n    EXECUTABLE = \"executable\"\n\n    def link(\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        \"\"\"Link a bunch of stuff together to create an executable or\n        shared library file.\n\n        The \"bunch of stuff\" consists of the list of object files supplied\n        as 'objects'.  'output_filename' should be a filename.  If\n        'output_dir' is supplied, 'output_filename' is relative to it\n        (i.e. 'output_filename' can provide directory components if\n        needed).\n\n        'libraries' is a list of libraries to link against.  These are\n        library names, not filenames, since they're translated into\n        filenames in a platform-specific way (eg. \"foo\" becomes \"libfoo.a\"\n        on Unix and \"foo.lib\" on DOS/Windows).  However, they can include a\n        directory component, which means the linker will look in that\n        specific directory rather than searching all the normal locations.\n\n        'library_dirs', if supplied, should be a list of directories to\n        search for libraries that were specified as bare library names\n        (ie. no directory component).  These are on top of the system\n        default and those supplied to 'add_library_dir()' and/or\n        'set_library_dirs()'.  'runtime_library_dirs' is a list of\n        directories that will be embedded into the shared library and used\n        to search for other shared libraries that *it* depends on at\n        run-time.  (This may only be relevant on Unix.)\n\n        'export_symbols' is a list of symbols that the shared library will\n        export.  (This appears to be relevant only on Windows.)\n\n        'debug' is as for 'compile()' and 'create_static_lib()', with the\n        slight distinction that it actually matters on most platforms (as\n        opposed to 'create_static_lib()', which includes a 'debug' flag\n        mostly for form's sake).\n\n        'extra_preargs' and 'extra_postargs' are as for 'compile()' (except\n        of course that they supply command-line arguments for the\n        particular linker being used).\n\n        'target_lang' is the target language for which the given objects\n        are being compiled. This allows specific linkage time treatment of\n        certain languages.\n\n        Raises LinkError on failure.\n        \"\"\"\n        raise NotImplementedError\n\n    # Old 'link_*()' methods, rewritten to use the new 'link()' method.\n\n    def link_shared_lib(\n        self,\n        objects,\n        output_libname,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        self.link(\n            CCompiler.SHARED_LIBRARY,\n            objects,\n            self.library_filename(output_libname, lib_type='shared'),\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            export_symbols,\n            debug,\n            extra_preargs,\n            extra_postargs,\n            build_temp,\n            target_lang,\n        )\n\n    def link_shared_object(\n        self,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        self.link(\n            CCompiler.SHARED_OBJECT,\n            objects,\n            output_filename,\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            export_symbols,\n            debug,\n            extra_preargs,\n            extra_postargs,\n            build_temp,\n            target_lang,\n        )\n\n    def link_executable(\n        self,\n        objects,\n        output_progname,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        target_lang=None,\n    ):\n        self.link(\n            CCompiler.EXECUTABLE,\n            objects,\n            self.executable_filename(output_progname),\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            None,\n            debug,\n            extra_preargs,\n            extra_postargs,\n            None,\n            target_lang,\n        )\n\n    # -- Miscellaneous methods -----------------------------------------\n    # These are all used by the 'gen_lib_options() function; there is\n    # no appropriate default implementation so subclasses should\n    # implement all of these.\n\n    def library_dir_option(self, dir):\n        \"\"\"Return the compiler option to add 'dir' to the list of\n        directories searched for libraries.\n        \"\"\"\n        raise NotImplementedError\n\n    def runtime_library_dir_option(self, dir):\n        \"\"\"Return the compiler option to add 'dir' to the list of\n        directories searched for runtime libraries.\n        \"\"\"\n        raise NotImplementedError\n\n    def library_option(self, lib):\n        \"\"\"Return the compiler option to add 'lib' to the list of libraries\n        linked into the shared library or executable.\n        \"\"\"\n        raise NotImplementedError\n\n    def has_function(  # noqa: C901\n        self,\n        funcname,\n        includes=None,\n        include_dirs=None,\n        libraries=None,\n        library_dirs=None,\n    ):\n        \"\"\"Return a boolean indicating whether funcname is provided as\n        a symbol on the current platform.  The optional arguments can\n        be used to augment the compilation environment.\n\n        The libraries argument is a list of flags to be passed to the\n        linker to make additional symbol definitions available for\n        linking.\n\n        The includes and include_dirs arguments are deprecated.\n        Usually, supplying include files with function declarations\n        will cause function detection to fail even in cases where the\n        symbol is available for linking.\n\n        \"\"\"\n        # this can't be included at module scope because it tries to\n        # import math which might not be available at that point - maybe\n        # the necessary logic should just be inlined?\n        import tempfile\n\n        if includes is None:\n            includes = []\n        else:\n            warnings.warn(\"includes is deprecated\", DeprecationWarning)\n        if include_dirs is None:\n            include_dirs = []\n        else:\n            warnings.warn(\"include_dirs is deprecated\", DeprecationWarning)\n        if libraries is None:\n            libraries = []\n        if library_dirs is None:\n            library_dirs = []\n        fd, fname = tempfile.mkstemp(\".c\", funcname, text=True)\n        with os.fdopen(fd, \"w\", encoding='utf-8') as f:\n            for incl in includes:\n                f.write(\"\"\"#include \"%s\"\\n\"\"\" % incl)\n            if not includes:\n                # Use \"char func(void);\" as the prototype to follow\n                # what autoconf does.  This prototype does not match\n                # any well-known function the compiler might recognize\n                # as a builtin, so this ends up as a true link test.\n                # Without a fake prototype, the test would need to\n                # know the exact argument types, and the has_function\n                # interface does not provide that level of information.\n                f.write(\n                    \"\"\"\\\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar %s(void);\n\"\"\"\n                    % funcname\n                )\n            f.write(\n                \"\"\"\\\nint main (int argc, char **argv) {\n    %s();\n    return 0;\n}\n\"\"\"\n                % funcname\n            )\n\n        try:\n            objects = self.compile([fname], include_dirs=include_dirs)\n        except CompileError:\n            return False\n        finally:\n            os.remove(fname)\n\n        try:\n            self.link_executable(\n                objects, \"a.out\", libraries=libraries, library_dirs=library_dirs\n            )\n        except (LinkError, TypeError):\n            return False\n        else:\n            os.remove(\n                self.executable_filename(\"a.out\", output_dir=self.output_dir or '')\n            )\n        finally:\n            for fn in objects:\n                os.remove(fn)\n        return True\n\n    def find_library_file(self, dirs, lib, debug=0):\n        \"\"\"Search the specified list of directories for a static or shared\n        library file 'lib' and return the full path to that file.  If\n        'debug' true, look for a debugging version (if that makes sense on\n        the current platform).  Return None if 'lib' wasn't found in any of\n        the specified directories.\n        \"\"\"\n        raise NotImplementedError\n\n    # -- Filename generation methods -----------------------------------\n\n    # The default implementation of the filename generating methods are\n    # prejudiced towards the Unix/DOS/Windows view of the world:\n    #   * object files are named by replacing the source file extension\n    #     (eg. .c/.cpp -> .o/.obj)\n    #   * library files (shared or static) are named by plugging the\n    #     library name and extension into a format string, eg.\n    #     \"lib%s.%s\" % (lib_name, \".a\") for Unix static libraries\n    #   * executables are named by appending an extension (possibly\n    #     empty) to the program name: eg. progname + \".exe\" for\n    #     Windows\n    #\n    # To reduce redundant code, these methods expect to find\n    # several attributes in the current object (presumably defined\n    # as class attributes):\n    #   * src_extensions -\n    #     list of C/C++ source file extensions, eg. ['.c', '.cpp']\n    #   * obj_extension -\n    #     object file extension, eg. '.o' or '.obj'\n    #   * static_lib_extension -\n    #     extension for static library files, eg. '.a' or '.lib'\n    #   * shared_lib_extension -\n    #     extension for shared library/object files, eg. '.so', '.dll'\n    #   * static_lib_format -\n    #     format string for generating static library filenames,\n    #     eg. 'lib%s.%s' or '%s.%s'\n    #   * shared_lib_format\n    #     format string for generating shared library filenames\n    #     (probably same as static_lib_format, since the extension\n    #     is one of the intended parameters to the format string)\n    #   * exe_extension -\n    #     extension for executable files, eg. '' or '.exe'\n\n    def object_filenames(self, source_filenames, strip_dir=0, output_dir=''):\n        if output_dir is None:\n            output_dir = ''\n        return list(\n            self._make_out_path(output_dir, strip_dir, src_name)\n            for src_name in source_filenames\n        )\n\n    @property\n    def out_extensions(self):\n        return dict.fromkeys(self.src_extensions, self.obj_extension)\n\n    def _make_out_path(self, output_dir, strip_dir, src_name):\n        base, ext = os.path.splitext(src_name)\n        base = self._make_relative(base)\n        try:\n            new_ext = self.out_extensions[ext]\n        except LookupError:\n            raise UnknownFileError(f\"unknown file type '{ext}' (from '{src_name}')\")\n        if strip_dir:\n            base = os.path.basename(base)\n        return os.path.join(output_dir, base + new_ext)\n\n    @staticmethod\n    def _make_relative(base):\n        \"\"\"\n        In order to ensure that a filename always honors the\n        indicated output_dir, make sure it's relative.\n        Ref python/cpython#37775.\n        \"\"\"\n        # Chop off the drive\n        no_drive = os.path.splitdrive(base)[1]\n        # If abs, chop off leading /\n        return no_drive[os.path.isabs(no_drive) :]\n\n    def shared_object_filename(self, basename, strip_dir=0, output_dir=''):\n        assert output_dir is not None\n        if strip_dir:\n            basename = os.path.basename(basename)\n        return os.path.join(output_dir, basename + self.shared_lib_extension)\n\n    def executable_filename(self, basename, strip_dir=0, output_dir=''):\n        assert output_dir is not None\n        if strip_dir:\n            basename = os.path.basename(basename)\n        return os.path.join(output_dir, basename + (self.exe_extension or ''))\n\n    def library_filename(\n        self,\n        libname,\n        lib_type='static',\n        strip_dir=0,\n        output_dir='',  # or 'shared'\n    ):\n        assert output_dir is not None\n        expected = '\"static\", \"shared\", \"dylib\", \"xcode_stub\"'\n        if lib_type not in eval(expected):\n            raise ValueError(f\"'lib_type' must be {expected}\")\n        fmt = getattr(self, lib_type + \"_lib_format\")\n        ext = getattr(self, lib_type + \"_lib_extension\")\n\n        dir, base = os.path.split(libname)\n        filename = fmt % (base, ext)\n        if strip_dir:\n            dir = ''\n\n        return os.path.join(output_dir, dir, filename)\n\n    # -- Utility methods -----------------------------------------------\n\n    def announce(self, msg, level=1):\n        log.debug(msg)\n\n    def debug_print(self, msg):\n        from distutils.debug import DEBUG\n\n        if DEBUG:\n            print(msg)\n\n    def warn(self, msg):\n        sys.stderr.write(\"warning: %s\\n\" % msg)\n\n    def execute(self, func, args, msg=None, level=1):\n        execute(func, args, msg, self.dry_run)\n\n    def spawn(self, cmd, **kwargs):\n        spawn(cmd, dry_run=self.dry_run, **kwargs)\n\n    def move_file(self, src, dst):\n        return move_file(src, dst, dry_run=self.dry_run)\n\n    def mkpath(self, name, mode=0o777):\n        mkpath(name, mode, dry_run=self.dry_run)\n\n\n# Map a sys.platform/os.name ('posix', 'nt') to the default compiler\n# type for that platform. Keys are interpreted as re match\n# patterns. Order is important; platform mappings are preferred over\n# OS names.\n_default_compilers = (\n    # Platform string mappings\n    # on a cygwin built python we can use gcc like an ordinary UNIXish\n    # compiler\n    ('cygwin.*', 'unix'),\n    ('zos', 'zos'),\n    # OS name mappings\n    ('posix', 'unix'),\n    ('nt', 'msvc'),\n)\n\n\ndef get_default_compiler(osname=None, platform=None):\n    \"\"\"Determine the default compiler to use for the given platform.\n\n    osname should be one of the standard Python OS names (i.e. the\n    ones returned by os.name) and platform the common value\n    returned by sys.platform for the platform in question.\n\n    The default values are os.name and sys.platform in case the\n    parameters are not given.\n    \"\"\"\n    if osname is None:\n        osname = os.name\n    if platform is None:\n        platform = sys.platform\n    for pattern, compiler in _default_compilers:\n        if (\n            re.match(pattern, platform) is not None\n            or re.match(pattern, osname) is not None\n        ):\n            return compiler\n    # Default to Unix compiler\n    return 'unix'\n\n\n# Map compiler types to (module_name, class_name) pairs -- ie. where to\n# find the code that implements an interface to this compiler.  (The module\n# is assumed to be in the 'distutils' package.)\ncompiler_class = {\n    'unix': ('unixccompiler', 'UnixCCompiler', \"standard UNIX-style compiler\"),\n    'msvc': ('_msvccompiler', 'MSVCCompiler', \"Microsoft Visual C++\"),\n    'cygwin': (\n        'cygwinccompiler',\n        'CygwinCCompiler',\n        \"Cygwin port of GNU C Compiler for Win32\",\n    ),\n    'mingw32': (\n        'cygwinccompiler',\n        'Mingw32CCompiler',\n        \"Mingw32 port of GNU C Compiler for Win32\",\n    ),\n    'bcpp': ('bcppcompiler', 'BCPPCompiler', \"Borland C++ Compiler\"),\n    'zos': ('zosccompiler', 'zOSCCompiler', 'IBM XL C/C++ Compilers'),\n}\n\n\ndef show_compilers():\n    \"\"\"Print list of available compilers (used by the \"--help-compiler\"\n    options to \"build\", \"build_ext\", \"build_clib\").\n    \"\"\"\n    # XXX this \"knows\" that the compiler option it's describing is\n    # \"--compiler\", which just happens to be the case for the three\n    # commands that use it.\n    from distutils.fancy_getopt import FancyGetopt\n\n    compilers = []\n    for compiler in compiler_class.keys():\n        compilers.append((\"compiler=\" + compiler, None, compiler_class[compiler][2]))\n    compilers.sort()\n    pretty_printer = FancyGetopt(compilers)\n    pretty_printer.print_help(\"List of available compilers:\")\n\n\ndef new_compiler(plat=None, compiler=None, verbose=0, dry_run=0, force=0):\n    \"\"\"Generate an instance of some CCompiler subclass for the supplied\n    platform/compiler combination.  'plat' defaults to 'os.name'\n    (eg. 'posix', 'nt'), and 'compiler' defaults to the default compiler\n    for that platform.  Currently only 'posix' and 'nt' are supported, and\n    the default compilers are \"traditional Unix interface\" (UnixCCompiler\n    class) and Visual C++ (MSVCCompiler class).  Note that it's perfectly\n    possible to ask for a Unix compiler object under Windows, and a\n    Microsoft compiler object under Unix -- if you supply a value for\n    'compiler', 'plat' is ignored.\n    \"\"\"\n    if plat is None:\n        plat = os.name\n\n    try:\n        if compiler is None:\n            compiler = get_default_compiler(plat)\n\n        (module_name, class_name, long_description) = compiler_class[compiler]\n    except KeyError:\n        msg = \"don't know how to compile C/C++ code on platform '%s'\" % plat\n        if compiler is not None:\n            msg = msg + \" with '%s' compiler\" % compiler\n        raise DistutilsPlatformError(msg)\n\n    try:\n        module_name = \"distutils.\" + module_name\n        __import__(module_name)\n        module = sys.modules[module_name]\n        klass = vars(module)[class_name]\n    except ImportError:\n        raise DistutilsModuleError(\n            \"can't compile C/C++ code: unable to load module '%s'\" % module_name\n        )\n    except KeyError:\n        raise DistutilsModuleError(\n            f\"can't compile C/C++ code: unable to find class '{class_name}' \"\n            f\"in module '{module_name}'\"\n        )\n\n    # XXX The None is necessary to preserve backwards compatibility\n    # with classes that expect verbose to be the first positional\n    # argument.\n    return klass(None, dry_run, force)\n\n\ndef gen_preprocess_options(macros, include_dirs):\n    \"\"\"Generate C pre-processor options (-D, -U, -I) as used by at least\n    two types of compilers: the typical Unix compiler and Visual C++.\n    'macros' is the usual thing, a list of 1- or 2-tuples, where (name,)\n    means undefine (-U) macro 'name', and (name,value) means define (-D)\n    macro 'name' to 'value'.  'include_dirs' is just a list of directory\n    names to be added to the header file search path (-I).  Returns a list\n    of command-line options suitable for either Unix compilers or Visual\n    C++.\n    \"\"\"\n    # XXX it would be nice (mainly aesthetic, and so we don't generate\n    # stupid-looking command lines) to go over 'macros' and eliminate\n    # redundant definitions/undefinitions (ie. ensure that only the\n    # latest mention of a particular macro winds up on the command\n    # line).  I don't think it's essential, though, since most (all?)\n    # Unix C compilers only pay attention to the latest -D or -U\n    # mention of a macro on their command line.  Similar situation for\n    # 'include_dirs'.  I'm punting on both for now.  Anyways, weeding out\n    # redundancies like this should probably be the province of\n    # CCompiler, since the data structures used are inherited from it\n    # and therefore common to all CCompiler classes.\n    pp_opts = []\n    for macro in macros:\n        if not (isinstance(macro, tuple) and 1 <= len(macro) <= 2):\n            raise TypeError(\n                \"bad macro definition '%s': \"\n                \"each element of 'macros' list must be a 1- or 2-tuple\" % macro\n            )\n\n        if len(macro) == 1:  # undefine this macro\n            pp_opts.append(\"-U%s\" % macro[0])\n        elif len(macro) == 2:\n            if macro[1] is None:  # define with no explicit value\n                pp_opts.append(\"-D%s\" % macro[0])\n            else:\n                # XXX *don't* need to be clever about quoting the\n                # macro value here, because we're going to avoid the\n                # shell at all costs when we spawn the command!\n                pp_opts.append(\"-D{}={}\".format(*macro))\n\n    for dir in include_dirs:\n        pp_opts.append(\"-I%s\" % dir)\n    return pp_opts\n\n\ndef gen_lib_options(compiler, library_dirs, runtime_library_dirs, libraries):\n    \"\"\"Generate linker options for searching library directories and\n    linking with specific libraries.  'libraries' and 'library_dirs' are,\n    respectively, lists of library names (not filenames!) and search\n    directories.  Returns a list of command-line options suitable for use\n    with some compiler (depending on the two format strings passed in).\n    \"\"\"\n    lib_opts = []\n\n    for dir in library_dirs:\n        lib_opts.append(compiler.library_dir_option(dir))\n\n    for dir in runtime_library_dirs:\n        lib_opts.extend(always_iterable(compiler.runtime_library_dir_option(dir)))\n\n    # XXX it's important that we *not* remove redundant library mentions!\n    # sometimes you really do have to say \"-lfoo -lbar -lfoo\" in order to\n    # resolve all symbols.  I just hope we never have to say \"-lfoo obj.o\n    # -lbar\" to get things to work -- that's certainly a possibility, but a\n    # pretty nasty way to arrange your C code.\n\n    for lib in libraries:\n        (lib_dir, lib_name) = os.path.split(lib)\n        if lib_dir:\n            lib_file = compiler.find_library_file([lib_dir], lib_name)\n            if lib_file:\n                lib_opts.append(lib_file)\n            else:\n                compiler.warn(\n                    \"no library file corresponding to '%s' found (skipping)\" % lib\n                )\n        else:\n            lib_opts.append(compiler.library_option(lib))\n    return lib_opts\n", "setuptools/_distutils/errors.py": "\"\"\"distutils.errors\n\nProvides exceptions used by the Distutils modules.  Note that Distutils\nmodules may raise standard exceptions; in particular, SystemExit is\nusually raised for errors that are obviously the end-user's fault\n(eg. bad command-line arguments).\n\nThis module is safe to use in \"from ... import *\" mode; it only exports\nsymbols whose names start with \"Distutils\" and end with \"Error\".\"\"\"\n\n\nclass DistutilsError(Exception):\n    \"\"\"The root of all Distutils evil.\"\"\"\n\n    pass\n\n\nclass DistutilsModuleError(DistutilsError):\n    \"\"\"Unable to load an expected module, or to find an expected class\n    within some module (in particular, command modules and classes).\"\"\"\n\n    pass\n\n\nclass DistutilsClassError(DistutilsError):\n    \"\"\"Some command class (or possibly distribution class, if anyone\n    feels a need to subclass Distribution) is found not to be holding\n    up its end of the bargain, ie. implementing some part of the\n    \"command \"interface.\"\"\"\n\n    pass\n\n\nclass DistutilsGetoptError(DistutilsError):\n    \"\"\"The option table provided to 'fancy_getopt()' is bogus.\"\"\"\n\n    pass\n\n\nclass DistutilsArgError(DistutilsError):\n    \"\"\"Raised by fancy_getopt in response to getopt.error -- ie. an\n    error in the command line usage.\"\"\"\n\n    pass\n\n\nclass DistutilsFileError(DistutilsError):\n    \"\"\"Any problems in the filesystem: expected file not found, etc.\n    Typically this is for problems that we detect before OSError\n    could be raised.\"\"\"\n\n    pass\n\n\nclass DistutilsOptionError(DistutilsError):\n    \"\"\"Syntactic/semantic errors in command options, such as use of\n    mutually conflicting options, or inconsistent options,\n    badly-spelled values, etc.  No distinction is made between option\n    values originating in the setup script, the command line, config\n    files, or what-have-you -- but if we *know* something originated in\n    the setup script, we'll raise DistutilsSetupError instead.\"\"\"\n\n    pass\n\n\nclass DistutilsSetupError(DistutilsError):\n    \"\"\"For errors that can be definitely blamed on the setup script,\n    such as invalid keyword arguments to 'setup()'.\"\"\"\n\n    pass\n\n\nclass DistutilsPlatformError(DistutilsError):\n    \"\"\"We don't know how to do something on the current platform (but\n    we do know how to do it on some platform) -- eg. trying to compile\n    C files on a platform not supported by a CCompiler subclass.\"\"\"\n\n    pass\n\n\nclass DistutilsExecError(DistutilsError):\n    \"\"\"Any problems executing an external program (such as the C\n    compiler, when compiling C files).\"\"\"\n\n    pass\n\n\nclass DistutilsInternalError(DistutilsError):\n    \"\"\"Internal inconsistencies or impossibilities (obviously, this\n    should never be seen if the code is working!).\"\"\"\n\n    pass\n\n\nclass DistutilsTemplateError(DistutilsError):\n    \"\"\"Syntax error in a file list template.\"\"\"\n\n\nclass DistutilsByteCompileError(DistutilsError):\n    \"\"\"Byte compile error.\"\"\"\n\n\n# Exception classes used by the CCompiler implementation classes\nclass CCompilerError(Exception):\n    \"\"\"Some compile/link operation failed.\"\"\"\n\n\nclass PreprocessError(CCompilerError):\n    \"\"\"Failure to preprocess one or more C/C++ files.\"\"\"\n\n\nclass CompileError(CCompilerError):\n    \"\"\"Failure to compile one or more C/C++ source files.\"\"\"\n\n\nclass LibError(CCompilerError):\n    \"\"\"Failure to create a static library from one or more C/C++ object\n    files.\"\"\"\n\n\nclass LinkError(CCompilerError):\n    \"\"\"Failure to link one or more C/C++ object files into an executable\n    or shared library file.\"\"\"\n\n\nclass UnknownFileError(CCompilerError):\n    \"\"\"Attempt to process an unknown file type.\"\"\"\n", "setuptools/_distutils/cygwinccompiler.py": "\"\"\"distutils.cygwinccompiler\n\nProvides the CygwinCCompiler class, a subclass of UnixCCompiler that\nhandles the Cygwin port of the GNU C compiler to Windows.  It also contains\nthe Mingw32CCompiler class which handles the mingw32 port of GCC (same as\ncygwin in no-cygwin mode).\n\"\"\"\n\nimport copy\nimport os\nimport pathlib\nimport re\nimport shlex\nimport sys\nimport warnings\nfrom subprocess import check_output\n\nfrom ._collections import RangeMap\nfrom .errors import (\n    CCompilerError,\n    CompileError,\n    DistutilsExecError,\n    DistutilsPlatformError,\n)\nfrom .file_util import write_file\nfrom .unixccompiler import UnixCCompiler\nfrom .version import LooseVersion, suppress_known_deprecation\n\n_msvcr_lookup = RangeMap.left(\n    {\n        # MSVC 7.0\n        1300: ['msvcr70'],\n        # MSVC 7.1\n        1310: ['msvcr71'],\n        # VS2005 / MSVC 8.0\n        1400: ['msvcr80'],\n        # VS2008 / MSVC 9.0\n        1500: ['msvcr90'],\n        # VS2010 / MSVC 10.0\n        1600: ['msvcr100'],\n        # VS2012 / MSVC 11.0\n        1700: ['msvcr110'],\n        # VS2013 / MSVC 12.0\n        1800: ['msvcr120'],\n        # VS2015 / MSVC 14.0\n        1900: ['vcruntime140'],\n        2000: RangeMap.undefined_value,\n    },\n)\n\n\ndef get_msvcr():\n    \"\"\"Include the appropriate MSVC runtime library if Python was built\n    with MSVC 7.0 or later.\n    \"\"\"\n    match = re.search(r'MSC v\\.(\\d{4})', sys.version)\n    try:\n        msc_ver = int(match.group(1))\n    except AttributeError:\n        return\n    try:\n        return _msvcr_lookup[msc_ver]\n    except KeyError:\n        raise ValueError(\"Unknown MS Compiler version %s \" % msc_ver)\n\n\n_runtime_library_dirs_msg = (\n    \"Unable to set runtime library search path on Windows, \"\n    \"usually indicated by `runtime_library_dirs` parameter to Extension\"\n)\n\n\nclass CygwinCCompiler(UnixCCompiler):\n    \"\"\"Handles the Cygwin port of the GNU C compiler to Windows.\"\"\"\n\n    compiler_type = 'cygwin'\n    obj_extension = \".o\"\n    static_lib_extension = \".a\"\n    shared_lib_extension = \".dll.a\"\n    dylib_lib_extension = \".dll\"\n    static_lib_format = \"lib%s%s\"\n    shared_lib_format = \"lib%s%s\"\n    dylib_lib_format = \"cyg%s%s\"\n    exe_extension = \".exe\"\n\n    def __init__(self, verbose=0, dry_run=0, force=0):\n        super().__init__(verbose, dry_run, force)\n\n        status, details = check_config_h()\n        self.debug_print(f\"Python's GCC status: {status} (details: {details})\")\n        if status is not CONFIG_H_OK:\n            self.warn(\n                \"Python's pyconfig.h doesn't seem to support your compiler. \"\n                \"Reason: %s. \"\n                \"Compiling may fail because of undefined preprocessor macros.\" % details\n            )\n\n        self.cc = os.environ.get('CC', 'gcc')\n        self.cxx = os.environ.get('CXX', 'g++')\n\n        self.linker_dll = self.cc\n        shared_option = \"-shared\"\n\n        self.set_executables(\n            compiler='%s -mcygwin -O -Wall' % self.cc,\n            compiler_so='%s -mcygwin -mdll -O -Wall' % self.cc,\n            compiler_cxx='%s -mcygwin -O -Wall' % self.cxx,\n            linker_exe='%s -mcygwin' % self.cc,\n            linker_so=(f'{self.linker_dll} -mcygwin {shared_option}'),\n        )\n\n        # Include the appropriate MSVC runtime library if Python was built\n        # with MSVC 7.0 or later.\n        self.dll_libraries = get_msvcr()\n\n    @property\n    def gcc_version(self):\n        # Older numpy depended on this existing to check for ancient\n        # gcc versions. This doesn't make much sense with clang etc so\n        # just hardcode to something recent.\n        # https://github.com/numpy/numpy/pull/20333\n        warnings.warn(\n            \"gcc_version attribute of CygwinCCompiler is deprecated. \"\n            \"Instead of returning actual gcc version a fixed value 11.2.0 is returned.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        with suppress_known_deprecation():\n            return LooseVersion(\"11.2.0\")\n\n    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compiles the source by spawning GCC and windres if needed.\"\"\"\n        if ext in ('.rc', '.res'):\n            # gcc needs '.res' and '.rc' compiled to object files !!!\n            try:\n                self.spawn([\"windres\", \"-i\", src, \"-o\", obj])\n            except DistutilsExecError as msg:\n                raise CompileError(msg)\n        else:  # for other files use the C-compiler\n            try:\n                self.spawn(\n                    self.compiler_so + cc_args + [src, '-o', obj] + extra_postargs\n                )\n            except DistutilsExecError as msg:\n                raise CompileError(msg)\n\n    def link(\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        \"\"\"Link the objects.\"\"\"\n        # use separate copies, so we can modify the lists\n        extra_preargs = copy.copy(extra_preargs or [])\n        libraries = copy.copy(libraries or [])\n        objects = copy.copy(objects or [])\n\n        if runtime_library_dirs:\n            self.warn(_runtime_library_dirs_msg)\n\n        # Additional libraries\n        libraries.extend(self.dll_libraries)\n\n        # handle export symbols by creating a def-file\n        # with executables this only works with gcc/ld as linker\n        if (export_symbols is not None) and (\n            target_desc != self.EXECUTABLE or self.linker_dll == \"gcc\"\n        ):\n            # (The linker doesn't do anything if output is up-to-date.\n            # So it would probably better to check if we really need this,\n            # but for this we had to insert some unchanged parts of\n            # UnixCCompiler, and this is not what we want.)\n\n            # we want to put some files in the same directory as the\n            # object files are, build_temp doesn't help much\n            # where are the object files\n            temp_dir = os.path.dirname(objects[0])\n            # name of dll to give the helper files the same base name\n            (dll_name, dll_extension) = os.path.splitext(\n                os.path.basename(output_filename)\n            )\n\n            # generate the filenames for these files\n            def_file = os.path.join(temp_dir, dll_name + \".def\")\n\n            # Generate .def file\n            contents = [\"LIBRARY %s\" % os.path.basename(output_filename), \"EXPORTS\"]\n            for sym in export_symbols:\n                contents.append(sym)\n            self.execute(write_file, (def_file, contents), \"writing %s\" % def_file)\n\n            # next add options for def-file\n\n            # for gcc/ld the def-file is specified as any object files\n            objects.append(def_file)\n\n        # end: if ((export_symbols is not None) and\n        #        (target_desc != self.EXECUTABLE or self.linker_dll == \"gcc\")):\n\n        # who wants symbols and a many times larger output file\n        # should explicitly switch the debug mode on\n        # otherwise we let ld strip the output file\n        # (On my machine: 10KiB < stripped_file < ??100KiB\n        #   unstripped_file = stripped_file + XXX KiB\n        #  ( XXX=254 for a typical python extension))\n        if not debug:\n            extra_preargs.append(\"-s\")\n\n        UnixCCompiler.link(\n            self,\n            target_desc,\n            objects,\n            output_filename,\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            None,  # export_symbols, we do this in our def-file\n            debug,\n            extra_preargs,\n            extra_postargs,\n            build_temp,\n            target_lang,\n        )\n\n    def runtime_library_dir_option(self, dir):\n        # cygwin doesn't support rpath. While in theory we could error\n        # out like MSVC does, code might expect it to work like on Unix, so\n        # just warn and hope for the best.\n        self.warn(_runtime_library_dirs_msg)\n        return []\n\n    # -- Miscellaneous methods -----------------------------------------\n\n    def _make_out_path(self, output_dir, strip_dir, src_name):\n        # use normcase to make sure '.rc' is really '.rc' and not '.RC'\n        norm_src_name = os.path.normcase(src_name)\n        return super()._make_out_path(output_dir, strip_dir, norm_src_name)\n\n    @property\n    def out_extensions(self):\n        \"\"\"\n        Add support for rc and res files.\n        \"\"\"\n        return {\n            **super().out_extensions,\n            **{ext: ext + self.obj_extension for ext in ('.res', '.rc')},\n        }\n\n\n# the same as cygwin plus some additional parameters\nclass Mingw32CCompiler(CygwinCCompiler):\n    \"\"\"Handles the Mingw32 port of the GNU C compiler to Windows.\"\"\"\n\n    compiler_type = 'mingw32'\n\n    def __init__(self, verbose=0, dry_run=0, force=0):\n        super().__init__(verbose, dry_run, force)\n\n        shared_option = \"-shared\"\n\n        if is_cygwincc(self.cc):\n            raise CCompilerError('Cygwin gcc cannot be used with --compiler=mingw32')\n\n        self.set_executables(\n            compiler='%s -O -Wall' % self.cc,\n            compiler_so='%s -mdll -O -Wall' % self.cc,\n            compiler_cxx='%s -O -Wall' % self.cxx,\n            linker_exe='%s' % self.cc,\n            linker_so=f'{self.linker_dll} {shared_option}',\n        )\n\n    def runtime_library_dir_option(self, dir):\n        raise DistutilsPlatformError(_runtime_library_dirs_msg)\n\n\n# Because these compilers aren't configured in Python's pyconfig.h file by\n# default, we should at least warn the user if he is using an unmodified\n# version.\n\nCONFIG_H_OK = \"ok\"\nCONFIG_H_NOTOK = \"not ok\"\nCONFIG_H_UNCERTAIN = \"uncertain\"\n\n\ndef check_config_h():\n    \"\"\"Check if the current Python installation appears amenable to building\n    extensions with GCC.\n\n    Returns a tuple (status, details), where 'status' is one of the following\n    constants:\n\n    - CONFIG_H_OK: all is well, go ahead and compile\n    - CONFIG_H_NOTOK: doesn't look good\n    - CONFIG_H_UNCERTAIN: not sure -- unable to read pyconfig.h\n\n    'details' is a human-readable string explaining the situation.\n\n    Note there are two ways to conclude \"OK\": either 'sys.version' contains\n    the string \"GCC\" (implying that this Python was built with GCC), or the\n    installed \"pyconfig.h\" contains the string \"__GNUC__\".\n    \"\"\"\n\n    # XXX since this function also checks sys.version, it's not strictly a\n    # \"pyconfig.h\" check -- should probably be renamed...\n\n    from distutils import sysconfig\n\n    # if sys.version contains GCC then python was compiled with GCC, and the\n    # pyconfig.h file should be OK\n    if \"GCC\" in sys.version:\n        return CONFIG_H_OK, \"sys.version mentions 'GCC'\"\n\n    # Clang would also work\n    if \"Clang\" in sys.version:\n        return CONFIG_H_OK, \"sys.version mentions 'Clang'\"\n\n    # let's see if __GNUC__ is mentioned in python.h\n    fn = sysconfig.get_config_h_filename()\n    try:\n        config_h = pathlib.Path(fn).read_text(encoding='utf-8')\n        substring = '__GNUC__'\n        if substring in config_h:\n            code = CONFIG_H_OK\n            mention_inflected = 'mentions'\n        else:\n            code = CONFIG_H_NOTOK\n            mention_inflected = 'does not mention'\n        return code, f\"{fn!r} {mention_inflected} {substring!r}\"\n    except OSError as exc:\n        return (CONFIG_H_UNCERTAIN, f\"couldn't read '{fn}': {exc.strerror}\")\n\n\ndef is_cygwincc(cc):\n    \"\"\"Try to determine if the compiler that would be used is from cygwin.\"\"\"\n    out_string = check_output(shlex.split(cc) + ['-dumpmachine'])\n    return out_string.strip().endswith(b'cygwin')\n\n\nget_versions = None\n\"\"\"\nA stand-in for the previous get_versions() function to prevent failures\nwhen monkeypatched. See pypa/setuptools#2969.\n\"\"\"\n", "setuptools/_distutils/_collections.py": "from __future__ import annotations\n\nimport collections\nimport functools\nimport itertools\nimport operator\nfrom collections.abc import Mapping\nfrom typing import Any\n\n\n# from jaraco.collections 3.5.1\nclass DictStack(list, collections.abc.Mapping):\n    \"\"\"\n    A stack of dictionaries that behaves as a view on those dictionaries,\n    giving preference to the last.\n\n    >>> stack = DictStack([dict(a=1, c=2), dict(b=2, a=2)])\n    >>> stack['a']\n    2\n    >>> stack['b']\n    2\n    >>> stack['c']\n    2\n    >>> len(stack)\n    3\n    >>> stack.push(dict(a=3))\n    >>> stack['a']\n    3\n    >>> set(stack.keys()) == set(['a', 'b', 'c'])\n    True\n    >>> set(stack.items()) == set([('a', 3), ('b', 2), ('c', 2)])\n    True\n    >>> dict(**stack) == dict(stack) == dict(a=3, c=2, b=2)\n    True\n    >>> d = stack.pop()\n    >>> stack['a']\n    2\n    >>> d = stack.pop()\n    >>> stack['a']\n    1\n    >>> stack.get('b', None)\n    >>> 'c' in stack\n    True\n    \"\"\"\n\n    def __iter__(self):\n        dicts = list.__iter__(self)\n        return iter(set(itertools.chain.from_iterable(c.keys() for c in dicts)))\n\n    def __getitem__(self, key):\n        for scope in reversed(tuple(list.__iter__(self))):\n            if key in scope:\n                return scope[key]\n        raise KeyError(key)\n\n    push = list.append\n\n    def __contains__(self, other):\n        return collections.abc.Mapping.__contains__(self, other)\n\n    def __len__(self):\n        return len(list(iter(self)))\n\n\n# from jaraco.collections 5.0.1\nclass RangeMap(dict):\n    \"\"\"\n    A dictionary-like object that uses the keys as bounds for a range.\n    Inclusion of the value for that range is determined by the\n    key_match_comparator, which defaults to less-than-or-equal.\n    A value is returned for a key if it is the first key that matches in\n    the sorted list of keys.\n\n    One may supply keyword parameters to be passed to the sort function used\n    to sort keys (i.e. key, reverse) as sort_params.\n\n    Create a map that maps 1-3 -> 'a', 4-6 -> 'b'\n\n    >>> r = RangeMap({3: 'a', 6: 'b'})  # boy, that was easy\n    >>> r[1], r[2], r[3], r[4], r[5], r[6]\n    ('a', 'a', 'a', 'b', 'b', 'b')\n\n    Even float values should work so long as the comparison operator\n    supports it.\n\n    >>> r[4.5]\n    'b'\n\n    Notice that the way rangemap is defined, it must be open-ended\n    on one side.\n\n    >>> r[0]\n    'a'\n    >>> r[-1]\n    'a'\n\n    One can close the open-end of the RangeMap by using undefined_value\n\n    >>> r = RangeMap({0: RangeMap.undefined_value, 3: 'a', 6: 'b'})\n    >>> r[0]\n    Traceback (most recent call last):\n    ...\n    KeyError: 0\n\n    One can get the first or last elements in the range by using RangeMap.Item\n\n    >>> last_item = RangeMap.Item(-1)\n    >>> r[last_item]\n    'b'\n\n    .last_item is a shortcut for Item(-1)\n\n    >>> r[RangeMap.last_item]\n    'b'\n\n    Sometimes it's useful to find the bounds for a RangeMap\n\n    >>> r.bounds()\n    (0, 6)\n\n    RangeMap supports .get(key, default)\n\n    >>> r.get(0, 'not found')\n    'not found'\n\n    >>> r.get(7, 'not found')\n    'not found'\n\n    One often wishes to define the ranges by their left-most values,\n    which requires use of sort params and a key_match_comparator.\n\n    >>> r = RangeMap({1: 'a', 4: 'b'},\n    ...     sort_params=dict(reverse=True),\n    ...     key_match_comparator=operator.ge)\n    >>> r[1], r[2], r[3], r[4], r[5], r[6]\n    ('a', 'a', 'a', 'b', 'b', 'b')\n\n    That wasn't nearly as easy as before, so an alternate constructor\n    is provided:\n\n    >>> r = RangeMap.left({1: 'a', 4: 'b', 7: RangeMap.undefined_value})\n    >>> r[1], r[2], r[3], r[4], r[5], r[6]\n    ('a', 'a', 'a', 'b', 'b', 'b')\n\n    \"\"\"\n\n    def __init__(\n        self,\n        source,\n        sort_params: Mapping[str, Any] = {},\n        key_match_comparator=operator.le,\n    ):\n        dict.__init__(self, source)\n        self.sort_params = sort_params\n        self.match = key_match_comparator\n\n    @classmethod\n    def left(cls, source):\n        return cls(\n            source, sort_params=dict(reverse=True), key_match_comparator=operator.ge\n        )\n\n    def __getitem__(self, item):\n        sorted_keys = sorted(self.keys(), **self.sort_params)\n        if isinstance(item, RangeMap.Item):\n            result = self.__getitem__(sorted_keys[item])\n        else:\n            key = self._find_first_match_(sorted_keys, item)\n            result = dict.__getitem__(self, key)\n            if result is RangeMap.undefined_value:\n                raise KeyError(key)\n        return result\n\n    def get(self, key, default=None):\n        \"\"\"\n        Return the value for key if key is in the dictionary, else default.\n        If default is not given, it defaults to None, so that this method\n        never raises a KeyError.\n        \"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def _find_first_match_(self, keys, item):\n        is_match = functools.partial(self.match, item)\n        matches = list(filter(is_match, keys))\n        if matches:\n            return matches[0]\n        raise KeyError(item)\n\n    def bounds(self):\n        sorted_keys = sorted(self.keys(), **self.sort_params)\n        return (sorted_keys[RangeMap.first_item], sorted_keys[RangeMap.last_item])\n\n    # some special values for the RangeMap\n    undefined_value = type('RangeValueUndefined', (), {})()\n\n    class Item(int):\n        \"RangeMap Item\"\n\n    first_item = Item(0)\n    last_item = Item(-1)\n", "setuptools/_distutils/file_util.py": "\"\"\"distutils.file_util\n\nUtility functions for operating on single files.\n\"\"\"\n\nimport os\n\nfrom ._log import log\nfrom .errors import DistutilsFileError\n\n# for generating verbose output in 'copy_file()'\n_copy_action = {None: 'copying', 'hard': 'hard linking', 'sym': 'symbolically linking'}\n\n\ndef _copy_file_contents(src, dst, buffer_size=16 * 1024):  # noqa: C901\n    \"\"\"Copy the file 'src' to 'dst'; both must be filenames.  Any error\n    opening either file, reading from 'src', or writing to 'dst', raises\n    DistutilsFileError.  Data is read/written in chunks of 'buffer_size'\n    bytes (default 16k).  No attempt is made to handle anything apart from\n    regular files.\n    \"\"\"\n    # Stolen from shutil module in the standard library, but with\n    # custom error-handling added.\n    fsrc = None\n    fdst = None\n    try:\n        try:\n            fsrc = open(src, 'rb')\n        except OSError as e:\n            raise DistutilsFileError(f\"could not open '{src}': {e.strerror}\")\n\n        if os.path.exists(dst):\n            try:\n                os.unlink(dst)\n            except OSError as e:\n                raise DistutilsFileError(f\"could not delete '{dst}': {e.strerror}\")\n\n        try:\n            fdst = open(dst, 'wb')\n        except OSError as e:\n            raise DistutilsFileError(f\"could not create '{dst}': {e.strerror}\")\n\n        while True:\n            try:\n                buf = fsrc.read(buffer_size)\n            except OSError as e:\n                raise DistutilsFileError(f\"could not read from '{src}': {e.strerror}\")\n\n            if not buf:\n                break\n\n            try:\n                fdst.write(buf)\n            except OSError as e:\n                raise DistutilsFileError(f\"could not write to '{dst}': {e.strerror}\")\n    finally:\n        if fdst:\n            fdst.close()\n        if fsrc:\n            fsrc.close()\n\n\ndef copy_file(  # noqa: C901\n    src,\n    dst,\n    preserve_mode=1,\n    preserve_times=1,\n    update=0,\n    link=None,\n    verbose=1,\n    dry_run=0,\n):\n    \"\"\"Copy a file 'src' to 'dst'.  If 'dst' is a directory, then 'src' is\n    copied there with the same name; otherwise, it must be a filename.  (If\n    the file exists, it will be ruthlessly clobbered.)  If 'preserve_mode'\n    is true (the default), the file's mode (type and permission bits, or\n    whatever is analogous on the current platform) is copied.  If\n    'preserve_times' is true (the default), the last-modified and\n    last-access times are copied as well.  If 'update' is true, 'src' will\n    only be copied if 'dst' does not exist, or if 'dst' does exist but is\n    older than 'src'.\n\n    'link' allows you to make hard links (os.link) or symbolic links\n    (os.symlink) instead of copying: set it to \"hard\" or \"sym\"; if it is\n    None (the default), files are copied.  Don't set 'link' on systems that\n    don't support it: 'copy_file()' doesn't check if hard or symbolic\n    linking is available. If hardlink fails, falls back to\n    _copy_file_contents().\n\n    Under Mac OS, uses the native file copy function in macostools; on\n    other systems, uses '_copy_file_contents()' to copy file contents.\n\n    Return a tuple (dest_name, copied): 'dest_name' is the actual name of\n    the output file, and 'copied' is true if the file was copied (or would\n    have been copied, if 'dry_run' true).\n    \"\"\"\n    # XXX if the destination file already exists, we clobber it if\n    # copying, but blow up if linking.  Hmmm.  And I don't know what\n    # macostools.copyfile() does.  Should definitely be consistent, and\n    # should probably blow up if destination exists and we would be\n    # changing it (ie. it's not already a hard/soft link to src OR\n    # (not update) and (src newer than dst).\n\n    from distutils._modified import newer\n    from stat import S_IMODE, ST_ATIME, ST_MODE, ST_MTIME\n\n    if not os.path.isfile(src):\n        raise DistutilsFileError(\n            \"can't copy '%s': doesn't exist or not a regular file\" % src\n        )\n\n    if os.path.isdir(dst):\n        dir = dst\n        dst = os.path.join(dst, os.path.basename(src))\n    else:\n        dir = os.path.dirname(dst)\n\n    if update and not newer(src, dst):\n        if verbose >= 1:\n            log.debug(\"not copying %s (output up-to-date)\", src)\n        return (dst, 0)\n\n    try:\n        action = _copy_action[link]\n    except KeyError:\n        raise ValueError(\"invalid value '%s' for 'link' argument\" % link)\n\n    if verbose >= 1:\n        if os.path.basename(dst) == os.path.basename(src):\n            log.info(\"%s %s -> %s\", action, src, dir)\n        else:\n            log.info(\"%s %s -> %s\", action, src, dst)\n\n    if dry_run:\n        return (dst, 1)\n\n    # If linking (hard or symbolic), use the appropriate system call\n    # (Unix only, of course, but that's the caller's responsibility)\n    elif link == 'hard':\n        if not (os.path.exists(dst) and os.path.samefile(src, dst)):\n            try:\n                os.link(src, dst)\n                return (dst, 1)\n            except OSError:\n                # If hard linking fails, fall back on copying file\n                # (some special filesystems don't support hard linking\n                #  even under Unix, see issue #8876).\n                pass\n    elif link == 'sym':\n        if not (os.path.exists(dst) and os.path.samefile(src, dst)):\n            os.symlink(src, dst)\n            return (dst, 1)\n\n    # Otherwise (non-Mac, not linking), copy the file contents and\n    # (optionally) copy the times and mode.\n    _copy_file_contents(src, dst)\n    if preserve_mode or preserve_times:\n        st = os.stat(src)\n\n        # According to David Ascher <da@ski.org>, utime() should be done\n        # before chmod() (at least under NT).\n        if preserve_times:\n            os.utime(dst, (st[ST_ATIME], st[ST_MTIME]))\n        if preserve_mode:\n            os.chmod(dst, S_IMODE(st[ST_MODE]))\n\n    return (dst, 1)\n\n\n# XXX I suspect this is Unix-specific -- need porting help!\ndef move_file(src, dst, verbose=1, dry_run=0):  # noqa: C901\n    \"\"\"Move a file 'src' to 'dst'.  If 'dst' is a directory, the file will\n    be moved into it with the same name; otherwise, 'src' is just renamed\n    to 'dst'.  Return the new full name of the file.\n\n    Handles cross-device moves on Unix using 'copy_file()'.  What about\n    other systems???\n    \"\"\"\n    import errno\n    from os.path import basename, dirname, exists, isdir, isfile\n\n    if verbose >= 1:\n        log.info(\"moving %s -> %s\", src, dst)\n\n    if dry_run:\n        return dst\n\n    if not isfile(src):\n        raise DistutilsFileError(\"can't move '%s': not a regular file\" % src)\n\n    if isdir(dst):\n        dst = os.path.join(dst, basename(src))\n    elif exists(dst):\n        raise DistutilsFileError(\n            f\"can't move '{src}': destination '{dst}' already exists\"\n        )\n\n    if not isdir(dirname(dst)):\n        raise DistutilsFileError(\n            f\"can't move '{src}': destination '{dst}' not a valid path\"\n        )\n\n    copy_it = False\n    try:\n        os.rename(src, dst)\n    except OSError as e:\n        (num, msg) = e.args\n        if num == errno.EXDEV:\n            copy_it = True\n        else:\n            raise DistutilsFileError(f\"couldn't move '{src}' to '{dst}': {msg}\")\n\n    if copy_it:\n        copy_file(src, dst, verbose=verbose)\n        try:\n            os.unlink(src)\n        except OSError as e:\n            (num, msg) = e.args\n            try:\n                os.unlink(dst)\n            except OSError:\n                pass\n            raise DistutilsFileError(\n                f\"couldn't move '{src}' to '{dst}' by copy/delete: \"\n                f\"delete '{src}' failed: {msg}\"\n            )\n    return dst\n\n\ndef write_file(filename, contents):\n    \"\"\"Create a file with the specified name and write 'contents' (a\n    sequence of strings without line terminators) to it.\n    \"\"\"\n    with open(filename, 'w', encoding='utf-8') as f:\n        f.writelines(line + '\\n' for line in contents)\n", "setuptools/_distutils/fancy_getopt.py": "\"\"\"distutils.fancy_getopt\n\nWrapper around the standard getopt module that provides the following\nadditional features:\n  * short and long options are tied together\n  * options have help strings, so fancy_getopt could potentially\n    create a complete usage summary\n  * options set attributes of a passed-in object\n\"\"\"\n\nimport getopt\nimport re\nimport string\nimport sys\nfrom typing import Any, Sequence\n\nfrom .errors import DistutilsArgError, DistutilsGetoptError\n\n# Much like command_re in distutils.core, this is close to but not quite\n# the same as a Python NAME -- except, in the spirit of most GNU\n# utilities, we use '-' in place of '_'.  (The spirit of LISP lives on!)\n# The similarities to NAME are again not a coincidence...\nlongopt_pat = r'[a-zA-Z](?:[a-zA-Z0-9-]*)'\nlongopt_re = re.compile(r'^%s$' % longopt_pat)\n\n# For recognizing \"negative alias\" options, eg. \"quiet=!verbose\"\nneg_alias_re = re.compile(f\"^({longopt_pat})=!({longopt_pat})$\")\n\n# This is used to translate long options to legitimate Python identifiers\n# (for use as attributes of some object).\nlongopt_xlate = str.maketrans('-', '_')\n\n\nclass FancyGetopt:\n    \"\"\"Wrapper around the standard 'getopt()' module that provides some\n    handy extra functionality:\n      * short and long options are tied together\n      * options have help strings, and help text can be assembled\n        from them\n      * options set attributes of a passed-in object\n      * boolean options can have \"negative aliases\" -- eg. if\n        --quiet is the \"negative alias\" of --verbose, then \"--quiet\"\n        on the command line sets 'verbose' to false\n    \"\"\"\n\n    def __init__(self, option_table=None):\n        # The option table is (currently) a list of tuples.  The\n        # tuples may have 3 or four values:\n        #   (long_option, short_option, help_string [, repeatable])\n        # if an option takes an argument, its long_option should have '='\n        # appended; short_option should just be a single character, no ':'\n        # in any case.  If a long_option doesn't have a corresponding\n        # short_option, short_option should be None.  All option tuples\n        # must have long options.\n        self.option_table = option_table\n\n        # 'option_index' maps long option names to entries in the option\n        # table (ie. those 3-tuples).\n        self.option_index = {}\n        if self.option_table:\n            self._build_index()\n\n        # 'alias' records (duh) alias options; {'foo': 'bar'} means\n        # --foo is an alias for --bar\n        self.alias = {}\n\n        # 'negative_alias' keeps track of options that are the boolean\n        # opposite of some other option\n        self.negative_alias = {}\n\n        # These keep track of the information in the option table.  We\n        # don't actually populate these structures until we're ready to\n        # parse the command-line, since the 'option_table' passed in here\n        # isn't necessarily the final word.\n        self.short_opts = []\n        self.long_opts = []\n        self.short2long = {}\n        self.attr_name = {}\n        self.takes_arg = {}\n\n        # And 'option_order' is filled up in 'getopt()'; it records the\n        # original order of options (and their values) on the command-line,\n        # but expands short options, converts aliases, etc.\n        self.option_order = []\n\n    def _build_index(self):\n        self.option_index.clear()\n        for option in self.option_table:\n            self.option_index[option[0]] = option\n\n    def set_option_table(self, option_table):\n        self.option_table = option_table\n        self._build_index()\n\n    def add_option(self, long_option, short_option=None, help_string=None):\n        if long_option in self.option_index:\n            raise DistutilsGetoptError(\n                \"option conflict: already an option '%s'\" % long_option\n            )\n        else:\n            option = (long_option, short_option, help_string)\n            self.option_table.append(option)\n            self.option_index[long_option] = option\n\n    def has_option(self, long_option):\n        \"\"\"Return true if the option table for this parser has an\n        option with long name 'long_option'.\"\"\"\n        return long_option in self.option_index\n\n    def get_attr_name(self, long_option):\n        \"\"\"Translate long option name 'long_option' to the form it\n        has as an attribute of some object: ie., translate hyphens\n        to underscores.\"\"\"\n        return long_option.translate(longopt_xlate)\n\n    def _check_alias_dict(self, aliases, what):\n        assert isinstance(aliases, dict)\n        for alias, opt in aliases.items():\n            if alias not in self.option_index:\n                raise DistutilsGetoptError(\n                    f\"invalid {what} '{alias}': \" f\"option '{alias}' not defined\"\n                )\n            if opt not in self.option_index:\n                raise DistutilsGetoptError(\n                    f\"invalid {what} '{alias}': \" f\"aliased option '{opt}' not defined\"\n                )\n\n    def set_aliases(self, alias):\n        \"\"\"Set the aliases for this option parser.\"\"\"\n        self._check_alias_dict(alias, \"alias\")\n        self.alias = alias\n\n    def set_negative_aliases(self, negative_alias):\n        \"\"\"Set the negative aliases for this option parser.\n        'negative_alias' should be a dictionary mapping option names to\n        option names, both the key and value must already be defined\n        in the option table.\"\"\"\n        self._check_alias_dict(negative_alias, \"negative alias\")\n        self.negative_alias = negative_alias\n\n    def _grok_option_table(self):  # noqa: C901\n        \"\"\"Populate the various data structures that keep tabs on the\n        option table.  Called by 'getopt()' before it can do anything\n        worthwhile.\n        \"\"\"\n        self.long_opts = []\n        self.short_opts = []\n        self.short2long.clear()\n        self.repeat = {}\n\n        for option in self.option_table:\n            if len(option) == 3:\n                long, short, help = option\n                repeat = 0\n            elif len(option) == 4:\n                long, short, help, repeat = option\n            else:\n                # the option table is part of the code, so simply\n                # assert that it is correct\n                raise ValueError(f\"invalid option tuple: {option!r}\")\n\n            # Type- and value-check the option names\n            if not isinstance(long, str) or len(long) < 2:\n                raise DistutilsGetoptError(\n                    (\"invalid long option '%s': must be a string of length >= 2\") % long\n                )\n\n            if not ((short is None) or (isinstance(short, str) and len(short) == 1)):\n                raise DistutilsGetoptError(\n                    \"invalid short option '%s': \"\n                    \"must a single character or None\" % short\n                )\n\n            self.repeat[long] = repeat\n            self.long_opts.append(long)\n\n            if long[-1] == '=':  # option takes an argument?\n                if short:\n                    short = short + ':'\n                long = long[0:-1]\n                self.takes_arg[long] = 1\n            else:\n                # Is option is a \"negative alias\" for some other option (eg.\n                # \"quiet\" == \"!verbose\")?\n                alias_to = self.negative_alias.get(long)\n                if alias_to is not None:\n                    if self.takes_arg[alias_to]:\n                        raise DistutilsGetoptError(\n                            f\"invalid negative alias '{long}': \"\n                            f\"aliased option '{alias_to}' takes a value\"\n                        )\n\n                    self.long_opts[-1] = long  # XXX redundant?!\n                self.takes_arg[long] = 0\n\n            # If this is an alias option, make sure its \"takes arg\" flag is\n            # the same as the option it's aliased to.\n            alias_to = self.alias.get(long)\n            if alias_to is not None:\n                if self.takes_arg[long] != self.takes_arg[alias_to]:\n                    raise DistutilsGetoptError(\n                        f\"invalid alias '{long}': inconsistent with \"\n                        f\"aliased option '{alias_to}' (one of them takes a value, \"\n                        \"the other doesn't\"\n                    )\n\n            # Now enforce some bondage on the long option name, so we can\n            # later translate it to an attribute name on some object.  Have\n            # to do this a bit late to make sure we've removed any trailing\n            # '='.\n            if not longopt_re.match(long):\n                raise DistutilsGetoptError(\n                    \"invalid long option name '%s' \"\n                    \"(must be letters, numbers, hyphens only\" % long\n                )\n\n            self.attr_name[long] = self.get_attr_name(long)\n            if short:\n                self.short_opts.append(short)\n                self.short2long[short[0]] = long\n\n    def getopt(self, args=None, object=None):  # noqa: C901\n        \"\"\"Parse command-line options in args. Store as attributes on object.\n\n        If 'args' is None or not supplied, uses 'sys.argv[1:]'.  If\n        'object' is None or not supplied, creates a new OptionDummy\n        object, stores option values there, and returns a tuple (args,\n        object).  If 'object' is supplied, it is modified in place and\n        'getopt()' just returns 'args'; in both cases, the returned\n        'args' is a modified copy of the passed-in 'args' list, which\n        is left untouched.\n        \"\"\"\n        if args is None:\n            args = sys.argv[1:]\n        if object is None:\n            object = OptionDummy()\n            created_object = True\n        else:\n            created_object = False\n\n        self._grok_option_table()\n\n        short_opts = ' '.join(self.short_opts)\n        try:\n            opts, args = getopt.getopt(args, short_opts, self.long_opts)\n        except getopt.error as msg:\n            raise DistutilsArgError(msg)\n\n        for opt, val in opts:\n            if len(opt) == 2 and opt[0] == '-':  # it's a short option\n                opt = self.short2long[opt[1]]\n            else:\n                assert len(opt) > 2 and opt[:2] == '--'\n                opt = opt[2:]\n\n            alias = self.alias.get(opt)\n            if alias:\n                opt = alias\n\n            if not self.takes_arg[opt]:  # boolean option?\n                assert val == '', \"boolean option can't have value\"\n                alias = self.negative_alias.get(opt)\n                if alias:\n                    opt = alias\n                    val = 0\n                else:\n                    val = 1\n\n            attr = self.attr_name[opt]\n            # The only repeating option at the moment is 'verbose'.\n            # It has a negative option -q quiet, which should set verbose = 0.\n            if val and self.repeat.get(attr) is not None:\n                val = getattr(object, attr, 0) + 1\n            setattr(object, attr, val)\n            self.option_order.append((opt, val))\n\n        # for opts\n        if created_object:\n            return args, object\n        else:\n            return args\n\n    def get_option_order(self):\n        \"\"\"Returns the list of (option, value) tuples processed by the\n        previous run of 'getopt()'.  Raises RuntimeError if\n        'getopt()' hasn't been called yet.\n        \"\"\"\n        if self.option_order is None:\n            raise RuntimeError(\"'getopt()' hasn't been called yet\")\n        else:\n            return self.option_order\n\n    def generate_help(self, header=None):  # noqa: C901\n        \"\"\"Generate help text (a list of strings, one per suggested line of\n        output) from the option table for this FancyGetopt object.\n        \"\"\"\n        # Blithely assume the option table is good: probably wouldn't call\n        # 'generate_help()' unless you've already called 'getopt()'.\n\n        # First pass: determine maximum length of long option names\n        max_opt = 0\n        for option in self.option_table:\n            long = option[0]\n            short = option[1]\n            ell = len(long)\n            if long[-1] == '=':\n                ell = ell - 1\n            if short is not None:\n                ell = ell + 5  # \" (-x)\" where short == 'x'\n            if ell > max_opt:\n                max_opt = ell\n\n        opt_width = max_opt + 2 + 2 + 2  # room for indent + dashes + gutter\n\n        # Typical help block looks like this:\n        #   --foo       controls foonabulation\n        # Help block for longest option looks like this:\n        #   --flimflam  set the flim-flam level\n        # and with wrapped text:\n        #   --flimflam  set the flim-flam level (must be between\n        #               0 and 100, except on Tuesdays)\n        # Options with short names will have the short name shown (but\n        # it doesn't contribute to max_opt):\n        #   --foo (-f)  controls foonabulation\n        # If adding the short option would make the left column too wide,\n        # we push the explanation off to the next line\n        #   --flimflam (-l)\n        #               set the flim-flam level\n        # Important parameters:\n        #   - 2 spaces before option block start lines\n        #   - 2 dashes for each long option name\n        #   - min. 2 spaces between option and explanation (gutter)\n        #   - 5 characters (incl. space) for short option name\n\n        # Now generate lines of help text.  (If 80 columns were good enough\n        # for Jesus, then 78 columns are good enough for me!)\n        line_width = 78\n        text_width = line_width - opt_width\n        big_indent = ' ' * opt_width\n        if header:\n            lines = [header]\n        else:\n            lines = ['Option summary:']\n\n        for option in self.option_table:\n            long, short, help = option[:3]\n            text = wrap_text(help, text_width)\n            if long[-1] == '=':\n                long = long[0:-1]\n\n            # Case 1: no short option at all (makes life easy)\n            if short is None:\n                if text:\n                    lines.append(\"  --%-*s  %s\" % (max_opt, long, text[0]))\n                else:\n                    lines.append(\"  --%-*s  \" % (max_opt, long))\n\n            # Case 2: we have a short option, so we have to include it\n            # just after the long option\n            else:\n                opt_names = f\"{long} (-{short})\"\n                if text:\n                    lines.append(\"  --%-*s  %s\" % (max_opt, opt_names, text[0]))\n                else:\n                    lines.append(\"  --%-*s\" % opt_names)\n\n            for ell in text[1:]:\n                lines.append(big_indent + ell)\n        return lines\n\n    def print_help(self, header=None, file=None):\n        if file is None:\n            file = sys.stdout\n        for line in self.generate_help(header):\n            file.write(line + \"\\n\")\n\n\ndef fancy_getopt(options, negative_opt, object, args):\n    parser = FancyGetopt(options)\n    parser.set_negative_aliases(negative_opt)\n    return parser.getopt(args, object)\n\n\nWS_TRANS = {ord(_wschar): ' ' for _wschar in string.whitespace}\n\n\ndef wrap_text(text, width):\n    \"\"\"wrap_text(text : string, width : int) -> [string]\n\n    Split 'text' into multiple lines of no more than 'width' characters\n    each, and return the list of strings that results.\n    \"\"\"\n    if text is None:\n        return []\n    if len(text) <= width:\n        return [text]\n\n    text = text.expandtabs()\n    text = text.translate(WS_TRANS)\n    chunks = re.split(r'( +|-+)', text)\n    chunks = [ch for ch in chunks if ch]  # ' - ' results in empty strings\n    lines = []\n\n    while chunks:\n        cur_line = []  # list of chunks (to-be-joined)\n        cur_len = 0  # length of current line\n\n        while chunks:\n            ell = len(chunks[0])\n            if cur_len + ell <= width:  # can squeeze (at least) this chunk in\n                cur_line.append(chunks[0])\n                del chunks[0]\n                cur_len = cur_len + ell\n            else:  # this line is full\n                # drop last chunk if all space\n                if cur_line and cur_line[-1][0] == ' ':\n                    del cur_line[-1]\n                break\n\n        if chunks:  # any chunks left to process?\n            # if the current line is still empty, then we had a single\n            # chunk that's too big too fit on a line -- so we break\n            # down and break it up at the line width\n            if cur_len == 0:\n                cur_line.append(chunks[0][0:width])\n                chunks[0] = chunks[0][width:]\n\n            # all-whitespace chunks at the end of a line can be discarded\n            # (and we know from the re.split above that if a chunk has\n            # *any* whitespace, it is *all* whitespace)\n            if chunks[0][0] == ' ':\n                del chunks[0]\n\n        # and store this line in the list-of-all-lines -- as a single\n        # string, of course!\n        lines.append(''.join(cur_line))\n\n    return lines\n\n\ndef translate_longopt(opt):\n    \"\"\"Convert a long option name to a valid Python identifier by\n    changing \"-\" to \"_\".\n    \"\"\"\n    return opt.translate(longopt_xlate)\n\n\nclass OptionDummy:\n    \"\"\"Dummy class just used as a place to hold command-line option\n    values as instance attributes.\"\"\"\n\n    def __init__(self, options: Sequence[Any] = []):\n        \"\"\"Create a new OptionDummy instance.  The attributes listed in\n        'options' will be initialized to None.\"\"\"\n        for opt in options:\n            setattr(self, opt, None)\n\n\nif __name__ == \"__main__\":\n    text = \"\"\"\\\nTra-la-la, supercalifragilisticexpialidocious.\nHow *do* you spell that odd word, anyways?\n(Someone ask Mary -- she'll know [or she'll\nsay, \"How should I know?\"].)\"\"\"\n\n    for w in (10, 20, 30, 40):\n        print(\"width: %d\" % w)\n        print(\"\\n\".join(wrap_text(text, w)))\n        print()\n", "setuptools/_distutils/py38compat.py": "def aix_platform(osname, version, release):\n    try:\n        import _aix_support\n\n        return _aix_support.aix_platform()\n    except ImportError:\n        pass\n    return f\"{osname}-{version}.{release}\"\n", "setuptools/_distutils/bcppcompiler.py": "\"\"\"distutils.bcppcompiler\n\nContains BorlandCCompiler, an implementation of the abstract CCompiler class\nfor the Borland C++ compiler.\n\"\"\"\n\n# This implementation by Lyle Johnson, based on the original msvccompiler.py\n# module and using the directions originally published by Gordon Williams.\n\n# XXX looks like there's a LOT of overlap between these two classes:\n# someone should sit down and factor out the common code as\n# WindowsCCompiler!  --GPW\n\nimport os\nimport warnings\n\nfrom ._log import log\nfrom ._modified import newer\nfrom .ccompiler import CCompiler, gen_preprocess_options\nfrom .errors import (\n    CompileError,\n    DistutilsExecError,\n    LibError,\n    LinkError,\n    UnknownFileError,\n)\nfrom .file_util import write_file\n\nwarnings.warn(\n    \"bcppcompiler is deprecated and slated to be removed \"\n    \"in the future. Please discontinue use or file an issue \"\n    \"with pypa/distutils describing your use case.\",\n    DeprecationWarning,\n)\n\n\nclass BCPPCompiler(CCompiler):\n    \"\"\"Concrete class that implements an interface to the Borland C/C++\n    compiler, as defined by the CCompiler abstract class.\n    \"\"\"\n\n    compiler_type = 'bcpp'\n\n    # Just set this so CCompiler's constructor doesn't barf.  We currently\n    # don't use the 'set_executables()' bureaucracy provided by CCompiler,\n    # as it really isn't necessary for this sort of single-compiler class.\n    # Would be nice to have a consistent interface with UnixCCompiler,\n    # though, so it's worth thinking about.\n    executables = {}\n\n    # Private class data (need to distinguish C from C++ source for compiler)\n    _c_extensions = ['.c']\n    _cpp_extensions = ['.cc', '.cpp', '.cxx']\n\n    # Needed for the filename generation methods provided by the\n    # base class, CCompiler.\n    src_extensions = _c_extensions + _cpp_extensions\n    obj_extension = '.obj'\n    static_lib_extension = '.lib'\n    shared_lib_extension = '.dll'\n    static_lib_format = shared_lib_format = '%s%s'\n    exe_extension = '.exe'\n\n    def __init__(self, verbose=0, dry_run=0, force=0):\n        super().__init__(verbose, dry_run, force)\n\n        # These executables are assumed to all be in the path.\n        # Borland doesn't seem to use any special registry settings to\n        # indicate their installation locations.\n\n        self.cc = \"bcc32.exe\"\n        self.linker = \"ilink32.exe\"\n        self.lib = \"tlib.exe\"\n\n        self.preprocess_options = None\n        self.compile_options = ['/tWM', '/O2', '/q', '/g0']\n        self.compile_options_debug = ['/tWM', '/Od', '/q', '/g0']\n\n        self.ldflags_shared = ['/Tpd', '/Gn', '/q', '/x']\n        self.ldflags_shared_debug = ['/Tpd', '/Gn', '/q', '/x']\n        self.ldflags_static = []\n        self.ldflags_exe = ['/Gn', '/q', '/x']\n        self.ldflags_exe_debug = ['/Gn', '/q', '/x', '/r']\n\n    # -- Worker methods ------------------------------------------------\n\n    def compile(  # noqa: C901\n        self,\n        sources,\n        output_dir=None,\n        macros=None,\n        include_dirs=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        depends=None,\n    ):\n        macros, objects, extra_postargs, pp_opts, build = self._setup_compile(\n            output_dir, macros, include_dirs, sources, depends, extra_postargs\n        )\n        compile_opts = extra_preargs or []\n        compile_opts.append('-c')\n        if debug:\n            compile_opts.extend(self.compile_options_debug)\n        else:\n            compile_opts.extend(self.compile_options)\n\n        for obj in objects:\n            try:\n                src, ext = build[obj]\n            except KeyError:\n                continue\n            # XXX why do the normpath here?\n            src = os.path.normpath(src)\n            obj = os.path.normpath(obj)\n            # XXX _setup_compile() did a mkpath() too but before the normpath.\n            # Is it possible to skip the normpath?\n            self.mkpath(os.path.dirname(obj))\n\n            if ext == '.res':\n                # This is already a binary file -- skip it.\n                continue  # the 'for' loop\n            if ext == '.rc':\n                # This needs to be compiled to a .res file -- do it now.\n                try:\n                    self.spawn([\"brcc32\", \"-fo\", obj, src])\n                except DistutilsExecError as msg:\n                    raise CompileError(msg)\n                continue  # the 'for' loop\n\n            # The next two are both for the real compiler.\n            if ext in self._c_extensions:\n                input_opt = \"\"\n            elif ext in self._cpp_extensions:\n                input_opt = \"-P\"\n            else:\n                # Unknown file type -- no extra options.  The compiler\n                # will probably fail, but let it just in case this is a\n                # file the compiler recognizes even if we don't.\n                input_opt = \"\"\n\n            output_opt = \"-o\" + obj\n\n            # Compiler command line syntax is: \"bcc32 [options] file(s)\".\n            # Note that the source file names must appear at the end of\n            # the command line.\n            try:\n                self.spawn(\n                    [self.cc]\n                    + compile_opts\n                    + pp_opts\n                    + [input_opt, output_opt]\n                    + extra_postargs\n                    + [src]\n                )\n            except DistutilsExecError as msg:\n                raise CompileError(msg)\n\n        return objects\n\n    # compile ()\n\n    def create_static_lib(\n        self, objects, output_libname, output_dir=None, debug=0, target_lang=None\n    ):\n        (objects, output_dir) = self._fix_object_args(objects, output_dir)\n        output_filename = self.library_filename(output_libname, output_dir=output_dir)\n\n        if self._need_link(objects, output_filename):\n            lib_args = [output_filename, '/u'] + objects\n            if debug:\n                pass  # XXX what goes here?\n            try:\n                self.spawn([self.lib] + lib_args)\n            except DistutilsExecError as msg:\n                raise LibError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    # create_static_lib ()\n\n    def link(  # noqa: C901\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=0,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        # XXX this ignores 'build_temp'!  should follow the lead of\n        # msvccompiler.py\n\n        (objects, output_dir) = self._fix_object_args(objects, output_dir)\n        (libraries, library_dirs, runtime_library_dirs) = self._fix_lib_args(\n            libraries, library_dirs, runtime_library_dirs\n        )\n\n        if runtime_library_dirs:\n            log.warning(\n                \"I don't know what to do with 'runtime_library_dirs': %s\",\n                str(runtime_library_dirs),\n            )\n\n        if output_dir is not None:\n            output_filename = os.path.join(output_dir, output_filename)\n\n        if self._need_link(objects, output_filename):\n            # Figure out linker args based on type of target.\n            if target_desc == CCompiler.EXECUTABLE:\n                startup_obj = 'c0w32'\n                if debug:\n                    ld_args = self.ldflags_exe_debug[:]\n                else:\n                    ld_args = self.ldflags_exe[:]\n            else:\n                startup_obj = 'c0d32'\n                if debug:\n                    ld_args = self.ldflags_shared_debug[:]\n                else:\n                    ld_args = self.ldflags_shared[:]\n\n            # Create a temporary exports file for use by the linker\n            if export_symbols is None:\n                def_file = ''\n            else:\n                head, tail = os.path.split(output_filename)\n                modname, ext = os.path.splitext(tail)\n                temp_dir = os.path.dirname(objects[0])  # preserve tree structure\n                def_file = os.path.join(temp_dir, '%s.def' % modname)\n                contents = ['EXPORTS']\n                for sym in export_symbols or []:\n                    contents.append(f'  {sym}=_{sym}')\n                self.execute(write_file, (def_file, contents), \"writing %s\" % def_file)\n\n            # Borland C++ has problems with '/' in paths\n            objects2 = map(os.path.normpath, objects)\n            # split objects in .obj and .res files\n            # Borland C++ needs them at different positions in the command line\n            objects = [startup_obj]\n            resources = []\n            for file in objects2:\n                (base, ext) = os.path.splitext(os.path.normcase(file))\n                if ext == '.res':\n                    resources.append(file)\n                else:\n                    objects.append(file)\n\n            for ell in library_dirs:\n                ld_args.append(\"/L%s\" % os.path.normpath(ell))\n            ld_args.append(\"/L.\")  # we sometimes use relative paths\n\n            # list of object files\n            ld_args.extend(objects)\n\n            # XXX the command-line syntax for Borland C++ is a bit wonky;\n            # certain filenames are jammed together in one big string, but\n            # comma-delimited.  This doesn't mesh too well with the\n            # Unix-centric attitude (with a DOS/Windows quoting hack) of\n            # 'spawn()', so constructing the argument list is a bit\n            # awkward.  Note that doing the obvious thing and jamming all\n            # the filenames and commas into one argument would be wrong,\n            # because 'spawn()' would quote any filenames with spaces in\n            # them.  Arghghh!.  Apparently it works fine as coded...\n\n            # name of dll/exe file\n            ld_args.extend([',', output_filename])\n            # no map file and start libraries\n            ld_args.append(',,')\n\n            for lib in libraries:\n                # see if we find it and if there is a bcpp specific lib\n                # (xxx_bcpp.lib)\n                libfile = self.find_library_file(library_dirs, lib, debug)\n                if libfile is None:\n                    ld_args.append(lib)\n                    # probably a BCPP internal library -- don't warn\n                else:\n                    # full name which prefers bcpp_xxx.lib over xxx.lib\n                    ld_args.append(libfile)\n\n            # some default libraries\n            ld_args.extend(('import32', 'cw32mt'))\n\n            # def file for export symbols\n            ld_args.extend([',', def_file])\n            # add resource files\n            ld_args.append(',')\n            ld_args.extend(resources)\n\n            if extra_preargs:\n                ld_args[:0] = extra_preargs\n            if extra_postargs:\n                ld_args.extend(extra_postargs)\n\n            self.mkpath(os.path.dirname(output_filename))\n            try:\n                self.spawn([self.linker] + ld_args)\n            except DistutilsExecError as msg:\n                raise LinkError(msg)\n\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    # link ()\n\n    # -- Miscellaneous methods -----------------------------------------\n\n    def find_library_file(self, dirs, lib, debug=0):\n        # List of effective library names to try, in order of preference:\n        # xxx_bcpp.lib is better than xxx.lib\n        # and xxx_d.lib is better than xxx.lib if debug is set\n        #\n        # The \"_bcpp\" suffix is to handle a Python installation for people\n        # with multiple compilers (primarily Distutils hackers, I suspect\n        # ;-).  The idea is they'd have one static library for each\n        # compiler they care about, since (almost?) every Windows compiler\n        # seems to have a different format for static libraries.\n        if debug:\n            dlib = lib + \"_d\"\n            try_names = (dlib + \"_bcpp\", lib + \"_bcpp\", dlib, lib)\n        else:\n            try_names = (lib + \"_bcpp\", lib)\n\n        for dir in dirs:\n            for name in try_names:\n                libfile = os.path.join(dir, self.library_filename(name))\n                if os.path.exists(libfile):\n                    return libfile\n        else:\n            # Oops, didn't find it in *any* of 'dirs'\n            return None\n\n    # overwrite the one from CCompiler to support rc and res-files\n    def object_filenames(self, source_filenames, strip_dir=0, output_dir=''):\n        if output_dir is None:\n            output_dir = ''\n        obj_names = []\n        for src_name in source_filenames:\n            # use normcase to make sure '.rc' is really '.rc' and not '.RC'\n            (base, ext) = os.path.splitext(os.path.normcase(src_name))\n            if ext not in (self.src_extensions + ['.rc', '.res']):\n                raise UnknownFileError(f\"unknown file type '{ext}' (from '{src_name}')\")\n            if strip_dir:\n                base = os.path.basename(base)\n            if ext == '.res':\n                # these can go unchanged\n                obj_names.append(os.path.join(output_dir, base + ext))\n            elif ext == '.rc':\n                # these need to be compiled to .res-files\n                obj_names.append(os.path.join(output_dir, base + '.res'))\n            else:\n                obj_names.append(os.path.join(output_dir, base + self.obj_extension))\n        return obj_names\n\n    # object_filenames ()\n\n    def preprocess(\n        self,\n        source,\n        output_file=None,\n        macros=None,\n        include_dirs=None,\n        extra_preargs=None,\n        extra_postargs=None,\n    ):\n        (_, macros, include_dirs) = self._fix_compile_args(None, macros, include_dirs)\n        pp_opts = gen_preprocess_options(macros, include_dirs)\n        pp_args = ['cpp32.exe'] + pp_opts\n        if output_file is not None:\n            pp_args.append('-o' + output_file)\n        if extra_preargs:\n            pp_args[:0] = extra_preargs\n        if extra_postargs:\n            pp_args.extend(extra_postargs)\n        pp_args.append(source)\n\n        # We need to preprocess: either we're being forced to, or the\n        # source file is newer than the target (or the target doesn't\n        # exist).\n        if self.force or output_file is None or newer(source, output_file):\n            if output_file:\n                self.mkpath(os.path.dirname(output_file))\n            try:\n                self.spawn(pp_args)\n            except DistutilsExecError as msg:\n                print(msg)\n                raise CompileError(msg)\n\n    # preprocess()\n", "setuptools/_distutils/archive_util.py": "\"\"\"distutils.archive_util\n\nUtility functions for creating archive files (tarballs, zip files,\nthat sort of thing).\"\"\"\n\nimport os\nimport sys\nfrom warnings import warn\n\ntry:\n    import zipfile\nexcept ImportError:\n    zipfile = None\n\n\nfrom ._log import log\nfrom .dir_util import mkpath\nfrom .errors import DistutilsExecError\nfrom .spawn import spawn\n\ntry:\n    from pwd import getpwnam\nexcept ImportError:\n    getpwnam = None\n\ntry:\n    from grp import getgrnam\nexcept ImportError:\n    getgrnam = None\n\n\ndef _get_gid(name):\n    \"\"\"Returns a gid, given a group name.\"\"\"\n    if getgrnam is None or name is None:\n        return None\n    try:\n        result = getgrnam(name)\n    except KeyError:\n        result = None\n    if result is not None:\n        return result[2]\n    return None\n\n\ndef _get_uid(name):\n    \"\"\"Returns an uid, given a user name.\"\"\"\n    if getpwnam is None or name is None:\n        return None\n    try:\n        result = getpwnam(name)\n    except KeyError:\n        result = None\n    if result is not None:\n        return result[2]\n    return None\n\n\ndef make_tarball(\n    base_name, base_dir, compress=\"gzip\", verbose=0, dry_run=0, owner=None, group=None\n):\n    \"\"\"Create a (possibly compressed) tar file from all the files under\n    'base_dir'.\n\n    'compress' must be \"gzip\" (the default), \"bzip2\", \"xz\", \"compress\", or\n    None.  (\"compress\" will be deprecated in Python 3.2)\n\n    'owner' and 'group' can be used to define an owner and a group for the\n    archive that is being built. If not provided, the current owner and group\n    will be used.\n\n    The output tar file will be named 'base_dir' +  \".tar\", possibly plus\n    the appropriate compression extension (\".gz\", \".bz2\", \".xz\" or \".Z\").\n\n    Returns the output filename.\n    \"\"\"\n    tar_compression = {\n        'gzip': 'gz',\n        'bzip2': 'bz2',\n        'xz': 'xz',\n        None: '',\n        'compress': '',\n    }\n    compress_ext = {'gzip': '.gz', 'bzip2': '.bz2', 'xz': '.xz', 'compress': '.Z'}\n\n    # flags for compression program, each element of list will be an argument\n    if compress is not None and compress not in compress_ext.keys():\n        raise ValueError(\n            \"bad value for 'compress': must be None, 'gzip', 'bzip2', \"\n            \"'xz' or 'compress'\"\n        )\n\n    archive_name = base_name + '.tar'\n    if compress != 'compress':\n        archive_name += compress_ext.get(compress, '')\n\n    mkpath(os.path.dirname(archive_name), dry_run=dry_run)\n\n    # creating the tarball\n    import tarfile  # late import so Python build itself doesn't break\n\n    log.info('Creating tar archive')\n\n    uid = _get_uid(owner)\n    gid = _get_gid(group)\n\n    def _set_uid_gid(tarinfo):\n        if gid is not None:\n            tarinfo.gid = gid\n            tarinfo.gname = group\n        if uid is not None:\n            tarinfo.uid = uid\n            tarinfo.uname = owner\n        return tarinfo\n\n    if not dry_run:\n        tar = tarfile.open(archive_name, 'w|%s' % tar_compression[compress])\n        try:\n            tar.add(base_dir, filter=_set_uid_gid)\n        finally:\n            tar.close()\n\n    # compression using `compress`\n    if compress == 'compress':\n        warn(\"'compress' is deprecated.\", DeprecationWarning)\n        # the option varies depending on the platform\n        compressed_name = archive_name + compress_ext[compress]\n        if sys.platform == 'win32':\n            cmd = [compress, archive_name, compressed_name]\n        else:\n            cmd = [compress, '-f', archive_name]\n        spawn(cmd, dry_run=dry_run)\n        return compressed_name\n\n    return archive_name\n\n\ndef make_zipfile(base_name, base_dir, verbose=0, dry_run=0):  # noqa: C901\n    \"\"\"Create a zip file from all the files under 'base_dir'.\n\n    The output zip file will be named 'base_name' + \".zip\".  Uses either the\n    \"zipfile\" Python module (if available) or the InfoZIP \"zip\" utility\n    (if installed and found on the default search path).  If neither tool is\n    available, raises DistutilsExecError.  Returns the name of the output zip\n    file.\n    \"\"\"\n    zip_filename = base_name + \".zip\"\n    mkpath(os.path.dirname(zip_filename), dry_run=dry_run)\n\n    # If zipfile module is not available, try spawning an external\n    # 'zip' command.\n    if zipfile is None:\n        if verbose:\n            zipoptions = \"-r\"\n        else:\n            zipoptions = \"-rq\"\n\n        try:\n            spawn([\"zip\", zipoptions, zip_filename, base_dir], dry_run=dry_run)\n        except DistutilsExecError:\n            # XXX really should distinguish between \"couldn't find\n            # external 'zip' command\" and \"zip failed\".\n            raise DistutilsExecError(\n                (\n                    \"unable to create zip file '%s': \"\n                    \"could neither import the 'zipfile' module nor \"\n                    \"find a standalone zip utility\"\n                )\n                % zip_filename\n            )\n\n    else:\n        log.info(\"creating '%s' and adding '%s' to it\", zip_filename, base_dir)\n\n        if not dry_run:\n            try:\n                zip = zipfile.ZipFile(\n                    zip_filename, \"w\", compression=zipfile.ZIP_DEFLATED\n                )\n            except RuntimeError:\n                zip = zipfile.ZipFile(zip_filename, \"w\", compression=zipfile.ZIP_STORED)\n\n            with zip:\n                if base_dir != os.curdir:\n                    path = os.path.normpath(os.path.join(base_dir, ''))\n                    zip.write(path, path)\n                    log.info(\"adding '%s'\", path)\n                for dirpath, dirnames, filenames in os.walk(base_dir):\n                    for name in dirnames:\n                        path = os.path.normpath(os.path.join(dirpath, name, ''))\n                        zip.write(path, path)\n                        log.info(\"adding '%s'\", path)\n                    for name in filenames:\n                        path = os.path.normpath(os.path.join(dirpath, name))\n                        if os.path.isfile(path):\n                            zip.write(path, path)\n                            log.info(\"adding '%s'\", path)\n\n    return zip_filename\n\n\nARCHIVE_FORMATS = {\n    'gztar': (make_tarball, [('compress', 'gzip')], \"gzip'ed tar-file\"),\n    'bztar': (make_tarball, [('compress', 'bzip2')], \"bzip2'ed tar-file\"),\n    'xztar': (make_tarball, [('compress', 'xz')], \"xz'ed tar-file\"),\n    'ztar': (make_tarball, [('compress', 'compress')], \"compressed tar file\"),\n    'tar': (make_tarball, [('compress', None)], \"uncompressed tar file\"),\n    'zip': (make_zipfile, [], \"ZIP file\"),\n}\n\n\ndef check_archive_formats(formats):\n    \"\"\"Returns the first format from the 'format' list that is unknown.\n\n    If all formats are known, returns None\n    \"\"\"\n    for format in formats:\n        if format not in ARCHIVE_FORMATS:\n            return format\n    return None\n\n\ndef make_archive(\n    base_name,\n    format,\n    root_dir=None,\n    base_dir=None,\n    verbose=0,\n    dry_run=0,\n    owner=None,\n    group=None,\n):\n    \"\"\"Create an archive file (eg. zip or tar).\n\n    'base_name' is the name of the file to create, minus any format-specific\n    extension; 'format' is the archive format: one of \"zip\", \"tar\", \"gztar\",\n    \"bztar\", \"xztar\", or \"ztar\".\n\n    'root_dir' is a directory that will be the root directory of the\n    archive; ie. we typically chdir into 'root_dir' before creating the\n    archive.  'base_dir' is the directory where we start archiving from;\n    ie. 'base_dir' will be the common prefix of all files and\n    directories in the archive.  'root_dir' and 'base_dir' both default\n    to the current directory.  Returns the name of the archive file.\n\n    'owner' and 'group' are used when creating a tar archive. By default,\n    uses the current owner and group.\n    \"\"\"\n    save_cwd = os.getcwd()\n    if root_dir is not None:\n        log.debug(\"changing into '%s'\", root_dir)\n        base_name = os.path.abspath(base_name)\n        if not dry_run:\n            os.chdir(root_dir)\n\n    if base_dir is None:\n        base_dir = os.curdir\n\n    kwargs = {'dry_run': dry_run}\n\n    try:\n        format_info = ARCHIVE_FORMATS[format]\n    except KeyError:\n        raise ValueError(\"unknown archive format '%s'\" % format)\n\n    func = format_info[0]\n    for arg, val in format_info[1]:\n        kwargs[arg] = val\n\n    if format != 'zip':\n        kwargs['owner'] = owner\n        kwargs['group'] = group\n\n    try:\n        filename = func(base_name, base_dir, **kwargs)\n    finally:\n        if root_dir is not None:\n            log.debug(\"changing back to '%s'\", save_cwd)\n            os.chdir(save_cwd)\n\n    return filename\n", "setuptools/_distutils/_functools.py": "import collections.abc\nimport functools\n\n\n# from jaraco.functools 3.5\ndef pass_none(func):\n    \"\"\"\n    Wrap func so it's not called if its first param is None\n\n    >>> print_text = pass_none(print)\n    >>> print_text('text')\n    text\n    >>> print_text(None)\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(param, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n\n    return wrapper\n\n\n# from jaraco.functools 4.0\n@functools.singledispatch\ndef _splat_inner(args, func):\n    \"\"\"Splat args to func.\"\"\"\n    return func(*args)\n\n\n@_splat_inner.register\ndef _(args: collections.abc.Mapping, func):\n    \"\"\"Splat kargs to func as kwargs.\"\"\"\n    return func(**args)\n\n\ndef splat(func):\n    \"\"\"\n    Wrap func to expect its parameters to be passed positionally in a tuple.\n\n    Has a similar effect to that of ``itertools.starmap`` over\n    simple ``map``.\n\n    >>> import itertools, operator\n    >>> pairs = [(-1, 1), (0, 2)]\n    >>> _ = tuple(itertools.starmap(print, pairs))\n    -1 1\n    0 2\n    >>> _ = tuple(map(splat(print), pairs))\n    -1 1\n    0 2\n\n    The approach generalizes to other iterators that don't have a \"star\"\n    equivalent, such as a \"starfilter\".\n\n    >>> list(filter(splat(operator.add), pairs))\n    [(0, 2)]\n\n    Splat also accepts a mapping argument.\n\n    >>> def is_nice(msg, code):\n    ...     return \"smile\" in msg or code == 0\n    >>> msgs = [\n    ...     dict(msg='smile!', code=20),\n    ...     dict(msg='error :(', code=1),\n    ...     dict(msg='unknown', code=0),\n    ... ]\n    >>> for msg in filter(splat(is_nice), msgs):\n    ...     print(msg)\n    {'msg': 'smile!', 'code': 20}\n    {'msg': 'unknown', 'code': 0}\n    \"\"\"\n    return functools.wraps(func)(functools.partial(_splat_inner, func=func))\n", "setuptools/_distutils/__init__.py": "import importlib\nimport sys\n\n__version__, _, _ = sys.version.partition(' ')\n\n\ntry:\n    # Allow Debian and pkgsrc (only) to customize system\n    # behavior. Ref pypa/distutils#2 and pypa/distutils#16.\n    # This hook is deprecated and no other environments\n    # should use it.\n    importlib.import_module('_distutils_system_mod')\nexcept ImportError:\n    pass\n", "setuptools/_distutils/_modified.py": "\"\"\"Timestamp comparison of files and groups of files.\"\"\"\n\nimport functools\nimport os.path\n\nfrom ._functools import splat\nfrom .errors import DistutilsFileError\nfrom .py39compat import zip_strict\n\n\ndef _newer(source, target):\n    return not os.path.exists(target) or (\n        os.path.getmtime(source) > os.path.getmtime(target)\n    )\n\n\ndef newer(source, target):\n    \"\"\"\n    Is source modified more recently than target.\n\n    Returns True if 'source' is modified more recently than\n    'target' or if 'target' does not exist.\n\n    Raises DistutilsFileError if 'source' does not exist.\n    \"\"\"\n    if not os.path.exists(source):\n        raise DistutilsFileError(\"file '%s' does not exist\" % os.path.abspath(source))\n\n    return _newer(source, target)\n\n\ndef newer_pairwise(sources, targets, newer=newer):\n    \"\"\"\n    Filter filenames where sources are newer than targets.\n\n    Walk two filename iterables in parallel, testing if each source is newer\n    than its corresponding target.  Returns a pair of lists (sources,\n    targets) where source is newer than target, according to the semantics\n    of 'newer()'.\n    \"\"\"\n    newer_pairs = filter(splat(newer), zip_strict(sources, targets))\n    return tuple(map(list, zip(*newer_pairs))) or ([], [])\n\n\ndef newer_group(sources, target, missing='error'):\n    \"\"\"\n    Is target out-of-date with respect to any file in sources.\n\n    Return True if 'target' is out-of-date with respect to any file\n    listed in 'sources'. In other words, if 'target' exists and is newer\n    than every file in 'sources', return False; otherwise return True.\n    ``missing`` controls how to handle a missing source file:\n\n    - error (default): allow the ``stat()`` call to fail.\n    - ignore: silently disregard any missing source files.\n    - newer: treat missing source files as \"target out of date\". This\n      mode is handy in \"dry-run\" mode: it will pretend to carry out\n      commands that wouldn't work because inputs are missing, but\n      that doesn't matter because dry-run won't run the commands.\n    \"\"\"\n\n    def missing_as_newer(source):\n        return missing == 'newer' and not os.path.exists(source)\n\n    ignored = os.path.exists if missing == 'ignore' else None\n    return any(\n        missing_as_newer(source) or _newer(source, target)\n        for source in filter(ignored, sources)\n    )\n\n\nnewer_pairwise_group = functools.partial(newer_pairwise, newer=newer_group)\n", "setuptools/_distutils/cmd.py": "\"\"\"distutils.cmd\n\nProvides the Command class, the base class for the command classes\nin the distutils.command package.\n\"\"\"\n\nimport logging\nimport os\nimport re\nimport sys\n\nfrom . import _modified, archive_util, dir_util, file_util, util\nfrom ._log import log\nfrom .errors import DistutilsOptionError\n\n\nclass Command:\n    \"\"\"Abstract base class for defining command classes, the \"worker bees\"\n    of the Distutils.  A useful analogy for command classes is to think of\n    them as subroutines with local variables called \"options\".  The options\n    are \"declared\" in 'initialize_options()' and \"defined\" (given their\n    final values, aka \"finalized\") in 'finalize_options()', both of which\n    must be defined by every command class.  The distinction between the\n    two is necessary because option values might come from the outside\n    world (command line, config file, ...), and any options dependent on\n    other options must be computed *after* these outside influences have\n    been processed -- hence 'finalize_options()'.  The \"body\" of the\n    subroutine, where it does all its work based on the values of its\n    options, is the 'run()' method, which must also be implemented by every\n    command class.\n    \"\"\"\n\n    # 'sub_commands' formalizes the notion of a \"family\" of commands,\n    # eg. \"install\" as the parent with sub-commands \"install_lib\",\n    # \"install_headers\", etc.  The parent of a family of commands\n    # defines 'sub_commands' as a class attribute; it's a list of\n    #    (command_name : string, predicate : unbound_method | string | None)\n    # tuples, where 'predicate' is a method of the parent command that\n    # determines whether the corresponding command is applicable in the\n    # current situation.  (Eg. we \"install_headers\" is only applicable if\n    # we have any C header files to install.)  If 'predicate' is None,\n    # that command is always applicable.\n    #\n    # 'sub_commands' is usually defined at the *end* of a class, because\n    # predicates can be unbound methods, so they must already have been\n    # defined.  The canonical example is the \"install\" command.\n    sub_commands = []\n\n    # -- Creation/initialization methods -------------------------------\n\n    def __init__(self, dist):\n        \"\"\"Create and initialize a new Command object.  Most importantly,\n        invokes the 'initialize_options()' method, which is the real\n        initializer and depends on the actual command being\n        instantiated.\n        \"\"\"\n        # late import because of mutual dependence between these classes\n        from distutils.dist import Distribution\n\n        if not isinstance(dist, Distribution):\n            raise TypeError(\"dist must be a Distribution instance\")\n        if self.__class__ is Command:\n            raise RuntimeError(\"Command is an abstract class\")\n\n        self.distribution = dist\n        self.initialize_options()\n\n        # Per-command versions of the global flags, so that the user can\n        # customize Distutils' behaviour command-by-command and let some\n        # commands fall back on the Distribution's behaviour.  None means\n        # \"not defined, check self.distribution's copy\", while 0 or 1 mean\n        # false and true (duh).  Note that this means figuring out the real\n        # value of each flag is a touch complicated -- hence \"self._dry_run\"\n        # will be handled by __getattr__, below.\n        # XXX This needs to be fixed.\n        self._dry_run = None\n\n        # verbose is largely ignored, but needs to be set for\n        # backwards compatibility (I think)?\n        self.verbose = dist.verbose\n\n        # Some commands define a 'self.force' option to ignore file\n        # timestamps, but methods defined *here* assume that\n        # 'self.force' exists for all commands.  So define it here\n        # just to be safe.\n        self.force = None\n\n        # The 'help' flag is just used for command-line parsing, so\n        # none of that complicated bureaucracy is needed.\n        self.help = 0\n\n        # 'finalized' records whether or not 'finalize_options()' has been\n        # called.  'finalize_options()' itself should not pay attention to\n        # this flag: it is the business of 'ensure_finalized()', which\n        # always calls 'finalize_options()', to respect/update it.\n        self.finalized = 0\n\n    # XXX A more explicit way to customize dry_run would be better.\n    def __getattr__(self, attr):\n        if attr == 'dry_run':\n            myval = getattr(self, \"_\" + attr)\n            if myval is None:\n                return getattr(self.distribution, attr)\n            else:\n                return myval\n        else:\n            raise AttributeError(attr)\n\n    def ensure_finalized(self):\n        if not self.finalized:\n            self.finalize_options()\n        self.finalized = 1\n\n    # Subclasses must define:\n    #   initialize_options()\n    #     provide default values for all options; may be customized by\n    #     setup script, by options from config file(s), or by command-line\n    #     options\n    #   finalize_options()\n    #     decide on the final values for all options; this is called\n    #     after all possible intervention from the outside world\n    #     (command-line, option file, etc.) has been processed\n    #   run()\n    #     run the command: do whatever it is we're here to do,\n    #     controlled by the command's various option values\n\n    def initialize_options(self):\n        \"\"\"Set default values for all the options that this command\n        supports.  Note that these defaults may be overridden by other\n        commands, by the setup script, by config files, or by the\n        command-line.  Thus, this is not the place to code dependencies\n        between options; generally, 'initialize_options()' implementations\n        are just a bunch of \"self.foo = None\" assignments.\n\n        This method must be implemented by all command classes.\n        \"\"\"\n        raise RuntimeError(\n            \"abstract method -- subclass %s must override\" % self.__class__\n        )\n\n    def finalize_options(self):\n        \"\"\"Set final values for all the options that this command supports.\n        This is always called as late as possible, ie.  after any option\n        assignments from the command-line or from other commands have been\n        done.  Thus, this is the place to code option dependencies: if\n        'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as\n        long as 'foo' still has the same value it was assigned in\n        'initialize_options()'.\n\n        This method must be implemented by all command classes.\n        \"\"\"\n        raise RuntimeError(\n            \"abstract method -- subclass %s must override\" % self.__class__\n        )\n\n    def dump_options(self, header=None, indent=\"\"):\n        from distutils.fancy_getopt import longopt_xlate\n\n        if header is None:\n            header = \"command options for '%s':\" % self.get_command_name()\n        self.announce(indent + header, level=logging.INFO)\n        indent = indent + \"  \"\n        for option, _, _ in self.user_options:\n            option = option.translate(longopt_xlate)\n            if option[-1] == \"=\":\n                option = option[:-1]\n            value = getattr(self, option)\n            self.announce(indent + f\"{option} = {value}\", level=logging.INFO)\n\n    def run(self):\n        \"\"\"A command's raison d'etre: carry out the action it exists to\n        perform, controlled by the options initialized in\n        'initialize_options()', customized by other commands, the setup\n        script, the command-line, and config files, and finalized in\n        'finalize_options()'.  All terminal output and filesystem\n        interaction should be done by 'run()'.\n\n        This method must be implemented by all command classes.\n        \"\"\"\n        raise RuntimeError(\n            \"abstract method -- subclass %s must override\" % self.__class__\n        )\n\n    def announce(self, msg, level=logging.DEBUG):\n        log.log(level, msg)\n\n    def debug_print(self, msg):\n        \"\"\"Print 'msg' to stdout if the global DEBUG (taken from the\n        DISTUTILS_DEBUG environment variable) flag is true.\n        \"\"\"\n        from distutils.debug import DEBUG\n\n        if DEBUG:\n            print(msg)\n            sys.stdout.flush()\n\n    # -- Option validation methods -------------------------------------\n    # (these are very handy in writing the 'finalize_options()' method)\n    #\n    # NB. the general philosophy here is to ensure that a particular option\n    # value meets certain type and value constraints.  If not, we try to\n    # force it into conformance (eg. if we expect a list but have a string,\n    # split the string on comma and/or whitespace).  If we can't force the\n    # option into conformance, raise DistutilsOptionError.  Thus, command\n    # classes need do nothing more than (eg.)\n    #   self.ensure_string_list('foo')\n    # and they can be guaranteed that thereafter, self.foo will be\n    # a list of strings.\n\n    def _ensure_stringlike(self, option, what, default=None):\n        val = getattr(self, option)\n        if val is None:\n            setattr(self, option, default)\n            return default\n        elif not isinstance(val, str):\n            raise DistutilsOptionError(f\"'{option}' must be a {what} (got `{val}`)\")\n        return val\n\n    def ensure_string(self, option, default=None):\n        \"\"\"Ensure that 'option' is a string; if not defined, set it to\n        'default'.\n        \"\"\"\n        self._ensure_stringlike(option, \"string\", default)\n\n    def ensure_string_list(self, option):\n        r\"\"\"Ensure that 'option' is a list of strings.  If 'option' is\n        currently a string, we split it either on /,\\s*/ or /\\s+/, so\n        \"foo bar baz\", \"foo,bar,baz\", and \"foo,   bar baz\" all become\n        [\"foo\", \"bar\", \"baz\"].\n        \"\"\"\n        val = getattr(self, option)\n        if val is None:\n            return\n        elif isinstance(val, str):\n            setattr(self, option, re.split(r',\\s*|\\s+', val))\n        else:\n            if isinstance(val, list):\n                ok = all(isinstance(v, str) for v in val)\n            else:\n                ok = False\n            if not ok:\n                raise DistutilsOptionError(\n                    f\"'{option}' must be a list of strings (got {val!r})\"\n                )\n\n    def _ensure_tested_string(self, option, tester, what, error_fmt, default=None):\n        val = self._ensure_stringlike(option, what, default)\n        if val is not None and not tester(val):\n            raise DistutilsOptionError(\n                (\"error in '%s' option: \" + error_fmt) % (option, val)\n            )\n\n    def ensure_filename(self, option):\n        \"\"\"Ensure that 'option' is the name of an existing file.\"\"\"\n        self._ensure_tested_string(\n            option, os.path.isfile, \"filename\", \"'%s' does not exist or is not a file\"\n        )\n\n    def ensure_dirname(self, option):\n        self._ensure_tested_string(\n            option,\n            os.path.isdir,\n            \"directory name\",\n            \"'%s' does not exist or is not a directory\",\n        )\n\n    # -- Convenience methods for commands ------------------------------\n\n    def get_command_name(self):\n        if hasattr(self, 'command_name'):\n            return self.command_name\n        else:\n            return self.__class__.__name__\n\n    def set_undefined_options(self, src_cmd, *option_pairs):\n        \"\"\"Set the values of any \"undefined\" options from corresponding\n        option values in some other command object.  \"Undefined\" here means\n        \"is None\", which is the convention used to indicate that an option\n        has not been changed between 'initialize_options()' and\n        'finalize_options()'.  Usually called from 'finalize_options()' for\n        options that depend on some other command rather than another\n        option of the same command.  'src_cmd' is the other command from\n        which option values will be taken (a command object will be created\n        for it if necessary); the remaining arguments are\n        '(src_option,dst_option)' tuples which mean \"take the value of\n        'src_option' in the 'src_cmd' command object, and copy it to\n        'dst_option' in the current command object\".\n        \"\"\"\n        # Option_pairs: list of (src_option, dst_option) tuples\n        src_cmd_obj = self.distribution.get_command_obj(src_cmd)\n        src_cmd_obj.ensure_finalized()\n        for src_option, dst_option in option_pairs:\n            if getattr(self, dst_option) is None:\n                setattr(self, dst_option, getattr(src_cmd_obj, src_option))\n\n    def get_finalized_command(self, command, create=1):\n        \"\"\"Wrapper around Distribution's 'get_command_obj()' method: find\n        (create if necessary and 'create' is true) the command object for\n        'command', call its 'ensure_finalized()' method, and return the\n        finalized command object.\n        \"\"\"\n        cmd_obj = self.distribution.get_command_obj(command, create)\n        cmd_obj.ensure_finalized()\n        return cmd_obj\n\n    # XXX rename to 'get_reinitialized_command()'? (should do the\n    # same in dist.py, if so)\n    def reinitialize_command(self, command, reinit_subcommands=0):\n        return self.distribution.reinitialize_command(command, reinit_subcommands)\n\n    def run_command(self, command):\n        \"\"\"Run some other command: uses the 'run_command()' method of\n        Distribution, which creates and finalizes the command object if\n        necessary and then invokes its 'run()' method.\n        \"\"\"\n        self.distribution.run_command(command)\n\n    def get_sub_commands(self):\n        \"\"\"Determine the sub-commands that are relevant in the current\n        distribution (ie., that need to be run).  This is based on the\n        'sub_commands' class attribute: each tuple in that list may include\n        a method that we call to determine if the subcommand needs to be\n        run for the current distribution.  Return a list of command names.\n        \"\"\"\n        commands = []\n        for cmd_name, method in self.sub_commands:\n            if method is None or method(self):\n                commands.append(cmd_name)\n        return commands\n\n    # -- External world manipulation -----------------------------------\n\n    def warn(self, msg):\n        log.warning(\"warning: %s: %s\\n\", self.get_command_name(), msg)\n\n    def execute(self, func, args, msg=None, level=1):\n        util.execute(func, args, msg, dry_run=self.dry_run)\n\n    def mkpath(self, name, mode=0o777):\n        dir_util.mkpath(name, mode, dry_run=self.dry_run)\n\n    def copy_file(\n        self, infile, outfile, preserve_mode=1, preserve_times=1, link=None, level=1\n    ):\n        \"\"\"Copy a file respecting verbose, dry-run and force flags.  (The\n        former two default to whatever is in the Distribution object, and\n        the latter defaults to false for commands that don't define it.)\"\"\"\n        return file_util.copy_file(\n            infile,\n            outfile,\n            preserve_mode,\n            preserve_times,\n            not self.force,\n            link,\n            dry_run=self.dry_run,\n        )\n\n    def copy_tree(\n        self,\n        infile,\n        outfile,\n        preserve_mode=1,\n        preserve_times=1,\n        preserve_symlinks=0,\n        level=1,\n    ):\n        \"\"\"Copy an entire directory tree respecting verbose, dry-run,\n        and force flags.\n        \"\"\"\n        return dir_util.copy_tree(\n            infile,\n            outfile,\n            preserve_mode,\n            preserve_times,\n            preserve_symlinks,\n            not self.force,\n            dry_run=self.dry_run,\n        )\n\n    def move_file(self, src, dst, level=1):\n        \"\"\"Move a file respecting dry-run flag.\"\"\"\n        return file_util.move_file(src, dst, dry_run=self.dry_run)\n\n    def spawn(self, cmd, search_path=1, level=1):\n        \"\"\"Spawn an external command respecting dry-run flag.\"\"\"\n        from distutils.spawn import spawn\n\n        spawn(cmd, search_path, dry_run=self.dry_run)\n\n    def make_archive(\n        self, base_name, format, root_dir=None, base_dir=None, owner=None, group=None\n    ):\n        return archive_util.make_archive(\n            base_name,\n            format,\n            root_dir,\n            base_dir,\n            dry_run=self.dry_run,\n            owner=owner,\n            group=group,\n        )\n\n    def make_file(\n        self, infiles, outfile, func, args, exec_msg=None, skip_msg=None, level=1\n    ):\n        \"\"\"Special case of 'execute()' for operations that process one or\n        more input files and generate one output file.  Works just like\n        'execute()', except the operation is skipped and a different\n        message printed if 'outfile' already exists and is newer than all\n        files listed in 'infiles'.  If the command defined 'self.force',\n        and it is true, then the command is unconditionally run -- does no\n        timestamp checks.\n        \"\"\"\n        if skip_msg is None:\n            skip_msg = \"skipping %s (inputs unchanged)\" % outfile\n\n        # Allow 'infiles' to be a single string\n        if isinstance(infiles, str):\n            infiles = (infiles,)\n        elif not isinstance(infiles, (list, tuple)):\n            raise TypeError(\"'infiles' must be a string, or a list or tuple of strings\")\n\n        if exec_msg is None:\n            exec_msg = \"generating {} from {}\".format(outfile, ', '.join(infiles))\n\n        # If 'outfile' must be regenerated (either because it doesn't\n        # exist, is out-of-date, or the 'force' flag is true) then\n        # perform the action that presumably regenerates it\n        if self.force or _modified.newer_group(infiles, outfile):\n            self.execute(func, args, exec_msg, level)\n        # Otherwise, print the \"skip\" message\n        else:\n            log.debug(skip_msg)\n", "setuptools/_distutils/compat/py38.py": "import sys\n\nif sys.version_info < (3, 9):\n\n    def removesuffix(self, suffix):\n        # suffix='' should not call self[:-0].\n        if suffix and self.endswith(suffix):\n            return self[: -len(suffix)]\n        else:\n            return self[:]\n\n    def removeprefix(self, prefix):\n        if self.startswith(prefix):\n            return self[len(prefix) :]\n        else:\n            return self[:]\nelse:\n\n    def removesuffix(self, suffix):\n        return self.removesuffix(suffix)\n\n    def removeprefix(self, prefix):\n        return self.removeprefix(prefix)\n", "setuptools/_distutils/compat/__init__.py": "from __future__ import annotations\n\nfrom .py38 import removeprefix\n\n\ndef consolidate_linker_args(args: list[str]) -> str:\n    \"\"\"\n    Ensure the return value is a string for backward compatibility.\n\n    Retain until at least 2024-04-31. See pypa/distutils#246\n    \"\"\"\n\n    if not all(arg.startswith('-Wl,') for arg in args):\n        return args\n    return '-Wl,' + ','.join(removeprefix(arg, '-Wl,') for arg in args)\n", "setuptools/_distutils/command/register.py": "\"\"\"distutils.command.register\n\nImplements the Distutils 'register' command (register with the repository).\n\"\"\"\n\n# created 2002/10/21, Richard Jones\n\nimport getpass\nimport io\nimport logging\nimport urllib.parse\nimport urllib.request\nfrom distutils._log import log\nfrom warnings import warn\n\nfrom .._itertools import always_iterable\nfrom ..core import PyPIRCCommand\n\n\nclass register(PyPIRCCommand):\n    description = \"register the distribution with the Python package index\"\n    user_options = PyPIRCCommand.user_options + [\n        ('list-classifiers', None, 'list the valid Trove classifiers'),\n        (\n            'strict',\n            None,\n            'Will stop the registering if the meta-data are not fully compliant',\n        ),\n    ]\n    boolean_options = PyPIRCCommand.boolean_options + [\n        'verify',\n        'list-classifiers',\n        'strict',\n    ]\n\n    sub_commands = [('check', lambda self: True)]\n\n    def initialize_options(self):\n        PyPIRCCommand.initialize_options(self)\n        self.list_classifiers = 0\n        self.strict = 0\n\n    def finalize_options(self):\n        PyPIRCCommand.finalize_options(self)\n        # setting options for the `check` subcommand\n        check_options = {\n            'strict': ('register', self.strict),\n            'restructuredtext': ('register', 1),\n        }\n        self.distribution.command_options['check'] = check_options\n\n    def run(self):\n        self.finalize_options()\n        self._set_config()\n\n        # Run sub commands\n        for cmd_name in self.get_sub_commands():\n            self.run_command(cmd_name)\n\n        if self.dry_run:\n            self.verify_metadata()\n        elif self.list_classifiers:\n            self.classifiers()\n        else:\n            self.send_metadata()\n\n    def check_metadata(self):\n        \"\"\"Deprecated API.\"\"\"\n        warn(\n            \"distutils.command.register.check_metadata is deprecated; \"\n            \"use the check command instead\",\n            DeprecationWarning,\n        )\n        check = self.distribution.get_command_obj('check')\n        check.ensure_finalized()\n        check.strict = self.strict\n        check.restructuredtext = 1\n        check.run()\n\n    def _set_config(self):\n        \"\"\"Reads the configuration file and set attributes.\"\"\"\n        config = self._read_pypirc()\n        if config != {}:\n            self.username = config['username']\n            self.password = config['password']\n            self.repository = config['repository']\n            self.realm = config['realm']\n            self.has_config = True\n        else:\n            if self.repository not in ('pypi', self.DEFAULT_REPOSITORY):\n                raise ValueError('%s not found in .pypirc' % self.repository)\n            if self.repository == 'pypi':\n                self.repository = self.DEFAULT_REPOSITORY\n            self.has_config = False\n\n    def classifiers(self):\n        \"\"\"Fetch the list of classifiers from the server.\"\"\"\n        url = self.repository + '?:action=list_classifiers'\n        response = urllib.request.urlopen(url)\n        log.info(self._read_pypi_response(response))\n\n    def verify_metadata(self):\n        \"\"\"Send the metadata to the package index server to be checked.\"\"\"\n        # send the info to the server and report the result\n        (code, result) = self.post_to_server(self.build_post_data('verify'))\n        log.info('Server response (%s): %s', code, result)\n\n    def send_metadata(self):  # noqa: C901\n        \"\"\"Send the metadata to the package index server.\n\n        Well, do the following:\n        1. figure who the user is, and then\n        2. send the data as a Basic auth'ed POST.\n\n        First we try to read the username/password from $HOME/.pypirc,\n        which is a ConfigParser-formatted file with a section\n        [distutils] containing username and password entries (both\n        in clear text). Eg:\n\n            [distutils]\n            index-servers =\n                pypi\n\n            [pypi]\n            username: fred\n            password: sekrit\n\n        Otherwise, to figure who the user is, we offer the user three\n        choices:\n\n         1. use existing login,\n         2. register as a new user, or\n         3. set the password to a random string and email the user.\n\n        \"\"\"\n        # see if we can short-cut and get the username/password from the\n        # config\n        if self.has_config:\n            choice = '1'\n            username = self.username\n            password = self.password\n        else:\n            choice = 'x'\n            username = password = ''\n\n        # get the user's login info\n        choices = '1 2 3 4'.split()\n        while choice not in choices:\n            self.announce(\n                \"\"\"\\\nWe need to know who you are, so please choose either:\n 1. use your existing login,\n 2. register as a new user,\n 3. have the server generate a new password for you (and email it to you), or\n 4. quit\nYour selection [default 1]: \"\"\",\n                logging.INFO,\n            )\n            choice = input()\n            if not choice:\n                choice = '1'\n            elif choice not in choices:\n                print('Please choose one of the four options!')\n\n        if choice == '1':\n            # get the username and password\n            while not username:\n                username = input('Username: ')\n            while not password:\n                password = getpass.getpass('Password: ')\n\n            # set up the authentication\n            auth = urllib.request.HTTPPasswordMgr()\n            host = urllib.parse.urlparse(self.repository)[1]\n            auth.add_password(self.realm, host, username, password)\n            # send the info to the server and report the result\n            code, result = self.post_to_server(self.build_post_data('submit'), auth)\n            self.announce(f'Server response ({code}): {result}', logging.INFO)\n\n            # possibly save the login\n            if code == 200:\n                if self.has_config:\n                    # sharing the password in the distribution instance\n                    # so the upload command can reuse it\n                    self.distribution.password = password\n                else:\n                    self.announce(\n                        (\n                            'I can store your PyPI login so future '\n                            'submissions will be faster.'\n                        ),\n                        logging.INFO,\n                    )\n                    self.announce(\n                        '(the login will be stored in %s)' % self._get_rc_file(),\n                        logging.INFO,\n                    )\n                    choice = 'X'\n                    while choice.lower() not in 'yn':\n                        choice = input('Save your login (y/N)?')\n                        if not choice:\n                            choice = 'n'\n                    if choice.lower() == 'y':\n                        self._store_pypirc(username, password)\n\n        elif choice == '2':\n            data = {':action': 'user'}\n            data['name'] = data['password'] = data['email'] = ''\n            data['confirm'] = None\n            while not data['name']:\n                data['name'] = input('Username: ')\n            while data['password'] != data['confirm']:\n                while not data['password']:\n                    data['password'] = getpass.getpass('Password: ')\n                while not data['confirm']:\n                    data['confirm'] = getpass.getpass(' Confirm: ')\n                if data['password'] != data['confirm']:\n                    data['password'] = ''\n                    data['confirm'] = None\n                    print(\"Password and confirm don't match!\")\n            while not data['email']:\n                data['email'] = input('   EMail: ')\n            code, result = self.post_to_server(data)\n            if code != 200:\n                log.info('Server response (%s): %s', code, result)\n            else:\n                log.info('You will receive an email shortly.')\n                log.info('Follow the instructions in it to ' 'complete registration.')\n        elif choice == '3':\n            data = {':action': 'password_reset'}\n            data['email'] = ''\n            while not data['email']:\n                data['email'] = input('Your email address: ')\n            code, result = self.post_to_server(data)\n            log.info('Server response (%s): %s', code, result)\n\n    def build_post_data(self, action):\n        # figure the data to send - the metadata plus some additional\n        # information used by the package server\n        meta = self.distribution.metadata\n        data = {\n            ':action': action,\n            'metadata_version': '1.0',\n            'name': meta.get_name(),\n            'version': meta.get_version(),\n            'summary': meta.get_description(),\n            'home_page': meta.get_url(),\n            'author': meta.get_contact(),\n            'author_email': meta.get_contact_email(),\n            'license': meta.get_licence(),\n            'description': meta.get_long_description(),\n            'keywords': meta.get_keywords(),\n            'platform': meta.get_platforms(),\n            'classifiers': meta.get_classifiers(),\n            'download_url': meta.get_download_url(),\n            # PEP 314\n            'provides': meta.get_provides(),\n            'requires': meta.get_requires(),\n            'obsoletes': meta.get_obsoletes(),\n        }\n        if data['provides'] or data['requires'] or data['obsoletes']:\n            data['metadata_version'] = '1.1'\n        return data\n\n    def post_to_server(self, data, auth=None):  # noqa: C901\n        \"\"\"Post a query to the server, and return a string response.\"\"\"\n        if 'name' in data:\n            self.announce(\n                'Registering {} to {}'.format(data['name'], self.repository),\n                logging.INFO,\n            )\n        # Build up the MIME payload for the urllib2 POST data\n        boundary = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'\n        sep_boundary = '\\n--' + boundary\n        end_boundary = sep_boundary + '--'\n        body = io.StringIO()\n        for key, values in data.items():\n            for value in map(str, make_iterable(values)):\n                body.write(sep_boundary)\n                body.write('\\nContent-Disposition: form-data; name=\"%s\"' % key)\n                body.write(\"\\n\\n\")\n                body.write(value)\n                if value and value[-1] == '\\r':\n                    body.write('\\n')  # write an extra newline (lurve Macs)\n        body.write(end_boundary)\n        body.write(\"\\n\")\n        body = body.getvalue().encode(\"utf-8\")\n\n        # build the Request\n        headers = {\n            'Content-type': 'multipart/form-data; boundary=%s; charset=utf-8'\n            % boundary,\n            'Content-length': str(len(body)),\n        }\n        req = urllib.request.Request(self.repository, body, headers)\n\n        # handle HTTP and include the Basic Auth handler\n        opener = urllib.request.build_opener(\n            urllib.request.HTTPBasicAuthHandler(password_mgr=auth)\n        )\n        data = ''\n        try:\n            result = opener.open(req)\n        except urllib.error.HTTPError as e:\n            if self.show_response:\n                data = e.fp.read()\n            result = e.code, e.msg\n        except urllib.error.URLError as e:\n            result = 500, str(e)\n        else:\n            if self.show_response:\n                data = self._read_pypi_response(result)\n            result = 200, 'OK'\n        if self.show_response:\n            msg = '\\n'.join(('-' * 75, data, '-' * 75))\n            self.announce(msg, logging.INFO)\n        return result\n\n\ndef make_iterable(values):\n    if values is None:\n        return [None]\n    return always_iterable(values)\n", "setuptools/_distutils/command/install_egg_info.py": "\"\"\"\ndistutils.command.install_egg_info\n\nImplements the Distutils 'install_egg_info' command, for installing\na package's PKG-INFO metadata.\n\"\"\"\n\nimport os\nimport re\nimport sys\n\nfrom .. import dir_util\nfrom .._log import log\nfrom ..cmd import Command\n\n\nclass install_egg_info(Command):\n    \"\"\"Install an .egg-info file for the package\"\"\"\n\n    description = \"Install package's PKG-INFO metadata as an .egg-info file\"\n    user_options = [\n        ('install-dir=', 'd', \"directory to install to\"),\n    ]\n\n    def initialize_options(self):\n        self.install_dir = None\n\n    @property\n    def basename(self):\n        \"\"\"\n        Allow basename to be overridden by child class.\n        Ref pypa/distutils#2.\n        \"\"\"\n        return \"%s-%s-py%d.%d.egg-info\" % (\n            to_filename(safe_name(self.distribution.get_name())),\n            to_filename(safe_version(self.distribution.get_version())),\n            *sys.version_info[:2],\n        )\n\n    def finalize_options(self):\n        self.set_undefined_options('install_lib', ('install_dir', 'install_dir'))\n        self.target = os.path.join(self.install_dir, self.basename)\n        self.outputs = [self.target]\n\n    def run(self):\n        target = self.target\n        if os.path.isdir(target) and not os.path.islink(target):\n            dir_util.remove_tree(target, dry_run=self.dry_run)\n        elif os.path.exists(target):\n            self.execute(os.unlink, (self.target,), \"Removing \" + target)\n        elif not os.path.isdir(self.install_dir):\n            self.execute(\n                os.makedirs, (self.install_dir,), \"Creating \" + self.install_dir\n            )\n        log.info(\"Writing %s\", target)\n        if not self.dry_run:\n            with open(target, 'w', encoding='UTF-8') as f:\n                self.distribution.metadata.write_pkg_file(f)\n\n    def get_outputs(self):\n        return self.outputs\n\n\n# The following routines are taken from setuptools' pkg_resources module and\n# can be replaced by importing them from pkg_resources once it is included\n# in the stdlib.\n\n\ndef safe_name(name):\n    \"\"\"Convert an arbitrary string to a standard distribution name\n\n    Any runs of non-alphanumeric/. characters are replaced with a single '-'.\n    \"\"\"\n    return re.sub('[^A-Za-z0-9.]+', '-', name)\n\n\ndef safe_version(version):\n    \"\"\"Convert an arbitrary string to a standard version string\n\n    Spaces become dots, and all other non-alphanumeric characters become\n    dashes, with runs of multiple dashes condensed to a single dash.\n    \"\"\"\n    version = version.replace(' ', '.')\n    return re.sub('[^A-Za-z0-9.]+', '-', version)\n\n\ndef to_filename(name):\n    \"\"\"Convert a project or version name to its filename-escaped form\n\n    Any '-' characters are currently replaced with '_'.\n    \"\"\"\n    return name.replace('-', '_')\n", "setuptools/_distutils/command/config.py": "\"\"\"distutils.command.config\n\nImplements the Distutils 'config' command, a (mostly) empty command class\nthat exists mainly to be sub-classed by specific module distributions and\napplications.  The idea is that while every \"config\" command is different,\nat least they're all named the same, and users always see \"config\" in the\nlist of standard commands.  Also, this is a good place to put common\nconfigure-like tasks: \"try to compile this C code\", or \"figure out where\nthis header file lives\".\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport pathlib\nimport re\nfrom collections.abc import Sequence\nfrom distutils._log import log\n\nfrom ..core import Command\nfrom ..errors import DistutilsExecError\nfrom ..sysconfig import customize_compiler\n\nLANG_EXT = {\"c\": \".c\", \"c++\": \".cxx\"}\n\n\nclass config(Command):\n    description = \"prepare to build\"\n\n    user_options = [\n        ('compiler=', None, \"specify the compiler type\"),\n        ('cc=', None, \"specify the compiler executable\"),\n        ('include-dirs=', 'I', \"list of directories to search for header files\"),\n        ('define=', 'D', \"C preprocessor macros to define\"),\n        ('undef=', 'U', \"C preprocessor macros to undefine\"),\n        ('libraries=', 'l', \"external C libraries to link with\"),\n        ('library-dirs=', 'L', \"directories to search for external C libraries\"),\n        ('noisy', None, \"show every action (compile, link, run, ...) taken\"),\n        (\n            'dump-source',\n            None,\n            \"dump generated source files before attempting to compile them\",\n        ),\n    ]\n\n    # The three standard command methods: since the \"config\" command\n    # does nothing by default, these are empty.\n\n    def initialize_options(self):\n        self.compiler = None\n        self.cc = None\n        self.include_dirs = None\n        self.libraries = None\n        self.library_dirs = None\n\n        # maximal output for now\n        self.noisy = 1\n        self.dump_source = 1\n\n        # list of temporary files generated along-the-way that we have\n        # to clean at some point\n        self.temp_files = []\n\n    def finalize_options(self):\n        if self.include_dirs is None:\n            self.include_dirs = self.distribution.include_dirs or []\n        elif isinstance(self.include_dirs, str):\n            self.include_dirs = self.include_dirs.split(os.pathsep)\n\n        if self.libraries is None:\n            self.libraries = []\n        elif isinstance(self.libraries, str):\n            self.libraries = [self.libraries]\n\n        if self.library_dirs is None:\n            self.library_dirs = []\n        elif isinstance(self.library_dirs, str):\n            self.library_dirs = self.library_dirs.split(os.pathsep)\n\n    def run(self):\n        pass\n\n    # Utility methods for actual \"config\" commands.  The interfaces are\n    # loosely based on Autoconf macros of similar names.  Sub-classes\n    # may use these freely.\n\n    def _check_compiler(self):\n        \"\"\"Check that 'self.compiler' really is a CCompiler object;\n        if not, make it one.\n        \"\"\"\n        # We do this late, and only on-demand, because this is an expensive\n        # import.\n        from ..ccompiler import CCompiler, new_compiler\n\n        if not isinstance(self.compiler, CCompiler):\n            self.compiler = new_compiler(\n                compiler=self.compiler, dry_run=self.dry_run, force=1\n            )\n            customize_compiler(self.compiler)\n            if self.include_dirs:\n                self.compiler.set_include_dirs(self.include_dirs)\n            if self.libraries:\n                self.compiler.set_libraries(self.libraries)\n            if self.library_dirs:\n                self.compiler.set_library_dirs(self.library_dirs)\n\n    def _gen_temp_sourcefile(self, body, headers, lang):\n        filename = \"_configtest\" + LANG_EXT[lang]\n        with open(filename, \"w\", encoding='utf-8') as file:\n            if headers:\n                for header in headers:\n                    file.write(\"#include <%s>\\n\" % header)\n                file.write(\"\\n\")\n            file.write(body)\n            if body[-1] != \"\\n\":\n                file.write(\"\\n\")\n        return filename\n\n    def _preprocess(self, body, headers, include_dirs, lang):\n        src = self._gen_temp_sourcefile(body, headers, lang)\n        out = \"_configtest.i\"\n        self.temp_files.extend([src, out])\n        self.compiler.preprocess(src, out, include_dirs=include_dirs)\n        return (src, out)\n\n    def _compile(self, body, headers, include_dirs, lang):\n        src = self._gen_temp_sourcefile(body, headers, lang)\n        if self.dump_source:\n            dump_file(src, \"compiling '%s':\" % src)\n        (obj,) = self.compiler.object_filenames([src])\n        self.temp_files.extend([src, obj])\n        self.compiler.compile([src], include_dirs=include_dirs)\n        return (src, obj)\n\n    def _link(self, body, headers, include_dirs, libraries, library_dirs, lang):\n        (src, obj) = self._compile(body, headers, include_dirs, lang)\n        prog = os.path.splitext(os.path.basename(src))[0]\n        self.compiler.link_executable(\n            [obj],\n            prog,\n            libraries=libraries,\n            library_dirs=library_dirs,\n            target_lang=lang,\n        )\n\n        if self.compiler.exe_extension is not None:\n            prog = prog + self.compiler.exe_extension\n        self.temp_files.append(prog)\n\n        return (src, obj, prog)\n\n    def _clean(self, *filenames):\n        if not filenames:\n            filenames = self.temp_files\n            self.temp_files = []\n        log.info(\"removing: %s\", ' '.join(filenames))\n        for filename in filenames:\n            try:\n                os.remove(filename)\n            except OSError:\n                pass\n\n    # XXX these ignore the dry-run flag: what to do, what to do? even if\n    # you want a dry-run build, you still need some sort of configuration\n    # info.  My inclination is to make it up to the real config command to\n    # consult 'dry_run', and assume a default (minimal) configuration if\n    # true.  The problem with trying to do it here is that you'd have to\n    # return either true or false from all the 'try' methods, neither of\n    # which is correct.\n\n    # XXX need access to the header search path and maybe default macros.\n\n    def try_cpp(self, body=None, headers=None, include_dirs=None, lang=\"c\"):\n        \"\"\"Construct a source file from 'body' (a string containing lines\n        of C/C++ code) and 'headers' (a list of header files to include)\n        and run it through the preprocessor.  Return true if the\n        preprocessor succeeded, false if there were any errors.\n        ('body' probably isn't of much use, but what the heck.)\n        \"\"\"\n        from ..ccompiler import CompileError\n\n        self._check_compiler()\n        ok = True\n        try:\n            self._preprocess(body, headers, include_dirs, lang)\n        except CompileError:\n            ok = False\n\n        self._clean()\n        return ok\n\n    def search_cpp(self, pattern, body=None, headers=None, include_dirs=None, lang=\"c\"):\n        \"\"\"Construct a source file (just like 'try_cpp()'), run it through\n        the preprocessor, and return true if any line of the output matches\n        'pattern'.  'pattern' should either be a compiled regex object or a\n        string containing a regex.  If both 'body' and 'headers' are None,\n        preprocesses an empty file -- which can be useful to determine the\n        symbols the preprocessor and compiler set by default.\n        \"\"\"\n        self._check_compiler()\n        src, out = self._preprocess(body, headers, include_dirs, lang)\n\n        if isinstance(pattern, str):\n            pattern = re.compile(pattern)\n\n        with open(out, encoding='utf-8') as file:\n            match = any(pattern.search(line) for line in file)\n\n        self._clean()\n        return match\n\n    def try_compile(self, body, headers=None, include_dirs=None, lang=\"c\"):\n        \"\"\"Try to compile a source file built from 'body' and 'headers'.\n        Return true on success, false otherwise.\n        \"\"\"\n        from ..ccompiler import CompileError\n\n        self._check_compiler()\n        try:\n            self._compile(body, headers, include_dirs, lang)\n            ok = True\n        except CompileError:\n            ok = False\n\n        log.info(ok and \"success!\" or \"failure.\")\n        self._clean()\n        return ok\n\n    def try_link(\n        self,\n        body,\n        headers=None,\n        include_dirs=None,\n        libraries=None,\n        library_dirs=None,\n        lang=\"c\",\n    ):\n        \"\"\"Try to compile and link a source file, built from 'body' and\n        'headers', to executable form.  Return true on success, false\n        otherwise.\n        \"\"\"\n        from ..ccompiler import CompileError, LinkError\n\n        self._check_compiler()\n        try:\n            self._link(body, headers, include_dirs, libraries, library_dirs, lang)\n            ok = True\n        except (CompileError, LinkError):\n            ok = False\n\n        log.info(ok and \"success!\" or \"failure.\")\n        self._clean()\n        return ok\n\n    def try_run(\n        self,\n        body,\n        headers=None,\n        include_dirs=None,\n        libraries=None,\n        library_dirs=None,\n        lang=\"c\",\n    ):\n        \"\"\"Try to compile, link to an executable, and run a program\n        built from 'body' and 'headers'.  Return true on success, false\n        otherwise.\n        \"\"\"\n        from ..ccompiler import CompileError, LinkError\n\n        self._check_compiler()\n        try:\n            src, obj, exe = self._link(\n                body, headers, include_dirs, libraries, library_dirs, lang\n            )\n            self.spawn([exe])\n            ok = True\n        except (CompileError, LinkError, DistutilsExecError):\n            ok = False\n\n        log.info(ok and \"success!\" or \"failure.\")\n        self._clean()\n        return ok\n\n    # -- High-level methods --------------------------------------------\n    # (these are the ones that are actually likely to be useful\n    # when implementing a real-world config command!)\n\n    def check_func(\n        self,\n        func,\n        headers=None,\n        include_dirs=None,\n        libraries=None,\n        library_dirs=None,\n        decl=0,\n        call=0,\n    ):\n        \"\"\"Determine if function 'func' is available by constructing a\n        source file that refers to 'func', and compiles and links it.\n        If everything succeeds, returns true; otherwise returns false.\n\n        The constructed source file starts out by including the header\n        files listed in 'headers'.  If 'decl' is true, it then declares\n        'func' (as \"int func()\"); you probably shouldn't supply 'headers'\n        and set 'decl' true in the same call, or you might get errors about\n        a conflicting declarations for 'func'.  Finally, the constructed\n        'main()' function either references 'func' or (if 'call' is true)\n        calls it.  'libraries' and 'library_dirs' are used when\n        linking.\n        \"\"\"\n        self._check_compiler()\n        body = []\n        if decl:\n            body.append(\"int %s ();\" % func)\n        body.append(\"int main () {\")\n        if call:\n            body.append(\"  %s();\" % func)\n        else:\n            body.append(\"  %s;\" % func)\n        body.append(\"}\")\n        body = \"\\n\".join(body) + \"\\n\"\n\n        return self.try_link(body, headers, include_dirs, libraries, library_dirs)\n\n    def check_lib(\n        self,\n        library,\n        library_dirs=None,\n        headers=None,\n        include_dirs=None,\n        other_libraries: Sequence[str] = [],\n    ):\n        \"\"\"Determine if 'library' is available to be linked against,\n        without actually checking that any particular symbols are provided\n        by it.  'headers' will be used in constructing the source file to\n        be compiled, but the only effect of this is to check if all the\n        header files listed are available.  Any libraries listed in\n        'other_libraries' will be included in the link, in case 'library'\n        has symbols that depend on other libraries.\n        \"\"\"\n        self._check_compiler()\n        return self.try_link(\n            \"int main (void) { }\",\n            headers,\n            include_dirs,\n            [library] + list(other_libraries),\n            library_dirs,\n        )\n\n    def check_header(self, header, include_dirs=None, library_dirs=None, lang=\"c\"):\n        \"\"\"Determine if the system header file named by 'header_file'\n        exists and can be found by the preprocessor; return true if so,\n        false otherwise.\n        \"\"\"\n        return self.try_cpp(\n            body=\"/* No body */\", headers=[header], include_dirs=include_dirs\n        )\n\n\ndef dump_file(filename, head=None):\n    \"\"\"Dumps a file content into log.info.\n\n    If head is not None, will be dumped before the file content.\n    \"\"\"\n    if head is None:\n        log.info('%s', filename)\n    else:\n        log.info(head)\n    log.info(pathlib.Path(filename).read_text(encoding='utf-8'))\n", "setuptools/_distutils/command/install_headers.py": "\"\"\"distutils.command.install_headers\n\nImplements the Distutils 'install_headers' command, to install C/C++ header\nfiles to the Python include directory.\"\"\"\n\nfrom ..core import Command\n\n\n# XXX force is never used\nclass install_headers(Command):\n    description = \"install C/C++ header files\"\n\n    user_options = [\n        ('install-dir=', 'd', \"directory to install header files to\"),\n        ('force', 'f', \"force installation (overwrite existing files)\"),\n    ]\n\n    boolean_options = ['force']\n\n    def initialize_options(self):\n        self.install_dir = None\n        self.force = 0\n        self.outfiles = []\n\n    def finalize_options(self):\n        self.set_undefined_options(\n            'install', ('install_headers', 'install_dir'), ('force', 'force')\n        )\n\n    def run(self):\n        headers = self.distribution.headers\n        if not headers:\n            return\n\n        self.mkpath(self.install_dir)\n        for header in headers:\n            (out, _) = self.copy_file(header, self.install_dir)\n            self.outfiles.append(out)\n\n    def get_inputs(self):\n        return self.distribution.headers or []\n\n    def get_outputs(self):\n        return self.outfiles\n", "setuptools/_distutils/command/sdist.py": "\"\"\"distutils.command.sdist\n\nImplements the Distutils 'sdist' command (create a source distribution).\"\"\"\n\nimport os\nimport sys\nfrom distutils import archive_util, dir_util, file_util\nfrom distutils._log import log\nfrom glob import glob\nfrom itertools import filterfalse\nfrom warnings import warn\n\nfrom ..core import Command\nfrom ..errors import DistutilsOptionError, DistutilsTemplateError\nfrom ..filelist import FileList\nfrom ..text_file import TextFile\nfrom ..util import convert_path\n\n\ndef show_formats():\n    \"\"\"Print all possible values for the 'formats' option (used by\n    the \"--help-formats\" command-line option).\n    \"\"\"\n    from ..archive_util import ARCHIVE_FORMATS\n    from ..fancy_getopt import FancyGetopt\n\n    formats = []\n    for format in ARCHIVE_FORMATS.keys():\n        formats.append((\"formats=\" + format, None, ARCHIVE_FORMATS[format][2]))\n    formats.sort()\n    FancyGetopt(formats).print_help(\"List of available source distribution formats:\")\n\n\nclass sdist(Command):\n    description = \"create a source distribution (tarball, zip file, etc.)\"\n\n    def checking_metadata(self):\n        \"\"\"Callable used for the check sub-command.\n\n        Placed here so user_options can view it\"\"\"\n        return self.metadata_check\n\n    user_options = [\n        ('template=', 't', \"name of manifest template file [default: MANIFEST.in]\"),\n        ('manifest=', 'm', \"name of manifest file [default: MANIFEST]\"),\n        (\n            'use-defaults',\n            None,\n            \"include the default file set in the manifest \"\n            \"[default; disable with --no-defaults]\",\n        ),\n        ('no-defaults', None, \"don't include the default file set\"),\n        (\n            'prune',\n            None,\n            \"specifically exclude files/directories that should not be \"\n            \"distributed (build tree, RCS/CVS dirs, etc.) \"\n            \"[default; disable with --no-prune]\",\n        ),\n        ('no-prune', None, \"don't automatically exclude anything\"),\n        (\n            'manifest-only',\n            'o',\n            \"just regenerate the manifest and then stop (implies --force-manifest)\",\n        ),\n        (\n            'force-manifest',\n            'f',\n            \"forcibly regenerate the manifest and carry on as usual. \"\n            \"Deprecated: now the manifest is always regenerated.\",\n        ),\n        ('formats=', None, \"formats for source distribution (comma-separated list)\"),\n        (\n            'keep-temp',\n            'k',\n            \"keep the distribution tree around after creating \" + \"archive file(s)\",\n        ),\n        (\n            'dist-dir=',\n            'd',\n            \"directory to put the source distribution archive(s) in [default: dist]\",\n        ),\n        (\n            'metadata-check',\n            None,\n            \"Ensure that all required elements of meta-data \"\n            \"are supplied. Warn if any missing. [default]\",\n        ),\n        (\n            'owner=',\n            'u',\n            \"Owner name used when creating a tar file [default: current user]\",\n        ),\n        (\n            'group=',\n            'g',\n            \"Group name used when creating a tar file [default: current group]\",\n        ),\n    ]\n\n    boolean_options = [\n        'use-defaults',\n        'prune',\n        'manifest-only',\n        'force-manifest',\n        'keep-temp',\n        'metadata-check',\n    ]\n\n    help_options = [\n        ('help-formats', None, \"list available distribution formats\", show_formats),\n    ]\n\n    negative_opt = {'no-defaults': 'use-defaults', 'no-prune': 'prune'}\n\n    sub_commands = [('check', checking_metadata)]\n\n    READMES = ('README', 'README.txt', 'README.rst')\n\n    def initialize_options(self):\n        # 'template' and 'manifest' are, respectively, the names of\n        # the manifest template and manifest file.\n        self.template = None\n        self.manifest = None\n\n        # 'use_defaults': if true, we will include the default file set\n        # in the manifest\n        self.use_defaults = 1\n        self.prune = 1\n\n        self.manifest_only = 0\n        self.force_manifest = 0\n\n        self.formats = ['gztar']\n        self.keep_temp = 0\n        self.dist_dir = None\n\n        self.archive_files = None\n        self.metadata_check = 1\n        self.owner = None\n        self.group = None\n\n    def finalize_options(self):\n        if self.manifest is None:\n            self.manifest = \"MANIFEST\"\n        if self.template is None:\n            self.template = \"MANIFEST.in\"\n\n        self.ensure_string_list('formats')\n\n        bad_format = archive_util.check_archive_formats(self.formats)\n        if bad_format:\n            raise DistutilsOptionError(\"unknown archive format '%s'\" % bad_format)\n\n        if self.dist_dir is None:\n            self.dist_dir = \"dist\"\n\n    def run(self):\n        # 'filelist' contains the list of files that will make up the\n        # manifest\n        self.filelist = FileList()\n\n        # Run sub commands\n        for cmd_name in self.get_sub_commands():\n            self.run_command(cmd_name)\n\n        # Do whatever it takes to get the list of files to process\n        # (process the manifest template, read an existing manifest,\n        # whatever).  File list is accumulated in 'self.filelist'.\n        self.get_file_list()\n\n        # If user just wanted us to regenerate the manifest, stop now.\n        if self.manifest_only:\n            return\n\n        # Otherwise, go ahead and create the source distribution tarball,\n        # or zipfile, or whatever.\n        self.make_distribution()\n\n    def check_metadata(self):\n        \"\"\"Deprecated API.\"\"\"\n        warn(\n            \"distutils.command.sdist.check_metadata is deprecated, \\\n              use the check command instead\",\n            PendingDeprecationWarning,\n        )\n        check = self.distribution.get_command_obj('check')\n        check.ensure_finalized()\n        check.run()\n\n    def get_file_list(self):\n        \"\"\"Figure out the list of files to include in the source\n        distribution, and put it in 'self.filelist'.  This might involve\n        reading the manifest template (and writing the manifest), or just\n        reading the manifest, or just using the default file set -- it all\n        depends on the user's options.\n        \"\"\"\n        # new behavior when using a template:\n        # the file list is recalculated every time because\n        # even if MANIFEST.in or setup.py are not changed\n        # the user might have added some files in the tree that\n        # need to be included.\n        #\n        #  This makes --force the default and only behavior with templates.\n        template_exists = os.path.isfile(self.template)\n        if not template_exists and self._manifest_is_not_generated():\n            self.read_manifest()\n            self.filelist.sort()\n            self.filelist.remove_duplicates()\n            return\n\n        if not template_exists:\n            self.warn(\n                (\"manifest template '%s' does not exist \" + \"(using default file list)\")\n                % self.template\n            )\n        self.filelist.findall()\n\n        if self.use_defaults:\n            self.add_defaults()\n\n        if template_exists:\n            self.read_template()\n\n        if self.prune:\n            self.prune_file_list()\n\n        self.filelist.sort()\n        self.filelist.remove_duplicates()\n        self.write_manifest()\n\n    def add_defaults(self):\n        \"\"\"Add all the default files to self.filelist:\n          - README or README.txt\n          - setup.py\n          - tests/test*.py and test/test*.py\n          - all pure Python modules mentioned in setup script\n          - all files pointed by package_data (build_py)\n          - all files defined in data_files.\n          - all files defined as scripts.\n          - all C sources listed as part of extensions or C libraries\n            in the setup script (doesn't catch C headers!)\n        Warns if (README or README.txt) or setup.py are missing; everything\n        else is optional.\n        \"\"\"\n        self._add_defaults_standards()\n        self._add_defaults_optional()\n        self._add_defaults_python()\n        self._add_defaults_data_files()\n        self._add_defaults_ext()\n        self._add_defaults_c_libs()\n        self._add_defaults_scripts()\n\n    @staticmethod\n    def _cs_path_exists(fspath):\n        \"\"\"\n        Case-sensitive path existence check\n\n        >>> sdist._cs_path_exists(__file__)\n        True\n        >>> sdist._cs_path_exists(__file__.upper())\n        False\n        \"\"\"\n        if not os.path.exists(fspath):\n            return False\n        # make absolute so we always have a directory\n        abspath = os.path.abspath(fspath)\n        directory, filename = os.path.split(abspath)\n        return filename in os.listdir(directory)\n\n    def _add_defaults_standards(self):\n        standards = [self.READMES, self.distribution.script_name]\n        for fn in standards:\n            if isinstance(fn, tuple):\n                alts = fn\n                got_it = False\n                for fn in alts:\n                    if self._cs_path_exists(fn):\n                        got_it = True\n                        self.filelist.append(fn)\n                        break\n\n                if not got_it:\n                    self.warn(\n                        \"standard file not found: should have one of \" + ', '.join(alts)\n                    )\n            else:\n                if self._cs_path_exists(fn):\n                    self.filelist.append(fn)\n                else:\n                    self.warn(\"standard file '%s' not found\" % fn)\n\n    def _add_defaults_optional(self):\n        optional = ['tests/test*.py', 'test/test*.py', 'setup.cfg']\n        for pattern in optional:\n            files = filter(os.path.isfile, glob(pattern))\n            self.filelist.extend(files)\n\n    def _add_defaults_python(self):\n        # build_py is used to get:\n        #  - python modules\n        #  - files defined in package_data\n        build_py = self.get_finalized_command('build_py')\n\n        # getting python files\n        if self.distribution.has_pure_modules():\n            self.filelist.extend(build_py.get_source_files())\n\n        # getting package_data files\n        # (computed in build_py.data_files by build_py.finalize_options)\n        for _pkg, src_dir, _build_dir, filenames in build_py.data_files:\n            for filename in filenames:\n                self.filelist.append(os.path.join(src_dir, filename))\n\n    def _add_defaults_data_files(self):\n        # getting distribution.data_files\n        if self.distribution.has_data_files():\n            for item in self.distribution.data_files:\n                if isinstance(item, str):\n                    # plain file\n                    item = convert_path(item)\n                    if os.path.isfile(item):\n                        self.filelist.append(item)\n                else:\n                    # a (dirname, filenames) tuple\n                    dirname, filenames = item\n                    for f in filenames:\n                        f = convert_path(f)\n                        if os.path.isfile(f):\n                            self.filelist.append(f)\n\n    def _add_defaults_ext(self):\n        if self.distribution.has_ext_modules():\n            build_ext = self.get_finalized_command('build_ext')\n            self.filelist.extend(build_ext.get_source_files())\n\n    def _add_defaults_c_libs(self):\n        if self.distribution.has_c_libraries():\n            build_clib = self.get_finalized_command('build_clib')\n            self.filelist.extend(build_clib.get_source_files())\n\n    def _add_defaults_scripts(self):\n        if self.distribution.has_scripts():\n            build_scripts = self.get_finalized_command('build_scripts')\n            self.filelist.extend(build_scripts.get_source_files())\n\n    def read_template(self):\n        \"\"\"Read and parse manifest template file named by self.template.\n\n        (usually \"MANIFEST.in\") The parsing and processing is done by\n        'self.filelist', which updates itself accordingly.\n        \"\"\"\n        log.info(\"reading manifest template '%s'\", self.template)\n        template = TextFile(\n            self.template,\n            strip_comments=1,\n            skip_blanks=1,\n            join_lines=1,\n            lstrip_ws=1,\n            rstrip_ws=1,\n            collapse_join=1,\n        )\n\n        try:\n            while True:\n                line = template.readline()\n                if line is None:  # end of file\n                    break\n\n                try:\n                    self.filelist.process_template_line(line)\n                # the call above can raise a DistutilsTemplateError for\n                # malformed lines, or a ValueError from the lower-level\n                # convert_path function\n                except (DistutilsTemplateError, ValueError) as msg:\n                    self.warn(\n                        \"%s, line %d: %s\"\n                        % (template.filename, template.current_line, msg)\n                    )\n        finally:\n            template.close()\n\n    def prune_file_list(self):\n        \"\"\"Prune off branches that might slip into the file list as created\n        by 'read_template()', but really don't belong there:\n          * the build tree (typically \"build\")\n          * the release tree itself (only an issue if we ran \"sdist\"\n            previously with --keep-temp, or it aborted)\n          * any RCS, CVS, .svn, .hg, .git, .bzr, _darcs directories\n        \"\"\"\n        build = self.get_finalized_command('build')\n        base_dir = self.distribution.get_fullname()\n\n        self.filelist.exclude_pattern(None, prefix=build.build_base)\n        self.filelist.exclude_pattern(None, prefix=base_dir)\n\n        if sys.platform == 'win32':\n            seps = r'/|\\\\'\n        else:\n            seps = '/'\n\n        vcs_dirs = ['RCS', 'CVS', r'\\.svn', r'\\.hg', r'\\.git', r'\\.bzr', '_darcs']\n        vcs_ptrn = r'(^|{})({})({}).*'.format(seps, '|'.join(vcs_dirs), seps)\n        self.filelist.exclude_pattern(vcs_ptrn, is_regex=1)\n\n    def write_manifest(self):\n        \"\"\"Write the file list in 'self.filelist' (presumably as filled in\n        by 'add_defaults()' and 'read_template()') to the manifest file\n        named by 'self.manifest'.\n        \"\"\"\n        if self._manifest_is_not_generated():\n            log.info(\n                \"not writing to manually maintained \"\n                \"manifest file '%s'\" % self.manifest\n            )\n            return\n\n        content = self.filelist.files[:]\n        content.insert(0, '# file GENERATED by distutils, do NOT edit')\n        self.execute(\n            file_util.write_file,\n            (self.manifest, content),\n            \"writing manifest file '%s'\" % self.manifest,\n        )\n\n    def _manifest_is_not_generated(self):\n        # check for special comment used in 3.1.3 and higher\n        if not os.path.isfile(self.manifest):\n            return False\n\n        with open(self.manifest, encoding='utf-8') as fp:\n            first_line = next(fp)\n        return first_line != '# file GENERATED by distutils, do NOT edit\\n'\n\n    def read_manifest(self):\n        \"\"\"Read the manifest file (named by 'self.manifest') and use it to\n        fill in 'self.filelist', the list of files to include in the source\n        distribution.\n        \"\"\"\n        log.info(\"reading manifest file '%s'\", self.manifest)\n        with open(self.manifest, encoding='utf-8') as lines:\n            self.filelist.extend(\n                # ignore comments and blank lines\n                filter(None, filterfalse(is_comment, map(str.strip, lines)))\n            )\n\n    def make_release_tree(self, base_dir, files):\n        \"\"\"Create the directory tree that will become the source\n        distribution archive.  All directories implied by the filenames in\n        'files' are created under 'base_dir', and then we hard link or copy\n        (if hard linking is unavailable) those files into place.\n        Essentially, this duplicates the developer's source tree, but in a\n        directory named after the distribution, containing only the files\n        to be distributed.\n        \"\"\"\n        # Create all the directories under 'base_dir' necessary to\n        # put 'files' there; the 'mkpath()' is just so we don't die\n        # if the manifest happens to be empty.\n        self.mkpath(base_dir)\n        dir_util.create_tree(base_dir, files, dry_run=self.dry_run)\n\n        # And walk over the list of files, either making a hard link (if\n        # os.link exists) to each one that doesn't already exist in its\n        # corresponding location under 'base_dir', or copying each file\n        # that's out-of-date in 'base_dir'.  (Usually, all files will be\n        # out-of-date, because by default we blow away 'base_dir' when\n        # we're done making the distribution archives.)\n\n        if hasattr(os, 'link'):  # can make hard links on this system\n            link = 'hard'\n            msg = \"making hard links in %s...\" % base_dir\n        else:  # nope, have to copy\n            link = None\n            msg = \"copying files to %s...\" % base_dir\n\n        if not files:\n            log.warning(\"no files to distribute -- empty manifest?\")\n        else:\n            log.info(msg)\n        for file in files:\n            if not os.path.isfile(file):\n                log.warning(\"'%s' not a regular file -- skipping\", file)\n            else:\n                dest = os.path.join(base_dir, file)\n                self.copy_file(file, dest, link=link)\n\n        self.distribution.metadata.write_pkg_info(base_dir)\n\n    def make_distribution(self):\n        \"\"\"Create the source distribution(s).  First, we create the release\n        tree with 'make_release_tree()'; then, we create all required\n        archive files (according to 'self.formats') from the release tree.\n        Finally, we clean up by blowing away the release tree (unless\n        'self.keep_temp' is true).  The list of archive files created is\n        stored so it can be retrieved later by 'get_archive_files()'.\n        \"\"\"\n        # Don't warn about missing meta-data here -- should be (and is!)\n        # done elsewhere.\n        base_dir = self.distribution.get_fullname()\n        base_name = os.path.join(self.dist_dir, base_dir)\n\n        self.make_release_tree(base_dir, self.filelist.files)\n        archive_files = []  # remember names of files we create\n        # tar archive must be created last to avoid overwrite and remove\n        if 'tar' in self.formats:\n            self.formats.append(self.formats.pop(self.formats.index('tar')))\n\n        for fmt in self.formats:\n            file = self.make_archive(\n                base_name, fmt, base_dir=base_dir, owner=self.owner, group=self.group\n            )\n            archive_files.append(file)\n            self.distribution.dist_files.append(('sdist', '', file))\n\n        self.archive_files = archive_files\n\n        if not self.keep_temp:\n            dir_util.remove_tree(base_dir, dry_run=self.dry_run)\n\n    def get_archive_files(self):\n        \"\"\"Return the list of archive files created when the command\n        was run, or None if the command hasn't run yet.\n        \"\"\"\n        return self.archive_files\n\n\ndef is_comment(line):\n    return line.startswith('#')\n", "setuptools/_distutils/command/bdist_dumb.py": "\"\"\"distutils.command.bdist_dumb\n\nImplements the Distutils 'bdist_dumb' command (create a \"dumb\" built\ndistribution -- i.e., just an archive to be unpacked under $prefix or\n$exec_prefix).\"\"\"\n\nimport os\nfrom distutils._log import log\n\nfrom ..core import Command\nfrom ..dir_util import ensure_relative, remove_tree\nfrom ..errors import DistutilsPlatformError\nfrom ..sysconfig import get_python_version\nfrom ..util import get_platform\n\n\nclass bdist_dumb(Command):\n    description = \"create a \\\"dumb\\\" built distribution\"\n\n    user_options = [\n        ('bdist-dir=', 'd', \"temporary directory for creating the distribution\"),\n        (\n            'plat-name=',\n            'p',\n            \"platform name to embed in generated filenames \"\n            \"(default: %s)\" % get_platform(),\n        ),\n        (\n            'format=',\n            'f',\n            \"archive format to create (tar, gztar, bztar, xztar, ztar, zip)\",\n        ),\n        (\n            'keep-temp',\n            'k',\n            \"keep the pseudo-installation tree around after \"\n            + \"creating the distribution archive\",\n        ),\n        ('dist-dir=', 'd', \"directory to put final built distributions in\"),\n        ('skip-build', None, \"skip rebuilding everything (for testing/debugging)\"),\n        (\n            'relative',\n            None,\n            \"build the archive using relative paths (default: false)\",\n        ),\n        (\n            'owner=',\n            'u',\n            \"Owner name used when creating a tar file [default: current user]\",\n        ),\n        (\n            'group=',\n            'g',\n            \"Group name used when creating a tar file [default: current group]\",\n        ),\n    ]\n\n    boolean_options = ['keep-temp', 'skip-build', 'relative']\n\n    default_format = {'posix': 'gztar', 'nt': 'zip'}\n\n    def initialize_options(self):\n        self.bdist_dir = None\n        self.plat_name = None\n        self.format = None\n        self.keep_temp = 0\n        self.dist_dir = None\n        self.skip_build = None\n        self.relative = 0\n        self.owner = None\n        self.group = None\n\n    def finalize_options(self):\n        if self.bdist_dir is None:\n            bdist_base = self.get_finalized_command('bdist').bdist_base\n            self.bdist_dir = os.path.join(bdist_base, 'dumb')\n\n        if self.format is None:\n            try:\n                self.format = self.default_format[os.name]\n            except KeyError:\n                raise DistutilsPlatformError(\n                    \"don't know how to create dumb built distributions \"\n                    \"on platform %s\" % os.name\n                )\n\n        self.set_undefined_options(\n            'bdist',\n            ('dist_dir', 'dist_dir'),\n            ('plat_name', 'plat_name'),\n            ('skip_build', 'skip_build'),\n        )\n\n    def run(self):\n        if not self.skip_build:\n            self.run_command('build')\n\n        install = self.reinitialize_command('install', reinit_subcommands=1)\n        install.root = self.bdist_dir\n        install.skip_build = self.skip_build\n        install.warn_dir = 0\n\n        log.info(\"installing to %s\", self.bdist_dir)\n        self.run_command('install')\n\n        # And make an archive relative to the root of the\n        # pseudo-installation tree.\n        archive_basename = f\"{self.distribution.get_fullname()}.{self.plat_name}\"\n\n        pseudoinstall_root = os.path.join(self.dist_dir, archive_basename)\n        if not self.relative:\n            archive_root = self.bdist_dir\n        else:\n            if self.distribution.has_ext_modules() and (\n                install.install_base != install.install_platbase\n            ):\n                raise DistutilsPlatformError(\n                    \"can't make a dumb built distribution where \"\n                    f\"base and platbase are different ({repr(install.install_base)}, {repr(install.install_platbase)})\"\n                )\n            else:\n                archive_root = os.path.join(\n                    self.bdist_dir, ensure_relative(install.install_base)\n                )\n\n        # Make the archive\n        filename = self.make_archive(\n            pseudoinstall_root,\n            self.format,\n            root_dir=archive_root,\n            owner=self.owner,\n            group=self.group,\n        )\n        if self.distribution.has_ext_modules():\n            pyversion = get_python_version()\n        else:\n            pyversion = 'any'\n        self.distribution.dist_files.append(('bdist_dumb', pyversion, filename))\n\n        if not self.keep_temp:\n            remove_tree(self.bdist_dir, dry_run=self.dry_run)\n", "setuptools/_distutils/command/install.py": "\"\"\"distutils.command.install\n\nImplements the Distutils 'install' command.\"\"\"\n\nimport contextlib\nimport itertools\nimport os\nimport sys\nimport sysconfig\nfrom distutils._log import log\nfrom site import USER_BASE, USER_SITE\n\nfrom .. import _collections\nfrom ..core import Command\nfrom ..debug import DEBUG\nfrom ..errors import DistutilsOptionError, DistutilsPlatformError\nfrom ..file_util import write_file\nfrom ..sysconfig import get_config_vars\nfrom ..util import change_root, convert_path, get_platform, subst_vars\nfrom . import _framework_compat as fw\n\nHAS_USER_SITE = True\n\nWINDOWS_SCHEME = {\n    'purelib': '{base}/Lib/site-packages',\n    'platlib': '{base}/Lib/site-packages',\n    'headers': '{base}/Include/{dist_name}',\n    'scripts': '{base}/Scripts',\n    'data': '{base}',\n}\n\nINSTALL_SCHEMES = {\n    'posix_prefix': {\n        'purelib': '{base}/lib/{implementation_lower}{py_version_short}/site-packages',\n        'platlib': '{platbase}/{platlibdir}/{implementation_lower}'\n        '{py_version_short}/site-packages',\n        'headers': '{base}/include/{implementation_lower}'\n        '{py_version_short}{abiflags}/{dist_name}',\n        'scripts': '{base}/bin',\n        'data': '{base}',\n    },\n    'posix_home': {\n        'purelib': '{base}/lib/{implementation_lower}',\n        'platlib': '{base}/{platlibdir}/{implementation_lower}',\n        'headers': '{base}/include/{implementation_lower}/{dist_name}',\n        'scripts': '{base}/bin',\n        'data': '{base}',\n    },\n    'nt': WINDOWS_SCHEME,\n    'pypy': {\n        'purelib': '{base}/site-packages',\n        'platlib': '{base}/site-packages',\n        'headers': '{base}/include/{dist_name}',\n        'scripts': '{base}/bin',\n        'data': '{base}',\n    },\n    'pypy_nt': {\n        'purelib': '{base}/site-packages',\n        'platlib': '{base}/site-packages',\n        'headers': '{base}/include/{dist_name}',\n        'scripts': '{base}/Scripts',\n        'data': '{base}',\n    },\n}\n\n# user site schemes\nif HAS_USER_SITE:\n    INSTALL_SCHEMES['nt_user'] = {\n        'purelib': '{usersite}',\n        'platlib': '{usersite}',\n        'headers': '{userbase}/{implementation}{py_version_nodot_plat}'\n        '/Include/{dist_name}',\n        'scripts': '{userbase}/{implementation}{py_version_nodot_plat}/Scripts',\n        'data': '{userbase}',\n    }\n\n    INSTALL_SCHEMES['posix_user'] = {\n        'purelib': '{usersite}',\n        'platlib': '{usersite}',\n        'headers': '{userbase}/include/{implementation_lower}'\n        '{py_version_short}{abiflags}/{dist_name}',\n        'scripts': '{userbase}/bin',\n        'data': '{userbase}',\n    }\n\n\nINSTALL_SCHEMES.update(fw.schemes)\n\n\n# The keys to an installation scheme; if any new types of files are to be\n# installed, be sure to add an entry to every installation scheme above,\n# and to SCHEME_KEYS here.\nSCHEME_KEYS = ('purelib', 'platlib', 'headers', 'scripts', 'data')\n\n\ndef _load_sysconfig_schemes():\n    with contextlib.suppress(AttributeError):\n        return {\n            scheme: sysconfig.get_paths(scheme, expand=False)\n            for scheme in sysconfig.get_scheme_names()\n        }\n\n\ndef _load_schemes():\n    \"\"\"\n    Extend default schemes with schemes from sysconfig.\n    \"\"\"\n\n    sysconfig_schemes = _load_sysconfig_schemes() or {}\n\n    return {\n        scheme: {\n            **INSTALL_SCHEMES.get(scheme, {}),\n            **sysconfig_schemes.get(scheme, {}),\n        }\n        for scheme in set(itertools.chain(INSTALL_SCHEMES, sysconfig_schemes))\n    }\n\n\ndef _get_implementation():\n    if hasattr(sys, 'pypy_version_info'):\n        return 'PyPy'\n    else:\n        return 'Python'\n\n\ndef _select_scheme(ob, name):\n    scheme = _inject_headers(name, _load_scheme(_resolve_scheme(name)))\n    vars(ob).update(_remove_set(ob, _scheme_attrs(scheme)))\n\n\ndef _remove_set(ob, attrs):\n    \"\"\"\n    Include only attrs that are None in ob.\n    \"\"\"\n    return {key: value for key, value in attrs.items() if getattr(ob, key) is None}\n\n\ndef _resolve_scheme(name):\n    os_name, sep, key = name.partition('_')\n    try:\n        resolved = sysconfig.get_preferred_scheme(key)\n    except Exception:\n        resolved = fw.scheme(_pypy_hack(name))\n    return resolved\n\n\ndef _load_scheme(name):\n    return _load_schemes()[name]\n\n\ndef _inject_headers(name, scheme):\n    \"\"\"\n    Given a scheme name and the resolved scheme,\n    if the scheme does not include headers, resolve\n    the fallback scheme for the name and use headers\n    from it. pypa/distutils#88\n    \"\"\"\n    # Bypass the preferred scheme, which may not\n    # have defined headers.\n    fallback = _load_scheme(_pypy_hack(name))\n    scheme.setdefault('headers', fallback['headers'])\n    return scheme\n\n\ndef _scheme_attrs(scheme):\n    \"\"\"Resolve install directories by applying the install schemes.\"\"\"\n    return {f'install_{key}': scheme[key] for key in SCHEME_KEYS}\n\n\ndef _pypy_hack(name):\n    PY37 = sys.version_info < (3, 8)\n    old_pypy = hasattr(sys, 'pypy_version_info') and PY37\n    prefix = not name.endswith(('_user', '_home'))\n    pypy_name = 'pypy' + '_nt' * (os.name == 'nt')\n    return pypy_name if old_pypy and prefix else name\n\n\nclass install(Command):\n    description = \"install everything from build directory\"\n\n    user_options = [\n        # Select installation scheme and set base director(y|ies)\n        ('prefix=', None, \"installation prefix\"),\n        ('exec-prefix=', None, \"(Unix only) prefix for platform-specific files\"),\n        ('home=', None, \"(Unix only) home directory to install under\"),\n        # Or, just set the base director(y|ies)\n        (\n            'install-base=',\n            None,\n            \"base installation directory (instead of --prefix or --home)\",\n        ),\n        (\n            'install-platbase=',\n            None,\n            \"base installation directory for platform-specific files \"\n            + \"(instead of --exec-prefix or --home)\",\n        ),\n        ('root=', None, \"install everything relative to this alternate root directory\"),\n        # Or, explicitly set the installation scheme\n        (\n            'install-purelib=',\n            None,\n            \"installation directory for pure Python module distributions\",\n        ),\n        (\n            'install-platlib=',\n            None,\n            \"installation directory for non-pure module distributions\",\n        ),\n        (\n            'install-lib=',\n            None,\n            \"installation directory for all module distributions \"\n            + \"(overrides --install-purelib and --install-platlib)\",\n        ),\n        ('install-headers=', None, \"installation directory for C/C++ headers\"),\n        ('install-scripts=', None, \"installation directory for Python scripts\"),\n        ('install-data=', None, \"installation directory for data files\"),\n        # Byte-compilation options -- see install_lib.py for details, as\n        # these are duplicated from there (but only install_lib does\n        # anything with them).\n        ('compile', 'c', \"compile .py to .pyc [default]\"),\n        ('no-compile', None, \"don't compile .py files\"),\n        (\n            'optimize=',\n            'O',\n            \"also compile with optimization: -O1 for \\\"python -O\\\", \"\n            \"-O2 for \\\"python -OO\\\", and -O0 to disable [default: -O0]\",\n        ),\n        # Miscellaneous control options\n        ('force', 'f', \"force installation (overwrite any existing files)\"),\n        ('skip-build', None, \"skip rebuilding everything (for testing/debugging)\"),\n        # Where to install documentation (eventually!)\n        # ('doc-format=', None, \"format of documentation to generate\"),\n        # ('install-man=', None, \"directory for Unix man pages\"),\n        # ('install-html=', None, \"directory for HTML documentation\"),\n        # ('install-info=', None, \"directory for GNU info files\"),\n        ('record=', None, \"filename in which to record list of installed files\"),\n    ]\n\n    boolean_options = ['compile', 'force', 'skip-build']\n\n    if HAS_USER_SITE:\n        user_options.append((\n            'user',\n            None,\n            \"install in user site-package '%s'\" % USER_SITE,\n        ))\n        boolean_options.append('user')\n\n    negative_opt = {'no-compile': 'compile'}\n\n    def initialize_options(self):\n        \"\"\"Initializes options.\"\"\"\n        # High-level options: these select both an installation base\n        # and scheme.\n        self.prefix = None\n        self.exec_prefix = None\n        self.home = None\n        self.user = 0\n\n        # These select only the installation base; it's up to the user to\n        # specify the installation scheme (currently, that means supplying\n        # the --install-{platlib,purelib,scripts,data} options).\n        self.install_base = None\n        self.install_platbase = None\n        self.root = None\n\n        # These options are the actual installation directories; if not\n        # supplied by the user, they are filled in using the installation\n        # scheme implied by prefix/exec-prefix/home and the contents of\n        # that installation scheme.\n        self.install_purelib = None  # for pure module distributions\n        self.install_platlib = None  # non-pure (dists w/ extensions)\n        self.install_headers = None  # for C/C++ headers\n        self.install_lib = None  # set to either purelib or platlib\n        self.install_scripts = None\n        self.install_data = None\n        self.install_userbase = USER_BASE\n        self.install_usersite = USER_SITE\n\n        self.compile = None\n        self.optimize = None\n\n        # Deprecated\n        # These two are for putting non-packagized distributions into their\n        # own directory and creating a .pth file if it makes sense.\n        # 'extra_path' comes from the setup file; 'install_path_file' can\n        # be turned off if it makes no sense to install a .pth file.  (But\n        # better to install it uselessly than to guess wrong and not\n        # install it when it's necessary and would be used!)  Currently,\n        # 'install_path_file' is always true unless some outsider meddles\n        # with it.\n        self.extra_path = None\n        self.install_path_file = 1\n\n        # 'force' forces installation, even if target files are not\n        # out-of-date.  'skip_build' skips running the \"build\" command,\n        # handy if you know it's not necessary.  'warn_dir' (which is *not*\n        # a user option, it's just there so the bdist_* commands can turn\n        # it off) determines whether we warn about installing to a\n        # directory not in sys.path.\n        self.force = 0\n        self.skip_build = 0\n        self.warn_dir = 1\n\n        # These are only here as a conduit from the 'build' command to the\n        # 'install_*' commands that do the real work.  ('build_base' isn't\n        # actually used anywhere, but it might be useful in future.)  They\n        # are not user options, because if the user told the install\n        # command where the build directory is, that wouldn't affect the\n        # build command.\n        self.build_base = None\n        self.build_lib = None\n\n        # Not defined yet because we don't know anything about\n        # documentation yet.\n        # self.install_man = None\n        # self.install_html = None\n        # self.install_info = None\n\n        self.record = None\n\n    # -- Option finalizing methods -------------------------------------\n    # (This is rather more involved than for most commands,\n    # because this is where the policy for installing third-\n    # party Python modules on various platforms given a wide\n    # array of user input is decided.  Yes, it's quite complex!)\n\n    def finalize_options(self):  # noqa: C901\n        \"\"\"Finalizes options.\"\"\"\n        # This method (and its helpers, like 'finalize_unix()',\n        # 'finalize_other()', and 'select_scheme()') is where the default\n        # installation directories for modules, extension modules, and\n        # anything else we care to install from a Python module\n        # distribution.  Thus, this code makes a pretty important policy\n        # statement about how third-party stuff is added to a Python\n        # installation!  Note that the actual work of installation is done\n        # by the relatively simple 'install_*' commands; they just take\n        # their orders from the installation directory options determined\n        # here.\n\n        # Check for errors/inconsistencies in the options; first, stuff\n        # that's wrong on any platform.\n\n        if (self.prefix or self.exec_prefix or self.home) and (\n            self.install_base or self.install_platbase\n        ):\n            raise DistutilsOptionError(\n                \"must supply either prefix/exec-prefix/home or \"\n                + \"install-base/install-platbase -- not both\"\n            )\n\n        if self.home and (self.prefix or self.exec_prefix):\n            raise DistutilsOptionError(\n                \"must supply either home or prefix/exec-prefix -- not both\"\n            )\n\n        if self.user and (\n            self.prefix\n            or self.exec_prefix\n            or self.home\n            or self.install_base\n            or self.install_platbase\n        ):\n            raise DistutilsOptionError(\n                \"can't combine user with prefix, \"\n                \"exec_prefix/home, or install_(plat)base\"\n            )\n\n        # Next, stuff that's wrong (or dubious) only on certain platforms.\n        if os.name != \"posix\":\n            if self.exec_prefix:\n                self.warn(\"exec-prefix option ignored on this platform\")\n                self.exec_prefix = None\n\n        # Now the interesting logic -- so interesting that we farm it out\n        # to other methods.  The goal of these methods is to set the final\n        # values for the install_{lib,scripts,data,...}  options, using as\n        # input a heady brew of prefix, exec_prefix, home, install_base,\n        # install_platbase, user-supplied versions of\n        # install_{purelib,platlib,lib,scripts,data,...}, and the\n        # install schemes.  Phew!\n\n        self.dump_dirs(\"pre-finalize_{unix,other}\")\n\n        if os.name == 'posix':\n            self.finalize_unix()\n        else:\n            self.finalize_other()\n\n        self.dump_dirs(\"post-finalize_{unix,other}()\")\n\n        # Expand configuration variables, tilde, etc. in self.install_base\n        # and self.install_platbase -- that way, we can use $base or\n        # $platbase in the other installation directories and not worry\n        # about needing recursive variable expansion (shudder).\n\n        py_version = sys.version.split()[0]\n        (prefix, exec_prefix) = get_config_vars('prefix', 'exec_prefix')\n        try:\n            abiflags = sys.abiflags\n        except AttributeError:\n            # sys.abiflags may not be defined on all platforms.\n            abiflags = ''\n        local_vars = {\n            'dist_name': self.distribution.get_name(),\n            'dist_version': self.distribution.get_version(),\n            'dist_fullname': self.distribution.get_fullname(),\n            'py_version': py_version,\n            'py_version_short': '%d.%d' % sys.version_info[:2],\n            'py_version_nodot': '%d%d' % sys.version_info[:2],\n            'sys_prefix': prefix,\n            'prefix': prefix,\n            'sys_exec_prefix': exec_prefix,\n            'exec_prefix': exec_prefix,\n            'abiflags': abiflags,\n            'platlibdir': getattr(sys, 'platlibdir', 'lib'),\n            'implementation_lower': _get_implementation().lower(),\n            'implementation': _get_implementation(),\n        }\n\n        # vars for compatibility on older Pythons\n        compat_vars = dict(\n            # Python 3.9 and earlier\n            py_version_nodot_plat=getattr(sys, 'winver', '').replace('.', ''),\n        )\n\n        if HAS_USER_SITE:\n            local_vars['userbase'] = self.install_userbase\n            local_vars['usersite'] = self.install_usersite\n\n        self.config_vars = _collections.DictStack([\n            fw.vars(),\n            compat_vars,\n            sysconfig.get_config_vars(),\n            local_vars,\n        ])\n\n        self.expand_basedirs()\n\n        self.dump_dirs(\"post-expand_basedirs()\")\n\n        # Now define config vars for the base directories so we can expand\n        # everything else.\n        local_vars['base'] = self.install_base\n        local_vars['platbase'] = self.install_platbase\n\n        if DEBUG:\n            from pprint import pprint\n\n            print(\"config vars:\")\n            pprint(dict(self.config_vars))\n\n        # Expand \"~\" and configuration variables in the installation\n        # directories.\n        self.expand_dirs()\n\n        self.dump_dirs(\"post-expand_dirs()\")\n\n        # Create directories in the home dir:\n        if self.user:\n            self.create_home_path()\n\n        # Pick the actual directory to install all modules to: either\n        # install_purelib or install_platlib, depending on whether this\n        # module distribution is pure or not.  Of course, if the user\n        # already specified install_lib, use their selection.\n        if self.install_lib is None:\n            if self.distribution.has_ext_modules():  # has extensions: non-pure\n                self.install_lib = self.install_platlib\n            else:\n                self.install_lib = self.install_purelib\n\n        # Convert directories from Unix /-separated syntax to the local\n        # convention.\n        self.convert_paths(\n            'lib',\n            'purelib',\n            'platlib',\n            'scripts',\n            'data',\n            'headers',\n            'userbase',\n            'usersite',\n        )\n\n        # Deprecated\n        # Well, we're not actually fully completely finalized yet: we still\n        # have to deal with 'extra_path', which is the hack for allowing\n        # non-packagized module distributions (hello, Numerical Python!) to\n        # get their own directories.\n        self.handle_extra_path()\n        self.install_libbase = self.install_lib  # needed for .pth file\n        self.install_lib = os.path.join(self.install_lib, self.extra_dirs)\n\n        # If a new root directory was supplied, make all the installation\n        # dirs relative to it.\n        if self.root is not None:\n            self.change_roots(\n                'libbase', 'lib', 'purelib', 'platlib', 'scripts', 'data', 'headers'\n            )\n\n        self.dump_dirs(\"after prepending root\")\n\n        # Find out the build directories, ie. where to install from.\n        self.set_undefined_options(\n            'build', ('build_base', 'build_base'), ('build_lib', 'build_lib')\n        )\n\n        # Punt on doc directories for now -- after all, we're punting on\n        # documentation completely!\n\n    def dump_dirs(self, msg):\n        \"\"\"Dumps the list of user options.\"\"\"\n        if not DEBUG:\n            return\n        from ..fancy_getopt import longopt_xlate\n\n        log.debug(msg + \":\")\n        for opt in self.user_options:\n            opt_name = opt[0]\n            if opt_name[-1] == \"=\":\n                opt_name = opt_name[0:-1]\n            if opt_name in self.negative_opt:\n                opt_name = self.negative_opt[opt_name]\n                opt_name = opt_name.translate(longopt_xlate)\n                val = not getattr(self, opt_name)\n            else:\n                opt_name = opt_name.translate(longopt_xlate)\n                val = getattr(self, opt_name)\n            log.debug(\"  %s: %s\", opt_name, val)\n\n    def finalize_unix(self):\n        \"\"\"Finalizes options for posix platforms.\"\"\"\n        if self.install_base is not None or self.install_platbase is not None:\n            incomplete_scheme = (\n                (\n                    self.install_lib is None\n                    and self.install_purelib is None\n                    and self.install_platlib is None\n                )\n                or self.install_headers is None\n                or self.install_scripts is None\n                or self.install_data is None\n            )\n            if incomplete_scheme:\n                raise DistutilsOptionError(\n                    \"install-base or install-platbase supplied, but \"\n                    \"installation scheme is incomplete\"\n                )\n            return\n\n        if self.user:\n            if self.install_userbase is None:\n                raise DistutilsPlatformError(\"User base directory is not specified\")\n            self.install_base = self.install_platbase = self.install_userbase\n            self.select_scheme(\"posix_user\")\n        elif self.home is not None:\n            self.install_base = self.install_platbase = self.home\n            self.select_scheme(\"posix_home\")\n        else:\n            if self.prefix is None:\n                if self.exec_prefix is not None:\n                    raise DistutilsOptionError(\n                        \"must not supply exec-prefix without prefix\"\n                    )\n\n                # Allow Fedora to add components to the prefix\n                _prefix_addition = getattr(sysconfig, '_prefix_addition', \"\")\n\n                self.prefix = os.path.normpath(sys.prefix) + _prefix_addition\n                self.exec_prefix = os.path.normpath(sys.exec_prefix) + _prefix_addition\n\n            else:\n                if self.exec_prefix is None:\n                    self.exec_prefix = self.prefix\n\n            self.install_base = self.prefix\n            self.install_platbase = self.exec_prefix\n            self.select_scheme(\"posix_prefix\")\n\n    def finalize_other(self):\n        \"\"\"Finalizes options for non-posix platforms\"\"\"\n        if self.user:\n            if self.install_userbase is None:\n                raise DistutilsPlatformError(\"User base directory is not specified\")\n            self.install_base = self.install_platbase = self.install_userbase\n            self.select_scheme(os.name + \"_user\")\n        elif self.home is not None:\n            self.install_base = self.install_platbase = self.home\n            self.select_scheme(\"posix_home\")\n        else:\n            if self.prefix is None:\n                self.prefix = os.path.normpath(sys.prefix)\n\n            self.install_base = self.install_platbase = self.prefix\n            try:\n                self.select_scheme(os.name)\n            except KeyError:\n                raise DistutilsPlatformError(\n                    \"I don't know how to install stuff on '%s'\" % os.name\n                )\n\n    def select_scheme(self, name):\n        _select_scheme(self, name)\n\n    def _expand_attrs(self, attrs):\n        for attr in attrs:\n            val = getattr(self, attr)\n            if val is not None:\n                if os.name in ('posix', 'nt'):\n                    val = os.path.expanduser(val)\n                val = subst_vars(val, self.config_vars)\n                setattr(self, attr, val)\n\n    def expand_basedirs(self):\n        \"\"\"Calls `os.path.expanduser` on install_base, install_platbase and\n        root.\"\"\"\n        self._expand_attrs(['install_base', 'install_platbase', 'root'])\n\n    def expand_dirs(self):\n        \"\"\"Calls `os.path.expanduser` on install dirs.\"\"\"\n        self._expand_attrs([\n            'install_purelib',\n            'install_platlib',\n            'install_lib',\n            'install_headers',\n            'install_scripts',\n            'install_data',\n        ])\n\n    def convert_paths(self, *names):\n        \"\"\"Call `convert_path` over `names`.\"\"\"\n        for name in names:\n            attr = \"install_\" + name\n            setattr(self, attr, convert_path(getattr(self, attr)))\n\n    def handle_extra_path(self):\n        \"\"\"Set `path_file` and `extra_dirs` using `extra_path`.\"\"\"\n        if self.extra_path is None:\n            self.extra_path = self.distribution.extra_path\n\n        if self.extra_path is not None:\n            log.warning(\n                \"Distribution option extra_path is deprecated. \"\n                \"See issue27919 for details.\"\n            )\n            if isinstance(self.extra_path, str):\n                self.extra_path = self.extra_path.split(',')\n\n            if len(self.extra_path) == 1:\n                path_file = extra_dirs = self.extra_path[0]\n            elif len(self.extra_path) == 2:\n                path_file, extra_dirs = self.extra_path\n            else:\n                raise DistutilsOptionError(\n                    \"'extra_path' option must be a list, tuple, or \"\n                    \"comma-separated string with 1 or 2 elements\"\n                )\n\n            # convert to local form in case Unix notation used (as it\n            # should be in setup scripts)\n            extra_dirs = convert_path(extra_dirs)\n        else:\n            path_file = None\n            extra_dirs = ''\n\n        # XXX should we warn if path_file and not extra_dirs? (in which\n        # case the path file would be harmless but pointless)\n        self.path_file = path_file\n        self.extra_dirs = extra_dirs\n\n    def change_roots(self, *names):\n        \"\"\"Change the install directories pointed by name using root.\"\"\"\n        for name in names:\n            attr = \"install_\" + name\n            setattr(self, attr, change_root(self.root, getattr(self, attr)))\n\n    def create_home_path(self):\n        \"\"\"Create directories under ~.\"\"\"\n        if not self.user:\n            return\n        home = convert_path(os.path.expanduser(\"~\"))\n        for _name, path in self.config_vars.items():\n            if str(path).startswith(home) and not os.path.isdir(path):\n                self.debug_print(\"os.makedirs('%s', 0o700)\" % path)\n                os.makedirs(path, 0o700)\n\n    # -- Command execution methods -------------------------------------\n\n    def run(self):\n        \"\"\"Runs the command.\"\"\"\n        # Obviously have to build before we can install\n        if not self.skip_build:\n            self.run_command('build')\n            # If we built for any other platform, we can't install.\n            build_plat = self.distribution.get_command_obj('build').plat_name\n            # check warn_dir - it is a clue that the 'install' is happening\n            # internally, and not to sys.path, so we don't check the platform\n            # matches what we are running.\n            if self.warn_dir and build_plat != get_platform():\n                raise DistutilsPlatformError(\"Can't install when cross-compiling\")\n\n        # Run all sub-commands (at least those that need to be run)\n        for cmd_name in self.get_sub_commands():\n            self.run_command(cmd_name)\n\n        if self.path_file:\n            self.create_path_file()\n\n        # write list of installed files, if requested.\n        if self.record:\n            outputs = self.get_outputs()\n            if self.root:  # strip any package prefix\n                root_len = len(self.root)\n                for counter in range(len(outputs)):\n                    outputs[counter] = outputs[counter][root_len:]\n            self.execute(\n                write_file,\n                (self.record, outputs),\n                \"writing list of installed files to '%s'\" % self.record,\n            )\n\n        sys_path = map(os.path.normpath, sys.path)\n        sys_path = map(os.path.normcase, sys_path)\n        install_lib = os.path.normcase(os.path.normpath(self.install_lib))\n        if (\n            self.warn_dir\n            and not (self.path_file and self.install_path_file)\n            and install_lib not in sys_path\n        ):\n            log.debug(\n                (\n                    \"modules installed to '%s', which is not in \"\n                    \"Python's module search path (sys.path) -- \"\n                    \"you'll have to change the search path yourself\"\n                ),\n                self.install_lib,\n            )\n\n    def create_path_file(self):\n        \"\"\"Creates the .pth file\"\"\"\n        filename = os.path.join(self.install_libbase, self.path_file + \".pth\")\n        if self.install_path_file:\n            self.execute(\n                write_file, (filename, [self.extra_dirs]), \"creating %s\" % filename\n            )\n        else:\n            self.warn(\"path file '%s' not created\" % filename)\n\n    # -- Reporting methods ---------------------------------------------\n\n    def get_outputs(self):\n        \"\"\"Assembles the outputs of all the sub-commands.\"\"\"\n        outputs = []\n        for cmd_name in self.get_sub_commands():\n            cmd = self.get_finalized_command(cmd_name)\n            # Add the contents of cmd.get_outputs(), ensuring\n            # that outputs doesn't contain duplicate entries\n            for filename in cmd.get_outputs():\n                if filename not in outputs:\n                    outputs.append(filename)\n\n        if self.path_file and self.install_path_file:\n            outputs.append(os.path.join(self.install_libbase, self.path_file + \".pth\"))\n\n        return outputs\n\n    def get_inputs(self):\n        \"\"\"Returns the inputs of all the sub-commands\"\"\"\n        # XXX gee, this looks familiar ;-(\n        inputs = []\n        for cmd_name in self.get_sub_commands():\n            cmd = self.get_finalized_command(cmd_name)\n            inputs.extend(cmd.get_inputs())\n\n        return inputs\n\n    # -- Predicates for sub-command list -------------------------------\n\n    def has_lib(self):\n        \"\"\"Returns true if the current distribution has any Python\n        modules to install.\"\"\"\n        return (\n            self.distribution.has_pure_modules() or self.distribution.has_ext_modules()\n        )\n\n    def has_headers(self):\n        \"\"\"Returns true if the current distribution has any headers to\n        install.\"\"\"\n        return self.distribution.has_headers()\n\n    def has_scripts(self):\n        \"\"\"Returns true if the current distribution has any scripts to.\n        install.\"\"\"\n        return self.distribution.has_scripts()\n\n    def has_data(self):\n        \"\"\"Returns true if the current distribution has any data to.\n        install.\"\"\"\n        return self.distribution.has_data_files()\n\n    # 'sub_commands': a list of commands this command might have to run to\n    # get its work done.  See cmd.py for more info.\n    sub_commands = [\n        ('install_lib', has_lib),\n        ('install_headers', has_headers),\n        ('install_scripts', has_scripts),\n        ('install_data', has_data),\n        ('install_egg_info', lambda self: True),\n    ]\n", "setuptools/_distutils/command/_framework_compat.py": "\"\"\"\nBackward compatibility for homebrew builds on macOS.\n\"\"\"\n\nimport functools\nimport os\nimport subprocess\nimport sys\nimport sysconfig\n\n\n@functools.lru_cache\ndef enabled():\n    \"\"\"\n    Only enabled for Python 3.9 framework homebrew builds\n    except ensurepip and venv.\n    \"\"\"\n    PY39 = (3, 9) < sys.version_info < (3, 10)\n    framework = sys.platform == 'darwin' and sys._framework\n    homebrew = \"Cellar\" in sysconfig.get_config_var('projectbase')\n    venv = sys.prefix != sys.base_prefix\n    ensurepip = os.environ.get(\"ENSUREPIP_OPTIONS\")\n    return PY39 and framework and homebrew and not venv and not ensurepip\n\n\nschemes = dict(\n    osx_framework_library=dict(\n        stdlib='{installed_base}/{platlibdir}/python{py_version_short}',\n        platstdlib='{platbase}/{platlibdir}/python{py_version_short}',\n        purelib='{homebrew_prefix}/lib/python{py_version_short}/site-packages',\n        platlib='{homebrew_prefix}/{platlibdir}/python{py_version_short}/site-packages',\n        include='{installed_base}/include/python{py_version_short}{abiflags}',\n        platinclude='{installed_platbase}/include/python{py_version_short}{abiflags}',\n        scripts='{homebrew_prefix}/bin',\n        data='{homebrew_prefix}',\n    )\n)\n\n\n@functools.lru_cache\ndef vars():\n    if not enabled():\n        return {}\n    homebrew_prefix = subprocess.check_output(['brew', '--prefix'], text=True).strip()\n    return locals()\n\n\ndef scheme(name):\n    \"\"\"\n    Override the selected scheme for posix_prefix.\n    \"\"\"\n    if not enabled() or not name.endswith('_prefix'):\n        return name\n    return 'osx_framework_library'\n", "setuptools/_distutils/command/build_clib.py": "\"\"\"distutils.command.build_clib\n\nImplements the Distutils 'build_clib' command, to build a C/C++ library\nthat is included in the module distribution and needed by an extension\nmodule.\"\"\"\n\n\n# XXX this module has *lots* of code ripped-off quite transparently from\n# build_ext.py -- not surprisingly really, as the work required to build\n# a static library from a collection of C source files is not really all\n# that different from what's required to build a shared object file from\n# a collection of C source files.  Nevertheless, I haven't done the\n# necessary refactoring to account for the overlap in code between the\n# two modules, mainly because a number of subtle details changed in the\n# cut 'n paste.  Sigh.\n\nimport os\nfrom distutils._log import log\n\nfrom ..core import Command\nfrom ..errors import DistutilsSetupError\nfrom ..sysconfig import customize_compiler\n\n\ndef show_compilers():\n    from ..ccompiler import show_compilers\n\n    show_compilers()\n\n\nclass build_clib(Command):\n    description = \"build C/C++ libraries used by Python extensions\"\n\n    user_options = [\n        ('build-clib=', 'b', \"directory to build C/C++ libraries to\"),\n        ('build-temp=', 't', \"directory to put temporary build by-products\"),\n        ('debug', 'g', \"compile with debugging information\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps)\"),\n        ('compiler=', 'c', \"specify the compiler type\"),\n    ]\n\n    boolean_options = ['debug', 'force']\n\n    help_options = [\n        ('help-compiler', None, \"list available compilers\", show_compilers),\n    ]\n\n    def initialize_options(self):\n        self.build_clib = None\n        self.build_temp = None\n\n        # List of libraries to build\n        self.libraries = None\n\n        # Compilation options for all libraries\n        self.include_dirs = None\n        self.define = None\n        self.undef = None\n        self.debug = None\n        self.force = 0\n        self.compiler = None\n\n    def finalize_options(self):\n        # This might be confusing: both build-clib and build-temp default\n        # to build-temp as defined by the \"build\" command.  This is because\n        # I think that C libraries are really just temporary build\n        # by-products, at least from the point of view of building Python\n        # extensions -- but I want to keep my options open.\n        self.set_undefined_options(\n            'build',\n            ('build_temp', 'build_clib'),\n            ('build_temp', 'build_temp'),\n            ('compiler', 'compiler'),\n            ('debug', 'debug'),\n            ('force', 'force'),\n        )\n\n        self.libraries = self.distribution.libraries\n        if self.libraries:\n            self.check_library_list(self.libraries)\n\n        if self.include_dirs is None:\n            self.include_dirs = self.distribution.include_dirs or []\n        if isinstance(self.include_dirs, str):\n            self.include_dirs = self.include_dirs.split(os.pathsep)\n\n        # XXX same as for build_ext -- what about 'self.define' and\n        # 'self.undef' ?\n\n    def run(self):\n        if not self.libraries:\n            return\n\n        # Yech -- this is cut 'n pasted from build_ext.py!\n        from ..ccompiler import new_compiler\n\n        self.compiler = new_compiler(\n            compiler=self.compiler, dry_run=self.dry_run, force=self.force\n        )\n        customize_compiler(self.compiler)\n\n        if self.include_dirs is not None:\n            self.compiler.set_include_dirs(self.include_dirs)\n        if self.define is not None:\n            # 'define' option is a list of (name,value) tuples\n            for name, value in self.define:\n                self.compiler.define_macro(name, value)\n        if self.undef is not None:\n            for macro in self.undef:\n                self.compiler.undefine_macro(macro)\n\n        self.build_libraries(self.libraries)\n\n    def check_library_list(self, libraries):\n        \"\"\"Ensure that the list of libraries is valid.\n\n        `library` is presumably provided as a command option 'libraries'.\n        This method checks that it is a list of 2-tuples, where the tuples\n        are (library_name, build_info_dict).\n\n        Raise DistutilsSetupError if the structure is invalid anywhere;\n        just returns otherwise.\n        \"\"\"\n        if not isinstance(libraries, list):\n            raise DistutilsSetupError(\"'libraries' option must be a list of tuples\")\n\n        for lib in libraries:\n            if not isinstance(lib, tuple) and len(lib) != 2:\n                raise DistutilsSetupError(\"each element of 'libraries' must a 2-tuple\")\n\n            name, build_info = lib\n\n            if not isinstance(name, str):\n                raise DistutilsSetupError(\n                    \"first element of each tuple in 'libraries' \"\n                    \"must be a string (the library name)\"\n                )\n\n            if '/' in name or (os.sep != '/' and os.sep in name):\n                raise DistutilsSetupError(\n                    \"bad library name '%s': \"\n                    \"may not contain directory separators\" % lib[0]\n                )\n\n            if not isinstance(build_info, dict):\n                raise DistutilsSetupError(\n                    \"second element of each tuple in 'libraries' \"\n                    \"must be a dictionary (build info)\"\n                )\n\n    def get_library_names(self):\n        # Assume the library list is valid -- 'check_library_list()' is\n        # called from 'finalize_options()', so it should be!\n        if not self.libraries:\n            return None\n\n        lib_names = []\n        for lib_name, _build_info in self.libraries:\n            lib_names.append(lib_name)\n        return lib_names\n\n    def get_source_files(self):\n        self.check_library_list(self.libraries)\n        filenames = []\n        for lib_name, build_info in self.libraries:\n            sources = build_info.get('sources')\n            if sources is None or not isinstance(sources, (list, tuple)):\n                raise DistutilsSetupError(\n                    \"in 'libraries' option (library '%s'), \"\n                    \"'sources' must be present and must be \"\n                    \"a list of source filenames\" % lib_name\n                )\n\n            filenames.extend(sources)\n        return filenames\n\n    def build_libraries(self, libraries):\n        for lib_name, build_info in libraries:\n            sources = build_info.get('sources')\n            if sources is None or not isinstance(sources, (list, tuple)):\n                raise DistutilsSetupError(\n                    \"in 'libraries' option (library '%s'), \"\n                    \"'sources' must be present and must be \"\n                    \"a list of source filenames\" % lib_name\n                )\n            sources = list(sources)\n\n            log.info(\"building '%s' library\", lib_name)\n\n            # First, compile the source code to object files in the library\n            # directory.  (This should probably change to putting object\n            # files in a temporary build directory.)\n            macros = build_info.get('macros')\n            include_dirs = build_info.get('include_dirs')\n            objects = self.compiler.compile(\n                sources,\n                output_dir=self.build_temp,\n                macros=macros,\n                include_dirs=include_dirs,\n                debug=self.debug,\n            )\n\n            # Now \"link\" the object files together into a static library.\n            # (On Unix at least, this isn't really linking -- it just\n            # builds an archive.  Whatever.)\n            self.compiler.create_static_lib(\n                objects, lib_name, output_dir=self.build_clib, debug=self.debug\n            )\n", "setuptools/_distutils/command/bdist.py": "\"\"\"distutils.command.bdist\n\nImplements the Distutils 'bdist' command (create a built [binary]\ndistribution).\"\"\"\n\nimport os\nimport warnings\n\nfrom ..core import Command\nfrom ..errors import DistutilsOptionError, DistutilsPlatformError\nfrom ..util import get_platform\n\n\ndef show_formats():\n    \"\"\"Print list of available formats (arguments to \"--format\" option).\"\"\"\n    from ..fancy_getopt import FancyGetopt\n\n    formats = []\n    for format in bdist.format_commands:\n        formats.append((\"formats=\" + format, None, bdist.format_commands[format][1]))\n    pretty_printer = FancyGetopt(formats)\n    pretty_printer.print_help(\"List of available distribution formats:\")\n\n\nclass ListCompat(dict):\n    # adapter to allow for Setuptools compatibility in format_commands\n    def append(self, item):\n        warnings.warn(\n            \"\"\"format_commands is now a dict. append is deprecated.\"\"\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n\nclass bdist(Command):\n    description = \"create a built (binary) distribution\"\n\n    user_options = [\n        ('bdist-base=', 'b', \"temporary directory for creating built distributions\"),\n        (\n            'plat-name=',\n            'p',\n            \"platform name to embed in generated filenames \"\n            \"(default: %s)\" % get_platform(),\n        ),\n        ('formats=', None, \"formats for distribution (comma-separated list)\"),\n        (\n            'dist-dir=',\n            'd',\n            \"directory to put final built distributions in [default: dist]\",\n        ),\n        ('skip-build', None, \"skip rebuilding everything (for testing/debugging)\"),\n        (\n            'owner=',\n            'u',\n            \"Owner name used when creating a tar file [default: current user]\",\n        ),\n        (\n            'group=',\n            'g',\n            \"Group name used when creating a tar file [default: current group]\",\n        ),\n    ]\n\n    boolean_options = ['skip-build']\n\n    help_options = [\n        ('help-formats', None, \"lists available distribution formats\", show_formats),\n    ]\n\n    # The following commands do not take a format option from bdist\n    no_format_option = ('bdist_rpm',)\n\n    # This won't do in reality: will need to distinguish RPM-ish Linux,\n    # Debian-ish Linux, Solaris, FreeBSD, ..., Windows, Mac OS.\n    default_format = {'posix': 'gztar', 'nt': 'zip'}\n\n    # Define commands in preferred order for the --help-formats option\n    format_commands = ListCompat({\n        'rpm': ('bdist_rpm', \"RPM distribution\"),\n        'gztar': ('bdist_dumb', \"gzip'ed tar file\"),\n        'bztar': ('bdist_dumb', \"bzip2'ed tar file\"),\n        'xztar': ('bdist_dumb', \"xz'ed tar file\"),\n        'ztar': ('bdist_dumb', \"compressed tar file\"),\n        'tar': ('bdist_dumb', \"tar file\"),\n        'zip': ('bdist_dumb', \"ZIP file\"),\n    })\n\n    # for compatibility until consumers only reference format_commands\n    format_command = format_commands\n\n    def initialize_options(self):\n        self.bdist_base = None\n        self.plat_name = None\n        self.formats = None\n        self.dist_dir = None\n        self.skip_build = 0\n        self.group = None\n        self.owner = None\n\n    def finalize_options(self):\n        # have to finalize 'plat_name' before 'bdist_base'\n        if self.plat_name is None:\n            if self.skip_build:\n                self.plat_name = get_platform()\n            else:\n                self.plat_name = self.get_finalized_command('build').plat_name\n\n        # 'bdist_base' -- parent of per-built-distribution-format\n        # temporary directories (eg. we'll probably have\n        # \"build/bdist.<plat>/dumb\", \"build/bdist.<plat>/rpm\", etc.)\n        if self.bdist_base is None:\n            build_base = self.get_finalized_command('build').build_base\n            self.bdist_base = os.path.join(build_base, 'bdist.' + self.plat_name)\n\n        self.ensure_string_list('formats')\n        if self.formats is None:\n            try:\n                self.formats = [self.default_format[os.name]]\n            except KeyError:\n                raise DistutilsPlatformError(\n                    \"don't know how to create built distributions \"\n                    \"on platform %s\" % os.name\n                )\n\n        if self.dist_dir is None:\n            self.dist_dir = \"dist\"\n\n    def run(self):\n        # Figure out which sub-commands we need to run.\n        commands = []\n        for format in self.formats:\n            try:\n                commands.append(self.format_commands[format][0])\n            except KeyError:\n                raise DistutilsOptionError(\"invalid format '%s'\" % format)\n\n        # Reinitialize and run each command.\n        for i in range(len(self.formats)):\n            cmd_name = commands[i]\n            sub_cmd = self.reinitialize_command(cmd_name)\n            if cmd_name not in self.no_format_option:\n                sub_cmd.format = self.formats[i]\n\n            # passing the owner and group names for tar archiving\n            if cmd_name == 'bdist_dumb':\n                sub_cmd.owner = self.owner\n                sub_cmd.group = self.group\n\n            # If we're going to need to run this command again, tell it to\n            # keep its temporary files around so subsequent runs go faster.\n            if cmd_name in commands[i + 1 :]:\n                sub_cmd.keep_temp = 1\n            self.run_command(cmd_name)\n", "setuptools/_distutils/command/install_scripts.py": "\"\"\"distutils.command.install_scripts\n\nImplements the Distutils 'install_scripts' command, for installing\nPython scripts.\"\"\"\n\n# contributed by Bastian Kleineidam\n\nimport os\nfrom distutils._log import log\nfrom stat import ST_MODE\n\nfrom ..core import Command\n\n\nclass install_scripts(Command):\n    description = \"install scripts (Python or otherwise)\"\n\n    user_options = [\n        ('install-dir=', 'd', \"directory to install scripts to\"),\n        ('build-dir=', 'b', \"build directory (where to install from)\"),\n        ('force', 'f', \"force installation (overwrite existing files)\"),\n        ('skip-build', None, \"skip the build steps\"),\n    ]\n\n    boolean_options = ['force', 'skip-build']\n\n    def initialize_options(self):\n        self.install_dir = None\n        self.force = 0\n        self.build_dir = None\n        self.skip_build = None\n\n    def finalize_options(self):\n        self.set_undefined_options('build', ('build_scripts', 'build_dir'))\n        self.set_undefined_options(\n            'install',\n            ('install_scripts', 'install_dir'),\n            ('force', 'force'),\n            ('skip_build', 'skip_build'),\n        )\n\n    def run(self):\n        if not self.skip_build:\n            self.run_command('build_scripts')\n        self.outfiles = self.copy_tree(self.build_dir, self.install_dir)\n        if os.name == 'posix':\n            # Set the executable bits (owner, group, and world) on\n            # all the scripts we just installed.\n            for file in self.get_outputs():\n                if self.dry_run:\n                    log.info(\"changing mode of %s\", file)\n                else:\n                    mode = ((os.stat(file)[ST_MODE]) | 0o555) & 0o7777\n                    log.info(\"changing mode of %s to %o\", file, mode)\n                    os.chmod(file, mode)\n\n    def get_inputs(self):\n        return self.distribution.scripts or []\n\n    def get_outputs(self):\n        return self.outfiles or []\n", "setuptools/_distutils/command/upload.py": "\"\"\"\ndistutils.command.upload\n\nImplements the Distutils 'upload' subcommand (upload package to a package\nindex).\n\"\"\"\n\nimport hashlib\nimport io\nimport logging\nimport os\nfrom base64 import standard_b64encode\nfrom urllib.parse import urlparse\nfrom urllib.request import HTTPError, Request, urlopen\n\nfrom .._itertools import always_iterable\nfrom ..core import PyPIRCCommand\nfrom ..errors import DistutilsError, DistutilsOptionError\nfrom ..spawn import spawn\n\n# PyPI Warehouse supports MD5, SHA256, and Blake2 (blake2-256)\n# https://bugs.python.org/issue40698\n_FILE_CONTENT_DIGESTS = {\n    \"md5_digest\": getattr(hashlib, \"md5\", None),\n    \"sha256_digest\": getattr(hashlib, \"sha256\", None),\n    \"blake2_256_digest\": getattr(hashlib, \"blake2b\", None),\n}\n\n\nclass upload(PyPIRCCommand):\n    description = \"upload binary package to PyPI\"\n\n    user_options = PyPIRCCommand.user_options + [\n        ('sign', 's', 'sign files to upload using gpg'),\n        ('identity=', 'i', 'GPG identity used to sign files'),\n    ]\n\n    boolean_options = PyPIRCCommand.boolean_options + ['sign']\n\n    def initialize_options(self):\n        PyPIRCCommand.initialize_options(self)\n        self.username = ''\n        self.password = ''\n        self.show_response = 0\n        self.sign = False\n        self.identity = None\n\n    def finalize_options(self):\n        PyPIRCCommand.finalize_options(self)\n        if self.identity and not self.sign:\n            raise DistutilsOptionError(\"Must use --sign for --identity to have meaning\")\n        config = self._read_pypirc()\n        if config != {}:\n            self.username = config['username']\n            self.password = config['password']\n            self.repository = config['repository']\n            self.realm = config['realm']\n\n        # getting the password from the distribution\n        # if previously set by the register command\n        if not self.password and self.distribution.password:\n            self.password = self.distribution.password\n\n    def run(self):\n        if not self.distribution.dist_files:\n            msg = (\n                \"Must create and upload files in one command \"\n                \"(e.g. setup.py sdist upload)\"\n            )\n            raise DistutilsOptionError(msg)\n        for command, pyversion, filename in self.distribution.dist_files:\n            self.upload_file(command, pyversion, filename)\n\n    def upload_file(self, command, pyversion, filename):  # noqa: C901\n        # Makes sure the repository URL is compliant\n        schema, netloc, url, params, query, fragments = urlparse(self.repository)\n        if params or query or fragments:\n            raise AssertionError(\"Incompatible url %s\" % self.repository)\n\n        if schema not in ('http', 'https'):\n            raise AssertionError(\"unsupported schema \" + schema)\n\n        # Sign if requested\n        if self.sign:\n            gpg_args = [\"gpg\", \"--detach-sign\", \"-a\", filename]\n            if self.identity:\n                gpg_args[2:2] = [\"--local-user\", self.identity]\n            spawn(gpg_args, dry_run=self.dry_run)\n\n        # Fill in the data - send all the meta-data in case we need to\n        # register a new release\n        f = open(filename, 'rb')\n        try:\n            content = f.read()\n        finally:\n            f.close()\n\n        meta = self.distribution.metadata\n        data = {\n            # action\n            ':action': 'file_upload',\n            'protocol_version': '1',\n            # identify release\n            'name': meta.get_name(),\n            'version': meta.get_version(),\n            # file content\n            'content': (os.path.basename(filename), content),\n            'filetype': command,\n            'pyversion': pyversion,\n            # additional meta-data\n            'metadata_version': '1.0',\n            'summary': meta.get_description(),\n            'home_page': meta.get_url(),\n            'author': meta.get_contact(),\n            'author_email': meta.get_contact_email(),\n            'license': meta.get_licence(),\n            'description': meta.get_long_description(),\n            'keywords': meta.get_keywords(),\n            'platform': meta.get_platforms(),\n            'classifiers': meta.get_classifiers(),\n            'download_url': meta.get_download_url(),\n            # PEP 314\n            'provides': meta.get_provides(),\n            'requires': meta.get_requires(),\n            'obsoletes': meta.get_obsoletes(),\n        }\n\n        data['comment'] = ''\n\n        # file content digests\n        for digest_name, digest_cons in _FILE_CONTENT_DIGESTS.items():\n            if digest_cons is None:\n                continue\n            try:\n                data[digest_name] = digest_cons(content).hexdigest()\n            except ValueError:\n                # hash digest not available or blocked by security policy\n                pass\n\n        if self.sign:\n            with open(filename + \".asc\", \"rb\") as f:\n                data['gpg_signature'] = (os.path.basename(filename) + \".asc\", f.read())\n\n        # set up the authentication\n        user_pass = (self.username + \":\" + self.password).encode('ascii')\n        # The exact encoding of the authentication string is debated.\n        # Anyway PyPI only accepts ascii for both username or password.\n        auth = \"Basic \" + standard_b64encode(user_pass).decode('ascii')\n\n        # Build up the MIME payload for the POST data\n        boundary = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'\n        sep_boundary = b'\\r\\n--' + boundary.encode('ascii')\n        end_boundary = sep_boundary + b'--\\r\\n'\n        body = io.BytesIO()\n        for key, values in data.items():\n            title = '\\r\\nContent-Disposition: form-data; name=\"%s\"' % key\n            for value in make_iterable(values):\n                if type(value) is tuple:\n                    title += '; filename=\"%s\"' % value[0]\n                    value = value[1]\n                else:\n                    value = str(value).encode('utf-8')\n                body.write(sep_boundary)\n                body.write(title.encode('utf-8'))\n                body.write(b\"\\r\\n\\r\\n\")\n                body.write(value)\n        body.write(end_boundary)\n        body = body.getvalue()\n\n        msg = f\"Submitting {filename} to {self.repository}\"\n        self.announce(msg, logging.INFO)\n\n        # build the Request\n        headers = {\n            'Content-type': 'multipart/form-data; boundary=%s' % boundary,\n            'Content-length': str(len(body)),\n            'Authorization': auth,\n        }\n\n        request = Request(self.repository, data=body, headers=headers)\n        # send the data\n        try:\n            result = urlopen(request)\n            status = result.getcode()\n            reason = result.msg\n        except HTTPError as e:\n            status = e.code\n            reason = e.msg\n        except OSError as e:\n            self.announce(str(e), logging.ERROR)\n            raise\n\n        if status == 200:\n            self.announce(f'Server response ({status}): {reason}', logging.INFO)\n            if self.show_response:\n                text = self._read_pypi_response(result)\n                msg = '\\n'.join(('-' * 75, text, '-' * 75))\n                self.announce(msg, logging.INFO)\n        else:\n            msg = f'Upload failed ({status}): {reason}'\n            self.announce(msg, logging.ERROR)\n            raise DistutilsError(msg)\n\n\ndef make_iterable(values):\n    if values is None:\n        return [None]\n    return always_iterable(values, base_type=(bytes, str, tuple))\n", "setuptools/_distutils/command/build_ext.py": "\"\"\"distutils.command.build_ext\n\nImplements the Distutils 'build_ext' command, for building extension\nmodules (currently limited to C extensions, should accommodate C++\nextensions ASAP).\"\"\"\n\nimport contextlib\nimport os\nimport re\nimport sys\nfrom distutils._log import log\nfrom site import USER_BASE\n\nfrom .._modified import newer_group\nfrom ..core import Command\nfrom ..errors import (\n    CCompilerError,\n    CompileError,\n    DistutilsError,\n    DistutilsOptionError,\n    DistutilsPlatformError,\n    DistutilsSetupError,\n)\nfrom ..extension import Extension\nfrom ..sysconfig import customize_compiler, get_config_h_filename, get_python_version\nfrom ..util import get_platform\n\n# An extension name is just a dot-separated list of Python NAMEs (ie.\n# the same as a fully-qualified module name).\nextension_name_re = re.compile(r'^[a-zA-Z_][a-zA-Z_0-9]*(\\.[a-zA-Z_][a-zA-Z_0-9]*)*$')\n\n\ndef show_compilers():\n    from ..ccompiler import show_compilers\n\n    show_compilers()\n\n\nclass build_ext(Command):\n    description = \"build C/C++ extensions (compile/link to build directory)\"\n\n    # XXX thoughts on how to deal with complex command-line options like\n    # these, i.e. how to make it so fancy_getopt can suck them off the\n    # command line and make it look like setup.py defined the appropriate\n    # lists of tuples of what-have-you.\n    #   - each command needs a callback to process its command-line options\n    #   - Command.__init__() needs access to its share of the whole\n    #     command line (must ultimately come from\n    #     Distribution.parse_command_line())\n    #   - it then calls the current command class' option-parsing\n    #     callback to deal with weird options like -D, which have to\n    #     parse the option text and churn out some custom data\n    #     structure\n    #   - that data structure (in this case, a list of 2-tuples)\n    #     will then be present in the command object by the time\n    #     we get to finalize_options() (i.e. the constructor\n    #     takes care of both command-line and client options\n    #     in between initialize_options() and finalize_options())\n\n    sep_by = \" (separated by '%s')\" % os.pathsep\n    user_options = [\n        ('build-lib=', 'b', \"directory for compiled extension modules\"),\n        ('build-temp=', 't', \"directory for temporary files (build by-products)\"),\n        (\n            'plat-name=',\n            'p',\n            \"platform name to cross-compile for, if supported \"\n            \"(default: %s)\" % get_platform(),\n        ),\n        (\n            'inplace',\n            'i',\n            \"ignore build-lib and put compiled extensions into the source \"\n            + \"directory alongside your pure Python modules\",\n        ),\n        (\n            'include-dirs=',\n            'I',\n            \"list of directories to search for header files\" + sep_by,\n        ),\n        ('define=', 'D', \"C preprocessor macros to define\"),\n        ('undef=', 'U', \"C preprocessor macros to undefine\"),\n        ('libraries=', 'l', \"external C libraries to link with\"),\n        (\n            'library-dirs=',\n            'L',\n            \"directories to search for external C libraries\" + sep_by,\n        ),\n        ('rpath=', 'R', \"directories to search for shared C libraries at runtime\"),\n        ('link-objects=', 'O', \"extra explicit link objects to include in the link\"),\n        ('debug', 'g', \"compile/link with debugging information\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps)\"),\n        ('compiler=', 'c', \"specify the compiler type\"),\n        ('parallel=', 'j', \"number of parallel build jobs\"),\n        ('swig-cpp', None, \"make SWIG create C++ files (default is C)\"),\n        ('swig-opts=', None, \"list of SWIG command line options\"),\n        ('swig=', None, \"path to the SWIG executable\"),\n        ('user', None, \"add user include, library and rpath\"),\n    ]\n\n    boolean_options = ['inplace', 'debug', 'force', 'swig-cpp', 'user']\n\n    help_options = [\n        ('help-compiler', None, \"list available compilers\", show_compilers),\n    ]\n\n    def initialize_options(self):\n        self.extensions = None\n        self.build_lib = None\n        self.plat_name = None\n        self.build_temp = None\n        self.inplace = 0\n        self.package = None\n\n        self.include_dirs = None\n        self.define = None\n        self.undef = None\n        self.libraries = None\n        self.library_dirs = None\n        self.rpath = None\n        self.link_objects = None\n        self.debug = None\n        self.force = None\n        self.compiler = None\n        self.swig = None\n        self.swig_cpp = None\n        self.swig_opts = None\n        self.user = None\n        self.parallel = None\n\n    @staticmethod\n    def _python_lib_dir(sysconfig):\n        \"\"\"\n        Resolve Python's library directory for building extensions\n        that rely on a shared Python library.\n\n        See python/cpython#44264 and python/cpython#48686\n        \"\"\"\n        if not sysconfig.get_config_var('Py_ENABLE_SHARED'):\n            return\n\n        if sysconfig.python_build:\n            yield '.'\n            return\n\n        if sys.platform == 'zos':\n            # On z/OS, a user is not required to install Python to\n            # a predetermined path, but can use Python portably\n            installed_dir = sysconfig.get_config_var('base')\n            lib_dir = sysconfig.get_config_var('platlibdir')\n            yield os.path.join(installed_dir, lib_dir)\n        else:\n            # building third party extensions\n            yield sysconfig.get_config_var('LIBDIR')\n\n    def finalize_options(self):  # noqa: C901\n        from distutils import sysconfig\n\n        self.set_undefined_options(\n            'build',\n            ('build_lib', 'build_lib'),\n            ('build_temp', 'build_temp'),\n            ('compiler', 'compiler'),\n            ('debug', 'debug'),\n            ('force', 'force'),\n            ('parallel', 'parallel'),\n            ('plat_name', 'plat_name'),\n        )\n\n        if self.package is None:\n            self.package = self.distribution.ext_package\n\n        self.extensions = self.distribution.ext_modules\n\n        # Make sure Python's include directories (for Python.h, pyconfig.h,\n        # etc.) are in the include search path.\n        py_include = sysconfig.get_python_inc()\n        plat_py_include = sysconfig.get_python_inc(plat_specific=1)\n        if self.include_dirs is None:\n            self.include_dirs = self.distribution.include_dirs or []\n        if isinstance(self.include_dirs, str):\n            self.include_dirs = self.include_dirs.split(os.pathsep)\n\n        # If in a virtualenv, add its include directory\n        # Issue 16116\n        if sys.exec_prefix != sys.base_exec_prefix:\n            self.include_dirs.append(os.path.join(sys.exec_prefix, 'include'))\n\n        # Put the Python \"system\" include dir at the end, so that\n        # any local include dirs take precedence.\n        self.include_dirs.extend(py_include.split(os.path.pathsep))\n        if plat_py_include != py_include:\n            self.include_dirs.extend(plat_py_include.split(os.path.pathsep))\n\n        self.ensure_string_list('libraries')\n        self.ensure_string_list('link_objects')\n\n        # Life is easier if we're not forever checking for None, so\n        # simplify these options to empty lists if unset\n        if self.libraries is None:\n            self.libraries = []\n        if self.library_dirs is None:\n            self.library_dirs = []\n        elif isinstance(self.library_dirs, str):\n            self.library_dirs = self.library_dirs.split(os.pathsep)\n\n        if self.rpath is None:\n            self.rpath = []\n        elif isinstance(self.rpath, str):\n            self.rpath = self.rpath.split(os.pathsep)\n\n        # for extensions under windows use different directories\n        # for Release and Debug builds.\n        # also Python's library directory must be appended to library_dirs\n        if os.name == 'nt':\n            # the 'libs' directory is for binary installs - we assume that\n            # must be the *native* platform.  But we don't really support\n            # cross-compiling via a binary install anyway, so we let it go.\n            self.library_dirs.append(os.path.join(sys.exec_prefix, 'libs'))\n            if sys.base_exec_prefix != sys.prefix:  # Issue 16116\n                self.library_dirs.append(os.path.join(sys.base_exec_prefix, 'libs'))\n            if self.debug:\n                self.build_temp = os.path.join(self.build_temp, \"Debug\")\n            else:\n                self.build_temp = os.path.join(self.build_temp, \"Release\")\n\n            # Append the source distribution include and library directories,\n            # this allows distutils on windows to work in the source tree\n            self.include_dirs.append(os.path.dirname(get_config_h_filename()))\n            self.library_dirs.append(sys.base_exec_prefix)\n\n            # Use the .lib files for the correct architecture\n            if self.plat_name == 'win32':\n                suffix = 'win32'\n            else:\n                # win-amd64\n                suffix = self.plat_name[4:]\n            new_lib = os.path.join(sys.exec_prefix, 'PCbuild')\n            if suffix:\n                new_lib = os.path.join(new_lib, suffix)\n            self.library_dirs.append(new_lib)\n\n        # For extensions under Cygwin, Python's library directory must be\n        # appended to library_dirs\n        if sys.platform[:6] == 'cygwin':\n            if not sysconfig.python_build:\n                # building third party extensions\n                self.library_dirs.append(\n                    os.path.join(\n                        sys.prefix, \"lib\", \"python\" + get_python_version(), \"config\"\n                    )\n                )\n            else:\n                # building python standard extensions\n                self.library_dirs.append('.')\n\n        self.library_dirs.extend(self._python_lib_dir(sysconfig))\n\n        # The argument parsing will result in self.define being a string, but\n        # it has to be a list of 2-tuples.  All the preprocessor symbols\n        # specified by the 'define' option will be set to '1'.  Multiple\n        # symbols can be separated with commas.\n\n        if self.define:\n            defines = self.define.split(',')\n            self.define = [(symbol, '1') for symbol in defines]\n\n        # The option for macros to undefine is also a string from the\n        # option parsing, but has to be a list.  Multiple symbols can also\n        # be separated with commas here.\n        if self.undef:\n            self.undef = self.undef.split(',')\n\n        if self.swig_opts is None:\n            self.swig_opts = []\n        else:\n            self.swig_opts = self.swig_opts.split(' ')\n\n        # Finally add the user include and library directories if requested\n        if self.user:\n            user_include = os.path.join(USER_BASE, \"include\")\n            user_lib = os.path.join(USER_BASE, \"lib\")\n            if os.path.isdir(user_include):\n                self.include_dirs.append(user_include)\n            if os.path.isdir(user_lib):\n                self.library_dirs.append(user_lib)\n                self.rpath.append(user_lib)\n\n        if isinstance(self.parallel, str):\n            try:\n                self.parallel = int(self.parallel)\n            except ValueError:\n                raise DistutilsOptionError(\"parallel should be an integer\")\n\n    def run(self):  # noqa: C901\n        from ..ccompiler import new_compiler\n\n        # 'self.extensions', as supplied by setup.py, is a list of\n        # Extension instances.  See the documentation for Extension (in\n        # distutils.extension) for details.\n        #\n        # For backwards compatibility with Distutils 0.8.2 and earlier, we\n        # also allow the 'extensions' list to be a list of tuples:\n        #    (ext_name, build_info)\n        # where build_info is a dictionary containing everything that\n        # Extension instances do except the name, with a few things being\n        # differently named.  We convert these 2-tuples to Extension\n        # instances as needed.\n\n        if not self.extensions:\n            return\n\n        # If we were asked to build any C/C++ libraries, make sure that the\n        # directory where we put them is in the library search path for\n        # linking extensions.\n        if self.distribution.has_c_libraries():\n            build_clib = self.get_finalized_command('build_clib')\n            self.libraries.extend(build_clib.get_library_names() or [])\n            self.library_dirs.append(build_clib.build_clib)\n\n        # Setup the CCompiler object that we'll use to do all the\n        # compiling and linking\n        self.compiler = new_compiler(\n            compiler=self.compiler,\n            verbose=self.verbose,\n            dry_run=self.dry_run,\n            force=self.force,\n        )\n        customize_compiler(self.compiler)\n        # If we are cross-compiling, init the compiler now (if we are not\n        # cross-compiling, init would not hurt, but people may rely on\n        # late initialization of compiler even if they shouldn't...)\n        if os.name == 'nt' and self.plat_name != get_platform():\n            self.compiler.initialize(self.plat_name)\n\n        # And make sure that any compile/link-related options (which might\n        # come from the command-line or from the setup script) are set in\n        # that CCompiler object -- that way, they automatically apply to\n        # all compiling and linking done here.\n        if self.include_dirs is not None:\n            self.compiler.set_include_dirs(self.include_dirs)\n        if self.define is not None:\n            # 'define' option is a list of (name,value) tuples\n            for name, value in self.define:\n                self.compiler.define_macro(name, value)\n        if self.undef is not None:\n            for macro in self.undef:\n                self.compiler.undefine_macro(macro)\n        if self.libraries is not None:\n            self.compiler.set_libraries(self.libraries)\n        if self.library_dirs is not None:\n            self.compiler.set_library_dirs(self.library_dirs)\n        if self.rpath is not None:\n            self.compiler.set_runtime_library_dirs(self.rpath)\n        if self.link_objects is not None:\n            self.compiler.set_link_objects(self.link_objects)\n\n        # Now actually compile and link everything.\n        self.build_extensions()\n\n    def check_extensions_list(self, extensions):  # noqa: C901\n        \"\"\"Ensure that the list of extensions (presumably provided as a\n        command option 'extensions') is valid, i.e. it is a list of\n        Extension objects.  We also support the old-style list of 2-tuples,\n        where the tuples are (ext_name, build_info), which are converted to\n        Extension instances here.\n\n        Raise DistutilsSetupError if the structure is invalid anywhere;\n        just returns otherwise.\n        \"\"\"\n        if not isinstance(extensions, list):\n            raise DistutilsSetupError(\n                \"'ext_modules' option must be a list of Extension instances\"\n            )\n\n        for i, ext in enumerate(extensions):\n            if isinstance(ext, Extension):\n                continue  # OK! (assume type-checking done\n                # by Extension constructor)\n\n            if not isinstance(ext, tuple) or len(ext) != 2:\n                raise DistutilsSetupError(\n                    \"each element of 'ext_modules' option must be an \"\n                    \"Extension instance or 2-tuple\"\n                )\n\n            ext_name, build_info = ext\n\n            log.warning(\n                \"old-style (ext_name, build_info) tuple found in \"\n                \"ext_modules for extension '%s' \"\n                \"-- please convert to Extension instance\",\n                ext_name,\n            )\n\n            if not (isinstance(ext_name, str) and extension_name_re.match(ext_name)):\n                raise DistutilsSetupError(\n                    \"first element of each tuple in 'ext_modules' \"\n                    \"must be the extension name (a string)\"\n                )\n\n            if not isinstance(build_info, dict):\n                raise DistutilsSetupError(\n                    \"second element of each tuple in 'ext_modules' \"\n                    \"must be a dictionary (build info)\"\n                )\n\n            # OK, the (ext_name, build_info) dict is type-safe: convert it\n            # to an Extension instance.\n            ext = Extension(ext_name, build_info['sources'])\n\n            # Easy stuff: one-to-one mapping from dict elements to\n            # instance attributes.\n            for key in (\n                'include_dirs',\n                'library_dirs',\n                'libraries',\n                'extra_objects',\n                'extra_compile_args',\n                'extra_link_args',\n            ):\n                val = build_info.get(key)\n                if val is not None:\n                    setattr(ext, key, val)\n\n            # Medium-easy stuff: same syntax/semantics, different names.\n            ext.runtime_library_dirs = build_info.get('rpath')\n            if 'def_file' in build_info:\n                log.warning(\"'def_file' element of build info dict no longer supported\")\n\n            # Non-trivial stuff: 'macros' split into 'define_macros'\n            # and 'undef_macros'.\n            macros = build_info.get('macros')\n            if macros:\n                ext.define_macros = []\n                ext.undef_macros = []\n                for macro in macros:\n                    if not (isinstance(macro, tuple) and len(macro) in (1, 2)):\n                        raise DistutilsSetupError(\n                            \"'macros' element of build info dict \"\n                            \"must be 1- or 2-tuple\"\n                        )\n                    if len(macro) == 1:\n                        ext.undef_macros.append(macro[0])\n                    elif len(macro) == 2:\n                        ext.define_macros.append(macro)\n\n            extensions[i] = ext\n\n    def get_source_files(self):\n        self.check_extensions_list(self.extensions)\n        filenames = []\n\n        # Wouldn't it be neat if we knew the names of header files too...\n        for ext in self.extensions:\n            filenames.extend(ext.sources)\n        return filenames\n\n    def get_outputs(self):\n        # Sanity check the 'extensions' list -- can't assume this is being\n        # done in the same run as a 'build_extensions()' call (in fact, we\n        # can probably assume that it *isn't*!).\n        self.check_extensions_list(self.extensions)\n\n        # And build the list of output (built) filenames.  Note that this\n        # ignores the 'inplace' flag, and assumes everything goes in the\n        # \"build\" tree.\n        outputs = []\n        for ext in self.extensions:\n            outputs.append(self.get_ext_fullpath(ext.name))\n        return outputs\n\n    def build_extensions(self):\n        # First, sanity-check the 'extensions' list\n        self.check_extensions_list(self.extensions)\n        if self.parallel:\n            self._build_extensions_parallel()\n        else:\n            self._build_extensions_serial()\n\n    def _build_extensions_parallel(self):\n        workers = self.parallel\n        if self.parallel is True:\n            workers = os.cpu_count()  # may return None\n        try:\n            from concurrent.futures import ThreadPoolExecutor\n        except ImportError:\n            workers = None\n\n        if workers is None:\n            self._build_extensions_serial()\n            return\n\n        with ThreadPoolExecutor(max_workers=workers) as executor:\n            futures = [\n                executor.submit(self.build_extension, ext) for ext in self.extensions\n            ]\n            for ext, fut in zip(self.extensions, futures):\n                with self._filter_build_errors(ext):\n                    fut.result()\n\n    def _build_extensions_serial(self):\n        for ext in self.extensions:\n            with self._filter_build_errors(ext):\n                self.build_extension(ext)\n\n    @contextlib.contextmanager\n    def _filter_build_errors(self, ext):\n        try:\n            yield\n        except (CCompilerError, DistutilsError, CompileError) as e:\n            if not ext.optional:\n                raise\n            self.warn(f'building extension \"{ext.name}\" failed: {e}')\n\n    def build_extension(self, ext):\n        sources = ext.sources\n        if sources is None or not isinstance(sources, (list, tuple)):\n            raise DistutilsSetupError(\n                \"in 'ext_modules' option (extension '%s'), \"\n                \"'sources' must be present and must be \"\n                \"a list of source filenames\" % ext.name\n            )\n        # sort to make the resulting .so file build reproducible\n        sources = sorted(sources)\n\n        ext_path = self.get_ext_fullpath(ext.name)\n        depends = sources + ext.depends\n        if not (self.force or newer_group(depends, ext_path, 'newer')):\n            log.debug(\"skipping '%s' extension (up-to-date)\", ext.name)\n            return\n        else:\n            log.info(\"building '%s' extension\", ext.name)\n\n        # First, scan the sources for SWIG definition files (.i), run\n        # SWIG on 'em to create .c files, and modify the sources list\n        # accordingly.\n        sources = self.swig_sources(sources, ext)\n\n        # Next, compile the source code to object files.\n\n        # XXX not honouring 'define_macros' or 'undef_macros' -- the\n        # CCompiler API needs to change to accommodate this, and I\n        # want to do one thing at a time!\n\n        # Two possible sources for extra compiler arguments:\n        #   - 'extra_compile_args' in Extension object\n        #   - CFLAGS environment variable (not particularly\n        #     elegant, but people seem to expect it and I\n        #     guess it's useful)\n        # The environment variable should take precedence, and\n        # any sensible compiler will give precedence to later\n        # command line args.  Hence we combine them in order:\n        extra_args = ext.extra_compile_args or []\n\n        macros = ext.define_macros[:]\n        for undef in ext.undef_macros:\n            macros.append((undef,))\n\n        objects = self.compiler.compile(\n            sources,\n            output_dir=self.build_temp,\n            macros=macros,\n            include_dirs=ext.include_dirs,\n            debug=self.debug,\n            extra_postargs=extra_args,\n            depends=ext.depends,\n        )\n\n        # XXX outdated variable, kept here in case third-part code\n        # needs it.\n        self._built_objects = objects[:]\n\n        # Now link the object files together into a \"shared object\" --\n        # of course, first we have to figure out all the other things\n        # that go into the mix.\n        if ext.extra_objects:\n            objects.extend(ext.extra_objects)\n        extra_args = ext.extra_link_args or []\n\n        # Detect target language, if not provided\n        language = ext.language or self.compiler.detect_language(sources)\n\n        self.compiler.link_shared_object(\n            objects,\n            ext_path,\n            libraries=self.get_libraries(ext),\n            library_dirs=ext.library_dirs,\n            runtime_library_dirs=ext.runtime_library_dirs,\n            extra_postargs=extra_args,\n            export_symbols=self.get_export_symbols(ext),\n            debug=self.debug,\n            build_temp=self.build_temp,\n            target_lang=language,\n        )\n\n    def swig_sources(self, sources, extension):\n        \"\"\"Walk the list of source files in 'sources', looking for SWIG\n        interface (.i) files.  Run SWIG on all that are found, and\n        return a modified 'sources' list with SWIG source files replaced\n        by the generated C (or C++) files.\n        \"\"\"\n        new_sources = []\n        swig_sources = []\n        swig_targets = {}\n\n        # XXX this drops generated C/C++ files into the source tree, which\n        # is fine for developers who want to distribute the generated\n        # source -- but there should be an option to put SWIG output in\n        # the temp dir.\n\n        if self.swig_cpp:\n            log.warning(\"--swig-cpp is deprecated - use --swig-opts=-c++\")\n\n        if (\n            self.swig_cpp\n            or ('-c++' in self.swig_opts)\n            or ('-c++' in extension.swig_opts)\n        ):\n            target_ext = '.cpp'\n        else:\n            target_ext = '.c'\n\n        for source in sources:\n            (base, ext) = os.path.splitext(source)\n            if ext == \".i\":  # SWIG interface file\n                new_sources.append(base + '_wrap' + target_ext)\n                swig_sources.append(source)\n                swig_targets[source] = new_sources[-1]\n            else:\n                new_sources.append(source)\n\n        if not swig_sources:\n            return new_sources\n\n        swig = self.swig or self.find_swig()\n        swig_cmd = [swig, \"-python\"]\n        swig_cmd.extend(self.swig_opts)\n        if self.swig_cpp:\n            swig_cmd.append(\"-c++\")\n\n        # Do not override commandline arguments\n        if not self.swig_opts:\n            for o in extension.swig_opts:\n                swig_cmd.append(o)\n\n        for source in swig_sources:\n            target = swig_targets[source]\n            log.info(\"swigging %s to %s\", source, target)\n            self.spawn(swig_cmd + [\"-o\", target, source])\n\n        return new_sources\n\n    def find_swig(self):\n        \"\"\"Return the name of the SWIG executable.  On Unix, this is\n        just \"swig\" -- it should be in the PATH.  Tries a bit harder on\n        Windows.\n        \"\"\"\n        if os.name == \"posix\":\n            return \"swig\"\n        elif os.name == \"nt\":\n            # Look for SWIG in its standard installation directory on\n            # Windows (or so I presume!).  If we find it there, great;\n            # if not, act like Unix and assume it's in the PATH.\n            for vers in (\"1.3\", \"1.2\", \"1.1\"):\n                fn = os.path.join(\"c:\\\\swig%s\" % vers, \"swig.exe\")\n                if os.path.isfile(fn):\n                    return fn\n            else:\n                return \"swig.exe\"\n        else:\n            raise DistutilsPlatformError(\n                \"I don't know how to find (much less run) SWIG \"\n                \"on platform '%s'\" % os.name\n            )\n\n    # -- Name generators -----------------------------------------------\n    # (extension names, filenames, whatever)\n    def get_ext_fullpath(self, ext_name):\n        \"\"\"Returns the path of the filename for a given extension.\n\n        The file is located in `build_lib` or directly in the package\n        (inplace option).\n        \"\"\"\n        fullname = self.get_ext_fullname(ext_name)\n        modpath = fullname.split('.')\n        filename = self.get_ext_filename(modpath[-1])\n\n        if not self.inplace:\n            # no further work needed\n            # returning :\n            #   build_dir/package/path/filename\n            filename = os.path.join(*modpath[:-1] + [filename])\n            return os.path.join(self.build_lib, filename)\n\n        # the inplace option requires to find the package directory\n        # using the build_py command for that\n        package = '.'.join(modpath[0:-1])\n        build_py = self.get_finalized_command('build_py')\n        package_dir = os.path.abspath(build_py.get_package_dir(package))\n\n        # returning\n        #   package_dir/filename\n        return os.path.join(package_dir, filename)\n\n    def get_ext_fullname(self, ext_name):\n        \"\"\"Returns the fullname of a given extension name.\n\n        Adds the `package.` prefix\"\"\"\n        if self.package is None:\n            return ext_name\n        else:\n            return self.package + '.' + ext_name\n\n    def get_ext_filename(self, ext_name):\n        r\"\"\"Convert the name of an extension (eg. \"foo.bar\") into the name\n        of the file from which it will be loaded (eg. \"foo/bar.so\", or\n        \"foo\\bar.pyd\").\n        \"\"\"\n        from ..sysconfig import get_config_var\n\n        ext_path = ext_name.split('.')\n        ext_suffix = get_config_var('EXT_SUFFIX')\n        return os.path.join(*ext_path) + ext_suffix\n\n    def get_export_symbols(self, ext):\n        \"\"\"Return the list of symbols that a shared extension has to\n        export.  This either uses 'ext.export_symbols' or, if it's not\n        provided, \"PyInit_\" + module_name.  Only relevant on Windows, where\n        the .pyd file (DLL) must export the module \"PyInit_\" function.\n        \"\"\"\n        name = ext.name.split('.')[-1]\n        try:\n            # Unicode module name support as defined in PEP-489\n            # https://peps.python.org/pep-0489/#export-hook-name\n            name.encode('ascii')\n        except UnicodeEncodeError:\n            suffix = 'U_' + name.encode('punycode').replace(b'-', b'_').decode('ascii')\n        else:\n            suffix = \"_\" + name\n\n        initfunc_name = \"PyInit\" + suffix\n        if initfunc_name not in ext.export_symbols:\n            ext.export_symbols.append(initfunc_name)\n        return ext.export_symbols\n\n    def get_libraries(self, ext):  # noqa: C901\n        \"\"\"Return the list of libraries to link against when building a\n        shared extension.  On most platforms, this is just 'ext.libraries';\n        on Windows, we add the Python library (eg. python20.dll).\n        \"\"\"\n        # The python library is always needed on Windows.  For MSVC, this\n        # is redundant, since the library is mentioned in a pragma in\n        # pyconfig.h that MSVC groks.  The other Windows compilers all seem\n        # to need it mentioned explicitly, though, so that's what we do.\n        # Append '_d' to the python import library on debug builds.\n        if sys.platform == \"win32\":\n            from .._msvccompiler import MSVCCompiler\n\n            if not isinstance(self.compiler, MSVCCompiler):\n                template = \"python%d%d\"\n                if self.debug:\n                    template = template + '_d'\n                pythonlib = template % (\n                    sys.hexversion >> 24,\n                    (sys.hexversion >> 16) & 0xFF,\n                )\n                # don't extend ext.libraries, it may be shared with other\n                # extensions, it is a reference to the original list\n                return ext.libraries + [pythonlib]\n        else:\n            # On Android only the main executable and LD_PRELOADs are considered\n            # to be RTLD_GLOBAL, all the dependencies of the main executable\n            # remain RTLD_LOCAL and so the shared libraries must be linked with\n            # libpython when python is built with a shared python library (issue\n            # bpo-21536).\n            # On Cygwin (and if required, other POSIX-like platforms based on\n            # Windows like MinGW) it is simply necessary that all symbols in\n            # shared libraries are resolved at link time.\n            from ..sysconfig import get_config_var\n\n            link_libpython = False\n            if get_config_var('Py_ENABLE_SHARED'):\n                # A native build on an Android device or on Cygwin\n                if hasattr(sys, 'getandroidapilevel'):\n                    link_libpython = True\n                elif sys.platform == 'cygwin':\n                    link_libpython = True\n                elif '_PYTHON_HOST_PLATFORM' in os.environ:\n                    # We are cross-compiling for one of the relevant platforms\n                    if get_config_var('ANDROID_API_LEVEL') != 0:\n                        link_libpython = True\n                    elif get_config_var('MACHDEP') == 'cygwin':\n                        link_libpython = True\n\n            if link_libpython:\n                ldversion = get_config_var('LDVERSION')\n                return ext.libraries + ['python' + ldversion]\n\n        return ext.libraries\n", "setuptools/_distutils/command/build.py": "\"\"\"distutils.command.build\n\nImplements the Distutils 'build' command.\"\"\"\n\nimport os\nimport sys\n\nfrom ..core import Command\nfrom ..errors import DistutilsOptionError\nfrom ..util import get_platform\n\n\ndef show_compilers():\n    from ..ccompiler import show_compilers\n\n    show_compilers()\n\n\nclass build(Command):\n    description = \"build everything needed to install\"\n\n    user_options = [\n        ('build-base=', 'b', \"base directory for build library\"),\n        ('build-purelib=', None, \"build directory for platform-neutral distributions\"),\n        ('build-platlib=', None, \"build directory for platform-specific distributions\"),\n        (\n            'build-lib=',\n            None,\n            \"build directory for all distribution (defaults to either \"\n            + \"build-purelib or build-platlib\",\n        ),\n        ('build-scripts=', None, \"build directory for scripts\"),\n        ('build-temp=', 't', \"temporary build directory\"),\n        (\n            'plat-name=',\n            'p',\n            \"platform name to build for, if supported \"\n            \"(default: %s)\" % get_platform(),\n        ),\n        ('compiler=', 'c', \"specify the compiler type\"),\n        ('parallel=', 'j', \"number of parallel build jobs\"),\n        ('debug', 'g', \"compile extensions and libraries with debugging information\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps)\"),\n        ('executable=', 'e', \"specify final destination interpreter path (build.py)\"),\n    ]\n\n    boolean_options = ['debug', 'force']\n\n    help_options = [\n        ('help-compiler', None, \"list available compilers\", show_compilers),\n    ]\n\n    def initialize_options(self):\n        self.build_base = 'build'\n        # these are decided only after 'build_base' has its final value\n        # (unless overridden by the user or client)\n        self.build_purelib = None\n        self.build_platlib = None\n        self.build_lib = None\n        self.build_temp = None\n        self.build_scripts = None\n        self.compiler = None\n        self.plat_name = None\n        self.debug = None\n        self.force = 0\n        self.executable = None\n        self.parallel = None\n\n    def finalize_options(self):  # noqa: C901\n        if self.plat_name is None:\n            self.plat_name = get_platform()\n        else:\n            # plat-name only supported for windows (other platforms are\n            # supported via ./configure flags, if at all).  Avoid misleading\n            # other platforms.\n            if os.name != 'nt':\n                raise DistutilsOptionError(\n                    \"--plat-name only supported on Windows (try \"\n                    \"using './configure --help' on your platform)\"\n                )\n\n        plat_specifier = f\".{self.plat_name}-{sys.implementation.cache_tag}\"\n\n        # Make it so Python 2.x and Python 2.x with --with-pydebug don't\n        # share the same build directories. Doing so confuses the build\n        # process for C modules\n        if hasattr(sys, 'gettotalrefcount'):\n            plat_specifier += '-pydebug'\n\n        # 'build_purelib' and 'build_platlib' just default to 'lib' and\n        # 'lib.<plat>' under the base build directory.  We only use one of\n        # them for a given distribution, though --\n        if self.build_purelib is None:\n            self.build_purelib = os.path.join(self.build_base, 'lib')\n        if self.build_platlib is None:\n            self.build_platlib = os.path.join(self.build_base, 'lib' + plat_specifier)\n\n        # 'build_lib' is the actual directory that we will use for this\n        # particular module distribution -- if user didn't supply it, pick\n        # one of 'build_purelib' or 'build_platlib'.\n        if self.build_lib is None:\n            if self.distribution.has_ext_modules():\n                self.build_lib = self.build_platlib\n            else:\n                self.build_lib = self.build_purelib\n\n        # 'build_temp' -- temporary directory for compiler turds,\n        # \"build/temp.<plat>\"\n        if self.build_temp is None:\n            self.build_temp = os.path.join(self.build_base, 'temp' + plat_specifier)\n        if self.build_scripts is None:\n            self.build_scripts = os.path.join(\n                self.build_base, 'scripts-%d.%d' % sys.version_info[:2]\n            )\n\n        if self.executable is None and sys.executable:\n            self.executable = os.path.normpath(sys.executable)\n\n        if isinstance(self.parallel, str):\n            try:\n                self.parallel = int(self.parallel)\n            except ValueError:\n                raise DistutilsOptionError(\"parallel should be an integer\")\n\n    def run(self):\n        # Run all relevant sub-commands.  This will be some subset of:\n        #  - build_py      - pure Python modules\n        #  - build_clib    - standalone C libraries\n        #  - build_ext     - Python extensions\n        #  - build_scripts - (Python) scripts\n        for cmd_name in self.get_sub_commands():\n            self.run_command(cmd_name)\n\n    # -- Predicates for the sub-command list ---------------------------\n\n    def has_pure_modules(self):\n        return self.distribution.has_pure_modules()\n\n    def has_c_libraries(self):\n        return self.distribution.has_c_libraries()\n\n    def has_ext_modules(self):\n        return self.distribution.has_ext_modules()\n\n    def has_scripts(self):\n        return self.distribution.has_scripts()\n\n    sub_commands = [\n        ('build_py', has_pure_modules),\n        ('build_clib', has_c_libraries),\n        ('build_ext', has_ext_modules),\n        ('build_scripts', has_scripts),\n    ]\n", "setuptools/_distutils/command/install_lib.py": "\"\"\"distutils.command.install_lib\n\nImplements the Distutils 'install_lib' command\n(install all Python modules).\"\"\"\n\nimport importlib.util\nimport os\nimport sys\n\nfrom ..core import Command\nfrom ..errors import DistutilsOptionError\n\n# Extension for Python source files.\nPYTHON_SOURCE_EXTENSION = \".py\"\n\n\nclass install_lib(Command):\n    description = \"install all Python modules (extensions and pure Python)\"\n\n    # The byte-compilation options are a tad confusing.  Here are the\n    # possible scenarios:\n    #   1) no compilation at all (--no-compile --no-optimize)\n    #   2) compile .pyc only (--compile --no-optimize; default)\n    #   3) compile .pyc and \"opt-1\" .pyc (--compile --optimize)\n    #   4) compile \"opt-1\" .pyc only (--no-compile --optimize)\n    #   5) compile .pyc and \"opt-2\" .pyc (--compile --optimize-more)\n    #   6) compile \"opt-2\" .pyc only (--no-compile --optimize-more)\n    #\n    # The UI for this is two options, 'compile' and 'optimize'.\n    # 'compile' is strictly boolean, and only decides whether to\n    # generate .pyc files.  'optimize' is three-way (0, 1, or 2), and\n    # decides both whether to generate .pyc files and what level of\n    # optimization to use.\n\n    user_options = [\n        ('install-dir=', 'd', \"directory to install to\"),\n        ('build-dir=', 'b', \"build directory (where to install from)\"),\n        ('force', 'f', \"force installation (overwrite existing files)\"),\n        ('compile', 'c', \"compile .py to .pyc [default]\"),\n        ('no-compile', None, \"don't compile .py files\"),\n        (\n            'optimize=',\n            'O',\n            \"also compile with optimization: -O1 for \\\"python -O\\\", \"\n            \"-O2 for \\\"python -OO\\\", and -O0 to disable [default: -O0]\",\n        ),\n        ('skip-build', None, \"skip the build steps\"),\n    ]\n\n    boolean_options = ['force', 'compile', 'skip-build']\n    negative_opt = {'no-compile': 'compile'}\n\n    def initialize_options(self):\n        # let the 'install' command dictate our installation directory\n        self.install_dir = None\n        self.build_dir = None\n        self.force = 0\n        self.compile = None\n        self.optimize = None\n        self.skip_build = None\n\n    def finalize_options(self):\n        # Get all the information we need to install pure Python modules\n        # from the umbrella 'install' command -- build (source) directory,\n        # install (target) directory, and whether to compile .py files.\n        self.set_undefined_options(\n            'install',\n            ('build_lib', 'build_dir'),\n            ('install_lib', 'install_dir'),\n            ('force', 'force'),\n            ('compile', 'compile'),\n            ('optimize', 'optimize'),\n            ('skip_build', 'skip_build'),\n        )\n\n        if self.compile is None:\n            self.compile = True\n        if self.optimize is None:\n            self.optimize = False\n\n        if not isinstance(self.optimize, int):\n            try:\n                self.optimize = int(self.optimize)\n                if self.optimize not in (0, 1, 2):\n                    raise AssertionError\n            except (ValueError, AssertionError):\n                raise DistutilsOptionError(\"optimize must be 0, 1, or 2\")\n\n    def run(self):\n        # Make sure we have built everything we need first\n        self.build()\n\n        # Install everything: simply dump the entire contents of the build\n        # directory to the installation directory (that's the beauty of\n        # having a build directory!)\n        outfiles = self.install()\n\n        # (Optionally) compile .py to .pyc\n        if outfiles is not None and self.distribution.has_pure_modules():\n            self.byte_compile(outfiles)\n\n    # -- Top-level worker functions ------------------------------------\n    # (called from 'run()')\n\n    def build(self):\n        if not self.skip_build:\n            if self.distribution.has_pure_modules():\n                self.run_command('build_py')\n            if self.distribution.has_ext_modules():\n                self.run_command('build_ext')\n\n    def install(self):\n        if os.path.isdir(self.build_dir):\n            outfiles = self.copy_tree(self.build_dir, self.install_dir)\n        else:\n            self.warn(\n                \"'%s' does not exist -- no Python modules to install\" % self.build_dir\n            )\n            return\n        return outfiles\n\n    def byte_compile(self, files):\n        if sys.dont_write_bytecode:\n            self.warn('byte-compiling is disabled, skipping.')\n            return\n\n        from ..util import byte_compile\n\n        # Get the \"--root\" directory supplied to the \"install\" command,\n        # and use it as a prefix to strip off the purported filename\n        # encoded in bytecode files.  This is far from complete, but it\n        # should at least generate usable bytecode in RPM distributions.\n        install_root = self.get_finalized_command('install').root\n\n        if self.compile:\n            byte_compile(\n                files,\n                optimize=0,\n                force=self.force,\n                prefix=install_root,\n                dry_run=self.dry_run,\n            )\n        if self.optimize > 0:\n            byte_compile(\n                files,\n                optimize=self.optimize,\n                force=self.force,\n                prefix=install_root,\n                verbose=self.verbose,\n                dry_run=self.dry_run,\n            )\n\n    # -- Utility methods -----------------------------------------------\n\n    def _mutate_outputs(self, has_any, build_cmd, cmd_option, output_dir):\n        if not has_any:\n            return []\n\n        build_cmd = self.get_finalized_command(build_cmd)\n        build_files = build_cmd.get_outputs()\n        build_dir = getattr(build_cmd, cmd_option)\n\n        prefix_len = len(build_dir) + len(os.sep)\n        outputs = []\n        for file in build_files:\n            outputs.append(os.path.join(output_dir, file[prefix_len:]))\n\n        return outputs\n\n    def _bytecode_filenames(self, py_filenames):\n        bytecode_files = []\n        for py_file in py_filenames:\n            # Since build_py handles package data installation, the\n            # list of outputs can contain more than just .py files.\n            # Make sure we only report bytecode for the .py files.\n            ext = os.path.splitext(os.path.normcase(py_file))[1]\n            if ext != PYTHON_SOURCE_EXTENSION:\n                continue\n            if self.compile:\n                bytecode_files.append(\n                    importlib.util.cache_from_source(py_file, optimization='')\n                )\n            if self.optimize > 0:\n                bytecode_files.append(\n                    importlib.util.cache_from_source(\n                        py_file, optimization=self.optimize\n                    )\n                )\n\n        return bytecode_files\n\n    # -- External interface --------------------------------------------\n    # (called by outsiders)\n\n    def get_outputs(self):\n        \"\"\"Return the list of files that would be installed if this command\n        were actually run.  Not affected by the \"dry-run\" flag or whether\n        modules have actually been built yet.\n        \"\"\"\n        pure_outputs = self._mutate_outputs(\n            self.distribution.has_pure_modules(),\n            'build_py',\n            'build_lib',\n            self.install_dir,\n        )\n        if self.compile:\n            bytecode_outputs = self._bytecode_filenames(pure_outputs)\n        else:\n            bytecode_outputs = []\n\n        ext_outputs = self._mutate_outputs(\n            self.distribution.has_ext_modules(),\n            'build_ext',\n            'build_lib',\n            self.install_dir,\n        )\n\n        return pure_outputs + bytecode_outputs + ext_outputs\n\n    def get_inputs(self):\n        \"\"\"Get the list of files that are input to this command, ie. the\n        files that get installed as they are named in the build tree.\n        The files in this list correspond one-to-one to the output\n        filenames returned by 'get_outputs()'.\n        \"\"\"\n        inputs = []\n\n        if self.distribution.has_pure_modules():\n            build_py = self.get_finalized_command('build_py')\n            inputs.extend(build_py.get_outputs())\n\n        if self.distribution.has_ext_modules():\n            build_ext = self.get_finalized_command('build_ext')\n            inputs.extend(build_ext.get_outputs())\n\n        return inputs\n", "setuptools/_distutils/command/bdist_rpm.py": "\"\"\"distutils.command.bdist_rpm\n\nImplements the Distutils 'bdist_rpm' command (create RPM source and binary\ndistributions).\"\"\"\n\nimport os\nimport subprocess\nimport sys\nfrom distutils._log import log\n\nfrom ..core import Command\nfrom ..debug import DEBUG\nfrom ..errors import (\n    DistutilsExecError,\n    DistutilsFileError,\n    DistutilsOptionError,\n    DistutilsPlatformError,\n)\nfrom ..file_util import write_file\nfrom ..sysconfig import get_python_version\n\n\nclass bdist_rpm(Command):\n    description = \"create an RPM distribution\"\n\n    user_options = [\n        ('bdist-base=', None, \"base directory for creating built distributions\"),\n        (\n            'rpm-base=',\n            None,\n            \"base directory for creating RPMs (defaults to \\\"rpm\\\" under \"\n            \"--bdist-base; must be specified for RPM 2)\",\n        ),\n        (\n            'dist-dir=',\n            'd',\n            \"directory to put final RPM files in (and .spec files if --spec-only)\",\n        ),\n        (\n            'python=',\n            None,\n            \"path to Python interpreter to hard-code in the .spec file \"\n            \"(default: \\\"python\\\")\",\n        ),\n        (\n            'fix-python',\n            None,\n            \"hard-code the exact path to the current Python interpreter in \"\n            \"the .spec file\",\n        ),\n        ('spec-only', None, \"only regenerate spec file\"),\n        ('source-only', None, \"only generate source RPM\"),\n        ('binary-only', None, \"only generate binary RPM\"),\n        ('use-bzip2', None, \"use bzip2 instead of gzip to create source distribution\"),\n        # More meta-data: too RPM-specific to put in the setup script,\n        # but needs to go in the .spec file -- so we make these options\n        # to \"bdist_rpm\".  The idea is that packagers would put this\n        # info in setup.cfg, although they are of course free to\n        # supply it on the command line.\n        (\n            'distribution-name=',\n            None,\n            \"name of the (Linux) distribution to which this \"\n            \"RPM applies (*not* the name of the module distribution!)\",\n        ),\n        ('group=', None, \"package classification [default: \\\"Development/Libraries\\\"]\"),\n        ('release=', None, \"RPM release number\"),\n        ('serial=', None, \"RPM serial number\"),\n        (\n            'vendor=',\n            None,\n            \"RPM \\\"vendor\\\" (eg. \\\"Joe Blow <joe@example.com>\\\") \"\n            \"[default: maintainer or author from setup script]\",\n        ),\n        (\n            'packager=',\n            None,\n            \"RPM packager (eg. \\\"Jane Doe <jane@example.net>\\\") [default: vendor]\",\n        ),\n        ('doc-files=', None, \"list of documentation files (space or comma-separated)\"),\n        ('changelog=', None, \"RPM changelog\"),\n        ('icon=', None, \"name of icon file\"),\n        ('provides=', None, \"capabilities provided by this package\"),\n        ('requires=', None, \"capabilities required by this package\"),\n        ('conflicts=', None, \"capabilities which conflict with this package\"),\n        ('build-requires=', None, \"capabilities required to build this package\"),\n        ('obsoletes=', None, \"capabilities made obsolete by this package\"),\n        ('no-autoreq', None, \"do not automatically calculate dependencies\"),\n        # Actions to take when building RPM\n        ('keep-temp', 'k', \"don't clean up RPM build directory\"),\n        ('no-keep-temp', None, \"clean up RPM build directory [default]\"),\n        (\n            'use-rpm-opt-flags',\n            None,\n            \"compile with RPM_OPT_FLAGS when building from source RPM\",\n        ),\n        ('no-rpm-opt-flags', None, \"do not pass any RPM CFLAGS to compiler\"),\n        ('rpm3-mode', None, \"RPM 3 compatibility mode (default)\"),\n        ('rpm2-mode', None, \"RPM 2 compatibility mode\"),\n        # Add the hooks necessary for specifying custom scripts\n        ('prep-script=', None, \"Specify a script for the PREP phase of RPM building\"),\n        ('build-script=', None, \"Specify a script for the BUILD phase of RPM building\"),\n        (\n            'pre-install=',\n            None,\n            \"Specify a script for the pre-INSTALL phase of RPM building\",\n        ),\n        (\n            'install-script=',\n            None,\n            \"Specify a script for the INSTALL phase of RPM building\",\n        ),\n        (\n            'post-install=',\n            None,\n            \"Specify a script for the post-INSTALL phase of RPM building\",\n        ),\n        (\n            'pre-uninstall=',\n            None,\n            \"Specify a script for the pre-UNINSTALL phase of RPM building\",\n        ),\n        (\n            'post-uninstall=',\n            None,\n            \"Specify a script for the post-UNINSTALL phase of RPM building\",\n        ),\n        ('clean-script=', None, \"Specify a script for the CLEAN phase of RPM building\"),\n        (\n            'verify-script=',\n            None,\n            \"Specify a script for the VERIFY phase of the RPM build\",\n        ),\n        # Allow a packager to explicitly force an architecture\n        ('force-arch=', None, \"Force an architecture onto the RPM build process\"),\n        ('quiet', 'q', \"Run the INSTALL phase of RPM building in quiet mode\"),\n    ]\n\n    boolean_options = [\n        'keep-temp',\n        'use-rpm-opt-flags',\n        'rpm3-mode',\n        'no-autoreq',\n        'quiet',\n    ]\n\n    negative_opt = {\n        'no-keep-temp': 'keep-temp',\n        'no-rpm-opt-flags': 'use-rpm-opt-flags',\n        'rpm2-mode': 'rpm3-mode',\n    }\n\n    def initialize_options(self):\n        self.bdist_base = None\n        self.rpm_base = None\n        self.dist_dir = None\n        self.python = None\n        self.fix_python = None\n        self.spec_only = None\n        self.binary_only = None\n        self.source_only = None\n        self.use_bzip2 = None\n\n        self.distribution_name = None\n        self.group = None\n        self.release = None\n        self.serial = None\n        self.vendor = None\n        self.packager = None\n        self.doc_files = None\n        self.changelog = None\n        self.icon = None\n\n        self.prep_script = None\n        self.build_script = None\n        self.install_script = None\n        self.clean_script = None\n        self.verify_script = None\n        self.pre_install = None\n        self.post_install = None\n        self.pre_uninstall = None\n        self.post_uninstall = None\n        self.prep = None\n        self.provides = None\n        self.requires = None\n        self.conflicts = None\n        self.build_requires = None\n        self.obsoletes = None\n\n        self.keep_temp = 0\n        self.use_rpm_opt_flags = 1\n        self.rpm3_mode = 1\n        self.no_autoreq = 0\n\n        self.force_arch = None\n        self.quiet = 0\n\n    def finalize_options(self):\n        self.set_undefined_options('bdist', ('bdist_base', 'bdist_base'))\n        if self.rpm_base is None:\n            if not self.rpm3_mode:\n                raise DistutilsOptionError(\"you must specify --rpm-base in RPM 2 mode\")\n            self.rpm_base = os.path.join(self.bdist_base, \"rpm\")\n\n        if self.python is None:\n            if self.fix_python:\n                self.python = sys.executable\n            else:\n                self.python = \"python3\"\n        elif self.fix_python:\n            raise DistutilsOptionError(\n                \"--python and --fix-python are mutually exclusive options\"\n            )\n\n        if os.name != 'posix':\n            raise DistutilsPlatformError(\n                \"don't know how to create RPM distributions on platform %s\" % os.name\n            )\n        if self.binary_only and self.source_only:\n            raise DistutilsOptionError(\n                \"cannot supply both '--source-only' and '--binary-only'\"\n            )\n\n        # don't pass CFLAGS to pure python distributions\n        if not self.distribution.has_ext_modules():\n            self.use_rpm_opt_flags = 0\n\n        self.set_undefined_options('bdist', ('dist_dir', 'dist_dir'))\n        self.finalize_package_data()\n\n    def finalize_package_data(self):\n        self.ensure_string('group', \"Development/Libraries\")\n        self.ensure_string(\n            'vendor',\n            f\"{self.distribution.get_contact()} <{self.distribution.get_contact_email()}>\",\n        )\n        self.ensure_string('packager')\n        self.ensure_string_list('doc_files')\n        if isinstance(self.doc_files, list):\n            for readme in ('README', 'README.txt'):\n                if os.path.exists(readme) and readme not in self.doc_files:\n                    self.doc_files.append(readme)\n\n        self.ensure_string('release', \"1\")\n        self.ensure_string('serial')  # should it be an int?\n\n        self.ensure_string('distribution_name')\n\n        self.ensure_string('changelog')\n        # Format changelog correctly\n        self.changelog = self._format_changelog(self.changelog)\n\n        self.ensure_filename('icon')\n\n        self.ensure_filename('prep_script')\n        self.ensure_filename('build_script')\n        self.ensure_filename('install_script')\n        self.ensure_filename('clean_script')\n        self.ensure_filename('verify_script')\n        self.ensure_filename('pre_install')\n        self.ensure_filename('post_install')\n        self.ensure_filename('pre_uninstall')\n        self.ensure_filename('post_uninstall')\n\n        # XXX don't forget we punted on summaries and descriptions -- they\n        # should be handled here eventually!\n\n        # Now *this* is some meta-data that belongs in the setup script...\n        self.ensure_string_list('provides')\n        self.ensure_string_list('requires')\n        self.ensure_string_list('conflicts')\n        self.ensure_string_list('build_requires')\n        self.ensure_string_list('obsoletes')\n\n        self.ensure_string('force_arch')\n\n    def run(self):  # noqa: C901\n        if DEBUG:\n            print(\"before _get_package_data():\")\n            print(\"vendor =\", self.vendor)\n            print(\"packager =\", self.packager)\n            print(\"doc_files =\", self.doc_files)\n            print(\"changelog =\", self.changelog)\n\n        # make directories\n        if self.spec_only:\n            spec_dir = self.dist_dir\n            self.mkpath(spec_dir)\n        else:\n            rpm_dir = {}\n            for d in ('SOURCES', 'SPECS', 'BUILD', 'RPMS', 'SRPMS'):\n                rpm_dir[d] = os.path.join(self.rpm_base, d)\n                self.mkpath(rpm_dir[d])\n            spec_dir = rpm_dir['SPECS']\n\n        # Spec file goes into 'dist_dir' if '--spec-only specified',\n        # build/rpm.<plat> otherwise.\n        spec_path = os.path.join(spec_dir, \"%s.spec\" % self.distribution.get_name())\n        self.execute(\n            write_file, (spec_path, self._make_spec_file()), \"writing '%s'\" % spec_path\n        )\n\n        if self.spec_only:  # stop if requested\n            return\n\n        # Make a source distribution and copy to SOURCES directory with\n        # optional icon.\n        saved_dist_files = self.distribution.dist_files[:]\n        sdist = self.reinitialize_command('sdist')\n        if self.use_bzip2:\n            sdist.formats = ['bztar']\n        else:\n            sdist.formats = ['gztar']\n        self.run_command('sdist')\n        self.distribution.dist_files = saved_dist_files\n\n        source = sdist.get_archive_files()[0]\n        source_dir = rpm_dir['SOURCES']\n        self.copy_file(source, source_dir)\n\n        if self.icon:\n            if os.path.exists(self.icon):\n                self.copy_file(self.icon, source_dir)\n            else:\n                raise DistutilsFileError(\"icon file '%s' does not exist\" % self.icon)\n\n        # build package\n        log.info(\"building RPMs\")\n        rpm_cmd = ['rpmbuild']\n\n        if self.source_only:  # what kind of RPMs?\n            rpm_cmd.append('-bs')\n        elif self.binary_only:\n            rpm_cmd.append('-bb')\n        else:\n            rpm_cmd.append('-ba')\n        rpm_cmd.extend(['--define', '__python %s' % self.python])\n        if self.rpm3_mode:\n            rpm_cmd.extend(['--define', '_topdir %s' % os.path.abspath(self.rpm_base)])\n        if not self.keep_temp:\n            rpm_cmd.append('--clean')\n\n        if self.quiet:\n            rpm_cmd.append('--quiet')\n\n        rpm_cmd.append(spec_path)\n        # Determine the binary rpm names that should be built out of this spec\n        # file\n        # Note that some of these may not be really built (if the file\n        # list is empty)\n        nvr_string = \"%{name}-%{version}-%{release}\"\n        src_rpm = nvr_string + \".src.rpm\"\n        non_src_rpm = \"%{arch}/\" + nvr_string + \".%{arch}.rpm\"\n        q_cmd = rf\"rpm -q --qf '{src_rpm} {non_src_rpm}\\n' --specfile '{spec_path}'\"\n\n        out = os.popen(q_cmd)\n        try:\n            binary_rpms = []\n            source_rpm = None\n            while True:\n                line = out.readline()\n                if not line:\n                    break\n                ell = line.strip().split()\n                assert len(ell) == 2\n                binary_rpms.append(ell[1])\n                # The source rpm is named after the first entry in the spec file\n                if source_rpm is None:\n                    source_rpm = ell[0]\n\n            status = out.close()\n            if status:\n                raise DistutilsExecError(\"Failed to execute: %s\" % repr(q_cmd))\n\n        finally:\n            out.close()\n\n        self.spawn(rpm_cmd)\n\n        if not self.dry_run:\n            if self.distribution.has_ext_modules():\n                pyversion = get_python_version()\n            else:\n                pyversion = 'any'\n\n            if not self.binary_only:\n                srpm = os.path.join(rpm_dir['SRPMS'], source_rpm)\n                assert os.path.exists(srpm)\n                self.move_file(srpm, self.dist_dir)\n                filename = os.path.join(self.dist_dir, source_rpm)\n                self.distribution.dist_files.append(('bdist_rpm', pyversion, filename))\n\n            if not self.source_only:\n                for rpm in binary_rpms:\n                    rpm = os.path.join(rpm_dir['RPMS'], rpm)\n                    if os.path.exists(rpm):\n                        self.move_file(rpm, self.dist_dir)\n                        filename = os.path.join(self.dist_dir, os.path.basename(rpm))\n                        self.distribution.dist_files.append((\n                            'bdist_rpm',\n                            pyversion,\n                            filename,\n                        ))\n\n    def _dist_path(self, path):\n        return os.path.join(self.dist_dir, os.path.basename(path))\n\n    def _make_spec_file(self):  # noqa: C901\n        \"\"\"Generate the text of an RPM spec file and return it as a\n        list of strings (one per line).\n        \"\"\"\n        # definitions and headers\n        spec_file = [\n            '%define name ' + self.distribution.get_name(),\n            '%define version ' + self.distribution.get_version().replace('-', '_'),\n            '%define unmangled_version ' + self.distribution.get_version(),\n            '%define release ' + self.release.replace('-', '_'),\n            '',\n            'Summary: ' + (self.distribution.get_description() or \"UNKNOWN\"),\n        ]\n\n        # Workaround for #14443 which affects some RPM based systems such as\n        # RHEL6 (and probably derivatives)\n        vendor_hook = subprocess.getoutput('rpm --eval %{__os_install_post}')\n        # Generate a potential replacement value for __os_install_post (whilst\n        # normalizing the whitespace to simplify the test for whether the\n        # invocation of brp-python-bytecompile passes in __python):\n        vendor_hook = '\\n'.join([\n            '  %s \\\\' % line.strip() for line in vendor_hook.splitlines()\n        ])\n        problem = \"brp-python-bytecompile \\\\\\n\"\n        fixed = \"brp-python-bytecompile %{__python} \\\\\\n\"\n        fixed_hook = vendor_hook.replace(problem, fixed)\n        if fixed_hook != vendor_hook:\n            spec_file.append('# Workaround for https://bugs.python.org/issue14443')\n            spec_file.append('%define __os_install_post ' + fixed_hook + '\\n')\n\n        # put locale summaries into spec file\n        # XXX not supported for now (hard to put a dictionary\n        # in a config file -- arg!)\n        # for locale in self.summaries.keys():\n        #    spec_file.append('Summary(%s): %s' % (locale,\n        #                                          self.summaries[locale]))\n\n        spec_file.extend([\n            'Name: %{name}',\n            'Version: %{version}',\n            'Release: %{release}',\n        ])\n\n        # XXX yuck! this filename is available from the \"sdist\" command,\n        # but only after it has run: and we create the spec file before\n        # running \"sdist\", in case of --spec-only.\n        if self.use_bzip2:\n            spec_file.append('Source0: %{name}-%{unmangled_version}.tar.bz2')\n        else:\n            spec_file.append('Source0: %{name}-%{unmangled_version}.tar.gz')\n\n        spec_file.extend([\n            'License: ' + (self.distribution.get_license() or \"UNKNOWN\"),\n            'Group: ' + self.group,\n            'BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildroot',\n            'Prefix: %{_prefix}',\n        ])\n\n        if not self.force_arch:\n            # noarch if no extension modules\n            if not self.distribution.has_ext_modules():\n                spec_file.append('BuildArch: noarch')\n        else:\n            spec_file.append('BuildArch: %s' % self.force_arch)\n\n        for field in (\n            'Vendor',\n            'Packager',\n            'Provides',\n            'Requires',\n            'Conflicts',\n            'Obsoletes',\n        ):\n            val = getattr(self, field.lower())\n            if isinstance(val, list):\n                spec_file.append('{}: {}'.format(field, ' '.join(val)))\n            elif val is not None:\n                spec_file.append(f'{field}: {val}')\n\n        if self.distribution.get_url():\n            spec_file.append('Url: ' + self.distribution.get_url())\n\n        if self.distribution_name:\n            spec_file.append('Distribution: ' + self.distribution_name)\n\n        if self.build_requires:\n            spec_file.append('BuildRequires: ' + ' '.join(self.build_requires))\n\n        if self.icon:\n            spec_file.append('Icon: ' + os.path.basename(self.icon))\n\n        if self.no_autoreq:\n            spec_file.append('AutoReq: 0')\n\n        spec_file.extend([\n            '',\n            '%description',\n            self.distribution.get_long_description() or \"\",\n        ])\n\n        # put locale descriptions into spec file\n        # XXX again, suppressed because config file syntax doesn't\n        # easily support this ;-(\n        # for locale in self.descriptions.keys():\n        #    spec_file.extend([\n        #        '',\n        #        '%description -l ' + locale,\n        #        self.descriptions[locale],\n        #        ])\n\n        # rpm scripts\n        # figure out default build script\n        def_setup_call = f\"{self.python} {os.path.basename(sys.argv[0])}\"\n        def_build = \"%s build\" % def_setup_call\n        if self.use_rpm_opt_flags:\n            def_build = 'env CFLAGS=\"$RPM_OPT_FLAGS\" ' + def_build\n\n        # insert contents of files\n\n        # XXX this is kind of misleading: user-supplied options are files\n        # that we open and interpolate into the spec file, but the defaults\n        # are just text that we drop in as-is.  Hmmm.\n\n        install_cmd = (\n            '%s install -O1 --root=$RPM_BUILD_ROOT ' '--record=INSTALLED_FILES'\n        ) % def_setup_call\n\n        script_options = [\n            ('prep', 'prep_script', \"%setup -n %{name}-%{unmangled_version}\"),\n            ('build', 'build_script', def_build),\n            ('install', 'install_script', install_cmd),\n            ('clean', 'clean_script', \"rm -rf $RPM_BUILD_ROOT\"),\n            ('verifyscript', 'verify_script', None),\n            ('pre', 'pre_install', None),\n            ('post', 'post_install', None),\n            ('preun', 'pre_uninstall', None),\n            ('postun', 'post_uninstall', None),\n        ]\n\n        for rpm_opt, attr, default in script_options:\n            # Insert contents of file referred to, if no file is referred to\n            # use 'default' as contents of script\n            val = getattr(self, attr)\n            if val or default:\n                spec_file.extend([\n                    '',\n                    '%' + rpm_opt,\n                ])\n                if val:\n                    with open(val) as f:\n                        spec_file.extend(f.read().split('\\n'))\n                else:\n                    spec_file.append(default)\n\n        # files section\n        spec_file.extend([\n            '',\n            '%files -f INSTALLED_FILES',\n            '%defattr(-,root,root)',\n        ])\n\n        if self.doc_files:\n            spec_file.append('%doc ' + ' '.join(self.doc_files))\n\n        if self.changelog:\n            spec_file.extend([\n                '',\n                '%changelog',\n            ])\n            spec_file.extend(self.changelog)\n\n        return spec_file\n\n    def _format_changelog(self, changelog):\n        \"\"\"Format the changelog correctly and convert it to a list of strings\"\"\"\n        if not changelog:\n            return changelog\n        new_changelog = []\n        for line in changelog.strip().split('\\n'):\n            line = line.strip()\n            if line[0] == '*':\n                new_changelog.extend(['', line])\n            elif line[0] == '-':\n                new_changelog.append(line)\n            else:\n                new_changelog.append('  ' + line)\n\n        # strip trailing newline inserted by first changelog entry\n        if not new_changelog[0]:\n            del new_changelog[0]\n\n        return new_changelog\n", "setuptools/_distutils/command/clean.py": "\"\"\"distutils.command.clean\n\nImplements the Distutils 'clean' command.\"\"\"\n\n# contributed by Bastian Kleineidam <calvin@cs.uni-sb.de>, added 2000-03-18\n\nimport os\nfrom distutils._log import log\n\nfrom ..core import Command\nfrom ..dir_util import remove_tree\n\n\nclass clean(Command):\n    description = \"clean up temporary files from 'build' command\"\n    user_options = [\n        ('build-base=', 'b', \"base build directory (default: 'build.build-base')\"),\n        (\n            'build-lib=',\n            None,\n            \"build directory for all modules (default: 'build.build-lib')\",\n        ),\n        ('build-temp=', 't', \"temporary build directory (default: 'build.build-temp')\"),\n        (\n            'build-scripts=',\n            None,\n            \"build directory for scripts (default: 'build.build-scripts')\",\n        ),\n        ('bdist-base=', None, \"temporary directory for built distributions\"),\n        ('all', 'a', \"remove all build output, not just temporary by-products\"),\n    ]\n\n    boolean_options = ['all']\n\n    def initialize_options(self):\n        self.build_base = None\n        self.build_lib = None\n        self.build_temp = None\n        self.build_scripts = None\n        self.bdist_base = None\n        self.all = None\n\n    def finalize_options(self):\n        self.set_undefined_options(\n            'build',\n            ('build_base', 'build_base'),\n            ('build_lib', 'build_lib'),\n            ('build_scripts', 'build_scripts'),\n            ('build_temp', 'build_temp'),\n        )\n        self.set_undefined_options('bdist', ('bdist_base', 'bdist_base'))\n\n    def run(self):\n        # remove the build/temp.<plat> directory (unless it's already\n        # gone)\n        if os.path.exists(self.build_temp):\n            remove_tree(self.build_temp, dry_run=self.dry_run)\n        else:\n            log.debug(\"'%s' does not exist -- can't clean it\", self.build_temp)\n\n        if self.all:\n            # remove build directories\n            for directory in (self.build_lib, self.bdist_base, self.build_scripts):\n                if os.path.exists(directory):\n                    remove_tree(directory, dry_run=self.dry_run)\n                else:\n                    log.warning(\"'%s' does not exist -- can't clean it\", directory)\n\n        # just for the heck of it, try to remove the base build directory:\n        # we might have emptied it right now, but if not we don't care\n        if not self.dry_run:\n            try:\n                os.rmdir(self.build_base)\n                log.info(\"removing '%s'\", self.build_base)\n            except OSError:\n                pass\n", "setuptools/_distutils/command/build_scripts.py": "\"\"\"distutils.command.build_scripts\n\nImplements the Distutils 'build_scripts' command.\"\"\"\n\nimport os\nimport re\nimport tokenize\nfrom distutils import sysconfig\nfrom distutils._log import log\nfrom stat import ST_MODE\n\nfrom .._modified import newer\nfrom ..core import Command\nfrom ..util import convert_path\n\nshebang_pattern = re.compile('^#!.*python[0-9.]*([ \\t].*)?$')\n\"\"\"\nPattern matching a Python interpreter indicated in first line of a script.\n\"\"\"\n\n# for Setuptools compatibility\nfirst_line_re = shebang_pattern\n\n\nclass build_scripts(Command):\n    description = \"\\\"build\\\" scripts (copy and fixup #! line)\"\n\n    user_options = [\n        ('build-dir=', 'd', \"directory to \\\"build\\\" (copy) to\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps\"),\n        ('executable=', 'e', \"specify final destination interpreter path\"),\n    ]\n\n    boolean_options = ['force']\n\n    def initialize_options(self):\n        self.build_dir = None\n        self.scripts = None\n        self.force = None\n        self.executable = None\n\n    def finalize_options(self):\n        self.set_undefined_options(\n            'build',\n            ('build_scripts', 'build_dir'),\n            ('force', 'force'),\n            ('executable', 'executable'),\n        )\n        self.scripts = self.distribution.scripts\n\n    def get_source_files(self):\n        return self.scripts\n\n    def run(self):\n        if not self.scripts:\n            return\n        self.copy_scripts()\n\n    def copy_scripts(self):\n        \"\"\"\n        Copy each script listed in ``self.scripts``.\n\n        If a script is marked as a Python script (first line matches\n        'shebang_pattern', i.e. starts with ``#!`` and contains\n        \"python\"), then adjust in the copy the first line to refer to\n        the current Python interpreter.\n        \"\"\"\n        self.mkpath(self.build_dir)\n        outfiles = []\n        updated_files = []\n        for script in self.scripts:\n            self._copy_script(script, outfiles, updated_files)\n\n        self._change_modes(outfiles)\n\n        return outfiles, updated_files\n\n    def _copy_script(self, script, outfiles, updated_files):  # noqa: C901\n        shebang_match = None\n        script = convert_path(script)\n        outfile = os.path.join(self.build_dir, os.path.basename(script))\n        outfiles.append(outfile)\n\n        if not self.force and not newer(script, outfile):\n            log.debug(\"not copying %s (up-to-date)\", script)\n            return\n\n        # Always open the file, but ignore failures in dry-run mode\n        # in order to attempt to copy directly.\n        try:\n            f = tokenize.open(script)\n        except OSError:\n            if not self.dry_run:\n                raise\n            f = None\n        else:\n            first_line = f.readline()\n            if not first_line:\n                self.warn(\"%s is an empty file (skipping)\" % script)\n                return\n\n            shebang_match = shebang_pattern.match(first_line)\n\n        updated_files.append(outfile)\n        if shebang_match:\n            log.info(\"copying and adjusting %s -> %s\", script, self.build_dir)\n            if not self.dry_run:\n                if not sysconfig.python_build:\n                    executable = self.executable\n                else:\n                    executable = os.path.join(\n                        sysconfig.get_config_var(\"BINDIR\"),\n                        \"python{}{}\".format(\n                            sysconfig.get_config_var(\"VERSION\"),\n                            sysconfig.get_config_var(\"EXE\"),\n                        ),\n                    )\n                post_interp = shebang_match.group(1) or ''\n                shebang = \"#!\" + executable + post_interp + \"\\n\"\n                self._validate_shebang(shebang, f.encoding)\n                with open(outfile, \"w\", encoding=f.encoding) as outf:\n                    outf.write(shebang)\n                    outf.writelines(f.readlines())\n            if f:\n                f.close()\n        else:\n            if f:\n                f.close()\n            self.copy_file(script, outfile)\n\n    def _change_modes(self, outfiles):\n        if os.name != 'posix':\n            return\n\n        for file in outfiles:\n            self._change_mode(file)\n\n    def _change_mode(self, file):\n        if self.dry_run:\n            log.info(\"changing mode of %s\", file)\n            return\n\n        oldmode = os.stat(file)[ST_MODE] & 0o7777\n        newmode = (oldmode | 0o555) & 0o7777\n        if newmode != oldmode:\n            log.info(\"changing mode of %s from %o to %o\", file, oldmode, newmode)\n            os.chmod(file, newmode)\n\n    @staticmethod\n    def _validate_shebang(shebang, encoding):\n        # Python parser starts to read a script using UTF-8 until\n        # it gets a #coding:xxx cookie. The shebang has to be the\n        # first line of a file, the #coding:xxx cookie cannot be\n        # written before. So the shebang has to be encodable to\n        # UTF-8.\n        try:\n            shebang.encode('utf-8')\n        except UnicodeEncodeError:\n            raise ValueError(f\"The shebang ({shebang!r}) is not encodable to utf-8\")\n\n        # If the script is encoded to a custom encoding (use a\n        # #coding:xxx cookie), the shebang has to be encodable to\n        # the script encoding too.\n        try:\n            shebang.encode(encoding)\n        except UnicodeEncodeError:\n            raise ValueError(\n                f\"The shebang ({shebang!r}) is not encodable \"\n                f\"to the script encoding ({encoding})\"\n            )\n", "setuptools/_distutils/command/__init__.py": "\"\"\"distutils.command\n\nPackage containing implementation of all the standard Distutils\ncommands.\"\"\"\n\n__all__ = [  # noqa: F822\n    'build',\n    'build_py',\n    'build_ext',\n    'build_clib',\n    'build_scripts',\n    'clean',\n    'install',\n    'install_lib',\n    'install_headers',\n    'install_scripts',\n    'install_data',\n    'sdist',\n    'register',\n    'bdist',\n    'bdist_dumb',\n    'bdist_rpm',\n    'check',\n    'upload',\n]\n", "setuptools/_distutils/command/check.py": "\"\"\"distutils.command.check\n\nImplements the Distutils 'check' command.\n\"\"\"\n\nimport contextlib\n\nfrom ..core import Command\nfrom ..errors import DistutilsSetupError\n\nwith contextlib.suppress(ImportError):\n    import docutils.frontend\n    import docutils.nodes\n    import docutils.parsers.rst\n    import docutils.utils\n\n    class SilentReporter(docutils.utils.Reporter):\n        def __init__(\n            self,\n            source,\n            report_level,\n            halt_level,\n            stream=None,\n            debug=0,\n            encoding='ascii',\n            error_handler='replace',\n        ):\n            self.messages = []\n            super().__init__(\n                source, report_level, halt_level, stream, debug, encoding, error_handler\n            )\n\n        def system_message(self, level, message, *children, **kwargs):\n            self.messages.append((level, message, children, kwargs))\n            return docutils.nodes.system_message(\n                message, *children, level=level, type=self.levels[level], **kwargs\n            )\n\n\nclass check(Command):\n    \"\"\"This command checks the meta-data of the package.\"\"\"\n\n    description = \"perform some checks on the package\"\n    user_options = [\n        ('metadata', 'm', 'Verify meta-data'),\n        (\n            'restructuredtext',\n            'r',\n            (\n                'Checks if long string meta-data syntax '\n                'are reStructuredText-compliant'\n            ),\n        ),\n        ('strict', 's', 'Will exit with an error if a check fails'),\n    ]\n\n    boolean_options = ['metadata', 'restructuredtext', 'strict']\n\n    def initialize_options(self):\n        \"\"\"Sets default values for options.\"\"\"\n        self.restructuredtext = 0\n        self.metadata = 1\n        self.strict = 0\n        self._warnings = 0\n\n    def finalize_options(self):\n        pass\n\n    def warn(self, msg):\n        \"\"\"Counts the number of warnings that occurs.\"\"\"\n        self._warnings += 1\n        return Command.warn(self, msg)\n\n    def run(self):\n        \"\"\"Runs the command.\"\"\"\n        # perform the various tests\n        if self.metadata:\n            self.check_metadata()\n        if self.restructuredtext:\n            if 'docutils' in globals():\n                try:\n                    self.check_restructuredtext()\n                except TypeError as exc:\n                    raise DistutilsSetupError(str(exc))\n            elif self.strict:\n                raise DistutilsSetupError('The docutils package is needed.')\n\n        # let's raise an error in strict mode, if we have at least\n        # one warning\n        if self.strict and self._warnings > 0:\n            raise DistutilsSetupError('Please correct your package.')\n\n    def check_metadata(self):\n        \"\"\"Ensures that all required elements of meta-data are supplied.\n\n        Required fields:\n            name, version\n\n        Warns if any are missing.\n        \"\"\"\n        metadata = self.distribution.metadata\n\n        missing = []\n        for attr in 'name', 'version':\n            if not getattr(metadata, attr, None):\n                missing.append(attr)\n\n        if missing:\n            self.warn(\"missing required meta-data: %s\" % ', '.join(missing))\n\n    def check_restructuredtext(self):\n        \"\"\"Checks if the long string fields are reST-compliant.\"\"\"\n        data = self.distribution.get_long_description()\n        for warning in self._check_rst_data(data):\n            line = warning[-1].get('line')\n            if line is None:\n                warning = warning[1]\n            else:\n                warning = f'{warning[1]} (line {line})'\n            self.warn(warning)\n\n    def _check_rst_data(self, data):\n        \"\"\"Returns warnings when the provided data doesn't compile.\"\"\"\n        # the include and csv_table directives need this to be a path\n        source_path = self.distribution.script_name or 'setup.py'\n        parser = docutils.parsers.rst.Parser()\n        settings = docutils.frontend.OptionParser(\n            components=(docutils.parsers.rst.Parser,)\n        ).get_default_values()\n        settings.tab_width = 4\n        settings.pep_references = None\n        settings.rfc_references = None\n        reporter = SilentReporter(\n            source_path,\n            settings.report_level,\n            settings.halt_level,\n            stream=settings.warning_stream,\n            debug=settings.debug,\n            encoding=settings.error_encoding,\n            error_handler=settings.error_encoding_error_handler,\n        )\n\n        document = docutils.nodes.document(settings, reporter, source=source_path)\n        document.note_source(source_path, -1)\n        try:\n            parser.parse(data, document)\n        except AttributeError as e:\n            reporter.messages.append((\n                -1,\n                'Could not finish the parsing: %s.' % e,\n                '',\n                {},\n            ))\n\n        return reporter.messages\n", "setuptools/_distutils/command/build_py.py": "\"\"\"distutils.command.build_py\n\nImplements the Distutils 'build_py' command.\"\"\"\n\nimport glob\nimport importlib.util\nimport os\nimport sys\nfrom distutils._log import log\n\nfrom ..core import Command\nfrom ..errors import DistutilsFileError, DistutilsOptionError\nfrom ..util import convert_path\n\n\nclass build_py(Command):\n    description = \"\\\"build\\\" pure Python modules (copy to build directory)\"\n\n    user_options = [\n        ('build-lib=', 'd', \"directory to \\\"build\\\" (copy) to\"),\n        ('compile', 'c', \"compile .py to .pyc\"),\n        ('no-compile', None, \"don't compile .py files [default]\"),\n        (\n            'optimize=',\n            'O',\n            \"also compile with optimization: -O1 for \\\"python -O\\\", \"\n            \"-O2 for \\\"python -OO\\\", and -O0 to disable [default: -O0]\",\n        ),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps)\"),\n    ]\n\n    boolean_options = ['compile', 'force']\n    negative_opt = {'no-compile': 'compile'}\n\n    def initialize_options(self):\n        self.build_lib = None\n        self.py_modules = None\n        self.package = None\n        self.package_data = None\n        self.package_dir = None\n        self.compile = 0\n        self.optimize = 0\n        self.force = None\n\n    def finalize_options(self):\n        self.set_undefined_options(\n            'build', ('build_lib', 'build_lib'), ('force', 'force')\n        )\n\n        # Get the distribution options that are aliases for build_py\n        # options -- list of packages and list of modules.\n        self.packages = self.distribution.packages\n        self.py_modules = self.distribution.py_modules\n        self.package_data = self.distribution.package_data\n        self.package_dir = {}\n        if self.distribution.package_dir:\n            for name, path in self.distribution.package_dir.items():\n                self.package_dir[name] = convert_path(path)\n        self.data_files = self.get_data_files()\n\n        # Ick, copied straight from install_lib.py (fancy_getopt needs a\n        # type system!  Hell, *everything* needs a type system!!!)\n        if not isinstance(self.optimize, int):\n            try:\n                self.optimize = int(self.optimize)\n                assert 0 <= self.optimize <= 2\n            except (ValueError, AssertionError):\n                raise DistutilsOptionError(\"optimize must be 0, 1, or 2\")\n\n    def run(self):\n        # XXX copy_file by default preserves atime and mtime.  IMHO this is\n        # the right thing to do, but perhaps it should be an option -- in\n        # particular, a site administrator might want installed files to\n        # reflect the time of installation rather than the last\n        # modification time before the installed release.\n\n        # XXX copy_file by default preserves mode, which appears to be the\n        # wrong thing to do: if a file is read-only in the working\n        # directory, we want it to be installed read/write so that the next\n        # installation of the same module distribution can overwrite it\n        # without problems.  (This might be a Unix-specific issue.)  Thus\n        # we turn off 'preserve_mode' when copying to the build directory,\n        # since the build directory is supposed to be exactly what the\n        # installation will look like (ie. we preserve mode when\n        # installing).\n\n        # Two options control which modules will be installed: 'packages'\n        # and 'py_modules'.  The former lets us work with whole packages, not\n        # specifying individual modules at all; the latter is for\n        # specifying modules one-at-a-time.\n\n        if self.py_modules:\n            self.build_modules()\n        if self.packages:\n            self.build_packages()\n            self.build_package_data()\n\n        self.byte_compile(self.get_outputs(include_bytecode=0))\n\n    def get_data_files(self):\n        \"\"\"Generate list of '(package,src_dir,build_dir,filenames)' tuples\"\"\"\n        data = []\n        if not self.packages:\n            return data\n        for package in self.packages:\n            # Locate package source directory\n            src_dir = self.get_package_dir(package)\n\n            # Compute package build directory\n            build_dir = os.path.join(*([self.build_lib] + package.split('.')))\n\n            # Length of path to strip from found files\n            plen = 0\n            if src_dir:\n                plen = len(src_dir) + 1\n\n            # Strip directory from globbed filenames\n            filenames = [file[plen:] for file in self.find_data_files(package, src_dir)]\n            data.append((package, src_dir, build_dir, filenames))\n        return data\n\n    def find_data_files(self, package, src_dir):\n        \"\"\"Return filenames for package's data files in 'src_dir'\"\"\"\n        globs = self.package_data.get('', []) + self.package_data.get(package, [])\n        files = []\n        for pattern in globs:\n            # Each pattern has to be converted to a platform-specific path\n            filelist = glob.glob(\n                os.path.join(glob.escape(src_dir), convert_path(pattern))\n            )\n            # Files that match more than one pattern are only added once\n            files.extend([\n                fn for fn in filelist if fn not in files and os.path.isfile(fn)\n            ])\n        return files\n\n    def build_package_data(self):\n        \"\"\"Copy data files into build directory\"\"\"\n        for _package, src_dir, build_dir, filenames in self.data_files:\n            for filename in filenames:\n                target = os.path.join(build_dir, filename)\n                self.mkpath(os.path.dirname(target))\n                self.copy_file(\n                    os.path.join(src_dir, filename), target, preserve_mode=False\n                )\n\n    def get_package_dir(self, package):\n        \"\"\"Return the directory, relative to the top of the source\n        distribution, where package 'package' should be found\n        (at least according to the 'package_dir' option, if any).\"\"\"\n        path = package.split('.')\n\n        if not self.package_dir:\n            if path:\n                return os.path.join(*path)\n            else:\n                return ''\n        else:\n            tail = []\n            while path:\n                try:\n                    pdir = self.package_dir['.'.join(path)]\n                except KeyError:\n                    tail.insert(0, path[-1])\n                    del path[-1]\n                else:\n                    tail.insert(0, pdir)\n                    return os.path.join(*tail)\n            else:\n                # Oops, got all the way through 'path' without finding a\n                # match in package_dir.  If package_dir defines a directory\n                # for the root (nameless) package, then fallback on it;\n                # otherwise, we might as well have not consulted\n                # package_dir at all, as we just use the directory implied\n                # by 'tail' (which should be the same as the original value\n                # of 'path' at this point).\n                pdir = self.package_dir.get('')\n                if pdir is not None:\n                    tail.insert(0, pdir)\n\n                if tail:\n                    return os.path.join(*tail)\n                else:\n                    return ''\n\n    def check_package(self, package, package_dir):\n        # Empty dir name means current directory, which we can probably\n        # assume exists.  Also, os.path.exists and isdir don't know about\n        # my \"empty string means current dir\" convention, so we have to\n        # circumvent them.\n        if package_dir != \"\":\n            if not os.path.exists(package_dir):\n                raise DistutilsFileError(\n                    \"package directory '%s' does not exist\" % package_dir\n                )\n            if not os.path.isdir(package_dir):\n                raise DistutilsFileError(\n                    \"supposed package directory '%s' exists, \"\n                    \"but is not a directory\" % package_dir\n                )\n\n        # Directories without __init__.py are namespace packages (PEP 420).\n        if package:\n            init_py = os.path.join(package_dir, \"__init__.py\")\n            if os.path.isfile(init_py):\n                return init_py\n\n        # Either not in a package at all (__init__.py not expected), or\n        # __init__.py doesn't exist -- so don't return the filename.\n        return None\n\n    def check_module(self, module, module_file):\n        if not os.path.isfile(module_file):\n            log.warning(\"file %s (for module %s) not found\", module_file, module)\n            return False\n        else:\n            return True\n\n    def find_package_modules(self, package, package_dir):\n        self.check_package(package, package_dir)\n        module_files = glob.glob(os.path.join(glob.escape(package_dir), \"*.py\"))\n        modules = []\n        setup_script = os.path.abspath(self.distribution.script_name)\n\n        for f in module_files:\n            abs_f = os.path.abspath(f)\n            if abs_f != setup_script:\n                module = os.path.splitext(os.path.basename(f))[0]\n                modules.append((package, module, f))\n            else:\n                self.debug_print(\"excluding %s\" % setup_script)\n        return modules\n\n    def find_modules(self):\n        \"\"\"Finds individually-specified Python modules, ie. those listed by\n        module name in 'self.py_modules'.  Returns a list of tuples (package,\n        module_base, filename): 'package' is a tuple of the path through\n        package-space to the module; 'module_base' is the bare (no\n        packages, no dots) module name, and 'filename' is the path to the\n        \".py\" file (relative to the distribution root) that implements the\n        module.\n        \"\"\"\n        # Map package names to tuples of useful info about the package:\n        #    (package_dir, checked)\n        # package_dir - the directory where we'll find source files for\n        #   this package\n        # checked - true if we have checked that the package directory\n        #   is valid (exists, contains __init__.py, ... ?)\n        packages = {}\n\n        # List of (package, module, filename) tuples to return\n        modules = []\n\n        # We treat modules-in-packages almost the same as toplevel modules,\n        # just the \"package\" for a toplevel is empty (either an empty\n        # string or empty list, depending on context).  Differences:\n        #   - don't check for __init__.py in directory for empty package\n        for module in self.py_modules:\n            path = module.split('.')\n            package = '.'.join(path[0:-1])\n            module_base = path[-1]\n\n            try:\n                (package_dir, checked) = packages[package]\n            except KeyError:\n                package_dir = self.get_package_dir(package)\n                checked = 0\n\n            if not checked:\n                init_py = self.check_package(package, package_dir)\n                packages[package] = (package_dir, 1)\n                if init_py:\n                    modules.append((package, \"__init__\", init_py))\n\n            # XXX perhaps we should also check for just .pyc files\n            # (so greedy closed-source bastards can distribute Python\n            # modules too)\n            module_file = os.path.join(package_dir, module_base + \".py\")\n            if not self.check_module(module, module_file):\n                continue\n\n            modules.append((package, module_base, module_file))\n\n        return modules\n\n    def find_all_modules(self):\n        \"\"\"Compute the list of all modules that will be built, whether\n        they are specified one-module-at-a-time ('self.py_modules') or\n        by whole packages ('self.packages').  Return a list of tuples\n        (package, module, module_file), just like 'find_modules()' and\n        'find_package_modules()' do.\"\"\"\n        modules = []\n        if self.py_modules:\n            modules.extend(self.find_modules())\n        if self.packages:\n            for package in self.packages:\n                package_dir = self.get_package_dir(package)\n                m = self.find_package_modules(package, package_dir)\n                modules.extend(m)\n        return modules\n\n    def get_source_files(self):\n        return [module[-1] for module in self.find_all_modules()]\n\n    def get_module_outfile(self, build_dir, package, module):\n        outfile_path = [build_dir] + list(package) + [module + \".py\"]\n        return os.path.join(*outfile_path)\n\n    def get_outputs(self, include_bytecode=1):\n        modules = self.find_all_modules()\n        outputs = []\n        for package, module, _module_file in modules:\n            package = package.split('.')\n            filename = self.get_module_outfile(self.build_lib, package, module)\n            outputs.append(filename)\n            if include_bytecode:\n                if self.compile:\n                    outputs.append(\n                        importlib.util.cache_from_source(filename, optimization='')\n                    )\n                if self.optimize > 0:\n                    outputs.append(\n                        importlib.util.cache_from_source(\n                            filename, optimization=self.optimize\n                        )\n                    )\n\n        outputs += [\n            os.path.join(build_dir, filename)\n            for package, src_dir, build_dir, filenames in self.data_files\n            for filename in filenames\n        ]\n\n        return outputs\n\n    def build_module(self, module, module_file, package):\n        if isinstance(package, str):\n            package = package.split('.')\n        elif not isinstance(package, (list, tuple)):\n            raise TypeError(\n                \"'package' must be a string (dot-separated), list, or tuple\"\n            )\n\n        # Now put the module source file into the \"build\" area -- this is\n        # easy, we just copy it somewhere under self.build_lib (the build\n        # directory for Python source).\n        outfile = self.get_module_outfile(self.build_lib, package, module)\n        dir = os.path.dirname(outfile)\n        self.mkpath(dir)\n        return self.copy_file(module_file, outfile, preserve_mode=0)\n\n    def build_modules(self):\n        modules = self.find_modules()\n        for package, module, module_file in modules:\n            # Now \"build\" the module -- ie. copy the source file to\n            # self.build_lib (the build directory for Python source).\n            # (Actually, it gets copied to the directory for this package\n            # under self.build_lib.)\n            self.build_module(module, module_file, package)\n\n    def build_packages(self):\n        for package in self.packages:\n            # Get list of (package, module, module_file) tuples based on\n            # scanning the package directory.  'package' is only included\n            # in the tuple so that 'find_modules()' and\n            # 'find_package_tuples()' have a consistent interface; it's\n            # ignored here (apart from a sanity check).  Also, 'module' is\n            # the *unqualified* module name (ie. no dots, no package -- we\n            # already know its package!), and 'module_file' is the path to\n            # the .py file, relative to the current directory\n            # (ie. including 'package_dir').\n            package_dir = self.get_package_dir(package)\n            modules = self.find_package_modules(package, package_dir)\n\n            # Now loop over the modules we found, \"building\" each one (just\n            # copy it to self.build_lib).\n            for package_, module, module_file in modules:\n                assert package == package_\n                self.build_module(module, module_file, package)\n\n    def byte_compile(self, files):\n        if sys.dont_write_bytecode:\n            self.warn('byte-compiling is disabled, skipping.')\n            return\n\n        from ..util import byte_compile\n\n        prefix = self.build_lib\n        if prefix[-1] != os.sep:\n            prefix = prefix + os.sep\n\n        # XXX this code is essentially the same as the 'byte_compile()\n        # method of the \"install_lib\" command, except for the determination\n        # of the 'prefix' string.  Hmmm.\n        if self.compile:\n            byte_compile(\n                files, optimize=0, force=self.force, prefix=prefix, dry_run=self.dry_run\n            )\n        if self.optimize > 0:\n            byte_compile(\n                files,\n                optimize=self.optimize,\n                force=self.force,\n                prefix=prefix,\n                dry_run=self.dry_run,\n            )\n", "setuptools/extern/__init__.py": "import importlib.util\nimport sys\n\n\nclass VendorImporter:\n    \"\"\"\n    A PEP 302 meta path importer for finding optionally-vendored\n    or otherwise naturally-installed packages from root_name.\n    \"\"\"\n\n    def __init__(self, root_name, vendored_names=(), vendor_pkg=None):\n        self.root_name = root_name\n        self.vendored_names = set(vendored_names)\n        self.vendor_pkg = vendor_pkg or root_name.replace('extern', '_vendor')\n\n    @property\n    def search_path(self):\n        \"\"\"\n        Search first the vendor package then as a natural package.\n        \"\"\"\n        yield self.vendor_pkg + '.'\n        yield ''\n\n    def _module_matches_namespace(self, fullname):\n        \"\"\"Figure out if the target module is vendored.\"\"\"\n        root, base, target = fullname.partition(self.root_name + '.')\n        return not root and any(map(target.startswith, self.vendored_names))\n\n    def load_module(self, fullname):\n        \"\"\"\n        Iterate over the search path to locate and load fullname.\n        \"\"\"\n        root, base, target = fullname.partition(self.root_name + '.')\n        for prefix in self.search_path:\n            try:\n                extant = prefix + target\n                __import__(extant)\n                mod = sys.modules[extant]\n                sys.modules[fullname] = mod\n                return mod\n            except ImportError:\n                pass\n        else:\n            raise ImportError(\n                \"The '{target}' package is required; \"\n                \"normally this is bundled with this package so if you get \"\n                \"this warning, consult the packager of your \"\n                \"distribution.\".format(**locals())\n            )\n\n    def create_module(self, spec):\n        return self.load_module(spec.name)\n\n    def exec_module(self, module):\n        pass\n\n    def find_spec(self, fullname, path=None, target=None):\n        \"\"\"Return a module spec for vendored names.\"\"\"\n        return (\n            importlib.util.spec_from_loader(fullname, self)\n            if self._module_matches_namespace(fullname)\n            else None\n        )\n\n    def install(self):\n        \"\"\"\n        Install this importer into sys.meta_path if not already present.\n        \"\"\"\n        if self not in sys.meta_path:\n            sys.meta_path.append(self)\n\n\n# [[[cog\n# import cog\n# from tools.vendored import yield_top_level\n# names = \"\\n\".join(f\"    {x!r},\" for x in yield_top_level('setuptools'))\n# cog.outl(f\"names = (\\n{names}\\n)\")\n# ]]]\nnames = (\n    'backports',\n    'importlib_metadata',\n    'importlib_resources',\n    'jaraco',\n    'more_itertools',\n    'ordered_set',\n    'packaging',\n    'tomli',\n    'wheel',\n    'zipp',\n)\n# [[[end]]]\nVendorImporter(__name__, names, 'setuptools._vendor').install()\n", "setuptools/config/_apply_pyprojecttoml.py": "\"\"\"Translation layer between pyproject config and setuptools distribution and\nmetadata objects.\n\nThe distribution and metadata objects are modeled after (an old version of)\ncore metadata, therefore configs in the format specified for ``pyproject.toml``\nneed to be processed before being applied.\n\n**PRIVATE MODULE**: API reserved for setuptools internal usage only.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nfrom email.headerregistry import Address\nfrom functools import partial, reduce\nfrom inspect import cleandoc\nfrom itertools import chain\nfrom types import MappingProxyType\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Dict,\n    Mapping,\n    Union,\n)\nfrom .._path import StrPath\nfrom ..errors import RemovedConfigError\nfrom ..warnings import SetuptoolsWarning\n\nif TYPE_CHECKING:\n    from distutils.dist import _OptionsList\n    from setuptools._importlib import metadata  # noqa\n    from setuptools.dist import Distribution  # noqa\n\nEMPTY: Mapping = MappingProxyType({})  # Immutable dict-like\n_ProjectReadmeValue = Union[str, Dict[str, str]]\n_CorrespFn = Callable[[\"Distribution\", Any, StrPath], None]\n_Correspondence = Union[str, _CorrespFn]\n\n_logger = logging.getLogger(__name__)\n\n\ndef apply(dist: Distribution, config: dict, filename: StrPath) -> Distribution:\n    \"\"\"Apply configuration dict read with :func:`read_configuration`\"\"\"\n\n    if not config:\n        return dist  # short-circuit unrelated pyproject.toml file\n\n    root_dir = os.path.dirname(filename) or \".\"\n\n    _apply_project_table(dist, config, root_dir)\n    _apply_tool_table(dist, config, filename)\n\n    current_directory = os.getcwd()\n    os.chdir(root_dir)\n    try:\n        dist._finalize_requires()\n        dist._finalize_license_files()\n    finally:\n        os.chdir(current_directory)\n\n    return dist\n\n\ndef _apply_project_table(dist: Distribution, config: dict, root_dir: StrPath):\n    project_table = config.get(\"project\", {}).copy()\n    if not project_table:\n        return  # short-circuit\n\n    _handle_missing_dynamic(dist, project_table)\n    _unify_entry_points(project_table)\n\n    for field, value in project_table.items():\n        norm_key = json_compatible_key(field)\n        corresp = PYPROJECT_CORRESPONDENCE.get(norm_key, norm_key)\n        if callable(corresp):\n            corresp(dist, value, root_dir)\n        else:\n            _set_config(dist, corresp, value)\n\n\ndef _apply_tool_table(dist: Distribution, config: dict, filename: StrPath):\n    tool_table = config.get(\"tool\", {}).get(\"setuptools\", {})\n    if not tool_table:\n        return  # short-circuit\n\n    for field, value in tool_table.items():\n        norm_key = json_compatible_key(field)\n\n        if norm_key in TOOL_TABLE_REMOVALS:\n            suggestion = cleandoc(TOOL_TABLE_REMOVALS[norm_key])\n            msg = f\"\"\"\n            The parameter `tool.setuptools.{field}` was long deprecated\n            and has been removed from `pyproject.toml`.\n            \"\"\"\n            raise RemovedConfigError(\"\\n\".join([cleandoc(msg), suggestion]))\n\n        norm_key = TOOL_TABLE_RENAMES.get(norm_key, norm_key)\n        _set_config(dist, norm_key, value)\n\n    _copy_command_options(config, dist, filename)\n\n\ndef _handle_missing_dynamic(dist: Distribution, project_table: dict):\n    \"\"\"Be temporarily forgiving with ``dynamic`` fields not listed in ``dynamic``\"\"\"\n    dynamic = set(project_table.get(\"dynamic\", []))\n    for field, getter in _PREVIOUSLY_DEFINED.items():\n        if not (field in project_table or field in dynamic):\n            value = getter(dist)\n            if value:\n                _MissingDynamic.emit(field=field, value=value)\n                project_table[field] = _RESET_PREVIOUSLY_DEFINED.get(field)\n\n\ndef json_compatible_key(key: str) -> str:\n    \"\"\"As defined in :pep:`566#json-compatible-metadata`\"\"\"\n    return key.lower().replace(\"-\", \"_\")\n\n\ndef _set_config(dist: Distribution, field: str, value: Any):\n    setter = getattr(dist.metadata, f\"set_{field}\", None)\n    if setter:\n        setter(value)\n    elif hasattr(dist.metadata, field) or field in SETUPTOOLS_PATCHES:\n        setattr(dist.metadata, field, value)\n    else:\n        setattr(dist, field, value)\n\n\n_CONTENT_TYPES = {\n    \".md\": \"text/markdown\",\n    \".rst\": \"text/x-rst\",\n    \".txt\": \"text/plain\",\n}\n\n\ndef _guess_content_type(file: str) -> str | None:\n    _, ext = os.path.splitext(file.lower())\n    if not ext:\n        return None\n\n    if ext in _CONTENT_TYPES:\n        return _CONTENT_TYPES[ext]\n\n    valid = \", \".join(f\"{k} ({v})\" for k, v in _CONTENT_TYPES.items())\n    msg = f\"only the following file extensions are recognized: {valid}.\"\n    raise ValueError(f\"Undefined content type for {file}, {msg}\")\n\n\ndef _long_description(dist: Distribution, val: _ProjectReadmeValue, root_dir: StrPath):\n    from setuptools.config import expand\n\n    file: str | tuple[()]\n    if isinstance(val, str):\n        file = val\n        text = expand.read_files(file, root_dir)\n        ctype = _guess_content_type(file)\n    else:\n        file = val.get(\"file\") or ()\n        text = val.get(\"text\") or expand.read_files(file, root_dir)\n        ctype = val[\"content-type\"]\n\n    _set_config(dist, \"long_description\", text)\n\n    if ctype:\n        _set_config(dist, \"long_description_content_type\", ctype)\n\n    if file:\n        dist._referenced_files.add(file)\n\n\ndef _license(dist: Distribution, val: dict, root_dir: StrPath):\n    from setuptools.config import expand\n\n    if \"file\" in val:\n        _set_config(dist, \"license\", expand.read_files([val[\"file\"]], root_dir))\n        dist._referenced_files.add(val[\"file\"])\n    else:\n        _set_config(dist, \"license\", val[\"text\"])\n\n\ndef _people(dist: Distribution, val: list[dict], _root_dir: StrPath, kind: str):\n    field = []\n    email_field = []\n    for person in val:\n        if \"name\" not in person:\n            email_field.append(person[\"email\"])\n        elif \"email\" not in person:\n            field.append(person[\"name\"])\n        else:\n            addr = Address(display_name=person[\"name\"], addr_spec=person[\"email\"])\n            email_field.append(str(addr))\n\n    if field:\n        _set_config(dist, kind, \", \".join(field))\n    if email_field:\n        _set_config(dist, f\"{kind}_email\", \", \".join(email_field))\n\n\ndef _project_urls(dist: Distribution, val: dict, _root_dir):\n    _set_config(dist, \"project_urls\", val)\n\n\ndef _python_requires(dist: Distribution, val: dict, _root_dir):\n    from setuptools.extern.packaging.specifiers import SpecifierSet\n\n    _set_config(dist, \"python_requires\", SpecifierSet(val))\n\n\ndef _dependencies(dist: Distribution, val: list, _root_dir):\n    if getattr(dist, \"install_requires\", []):\n        msg = \"`install_requires` overwritten in `pyproject.toml` (dependencies)\"\n        SetuptoolsWarning.emit(msg)\n    dist.install_requires = val\n\n\ndef _optional_dependencies(dist: Distribution, val: dict, _root_dir):\n    existing = getattr(dist, \"extras_require\", None) or {}\n    dist.extras_require = {**existing, **val}\n\n\ndef _unify_entry_points(project_table: dict):\n    project = project_table\n    entry_points = project.pop(\"entry-points\", project.pop(\"entry_points\", {}))\n    renaming = {\"scripts\": \"console_scripts\", \"gui_scripts\": \"gui_scripts\"}\n    for key, value in list(project.items()):  # eager to allow modifications\n        norm_key = json_compatible_key(key)\n        if norm_key in renaming:\n            # Don't skip even if value is empty (reason: reset missing `dynamic`)\n            entry_points[renaming[norm_key]] = project.pop(key)\n\n    if entry_points:\n        project[\"entry-points\"] = {\n            name: [f\"{k} = {v}\" for k, v in group.items()]\n            for name, group in entry_points.items()\n            if group  # now we can skip empty groups\n        }\n        # Sometimes this will set `project[\"entry-points\"] = {}`, and that is\n        # intentional (for resetting configurations that are missing `dynamic`).\n\n\ndef _copy_command_options(pyproject: dict, dist: Distribution, filename: StrPath):\n    tool_table = pyproject.get(\"tool\", {})\n    cmdclass = tool_table.get(\"setuptools\", {}).get(\"cmdclass\", {})\n    valid_options = _valid_command_options(cmdclass)\n\n    cmd_opts = dist.command_options\n    for cmd, config in pyproject.get(\"tool\", {}).get(\"distutils\", {}).items():\n        cmd = json_compatible_key(cmd)\n        valid = valid_options.get(cmd, set())\n        cmd_opts.setdefault(cmd, {})\n        for key, value in config.items():\n            key = json_compatible_key(key)\n            cmd_opts[cmd][key] = (str(filename), value)\n            if key not in valid:\n                # To avoid removing options that are specified dynamically we\n                # just log a warn...\n                _logger.warning(f\"Command option {cmd}.{key} is not defined\")\n\n\ndef _valid_command_options(cmdclass: Mapping = EMPTY) -> dict[str, set[str]]:\n    from .._importlib import metadata\n    from setuptools.dist import Distribution\n\n    valid_options = {\"global\": _normalise_cmd_options(Distribution.global_options)}\n\n    unloaded_entry_points = metadata.entry_points(group='distutils.commands')\n    loaded_entry_points = (_load_ep(ep) for ep in unloaded_entry_points)\n    entry_points = (ep for ep in loaded_entry_points if ep)\n    for cmd, cmd_class in chain(entry_points, cmdclass.items()):\n        opts = valid_options.get(cmd, set())\n        opts = opts | _normalise_cmd_options(getattr(cmd_class, \"user_options\", []))\n        valid_options[cmd] = opts\n\n    return valid_options\n\n\ndef _load_ep(ep: metadata.EntryPoint) -> tuple[str, type] | None:\n    # Ignore all the errors\n    try:\n        return (ep.name, ep.load())\n    except Exception as ex:\n        msg = f\"{ex.__class__.__name__} while trying to load entry-point {ep.name}\"\n        _logger.warning(f\"{msg}: {ex}\")\n        return None\n\n\ndef _normalise_cmd_option_key(name: str) -> str:\n    return json_compatible_key(name).strip(\"_=\")\n\n\ndef _normalise_cmd_options(desc: _OptionsList) -> set[str]:\n    return {_normalise_cmd_option_key(fancy_option[0]) for fancy_option in desc}\n\n\ndef _get_previous_entrypoints(dist: Distribution) -> dict[str, list]:\n    ignore = (\"console_scripts\", \"gui_scripts\")\n    value = getattr(dist, \"entry_points\", None) or {}\n    return {k: v for k, v in value.items() if k not in ignore}\n\n\ndef _get_previous_scripts(dist: Distribution) -> list | None:\n    value = getattr(dist, \"entry_points\", None) or {}\n    return value.get(\"console_scripts\")\n\n\ndef _get_previous_gui_scripts(dist: Distribution) -> list | None:\n    value = getattr(dist, \"entry_points\", None) or {}\n    return value.get(\"gui_scripts\")\n\n\ndef _attrgetter(attr):\n    \"\"\"\n    Similar to ``operator.attrgetter`` but returns None if ``attr`` is not found\n    >>> from types import SimpleNamespace\n    >>> obj = SimpleNamespace(a=42, b=SimpleNamespace(c=13))\n    >>> _attrgetter(\"a\")(obj)\n    42\n    >>> _attrgetter(\"b.c\")(obj)\n    13\n    >>> _attrgetter(\"d\")(obj) is None\n    True\n    \"\"\"\n    return partial(reduce, lambda acc, x: getattr(acc, x, None), attr.split(\".\"))\n\n\ndef _some_attrgetter(*items):\n    \"\"\"\n    Return the first \"truth-y\" attribute or None\n    >>> from types import SimpleNamespace\n    >>> obj = SimpleNamespace(a=42, b=SimpleNamespace(c=13))\n    >>> _some_attrgetter(\"d\", \"a\", \"b.c\")(obj)\n    42\n    >>> _some_attrgetter(\"d\", \"e\", \"b.c\", \"a\")(obj)\n    13\n    >>> _some_attrgetter(\"d\", \"e\", \"f\")(obj) is None\n    True\n    \"\"\"\n\n    def _acessor(obj):\n        values = (_attrgetter(i)(obj) for i in items)\n        return next((i for i in values if i is not None), None)\n\n    return _acessor\n\n\nPYPROJECT_CORRESPONDENCE: dict[str, _Correspondence] = {\n    \"readme\": _long_description,\n    \"license\": _license,\n    \"authors\": partial(_people, kind=\"author\"),\n    \"maintainers\": partial(_people, kind=\"maintainer\"),\n    \"urls\": _project_urls,\n    \"dependencies\": _dependencies,\n    \"optional_dependencies\": _optional_dependencies,\n    \"requires_python\": _python_requires,\n}\n\nTOOL_TABLE_RENAMES = {\"script_files\": \"scripts\"}\nTOOL_TABLE_REMOVALS = {\n    \"namespace_packages\": \"\"\"\n        Please migrate to implicit native namespaces instead.\n        See https://packaging.python.org/en/latest/guides/packaging-namespace-packages/.\n        \"\"\",\n}\n\nSETUPTOOLS_PATCHES = {\n    \"long_description_content_type\",\n    \"project_urls\",\n    \"provides_extras\",\n    \"license_file\",\n    \"license_files\",\n}\n\n_PREVIOUSLY_DEFINED = {\n    \"name\": _attrgetter(\"metadata.name\"),\n    \"version\": _attrgetter(\"metadata.version\"),\n    \"description\": _attrgetter(\"metadata.description\"),\n    \"readme\": _attrgetter(\"metadata.long_description\"),\n    \"requires-python\": _some_attrgetter(\"python_requires\", \"metadata.python_requires\"),\n    \"license\": _attrgetter(\"metadata.license\"),\n    \"authors\": _some_attrgetter(\"metadata.author\", \"metadata.author_email\"),\n    \"maintainers\": _some_attrgetter(\"metadata.maintainer\", \"metadata.maintainer_email\"),\n    \"keywords\": _attrgetter(\"metadata.keywords\"),\n    \"classifiers\": _attrgetter(\"metadata.classifiers\"),\n    \"urls\": _attrgetter(\"metadata.project_urls\"),\n    \"entry-points\": _get_previous_entrypoints,\n    \"scripts\": _get_previous_scripts,\n    \"gui-scripts\": _get_previous_gui_scripts,\n    \"dependencies\": _attrgetter(\"install_requires\"),\n    \"optional-dependencies\": _attrgetter(\"extras_require\"),\n}\n\n\n_RESET_PREVIOUSLY_DEFINED: dict = {\n    # Fix improper setting: given in `setup.py`, but not listed in `dynamic`\n    # dict: pyproject name => value to which reset\n    \"license\": {},\n    \"authors\": [],\n    \"maintainers\": [],\n    \"keywords\": [],\n    \"classifiers\": [],\n    \"urls\": {},\n    \"entry-points\": {},\n    \"scripts\": {},\n    \"gui-scripts\": {},\n    \"dependencies\": [],\n    \"optional-dependencies\": {},\n}\n\n\nclass _MissingDynamic(SetuptoolsWarning):\n    _SUMMARY = \"`{field}` defined outside of `pyproject.toml` is ignored.\"\n\n    _DETAILS = \"\"\"\n    The following seems to be defined outside of `pyproject.toml`:\n\n    `{field} = {value!r}`\n\n    According to the spec (see the link below), however, setuptools CANNOT\n    consider this value unless `{field}` is listed as `dynamic`.\n\n    https://packaging.python.org/en/latest/specifications/pyproject-toml/#declaring-project-metadata-the-project-table\n\n    To prevent this problem, you can list `{field}` under `dynamic` or alternatively\n    remove the `[project]` table from your file and rely entirely on other means of\n    configuration.\n    \"\"\"\n    # TODO: Consider removing this check in the future?\n    #       There is a trade-off here between improving \"debug-ability\" and the cost\n    #       of running/testing/maintaining these unnecessary checks...\n\n    @classmethod\n    def details(cls, field: str, value: Any) -> str:\n        return cls._DETAILS.format(field=field, value=value)\n", "setuptools/config/pyprojecttoml.py": "\"\"\"\nLoad setuptools configuration from ``pyproject.toml`` files.\n\n**PRIVATE MODULE**: API reserved for setuptools internal usage only.\n\nTo read project metadata, consider using\n``build.util.project_wheel_metadata`` (https://pypi.org/project/build/).\nFor simple scenarios, you can also try parsing the file directly\nwith the help of ``tomllib`` or ``tomli``.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom functools import partial\nfrom typing import TYPE_CHECKING, Callable, Mapping\n\nfrom .._path import StrPath\nfrom ..errors import FileError, InvalidConfigError\nfrom ..warnings import SetuptoolsWarning\nfrom . import expand as _expand\nfrom ._apply_pyprojecttoml import _PREVIOUSLY_DEFINED, _MissingDynamic\nfrom ._apply_pyprojecttoml import apply as _apply\n\nif TYPE_CHECKING:\n    from setuptools.dist import Distribution  # noqa\n    from typing_extensions import Self\n\n_logger = logging.getLogger(__name__)\n\n\ndef load_file(filepath: StrPath) -> dict:\n    from ..compat.py310 import tomllib\n\n    with open(filepath, \"rb\") as file:\n        return tomllib.load(file)\n\n\ndef validate(config: dict, filepath: StrPath) -> bool:\n    from . import _validate_pyproject as validator\n\n    trove_classifier = validator.FORMAT_FUNCTIONS.get(\"trove-classifier\")\n    if hasattr(trove_classifier, \"_disable_download\"):\n        # Improve reproducibility by default. See issue 31 for validate-pyproject.\n        trove_classifier._disable_download()  # type: ignore\n\n    try:\n        return validator.validate(config)\n    except validator.ValidationError as ex:\n        summary = f\"configuration error: {ex.summary}\"\n        if ex.name.strip(\"`\") != \"project\":\n            # Probably it is just a field missing/misnamed, not worthy the verbosity...\n            _logger.debug(summary)\n            _logger.debug(ex.details)\n\n        error = f\"invalid pyproject.toml config: {ex.name}.\"\n        raise ValueError(f\"{error}\\n{summary}\") from None\n\n\ndef apply_configuration(\n    dist: Distribution,\n    filepath: StrPath,\n    ignore_option_errors=False,\n) -> Distribution:\n    \"\"\"Apply the configuration from a ``pyproject.toml`` file into an existing\n    distribution object.\n    \"\"\"\n    config = read_configuration(filepath, True, ignore_option_errors, dist)\n    return _apply(dist, config, filepath)\n\n\ndef read_configuration(\n    filepath: StrPath,\n    expand=True,\n    ignore_option_errors=False,\n    dist: Distribution | None = None,\n):\n    \"\"\"Read given configuration file and returns options from it as a dict.\n\n    :param str|unicode filepath: Path to configuration file in the ``pyproject.toml``\n        format.\n\n    :param bool expand: Whether to expand directives and other computed values\n        (i.e. post-process the given configuration)\n\n    :param bool ignore_option_errors: Whether to silently ignore\n        options, values of which could not be resolved (e.g. due to exceptions\n        in directives such as file:, attr:, etc.).\n        If False exceptions are propagated as expected.\n\n    :param Distribution|None: Distribution object to which the configuration refers.\n        If not given a dummy object will be created and discarded after the\n        configuration is read. This is used for auto-discovery of packages and in the\n        case a dynamic configuration (e.g. ``attr`` or ``cmdclass``) is expanded.\n        When ``expand=False`` this object is simply ignored.\n\n    :rtype: dict\n    \"\"\"\n    filepath = os.path.abspath(filepath)\n\n    if not os.path.isfile(filepath):\n        raise FileError(f\"Configuration file {filepath!r} does not exist.\")\n\n    asdict = load_file(filepath) or {}\n    project_table = asdict.get(\"project\", {})\n    tool_table = asdict.get(\"tool\", {})\n    setuptools_table = tool_table.get(\"setuptools\", {})\n    if not asdict or not (project_table or setuptools_table):\n        return {}  # User is not using pyproject to configure setuptools\n\n    if \"setuptools\" in asdict.get(\"tools\", {}):\n        # let the user know they probably have a typo in their metadata\n        _ToolsTypoInMetadata.emit()\n\n    if \"distutils\" in tool_table:\n        _ExperimentalConfiguration.emit(subject=\"[tool.distutils]\")\n\n    # There is an overall sense in the community that making include_package_data=True\n    # the default would be an improvement.\n    # `ini2toml` backfills include_package_data=False when nothing is explicitly given,\n    # therefore setting a default here is backwards compatible.\n    if dist and getattr(dist, \"include_package_data\", None) is not None:\n        setuptools_table.setdefault(\"include-package-data\", dist.include_package_data)\n    else:\n        setuptools_table.setdefault(\"include-package-data\", True)\n    # Persist changes:\n    asdict[\"tool\"] = tool_table\n    tool_table[\"setuptools\"] = setuptools_table\n\n    with _ignore_errors(ignore_option_errors):\n        # Don't complain about unrelated errors (e.g. tools not using the \"tool\" table)\n        subset = {\"project\": project_table, \"tool\": {\"setuptools\": setuptools_table}}\n        validate(subset, filepath)\n\n    if expand:\n        root_dir = os.path.dirname(filepath)\n        return expand_configuration(asdict, root_dir, ignore_option_errors, dist)\n\n    return asdict\n\n\ndef expand_configuration(\n    config: dict,\n    root_dir: StrPath | None = None,\n    ignore_option_errors: bool = False,\n    dist: Distribution | None = None,\n) -> dict:\n    \"\"\"Given a configuration with unresolved fields (e.g. dynamic, cmdclass, ...)\n    find their final values.\n\n    :param dict config: Dict containing the configuration for the distribution\n    :param str root_dir: Top-level directory for the distribution/project\n        (the same directory where ``pyproject.toml`` is place)\n    :param bool ignore_option_errors: see :func:`read_configuration`\n    :param Distribution|None: Distribution object to which the configuration refers.\n        If not given a dummy object will be created and discarded after the\n        configuration is read. Used in the case a dynamic configuration\n        (e.g. ``attr`` or ``cmdclass``).\n\n    :rtype: dict\n    \"\"\"\n    return _ConfigExpander(config, root_dir, ignore_option_errors, dist).expand()\n\n\nclass _ConfigExpander:\n    def __init__(\n        self,\n        config: dict,\n        root_dir: StrPath | None = None,\n        ignore_option_errors: bool = False,\n        dist: Distribution | None = None,\n    ):\n        self.config = config\n        self.root_dir = root_dir or os.getcwd()\n        self.project_cfg = config.get(\"project\", {})\n        self.dynamic = self.project_cfg.get(\"dynamic\", [])\n        self.setuptools_cfg = config.get(\"tool\", {}).get(\"setuptools\", {})\n        self.dynamic_cfg = self.setuptools_cfg.get(\"dynamic\", {})\n        self.ignore_option_errors = ignore_option_errors\n        self._dist = dist\n        self._referenced_files: set[str] = set()\n\n    def _ensure_dist(self) -> Distribution:\n        from setuptools.dist import Distribution\n\n        attrs = {\"src_root\": self.root_dir, \"name\": self.project_cfg.get(\"name\", None)}\n        return self._dist or Distribution(attrs)\n\n    def _process_field(self, container: dict, field: str, fn: Callable):\n        if field in container:\n            with _ignore_errors(self.ignore_option_errors):\n                container[field] = fn(container[field])\n\n    def _canonic_package_data(self, field=\"package-data\"):\n        package_data = self.setuptools_cfg.get(field, {})\n        return _expand.canonic_package_data(package_data)\n\n    def expand(self):\n        self._expand_packages()\n        self._canonic_package_data()\n        self._canonic_package_data(\"exclude-package-data\")\n\n        # A distribution object is required for discovering the correct package_dir\n        dist = self._ensure_dist()\n        ctx = _EnsurePackagesDiscovered(dist, self.project_cfg, self.setuptools_cfg)\n        with ctx as ensure_discovered:\n            package_dir = ensure_discovered.package_dir\n            self._expand_data_files()\n            self._expand_cmdclass(package_dir)\n            self._expand_all_dynamic(dist, package_dir)\n\n        dist._referenced_files.update(self._referenced_files)\n        return self.config\n\n    def _expand_packages(self):\n        packages = self.setuptools_cfg.get(\"packages\")\n        if packages is None or isinstance(packages, (list, tuple)):\n            return\n\n        find = packages.get(\"find\")\n        if isinstance(find, dict):\n            find[\"root_dir\"] = self.root_dir\n            find[\"fill_package_dir\"] = self.setuptools_cfg.setdefault(\"package-dir\", {})\n            with _ignore_errors(self.ignore_option_errors):\n                self.setuptools_cfg[\"packages\"] = _expand.find_packages(**find)\n\n    def _expand_data_files(self):\n        data_files = partial(_expand.canonic_data_files, root_dir=self.root_dir)\n        self._process_field(self.setuptools_cfg, \"data-files\", data_files)\n\n    def _expand_cmdclass(self, package_dir: Mapping[str, str]):\n        root_dir = self.root_dir\n        cmdclass = partial(_expand.cmdclass, package_dir=package_dir, root_dir=root_dir)\n        self._process_field(self.setuptools_cfg, \"cmdclass\", cmdclass)\n\n    def _expand_all_dynamic(self, dist: Distribution, package_dir: Mapping[str, str]):\n        special = (  # need special handling\n            \"version\",\n            \"readme\",\n            \"entry-points\",\n            \"scripts\",\n            \"gui-scripts\",\n            \"classifiers\",\n            \"dependencies\",\n            \"optional-dependencies\",\n        )\n        # `_obtain` functions are assumed to raise appropriate exceptions/warnings.\n        obtained_dynamic = {\n            field: self._obtain(dist, field, package_dir)\n            for field in self.dynamic\n            if field not in special\n        }\n        obtained_dynamic.update(\n            self._obtain_entry_points(dist, package_dir) or {},\n            version=self._obtain_version(dist, package_dir),\n            readme=self._obtain_readme(dist),\n            classifiers=self._obtain_classifiers(dist),\n            dependencies=self._obtain_dependencies(dist),\n            optional_dependencies=self._obtain_optional_dependencies(dist),\n        )\n        # `None` indicates there is nothing in `tool.setuptools.dynamic` but the value\n        # might have already been set by setup.py/extensions, so avoid overwriting.\n        updates = {k: v for k, v in obtained_dynamic.items() if v is not None}\n        self.project_cfg.update(updates)\n\n    def _ensure_previously_set(self, dist: Distribution, field: str):\n        previous = _PREVIOUSLY_DEFINED[field](dist)\n        if previous is None and not self.ignore_option_errors:\n            msg = (\n                f\"No configuration found for dynamic {field!r}.\\n\"\n                \"Some dynamic fields need to be specified via `tool.setuptools.dynamic`\"\n                \"\\nothers must be specified via the equivalent attribute in `setup.py`.\"\n            )\n            raise InvalidConfigError(msg)\n\n    def _expand_directive(\n        self, specifier: str, directive, package_dir: Mapping[str, str]\n    ):\n        from setuptools.extern.more_itertools import always_iterable\n\n        with _ignore_errors(self.ignore_option_errors):\n            root_dir = self.root_dir\n            if \"file\" in directive:\n                self._referenced_files.update(always_iterable(directive[\"file\"]))\n                return _expand.read_files(directive[\"file\"], root_dir)\n            if \"attr\" in directive:\n                return _expand.read_attr(directive[\"attr\"], package_dir, root_dir)\n            raise ValueError(f\"invalid `{specifier}`: {directive!r}\")\n        return None\n\n    def _obtain(self, dist: Distribution, field: str, package_dir: Mapping[str, str]):\n        if field in self.dynamic_cfg:\n            return self._expand_directive(\n                f\"tool.setuptools.dynamic.{field}\",\n                self.dynamic_cfg[field],\n                package_dir,\n            )\n        self._ensure_previously_set(dist, field)\n        return None\n\n    def _obtain_version(self, dist: Distribution, package_dir: Mapping[str, str]):\n        # Since plugins can set version, let's silently skip if it cannot be obtained\n        if \"version\" in self.dynamic and \"version\" in self.dynamic_cfg:\n            return _expand.version(self._obtain(dist, \"version\", package_dir))\n        return None\n\n    def _obtain_readme(self, dist: Distribution) -> dict[str, str] | None:\n        if \"readme\" not in self.dynamic:\n            return None\n\n        dynamic_cfg = self.dynamic_cfg\n        if \"readme\" in dynamic_cfg:\n            return {\n                \"text\": self._obtain(dist, \"readme\", {}),\n                \"content-type\": dynamic_cfg[\"readme\"].get(\"content-type\", \"text/x-rst\"),\n            }\n\n        self._ensure_previously_set(dist, \"readme\")\n        return None\n\n    def _obtain_entry_points(\n        self, dist: Distribution, package_dir: Mapping[str, str]\n    ) -> dict[str, dict] | None:\n        fields = (\"entry-points\", \"scripts\", \"gui-scripts\")\n        if not any(field in self.dynamic for field in fields):\n            return None\n\n        text = self._obtain(dist, \"entry-points\", package_dir)\n        if text is None:\n            return None\n\n        groups = _expand.entry_points(text)\n        expanded = {\"entry-points\": groups}\n\n        def _set_scripts(field: str, group: str):\n            if group in groups:\n                value = groups.pop(group)\n                if field not in self.dynamic:\n                    raise InvalidConfigError(_MissingDynamic.details(field, value))\n                expanded[field] = value\n\n        _set_scripts(\"scripts\", \"console_scripts\")\n        _set_scripts(\"gui-scripts\", \"gui_scripts\")\n\n        return expanded\n\n    def _obtain_classifiers(self, dist: Distribution):\n        if \"classifiers\" in self.dynamic:\n            value = self._obtain(dist, \"classifiers\", {})\n            if value:\n                return value.splitlines()\n        return None\n\n    def _obtain_dependencies(self, dist: Distribution):\n        if \"dependencies\" in self.dynamic:\n            value = self._obtain(dist, \"dependencies\", {})\n            if value:\n                return _parse_requirements_list(value)\n        return None\n\n    def _obtain_optional_dependencies(self, dist: Distribution):\n        if \"optional-dependencies\" not in self.dynamic:\n            return None\n        if \"optional-dependencies\" in self.dynamic_cfg:\n            optional_dependencies_map = self.dynamic_cfg[\"optional-dependencies\"]\n            assert isinstance(optional_dependencies_map, dict)\n            return {\n                group: _parse_requirements_list(\n                    self._expand_directive(\n                        f\"tool.setuptools.dynamic.optional-dependencies.{group}\",\n                        directive,\n                        {},\n                    )\n                )\n                for group, directive in optional_dependencies_map.items()\n            }\n        self._ensure_previously_set(dist, \"optional-dependencies\")\n        return None\n\n\ndef _parse_requirements_list(value):\n    return [\n        line\n        for line in value.splitlines()\n        if line.strip() and not line.strip().startswith(\"#\")\n    ]\n\n\n@contextmanager\ndef _ignore_errors(ignore_option_errors: bool):\n    if not ignore_option_errors:\n        yield\n        return\n\n    try:\n        yield\n    except Exception as ex:\n        _logger.debug(f\"ignored error: {ex.__class__.__name__} - {ex}\")\n\n\nclass _EnsurePackagesDiscovered(_expand.EnsurePackagesDiscovered):\n    def __init__(\n        self, distribution: Distribution, project_cfg: dict, setuptools_cfg: dict\n    ):\n        super().__init__(distribution)\n        self._project_cfg = project_cfg\n        self._setuptools_cfg = setuptools_cfg\n\n    def __enter__(self) -> Self:\n        \"\"\"When entering the context, the values of ``packages``, ``py_modules`` and\n        ``package_dir`` that are missing in ``dist`` are copied from ``setuptools_cfg``.\n        \"\"\"\n        dist, cfg = self._dist, self._setuptools_cfg\n        package_dir: dict[str, str] = cfg.setdefault(\"package-dir\", {})\n        package_dir.update(dist.package_dir or {})\n        dist.package_dir = package_dir  # needs to be the same object\n\n        dist.set_defaults._ignore_ext_modules()  # pyproject.toml-specific behaviour\n\n        # Set `name`, `py_modules` and `packages` in dist to short-circuit\n        # auto-discovery, but avoid overwriting empty lists purposefully set by users.\n        if dist.metadata.name is None:\n            dist.metadata.name = self._project_cfg.get(\"name\")\n        if dist.py_modules is None:\n            dist.py_modules = cfg.get(\"py-modules\")\n        if dist.packages is None:\n            dist.packages = cfg.get(\"packages\")\n\n        return super().__enter__()\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"When exiting the context, if values of ``packages``, ``py_modules`` and\n        ``package_dir`` are missing in ``setuptools_cfg``, copy from ``dist``.\n        \"\"\"\n        # If anything was discovered set them back, so they count in the final config.\n        self._setuptools_cfg.setdefault(\"packages\", self._dist.packages)\n        self._setuptools_cfg.setdefault(\"py-modules\", self._dist.py_modules)\n        return super().__exit__(exc_type, exc_value, traceback)\n\n\nclass _ExperimentalConfiguration(SetuptoolsWarning):\n    _SUMMARY = (\n        \"`{subject}` in `pyproject.toml` is still *experimental* \"\n        \"and likely to change in future releases.\"\n    )\n\n\nclass _ToolsTypoInMetadata(SetuptoolsWarning):\n    _SUMMARY = (\n        \"Ignoring [tools.setuptools] in pyproject.toml, did you mean [tool.setuptools]?\"\n    )\n", "setuptools/config/setupcfg.py": "\"\"\"\nLoad setuptools configuration from ``setup.cfg`` files.\n\n**API will be made private in the future**\n\nTo read project metadata, consider using\n``build.util.project_wheel_metadata`` (https://pypi.org/project/build/).\nFor simple scenarios, you can also try parsing the file directly\nwith the help of ``configparser``.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport contextlib\nimport functools\nimport os\nfrom collections import defaultdict\nfrom functools import partial\nfrom functools import wraps\nfrom typing import (\n    TYPE_CHECKING,\n    Callable,\n    Any,\n    Dict,\n    Generic,\n    Iterable,\n    Tuple,\n    TypeVar,\n    Union,\n)\n\nfrom .._path import StrPath\nfrom ..errors import FileError, OptionError\nfrom ..extern.packaging.markers import default_environment as marker_env\nfrom ..extern.packaging.requirements import InvalidRequirement, Requirement\nfrom ..extern.packaging.specifiers import SpecifierSet\nfrom ..extern.packaging.version import InvalidVersion, Version\nfrom ..warnings import SetuptoolsDeprecationWarning\nfrom . import expand\n\nif TYPE_CHECKING:\n    from distutils.dist import DistributionMetadata  # noqa\n\n    from setuptools.dist import Distribution  # noqa\n\nSingleCommandOptions = Dict[\"str\", Tuple[\"str\", Any]]\n\"\"\"Dict that associate the name of the options of a particular command to a\ntuple. The first element of the tuple indicates the origin of the option value\n(e.g. the name of the configuration file where it was read from),\nwhile the second element of the tuple is the option value itself\n\"\"\"\nAllCommandOptions = Dict[\"str\", SingleCommandOptions]  # cmd name => its options\nTarget = TypeVar(\"Target\", bound=Union[\"Distribution\", \"DistributionMetadata\"])\n\n\ndef read_configuration(\n    filepath: StrPath, find_others=False, ignore_option_errors=False\n) -> dict:\n    \"\"\"Read given configuration file and returns options from it as a dict.\n\n    :param str|unicode filepath: Path to configuration file\n        to get options from.\n\n    :param bool find_others: Whether to search for other configuration files\n        which could be on in various places.\n\n    :param bool ignore_option_errors: Whether to silently ignore\n        options, values of which could not be resolved (e.g. due to exceptions\n        in directives such as file:, attr:, etc.).\n        If False exceptions are propagated as expected.\n\n    :rtype: dict\n    \"\"\"\n    from setuptools.dist import Distribution\n\n    dist = Distribution()\n    filenames = dist.find_config_files() if find_others else []\n    handlers = _apply(dist, filepath, filenames, ignore_option_errors)\n    return configuration_to_dict(handlers)\n\n\ndef apply_configuration(dist: Distribution, filepath: StrPath) -> Distribution:\n    \"\"\"Apply the configuration from a ``setup.cfg`` file into an existing\n    distribution object.\n    \"\"\"\n    _apply(dist, filepath)\n    dist._finalize_requires()\n    return dist\n\n\ndef _apply(\n    dist: Distribution,\n    filepath: StrPath,\n    other_files: Iterable[StrPath] = (),\n    ignore_option_errors: bool = False,\n) -> tuple[ConfigHandler, ...]:\n    \"\"\"Read configuration from ``filepath`` and applies to the ``dist`` object.\"\"\"\n    from setuptools.dist import _Distribution\n\n    filepath = os.path.abspath(filepath)\n\n    if not os.path.isfile(filepath):\n        raise FileError(f'Configuration file {filepath} does not exist.')\n\n    current_directory = os.getcwd()\n    os.chdir(os.path.dirname(filepath))\n    filenames = [*other_files, filepath]\n\n    try:\n        _Distribution.parse_config_files(dist, filenames=filenames)  # type: ignore[arg-type] # TODO: fix in distutils stubs\n        handlers = parse_configuration(\n            dist, dist.command_options, ignore_option_errors=ignore_option_errors\n        )\n        dist._finalize_license_files()\n    finally:\n        os.chdir(current_directory)\n\n    return handlers\n\n\ndef _get_option(target_obj: Target, key: str):\n    \"\"\"\n    Given a target object and option key, get that option from\n    the target object, either through a get_{key} method or\n    from an attribute directly.\n    \"\"\"\n    getter_name = f'get_{key}'\n    by_attribute = functools.partial(getattr, target_obj, key)\n    getter = getattr(target_obj, getter_name, by_attribute)\n    return getter()\n\n\ndef configuration_to_dict(handlers: tuple[ConfigHandler, ...]) -> dict:\n    \"\"\"Returns configuration data gathered by given handlers as a dict.\n\n    :param list[ConfigHandler] handlers: Handlers list,\n        usually from parse_configuration()\n\n    :rtype: dict\n    \"\"\"\n    config_dict: dict = defaultdict(dict)\n\n    for handler in handlers:\n        for option in handler.set_options:\n            value = _get_option(handler.target_obj, option)\n            config_dict[handler.section_prefix][option] = value\n\n    return config_dict\n\n\ndef parse_configuration(\n    distribution: Distribution,\n    command_options: AllCommandOptions,\n    ignore_option_errors=False,\n) -> tuple[ConfigMetadataHandler, ConfigOptionsHandler]:\n    \"\"\"Performs additional parsing of configuration options\n    for a distribution.\n\n    Returns a list of used option handlers.\n\n    :param Distribution distribution:\n    :param dict command_options:\n    :param bool ignore_option_errors: Whether to silently ignore\n        options, values of which could not be resolved (e.g. due to exceptions\n        in directives such as file:, attr:, etc.).\n        If False exceptions are propagated as expected.\n    :rtype: list\n    \"\"\"\n    with expand.EnsurePackagesDiscovered(distribution) as ensure_discovered:\n        options = ConfigOptionsHandler(\n            distribution,\n            command_options,\n            ignore_option_errors,\n            ensure_discovered,\n        )\n\n        options.parse()\n        if not distribution.package_dir:\n            distribution.package_dir = options.package_dir  # Filled by `find_packages`\n\n        meta = ConfigMetadataHandler(\n            distribution.metadata,\n            command_options,\n            ignore_option_errors,\n            ensure_discovered,\n            distribution.package_dir,\n            distribution.src_root,\n        )\n        meta.parse()\n        distribution._referenced_files.update(\n            options._referenced_files, meta._referenced_files\n        )\n\n    return meta, options\n\n\ndef _warn_accidental_env_marker_misconfig(label: str, orig_value: str, parsed: list):\n    \"\"\"Because users sometimes misinterpret this configuration:\n\n    [options.extras_require]\n    foo = bar;python_version<\"4\"\n\n    It looks like one requirement with an environment marker\n    but because there is no newline, it's parsed as two requirements\n    with a semicolon as separator.\n\n    Therefore, if:\n        * input string does not contain a newline AND\n        * parsed result contains two requirements AND\n        * parsing of the two parts from the result (\"<first>;<second>\")\n        leads in a valid Requirement with a valid marker\n    a UserWarning is shown to inform the user about the possible problem.\n    \"\"\"\n    if \"\\n\" in orig_value or len(parsed) != 2:\n        return\n\n    markers = marker_env().keys()\n\n    try:\n        req = Requirement(parsed[1])\n        if req.name in markers:\n            _AmbiguousMarker.emit(field=label, req=parsed[1])\n    except InvalidRequirement as ex:\n        if any(parsed[1].startswith(marker) for marker in markers):\n            msg = _AmbiguousMarker.message(field=label, req=parsed[1])\n            raise InvalidRequirement(msg) from ex\n\n\nclass ConfigHandler(Generic[Target]):\n    \"\"\"Handles metadata supplied in configuration files.\"\"\"\n\n    section_prefix: str\n    \"\"\"Prefix for config sections handled by this handler.\n    Must be provided by class heirs.\n\n    \"\"\"\n\n    aliases: dict[str, str] = {}\n    \"\"\"Options aliases.\n    For compatibility with various packages. E.g.: d2to1 and pbr.\n    Note: `-` in keys is replaced with `_` by config parser.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        target_obj: Target,\n        options: AllCommandOptions,\n        ignore_option_errors,\n        ensure_discovered: expand.EnsurePackagesDiscovered,\n    ):\n        self.ignore_option_errors = ignore_option_errors\n        self.target_obj = target_obj\n        self.sections = dict(self._section_options(options))\n        self.set_options: list[str] = []\n        self.ensure_discovered = ensure_discovered\n        self._referenced_files: set[str] = set()\n        \"\"\"After parsing configurations, this property will enumerate\n        all files referenced by the \"file:\" directive. Private API for setuptools only.\n        \"\"\"\n\n    @classmethod\n    def _section_options(cls, options: AllCommandOptions):\n        for full_name, value in options.items():\n            pre, sep, name = full_name.partition(cls.section_prefix)\n            if pre:\n                continue\n            yield name.lstrip('.'), value\n\n    @property\n    def parsers(self):\n        \"\"\"Metadata item name to parser function mapping.\"\"\"\n        raise NotImplementedError(\n            '%s must provide .parsers property' % self.__class__.__name__\n        )\n\n    def __setitem__(self, option_name, value):\n        target_obj = self.target_obj\n\n        # Translate alias into real name.\n        option_name = self.aliases.get(option_name, option_name)\n\n        try:\n            current_value = getattr(target_obj, option_name)\n        except AttributeError as e:\n            raise KeyError(option_name) from e\n\n        if current_value:\n            # Already inhabited. Skipping.\n            return\n\n        try:\n            parsed = self.parsers.get(option_name, lambda x: x)(value)\n        except (Exception,) * self.ignore_option_errors:\n            return\n\n        simple_setter = functools.partial(target_obj.__setattr__, option_name)\n        setter = getattr(target_obj, 'set_%s' % option_name, simple_setter)\n        setter(parsed)\n\n        self.set_options.append(option_name)\n\n    @classmethod\n    def _parse_list(cls, value, separator=','):\n        \"\"\"Represents value as a list.\n\n        Value is split either by separator (defaults to comma) or by lines.\n\n        :param value:\n        :param separator: List items separator character.\n        :rtype: list\n        \"\"\"\n        if isinstance(value, list):  # _get_parser_compound case\n            return value\n\n        if '\\n' in value:\n            value = value.splitlines()\n        else:\n            value = value.split(separator)\n\n        return [chunk.strip() for chunk in value if chunk.strip()]\n\n    @classmethod\n    def _parse_dict(cls, value):\n        \"\"\"Represents value as a dict.\n\n        :param value:\n        :rtype: dict\n        \"\"\"\n        separator = '='\n        result = {}\n        for line in cls._parse_list(value):\n            key, sep, val = line.partition(separator)\n            if sep != separator:\n                raise OptionError(f\"Unable to parse option value to dict: {value}\")\n            result[key.strip()] = val.strip()\n\n        return result\n\n    @classmethod\n    def _parse_bool(cls, value):\n        \"\"\"Represents value as boolean.\n\n        :param value:\n        :rtype: bool\n        \"\"\"\n        value = value.lower()\n        return value in ('1', 'true', 'yes')\n\n    @classmethod\n    def _exclude_files_parser(cls, key):\n        \"\"\"Returns a parser function to make sure field inputs\n        are not files.\n\n        Parses a value after getting the key so error messages are\n        more informative.\n\n        :param key:\n        :rtype: callable\n        \"\"\"\n\n        def parser(value):\n            exclude_directive = 'file:'\n            if value.startswith(exclude_directive):\n                raise ValueError(\n                    'Only strings are accepted for the {0} field, '\n                    'files are not accepted'.format(key)\n                )\n            return value\n\n        return parser\n\n    def _parse_file(self, value, root_dir: StrPath):\n        \"\"\"Represents value as a string, allowing including text\n        from nearest files using `file:` directive.\n\n        Directive is sandboxed and won't reach anything outside\n        directory with setup.py.\n\n        Examples:\n            file: README.rst, CHANGELOG.md, src/file.txt\n\n        :param str value:\n        :rtype: str\n        \"\"\"\n        include_directive = 'file:'\n\n        if not isinstance(value, str):\n            return value\n\n        if not value.startswith(include_directive):\n            return value\n\n        spec = value[len(include_directive) :]\n        filepaths = [path.strip() for path in spec.split(',')]\n        self._referenced_files.update(filepaths)\n        return expand.read_files(filepaths, root_dir)\n\n    def _parse_attr(self, value, package_dir, root_dir: StrPath):\n        \"\"\"Represents value as a module attribute.\n\n        Examples:\n            attr: package.attr\n            attr: package.module.attr\n\n        :param str value:\n        :rtype: str\n        \"\"\"\n        attr_directive = 'attr:'\n        if not value.startswith(attr_directive):\n            return value\n\n        attr_desc = value.replace(attr_directive, '')\n\n        # Make sure package_dir is populated correctly, so `attr:` directives can work\n        package_dir.update(self.ensure_discovered.package_dir)\n        return expand.read_attr(attr_desc, package_dir, root_dir)\n\n    @classmethod\n    def _get_parser_compound(cls, *parse_methods):\n        \"\"\"Returns parser function to represents value as a list.\n\n        Parses a value applying given methods one after another.\n\n        :param parse_methods:\n        :rtype: callable\n        \"\"\"\n\n        def parse(value):\n            parsed = value\n\n            for method in parse_methods:\n                parsed = method(parsed)\n\n            return parsed\n\n        return parse\n\n    @classmethod\n    def _parse_section_to_dict_with_key(cls, section_options, values_parser):\n        \"\"\"Parses section options into a dictionary.\n\n        Applies a given parser to each option in a section.\n\n        :param dict section_options:\n        :param callable values_parser: function with 2 args corresponding to key, value\n        :rtype: dict\n        \"\"\"\n        value = {}\n        for key, (_, val) in section_options.items():\n            value[key] = values_parser(key, val)\n        return value\n\n    @classmethod\n    def _parse_section_to_dict(cls, section_options, values_parser=None):\n        \"\"\"Parses section options into a dictionary.\n\n        Optionally applies a given parser to each value.\n\n        :param dict section_options:\n        :param callable values_parser: function with 1 arg corresponding to option value\n        :rtype: dict\n        \"\"\"\n        parser = (lambda _, v: values_parser(v)) if values_parser else (lambda _, v: v)\n        return cls._parse_section_to_dict_with_key(section_options, parser)\n\n    def parse_section(self, section_options):\n        \"\"\"Parses configuration file section.\n\n        :param dict section_options:\n        \"\"\"\n        for name, (_, value) in section_options.items():\n            with contextlib.suppress(KeyError):\n                # Keep silent for a new option may appear anytime.\n                self[name] = value\n\n    def parse(self) -> None:\n        \"\"\"Parses configuration file items from one\n        or more related sections.\n\n        \"\"\"\n        for section_name, section_options in self.sections.items():\n            method_postfix = ''\n            if section_name:  # [section.option] variant\n                method_postfix = '_%s' % section_name\n\n            section_parser_method: Callable | None = getattr(\n                self,\n                # Dots in section names are translated into dunderscores.\n                ('parse_section%s' % method_postfix).replace('.', '__'),\n                None,\n            )\n\n            if section_parser_method is None:\n                raise OptionError(\n                    \"Unsupported distribution option section: \"\n                    f\"[{self.section_prefix}.{section_name}]\"\n                )\n\n            section_parser_method(section_options)\n\n    def _deprecated_config_handler(self, func, msg, **kw):\n        \"\"\"this function will wrap around parameters that are deprecated\n\n        :param msg: deprecation message\n        :param func: function to be wrapped around\n        \"\"\"\n\n        @wraps(func)\n        def config_handler(*args, **kwargs):\n            kw.setdefault(\"stacklevel\", 2)\n            _DeprecatedConfig.emit(\"Deprecated config in `setup.cfg`\", msg, **kw)\n            return func(*args, **kwargs)\n\n        return config_handler\n\n\nclass ConfigMetadataHandler(ConfigHandler[\"DistributionMetadata\"]):\n    section_prefix = 'metadata'\n\n    aliases = {\n        'home_page': 'url',\n        'summary': 'description',\n        'classifier': 'classifiers',\n        'platform': 'platforms',\n    }\n\n    strict_mode = False\n    \"\"\"We need to keep it loose, to be partially compatible with\n    `pbr` and `d2to1` packages which also uses `metadata` section.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        target_obj: DistributionMetadata,\n        options: AllCommandOptions,\n        ignore_option_errors: bool,\n        ensure_discovered: expand.EnsurePackagesDiscovered,\n        package_dir: dict | None = None,\n        root_dir: StrPath = os.curdir,\n    ):\n        super().__init__(target_obj, options, ignore_option_errors, ensure_discovered)\n        self.package_dir = package_dir\n        self.root_dir = root_dir\n\n    @property\n    def parsers(self):\n        \"\"\"Metadata item name to parser function mapping.\"\"\"\n        parse_list = self._parse_list\n        parse_file = partial(self._parse_file, root_dir=self.root_dir)\n        parse_dict = self._parse_dict\n        exclude_files_parser = self._exclude_files_parser\n\n        return {\n            'platforms': parse_list,\n            'keywords': parse_list,\n            'provides': parse_list,\n            'obsoletes': parse_list,\n            'classifiers': self._get_parser_compound(parse_file, parse_list),\n            'license': exclude_files_parser('license'),\n            'license_files': parse_list,\n            'description': parse_file,\n            'long_description': parse_file,\n            'version': self._parse_version,\n            'project_urls': parse_dict,\n        }\n\n    def _parse_version(self, value):\n        \"\"\"Parses `version` option value.\n\n        :param value:\n        :rtype: str\n\n        \"\"\"\n        version = self._parse_file(value, self.root_dir)\n\n        if version != value:\n            version = version.strip()\n            # Be strict about versions loaded from file because it's easy to\n            # accidentally include newlines and other unintended content\n            try:\n                Version(version)\n            except InvalidVersion as e:\n                raise OptionError(\n                    f'Version loaded from {value} does not '\n                    f'comply with PEP 440: {version}'\n                ) from e\n\n            return version\n\n        return expand.version(self._parse_attr(value, self.package_dir, self.root_dir))\n\n\nclass ConfigOptionsHandler(ConfigHandler[\"Distribution\"]):\n    section_prefix = 'options'\n\n    def __init__(\n        self,\n        target_obj: Distribution,\n        options: AllCommandOptions,\n        ignore_option_errors: bool,\n        ensure_discovered: expand.EnsurePackagesDiscovered,\n    ):\n        super().__init__(target_obj, options, ignore_option_errors, ensure_discovered)\n        self.root_dir = target_obj.src_root\n        self.package_dir: dict[str, str] = {}  # To be filled by `find_packages`\n\n    @classmethod\n    def _parse_list_semicolon(cls, value):\n        return cls._parse_list(value, separator=';')\n\n    def _parse_file_in_root(self, value):\n        return self._parse_file(value, root_dir=self.root_dir)\n\n    def _parse_requirements_list(self, label: str, value: str):\n        # Parse a requirements list, either by reading in a `file:`, or a list.\n        parsed = self._parse_list_semicolon(self._parse_file_in_root(value))\n        _warn_accidental_env_marker_misconfig(label, value, parsed)\n        # Filter it to only include lines that are not comments. `parse_list`\n        # will have stripped each line and filtered out empties.\n        return [line for line in parsed if not line.startswith(\"#\")]\n\n    @property\n    def parsers(self):\n        \"\"\"Metadata item name to parser function mapping.\"\"\"\n        parse_list = self._parse_list\n        parse_bool = self._parse_bool\n        parse_dict = self._parse_dict\n        parse_cmdclass = self._parse_cmdclass\n\n        return {\n            'zip_safe': parse_bool,\n            'include_package_data': parse_bool,\n            'package_dir': parse_dict,\n            'scripts': parse_list,\n            'eager_resources': parse_list,\n            'dependency_links': parse_list,\n            'namespace_packages': self._deprecated_config_handler(\n                parse_list,\n                \"The namespace_packages parameter is deprecated, \"\n                \"consider using implicit namespaces instead (PEP 420).\",\n                # TODO: define due date, see setuptools.dist:check_nsp.\n            ),\n            'install_requires': partial(\n                self._parse_requirements_list, \"install_requires\"\n            ),\n            'setup_requires': self._parse_list_semicolon,\n            'tests_require': self._parse_list_semicolon,\n            'packages': self._parse_packages,\n            'entry_points': self._parse_file_in_root,\n            'py_modules': parse_list,\n            'python_requires': SpecifierSet,\n            'cmdclass': parse_cmdclass,\n        }\n\n    def _parse_cmdclass(self, value):\n        package_dir = self.ensure_discovered.package_dir\n        return expand.cmdclass(self._parse_dict(value), package_dir, self.root_dir)\n\n    def _parse_packages(self, value):\n        \"\"\"Parses `packages` option value.\n\n        :param value:\n        :rtype: list\n        \"\"\"\n        find_directives = ['find:', 'find_namespace:']\n        trimmed_value = value.strip()\n\n        if trimmed_value not in find_directives:\n            return self._parse_list(value)\n\n        # Read function arguments from a dedicated section.\n        find_kwargs = self.parse_section_packages__find(\n            self.sections.get('packages.find', {})\n        )\n\n        find_kwargs.update(\n            namespaces=(trimmed_value == find_directives[1]),\n            root_dir=self.root_dir,\n            fill_package_dir=self.package_dir,\n        )\n\n        return expand.find_packages(**find_kwargs)\n\n    def parse_section_packages__find(self, section_options):\n        \"\"\"Parses `packages.find` configuration file section.\n\n        To be used in conjunction with _parse_packages().\n\n        :param dict section_options:\n        \"\"\"\n        section_data = self._parse_section_to_dict(section_options, self._parse_list)\n\n        valid_keys = ['where', 'include', 'exclude']\n\n        find_kwargs = dict([\n            (k, v) for k, v in section_data.items() if k in valid_keys and v\n        ])\n\n        where = find_kwargs.get('where')\n        if where is not None:\n            find_kwargs['where'] = where[0]  # cast list to single val\n\n        return find_kwargs\n\n    def parse_section_entry_points(self, section_options):\n        \"\"\"Parses `entry_points` configuration file section.\n\n        :param dict section_options:\n        \"\"\"\n        parsed = self._parse_section_to_dict(section_options, self._parse_list)\n        self['entry_points'] = parsed\n\n    def _parse_package_data(self, section_options):\n        package_data = self._parse_section_to_dict(section_options, self._parse_list)\n        return expand.canonic_package_data(package_data)\n\n    def parse_section_package_data(self, section_options):\n        \"\"\"Parses `package_data` configuration file section.\n\n        :param dict section_options:\n        \"\"\"\n        self['package_data'] = self._parse_package_data(section_options)\n\n    def parse_section_exclude_package_data(self, section_options):\n        \"\"\"Parses `exclude_package_data` configuration file section.\n\n        :param dict section_options:\n        \"\"\"\n        self['exclude_package_data'] = self._parse_package_data(section_options)\n\n    def parse_section_extras_require(self, section_options):\n        \"\"\"Parses `extras_require` configuration file section.\n\n        :param dict section_options:\n        \"\"\"\n        parsed = self._parse_section_to_dict_with_key(\n            section_options,\n            lambda k, v: self._parse_requirements_list(f\"extras_require[{k}]\", v),\n        )\n\n        self['extras_require'] = parsed\n\n    def parse_section_data_files(self, section_options):\n        \"\"\"Parses `data_files` configuration file section.\n\n        :param dict section_options:\n        \"\"\"\n        parsed = self._parse_section_to_dict(section_options, self._parse_list)\n        self['data_files'] = expand.canonic_data_files(parsed, self.root_dir)\n\n\nclass _AmbiguousMarker(SetuptoolsDeprecationWarning):\n    _SUMMARY = \"Ambiguous requirement marker.\"\n    _DETAILS = \"\"\"\n    One of the parsed requirements in `{field}` looks like a valid environment marker:\n\n        {req!r}\n\n    Please make sure that the configuration file is correct.\n    You can use dangling lines to avoid this problem.\n    \"\"\"\n    _SEE_DOCS = \"userguide/declarative_config.html#opt-2\"\n    # TODO: should we include due_date here? Initially introduced in 6 Aug 2022.\n    # Does this make sense with latest version of packaging?\n\n    @classmethod\n    def message(cls, **kw):\n        docs = f\"https://setuptools.pypa.io/en/latest/{cls._SEE_DOCS}\"\n        return cls._format(cls._SUMMARY, cls._DETAILS, see_url=docs, format_args=kw)\n\n\nclass _DeprecatedConfig(SetuptoolsDeprecationWarning):\n    _SEE_DOCS = \"userguide/declarative_config.html\"\n", "setuptools/config/__init__.py": "\"\"\"For backward compatibility, expose main functions from\n``setuptools.config.setupcfg``\n\"\"\"\n\nfrom functools import wraps\nfrom typing import Callable, TypeVar, cast\n\nfrom ..warnings import SetuptoolsDeprecationWarning\nfrom . import setupcfg\n\nFn = TypeVar(\"Fn\", bound=Callable)\n\n__all__ = ('parse_configuration', 'read_configuration')\n\n\ndef _deprecation_notice(fn: Fn) -> Fn:\n    @wraps(fn)\n    def _wrapper(*args, **kwargs):\n        SetuptoolsDeprecationWarning.emit(\n            \"Deprecated API usage.\",\n            f\"\"\"\n            As setuptools moves its configuration towards `pyproject.toml`,\n            `{__name__}.{fn.__name__}` became deprecated.\n\n            For the time being, you can use the `{setupcfg.__name__}` module\n            to access a backward compatible API, but this module is provisional\n            and might be removed in the future.\n\n            To read project metadata, consider using\n            ``build.util.project_wheel_metadata`` (https://pypi.org/project/build/).\n            For simple scenarios, you can also try parsing the file directly\n            with the help of ``configparser``.\n            \"\"\",\n            # due_date not defined yet, because the community still heavily relies on it\n            # Warning introduced in 24 Mar 2022\n        )\n        return fn(*args, **kwargs)\n\n    return cast(Fn, _wrapper)\n\n\nread_configuration = _deprecation_notice(setupcfg.read_configuration)\nparse_configuration = _deprecation_notice(setupcfg.parse_configuration)\n", "setuptools/config/expand.py": "\"\"\"Utility functions to expand configuration directives or special values\n(such glob patterns).\n\nWe can split the process of interpreting configuration files into 2 steps:\n\n1. The parsing the file contents from strings to value objects\n   that can be understand by Python (for example a string with a comma\n   separated list of keywords into an actual Python list of strings).\n\n2. The expansion (or post-processing) of these values according to the\n   semantics ``setuptools`` assign to them (for example a configuration field\n   with the ``file:`` directive should be expanded from a list of file paths to\n   a single string with the contents of those files concatenated)\n\nThis module focus on the second step, and therefore allow sharing the expansion\nfunctions among several configuration file formats.\n\n**PRIVATE MODULE**: API reserved for setuptools internal usage only.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nimport importlib\nimport os\nimport pathlib\nimport sys\nfrom glob import iglob\nfrom configparser import ConfigParser\nfrom importlib.machinery import ModuleSpec, all_suffixes\nfrom itertools import chain\nfrom typing import (\n    TYPE_CHECKING,\n    Callable,\n    Iterable,\n    Iterator,\n    Mapping,\n    TypeVar,\n)\nfrom pathlib import Path\nfrom types import ModuleType\n\nfrom distutils.errors import DistutilsOptionError\n\nfrom .._path import same_path as _same_path, StrPath\nfrom ..discovery import find_package_path\nfrom ..warnings import SetuptoolsWarning\n\nif TYPE_CHECKING:\n    from setuptools.dist import Distribution  # noqa\n\n_K = TypeVar(\"_K\")\n_V = TypeVar(\"_V\", covariant=True)\n\n\nclass StaticModule:\n    \"\"\"Proxy to a module object that avoids executing arbitrary code.\"\"\"\n\n    def __init__(self, name: str, spec: ModuleSpec):\n        module = ast.parse(pathlib.Path(spec.origin).read_bytes())  # type: ignore[arg-type] # Let it raise an error on None\n        vars(self).update(locals())\n        del self.self\n\n    def _find_assignments(self) -> Iterator[tuple[ast.AST, ast.AST]]:\n        for statement in self.module.body:\n            if isinstance(statement, ast.Assign):\n                yield from ((target, statement.value) for target in statement.targets)\n            elif isinstance(statement, ast.AnnAssign) and statement.value:\n                yield (statement.target, statement.value)\n\n    def __getattr__(self, attr):\n        \"\"\"Attempt to load an attribute \"statically\", via :func:`ast.literal_eval`.\"\"\"\n        try:\n            return next(\n                ast.literal_eval(value)\n                for target, value in self._find_assignments()\n                if isinstance(target, ast.Name) and target.id == attr\n            )\n        except Exception as e:\n            raise AttributeError(f\"{self.name} has no attribute {attr}\") from e\n\n\ndef glob_relative(\n    patterns: Iterable[str], root_dir: StrPath | None = None\n) -> list[str]:\n    \"\"\"Expand the list of glob patterns, but preserving relative paths.\n\n    :param list[str] patterns: List of glob patterns\n    :param str root_dir: Path to which globs should be relative\n                         (current directory by default)\n    :rtype: list\n    \"\"\"\n    glob_characters = {'*', '?', '[', ']', '{', '}'}\n    expanded_values = []\n    root_dir = root_dir or os.getcwd()\n    for value in patterns:\n        # Has globby characters?\n        if any(char in value for char in glob_characters):\n            # then expand the glob pattern while keeping paths *relative*:\n            glob_path = os.path.abspath(os.path.join(root_dir, value))\n            expanded_values.extend(\n                sorted(\n                    os.path.relpath(path, root_dir).replace(os.sep, \"/\")\n                    for path in iglob(glob_path, recursive=True)\n                )\n            )\n\n        else:\n            # take the value as-is\n            path = os.path.relpath(value, root_dir).replace(os.sep, \"/\")\n            expanded_values.append(path)\n\n    return expanded_values\n\n\ndef read_files(\n    filepaths: StrPath | Iterable[StrPath], root_dir: StrPath | None = None\n) -> str:\n    \"\"\"Return the content of the files concatenated using ``\\n`` as str\n\n    This function is sandboxed and won't reach anything outside ``root_dir``\n\n    (By default ``root_dir`` is the current directory).\n    \"\"\"\n    from setuptools.extern.more_itertools import always_iterable\n\n    root_dir = os.path.abspath(root_dir or os.getcwd())\n    _filepaths = (os.path.join(root_dir, path) for path in always_iterable(filepaths))\n    return '\\n'.join(\n        _read_file(path)\n        for path in _filter_existing_files(_filepaths)\n        if _assert_local(path, root_dir)\n    )\n\n\ndef _filter_existing_files(filepaths: Iterable[StrPath]) -> Iterator[StrPath]:\n    for path in filepaths:\n        if os.path.isfile(path):\n            yield path\n        else:\n            SetuptoolsWarning.emit(f\"File {path!r} cannot be found\")\n\n\ndef _read_file(filepath: bytes | StrPath) -> str:\n    with open(filepath, encoding='utf-8') as f:\n        return f.read()\n\n\ndef _assert_local(filepath: StrPath, root_dir: str):\n    if Path(os.path.abspath(root_dir)) not in Path(os.path.abspath(filepath)).parents:\n        msg = f\"Cannot access {filepath!r} (or anything outside {root_dir!r})\"\n        raise DistutilsOptionError(msg)\n\n    return True\n\n\ndef read_attr(\n    attr_desc: str,\n    package_dir: Mapping[str, str] | None = None,\n    root_dir: StrPath | None = None,\n):\n    \"\"\"Reads the value of an attribute from a module.\n\n    This function will try to read the attributed statically first\n    (via :func:`ast.literal_eval`), and only evaluate the module if it fails.\n\n    Examples:\n        read_attr(\"package.attr\")\n        read_attr(\"package.module.attr\")\n\n    :param str attr_desc: Dot-separated string describing how to reach the\n        attribute (see examples above)\n    :param dict[str, str] package_dir: Mapping of package names to their\n        location in disk (represented by paths relative to ``root_dir``).\n    :param str root_dir: Path to directory containing all the packages in\n        ``package_dir`` (current directory by default).\n    :rtype: str\n    \"\"\"\n    root_dir = root_dir or os.getcwd()\n    attrs_path = attr_desc.strip().split('.')\n    attr_name = attrs_path.pop()\n    module_name = '.'.join(attrs_path)\n    module_name = module_name or '__init__'\n    path = _find_module(module_name, package_dir, root_dir)\n    spec = _find_spec(module_name, path)\n\n    try:\n        return getattr(StaticModule(module_name, spec), attr_name)\n    except Exception:\n        # fallback to evaluate module\n        module = _load_spec(spec, module_name)\n        return getattr(module, attr_name)\n\n\ndef _find_spec(module_name: str, module_path: StrPath | None) -> ModuleSpec:\n    spec = importlib.util.spec_from_file_location(module_name, module_path)\n    spec = spec or importlib.util.find_spec(module_name)\n\n    if spec is None:\n        raise ModuleNotFoundError(module_name)\n\n    return spec\n\n\ndef _load_spec(spec: ModuleSpec, module_name: str) -> ModuleType:\n    name = getattr(spec, \"__name__\", module_name)\n    if name in sys.modules:\n        return sys.modules[name]\n    module = importlib.util.module_from_spec(spec)\n    sys.modules[name] = module  # cache (it also ensures `==` works on loaded items)\n    spec.loader.exec_module(module)  # type: ignore\n    return module\n\n\ndef _find_module(\n    module_name: str, package_dir: Mapping[str, str] | None, root_dir: StrPath\n) -> str | None:\n    \"\"\"Find the path to the module named ``module_name``,\n    considering the ``package_dir`` in the build configuration and ``root_dir``.\n\n    >>> tmp = getfixture('tmpdir')\n    >>> _ = tmp.ensure(\"a/b/c.py\")\n    >>> _ = tmp.ensure(\"a/b/d/__init__.py\")\n    >>> r = lambda x: x.replace(str(tmp), \"tmp\").replace(os.sep, \"/\")\n    >>> r(_find_module(\"a.b.c\", None, tmp))\n    'tmp/a/b/c.py'\n    >>> r(_find_module(\"f.g.h\", {\"\": \"1\", \"f\": \"2\", \"f.g\": \"3\", \"f.g.h\": \"a/b/d\"}, tmp))\n    'tmp/a/b/d/__init__.py'\n    \"\"\"\n    path_start = find_package_path(module_name, package_dir or {}, root_dir)\n    candidates = chain.from_iterable(\n        (f\"{path_start}{ext}\", os.path.join(path_start, f\"__init__{ext}\"))\n        for ext in all_suffixes()\n    )\n    return next((x for x in candidates if os.path.isfile(x)), None)\n\n\ndef resolve_class(\n    qualified_class_name: str,\n    package_dir: Mapping[str, str] | None = None,\n    root_dir: StrPath | None = None,\n) -> Callable:\n    \"\"\"Given a qualified class name, return the associated class object\"\"\"\n    root_dir = root_dir or os.getcwd()\n    idx = qualified_class_name.rfind('.')\n    class_name = qualified_class_name[idx + 1 :]\n    pkg_name = qualified_class_name[:idx]\n\n    path = _find_module(pkg_name, package_dir, root_dir)\n    module = _load_spec(_find_spec(pkg_name, path), pkg_name)\n    return getattr(module, class_name)\n\n\ndef cmdclass(\n    values: dict[str, str],\n    package_dir: Mapping[str, str] | None = None,\n    root_dir: StrPath | None = None,\n) -> dict[str, Callable]:\n    \"\"\"Given a dictionary mapping command names to strings for qualified class\n    names, apply :func:`resolve_class` to the dict values.\n    \"\"\"\n    return {k: resolve_class(v, package_dir, root_dir) for k, v in values.items()}\n\n\ndef find_packages(\n    *,\n    namespaces=True,\n    fill_package_dir: dict[str, str] | None = None,\n    root_dir: StrPath | None = None,\n    **kwargs,\n) -> list[str]:\n    \"\"\"Works similarly to :func:`setuptools.find_packages`, but with all\n    arguments given as keyword arguments. Moreover, ``where`` can be given\n    as a list (the results will be simply concatenated).\n\n    When the additional keyword argument ``namespaces`` is ``True``, it will\n    behave like :func:`setuptools.find_namespace_packages`` (i.e. include\n    implicit namespaces as per :pep:`420`).\n\n    The ``where`` argument will be considered relative to ``root_dir`` (or the current\n    working directory when ``root_dir`` is not given).\n\n    If the ``fill_package_dir`` argument is passed, this function will consider it as a\n    similar data structure to the ``package_dir`` configuration parameter add fill-in\n    any missing package location.\n\n    :rtype: list\n    \"\"\"\n    from setuptools.discovery import construct_package_dir\n    from setuptools.extern.more_itertools import unique_everseen, always_iterable\n\n    if namespaces:\n        from setuptools.discovery import PEP420PackageFinder as PackageFinder\n    else:\n        from setuptools.discovery import PackageFinder  # type: ignore\n\n    root_dir = root_dir or os.curdir\n    where = kwargs.pop('where', ['.'])\n    packages: list[str] = []\n    fill_package_dir = {} if fill_package_dir is None else fill_package_dir\n    search = list(unique_everseen(always_iterable(where)))\n\n    if len(search) == 1 and all(not _same_path(search[0], x) for x in (\".\", root_dir)):\n        fill_package_dir.setdefault(\"\", search[0])\n\n    for path in search:\n        package_path = _nest_path(root_dir, path)\n        pkgs = PackageFinder.find(package_path, **kwargs)\n        packages.extend(pkgs)\n        if pkgs and not (\n            fill_package_dir.get(\"\") == path or os.path.samefile(package_path, root_dir)\n        ):\n            fill_package_dir.update(construct_package_dir(pkgs, path))\n\n    return packages\n\n\ndef _nest_path(parent: StrPath, path: StrPath) -> str:\n    path = parent if path in {\".\", \"\"} else os.path.join(parent, path)\n    return os.path.normpath(path)\n\n\ndef version(value: Callable | Iterable[str | int] | str) -> str:\n    \"\"\"When getting the version directly from an attribute,\n    it should be normalised to string.\n    \"\"\"\n    _value = value() if callable(value) else value\n\n    if isinstance(_value, str):\n        return _value\n    if hasattr(_value, '__iter__'):\n        return '.'.join(map(str, _value))\n    return '%s' % _value\n\n\ndef canonic_package_data(package_data: dict) -> dict:\n    if \"*\" in package_data:\n        package_data[\"\"] = package_data.pop(\"*\")\n    return package_data\n\n\ndef canonic_data_files(\n    data_files: list | dict, root_dir: StrPath | None = None\n) -> list[tuple[str, list[str]]]:\n    \"\"\"For compatibility with ``setup.py``, ``data_files`` should be a list\n    of pairs instead of a dict.\n\n    This function also expands glob patterns.\n    \"\"\"\n    if isinstance(data_files, list):\n        return data_files\n\n    return [\n        (dest, glob_relative(patterns, root_dir))\n        for dest, patterns in data_files.items()\n    ]\n\n\ndef entry_points(text: str, text_source=\"entry-points\") -> dict[str, dict]:\n    \"\"\"Given the contents of entry-points file,\n    process it into a 2-level dictionary (``dict[str, dict[str, str]]``).\n    The first level keys are entry-point groups, the second level keys are\n    entry-point names, and the second level values are references to objects\n    (that correspond to the entry-point value).\n    \"\"\"\n    parser = ConfigParser(default_section=None, delimiters=(\"=\",))  # type: ignore\n    parser.optionxform = str  # case sensitive\n    parser.read_string(text, text_source)\n    groups = {k: dict(v.items()) for k, v in parser.items()}\n    groups.pop(parser.default_section, None)\n    return groups\n\n\nclass EnsurePackagesDiscovered:\n    \"\"\"Some expand functions require all the packages to already be discovered before\n    they run, e.g. :func:`read_attr`, :func:`resolve_class`, :func:`cmdclass`.\n\n    Therefore in some cases we will need to run autodiscovery during the evaluation of\n    the configuration. However, it is better to postpone calling package discovery as\n    much as possible, because some parameters can influence it (e.g. ``package_dir``),\n    and those might not have been processed yet.\n    \"\"\"\n\n    def __init__(self, distribution: Distribution):\n        self._dist = distribution\n        self._called = False\n\n    def __call__(self):\n        \"\"\"Trigger the automatic package discovery, if it is still necessary.\"\"\"\n        if not self._called:\n            self._called = True\n            self._dist.set_defaults(name=False)  # Skip name, we can still be parsing\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, _exc_type, _exc_value, _traceback):\n        if self._called:\n            self._dist.set_defaults.analyse_name()  # Now we can set a default name\n\n    def _get_package_dir(self) -> Mapping[str, str]:\n        self()\n        pkg_dir = self._dist.package_dir\n        return {} if pkg_dir is None else pkg_dir\n\n    @property\n    def package_dir(self) -> Mapping[str, str]:\n        \"\"\"Proxy to ``package_dir`` that may trigger auto-discovery when used.\"\"\"\n        return LazyMappingProxy(self._get_package_dir)\n\n\nclass LazyMappingProxy(Mapping[_K, _V]):\n    \"\"\"Mapping proxy that delays resolving the target object, until really needed.\n\n    >>> def obtain_mapping():\n    ...     print(\"Running expensive function!\")\n    ...     return {\"key\": \"value\", \"other key\": \"other value\"}\n    >>> mapping = LazyMappingProxy(obtain_mapping)\n    >>> mapping[\"key\"]\n    Running expensive function!\n    'value'\n    >>> mapping[\"other key\"]\n    'other value'\n    \"\"\"\n\n    def __init__(self, obtain_mapping_value: Callable[[], Mapping[_K, _V]]):\n        self._obtain = obtain_mapping_value\n        self._value: Mapping[_K, _V] | None = None\n\n    def _target(self) -> Mapping[_K, _V]:\n        if self._value is None:\n            self._value = self._obtain()\n        return self._value\n\n    def __getitem__(self, key: _K) -> _V:\n        return self._target()[key]\n\n    def __len__(self) -> int:\n        return len(self._target())\n\n    def __iter__(self) -> Iterator[_K]:\n        return iter(self._target())\n", "setuptools/config/_validate_pyproject/fastjsonschema_validations.py": "# noqa\n# ruff: noqa\n# flake8: noqa\n# pylint: skip-file\n# mypy: ignore-errors\n# yapf: disable\n# pylama:skip=1\n\n\n# *** PLEASE DO NOT MODIFY DIRECTLY: Automatically generated code *** \n\n\nVERSION = \"2.19.1\"\nfrom decimal import Decimal\nimport re\nfrom .fastjsonschema_exceptions import JsonSchemaValueException\n\n\nREGEX_PATTERNS = {\n    '^.*$': re.compile('^.*$'),\n    '.+': re.compile('.+'),\n    '^.+$': re.compile('^.+$'),\n    'idn-email_re_pattern': re.compile('^[^@]+@[^@]+\\\\.[^@]+\\\\Z')\n}\n\nNoneType = type(None)\n\ndef validate(data, custom_formats={}, name_prefix=None):\n    validate_https___packaging_python_org_en_latest_specifications_declaring_build_dependencies(data, custom_formats, (name_prefix or \"data\") + \"\")\n    return data\n\ndef validate_https___packaging_python_org_en_latest_specifications_declaring_build_dependencies(data, custom_formats={}, name_prefix=None):\n    if not isinstance(data, (dict)):\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be object\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://packaging.python.org/en/latest/specifications/declaring-build-dependencies/', 'title': 'Data structure for ``pyproject.toml`` files', '$$description': ['File format containing build-time configurations for the Python ecosystem. ', ':pep:`517` initially defined a build-system independent format for source trees', 'which was complemented by :pep:`518` to provide a way of specifying dependencies ', 'for building Python projects.', 'Please notice the ``project`` table (as initially defined in  :pep:`621`) is not included', 'in this schema and should be considered separately.'], 'type': 'object', 'additionalProperties': False, 'properties': {'build-system': {'type': 'object', 'description': 'Table used to store build-related data', 'additionalProperties': False, 'properties': {'requires': {'type': 'array', '$$description': ['List of dependencies in the :pep:`508` format required to execute the build', 'system. Please notice that the resulting dependency graph', '**MUST NOT contain cycles**'], 'items': {'type': 'string'}}, 'build-backend': {'type': 'string', 'description': 'Python object that will be used to perform the build according to :pep:`517`', 'format': 'pep517-backend-reference'}, 'backend-path': {'type': 'array', '$$description': ['List of directories to be prepended to ``sys.path`` when loading the', 'back-end, and running its hooks'], 'items': {'type': 'string', '$comment': 'Should be a path (TODO: enforce it with format?)'}}}, 'required': ['requires']}, 'project': {'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://packaging.python.org/en/latest/specifications/pyproject-toml/', 'title': 'Package metadata stored in the ``project`` table', '$$description': ['Data structure for the **project** table inside ``pyproject.toml``', '(as initially defined in :pep:`621`)'], 'type': 'object', 'properties': {'name': {'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, 'version': {'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, 'description': {'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, 'readme': {'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', \"with meaning similar to the one defined in `core metadata's Description\", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, 'requires-python': {'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, 'license': {'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, 'authors': {'type': 'array', 'items': {'$ref': '#/definitions/author'}, '$$description': [\"The people or organizations considered to be the 'authors' of the project.\", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, 'maintainers': {'type': 'array', 'items': {'$ref': '#/definitions/author'}, '$$description': [\"The people or organizations considered to be the 'maintainers' of the project.\", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, 'keywords': {'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, 'classifiers': {'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, 'urls': {'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, 'scripts': {'$ref': '#/definitions/entry-point-group', '$$description': ['Instruct the installer to create command-line wrappers for the given', '`entry points <https://packaging.python.org/specifications/entry-points/>`_.']}, 'gui-scripts': {'$ref': '#/definitions/entry-point-group', '$$description': ['Instruct the installer to create GUI wrappers for the given', '`entry points <https://packaging.python.org/specifications/entry-points/>`_.', 'The difference between ``scripts`` and ``gui-scripts`` is only relevant in', 'Windows.']}, 'entry-points': {'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$ref': '#/definitions/entry-point-group'}}}, 'dependencies': {'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$ref': '#/definitions/dependency'}}, 'optional-dependencies': {'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$ref': '#/definitions/dependency'}}}}, 'dynamic': {'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}}, 'required': ['name'], 'additionalProperties': False, 'if': {'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as \"Required\", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, 'then': {'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, 'definitions': {'author': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, 'entry-point-group': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'dependency': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}, 'tool': {'type': 'object', 'properties': {'distutils': {'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://setuptools.pypa.io/en/latest/deprecated/distutils/configfile.html', 'title': '``tool.distutils`` table', '$$description': ['**EXPERIMENTAL** (NOT OFFICIALLY SUPPORTED): Use ``tool.distutils``', 'subtables to configure arguments for ``distutils`` commands.', 'Originally, ``distutils`` allowed developers to configure arguments for', '``setup.py`` commands via `distutils configuration files', '<https://setuptools.pypa.io/en/latest/deprecated/distutils/configfile.html>`_.', 'See also `the old Python docs <https://docs.python.org/3.11/install/>_`.'], 'type': 'object', 'properties': {'global': {'type': 'object', 'description': 'Global options applied to all ``distutils`` commands'}}, 'patternProperties': {'.+': {'type': 'object'}}, '$comment': 'TODO: Is there a practical way of making this schema more specific?'}, 'setuptools': {'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html', 'title': '``tool.setuptools`` table', '$$description': ['``setuptools``-specific configurations that can be set by users that require', 'customization.', 'These configurations are completely optional and probably can be skipped when', 'creating simple packages. They are equivalent to some of the `Keywords', '<https://setuptools.pypa.io/en/latest/references/keywords.html>`_', 'used by the ``setup.py`` file, and can be set via the ``tool.setuptools`` table.', 'It considers only ``setuptools`` `parameters', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#setuptools-specific-configuration>`_', 'that are not covered by :pep:`621`; and intentionally excludes ``dependency_links``', 'and ``setup_requires`` (incompatible with modern workflows/standards).'], 'type': 'object', 'additionalProperties': False, 'properties': {'platforms': {'type': 'array', 'items': {'type': 'string'}}, 'provides': {'$$description': ['Package and virtual package names contained within this package', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'obsoletes': {'$$description': ['Packages which this package renders obsolete', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'zip-safe': {'$$description': ['Whether the project can be safely installed and run from a zip file.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'boolean'}, 'script-files': {'$$description': ['Legacy way of defining scripts (entry-points are preferred).', 'Equivalent to the ``script`` keyword in ``setup.py``', '(it was renamed to avoid confusion with entry-point based ``project.scripts``', 'defined in :pep:`621`).', '**DISCOURAGED**: generic script wrappers are tricky and may not work properly.', 'Whenever possible, please use ``project.scripts`` instead.'], 'type': 'array', 'items': {'type': 'string'}, '$comment': 'TODO: is this field deprecated/should be removed?'}, 'eager-resources': {'$$description': ['Resources that should be extracted together, if any of them is needed,', 'or if any C extensions included in the project are imported.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'array', 'items': {'type': 'string'}}, 'packages': {'$$description': ['Packages that should be included in the distribution.', 'It can be given either as a list of package identifiers', 'or as a ``dict``-like structure with a single key ``find``', 'which corresponds to a dynamic call to', '``setuptools.config.expand.find_packages`` function.', 'The ``find`` key is associated with a nested ``dict``-like structure that can', 'contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,', 'mimicking the keyword arguments of the associated function.'], 'oneOf': [{'title': 'Array of Python package identifiers', 'type': 'array', 'items': {'$ref': '#/definitions/package-name'}}, {'$ref': '#/definitions/find-directive'}]}, 'package-dir': {'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'const': ''}, {'$ref': '#/definitions/package-name'}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, 'package-data': {'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'include-package-data': {'$$description': ['Automatically include any data files inside the package directories', 'that are specified by ``MANIFEST.in``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'boolean'}, 'exclude-package-data': {'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'namespace-packages': {'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'https://setuptools.pypa.io/en/latest/userguide/package_discovery.html', 'description': '**DEPRECATED**: use implicit namespaces instead (:pep:`420`).'}, 'py-modules': {'description': 'Modules that setuptools will manipulate', 'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'TODO: clarify the relationship with ``packages``'}, 'data-files': {'$$description': ['``dict``-like structure where each key represents a directory and', 'the value is a list of glob patterns that should be installed in them.', '**DISCOURAGED**: please notice this might not work as expected with wheels.', 'Whenever possible, consider using data files inside the package directories', '(or create a new namespace package that only contains data files).', 'See `data files support', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'cmdclass': {'$$description': ['Mapping of distutils-style command names to ``setuptools.Command`` subclasses', 'which in turn should be represented by strings with a qualified class name', '(i.e., \"dotted\" form with module), e.g.::\\n\\n', '    cmdclass = {mycmd = \"pkg.subpkg.module.CommandClass\"}\\n\\n', 'The command class should be a directly defined at the top-level of the', 'containing module (no class nesting).'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'string', 'format': 'python-qualified-identifier'}}}, 'license-files': {'type': 'array', 'items': {'type': 'string'}, '$$description': ['**PROVISIONAL**: list of glob patterns for all license files being distributed.', '(likely to become standard with :pep:`639`).', \"By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``\"], '$comment': 'TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?'}, 'dynamic': {'type': 'object', 'description': 'Instructions for loading :pep:`621`-related metadata dynamically', 'additionalProperties': False, 'properties': {'version': {'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.', 'Also ensure to set ``project.dynamic`` accordingly.'], 'oneOf': [{'$ref': '#/definitions/attr-directive'}, {'$ref': '#/definitions/file-directive'}]}, 'classifiers': {'$ref': '#/definitions/file-directive'}, 'description': {'$ref': '#/definitions/file-directive'}, 'entry-points': {'$ref': '#/definitions/file-directive'}, 'dependencies': {'$ref': '#/definitions/file-directive-for-dependencies'}, 'optional-dependencies': {'type': 'object', 'propertyNames': {'type': 'string', 'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'$ref': '#/definitions/file-directive-for-dependencies'}}}, 'readme': {'type': 'object', 'anyOf': [{'$ref': '#/definitions/file-directive'}, {'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'$ref': '#/definitions/file-directive/properties/file'}}, 'additionalProperties': False}], 'required': ['file']}}}}, 'definitions': {'package-name': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}, 'file-directive': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'file-directive-for-dependencies': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}, 'attr-directive': {'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, 'find-directive': {'$id': '#/definitions/find-directive', 'title': \"'find:' directive\", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}}}}}}, 'project': {'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://packaging.python.org/en/latest/specifications/pyproject-toml/', 'title': 'Package metadata stored in the ``project`` table', '$$description': ['Data structure for the **project** table inside ``pyproject.toml``', '(as initially defined in :pep:`621`)'], 'type': 'object', 'properties': {'name': {'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, 'version': {'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, 'description': {'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, 'readme': {'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', \"with meaning similar to the one defined in `core metadata's Description\", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, 'requires-python': {'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, 'license': {'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, 'authors': {'type': 'array', 'items': {'$ref': '#/definitions/author'}, '$$description': [\"The people or organizations considered to be the 'authors' of the project.\", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, 'maintainers': {'type': 'array', 'items': {'$ref': '#/definitions/author'}, '$$description': [\"The people or organizations considered to be the 'maintainers' of the project.\", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, 'keywords': {'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, 'classifiers': {'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, 'urls': {'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, 'scripts': {'$ref': '#/definitions/entry-point-group', '$$description': ['Instruct the installer to create command-line wrappers for the given', '`entry points <https://packaging.python.org/specifications/entry-points/>`_.']}, 'gui-scripts': {'$ref': '#/definitions/entry-point-group', '$$description': ['Instruct the installer to create GUI wrappers for the given', '`entry points <https://packaging.python.org/specifications/entry-points/>`_.', 'The difference between ``scripts`` and ``gui-scripts`` is only relevant in', 'Windows.']}, 'entry-points': {'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$ref': '#/definitions/entry-point-group'}}}, 'dependencies': {'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$ref': '#/definitions/dependency'}}, 'optional-dependencies': {'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$ref': '#/definitions/dependency'}}}}, 'dynamic': {'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}}, 'required': ['name'], 'additionalProperties': False, 'if': {'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as \"Required\", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, 'then': {'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, 'definitions': {'author': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, 'entry-point-group': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'dependency': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, rule='type')\n    data_is_dict = isinstance(data, dict)\n    if data_is_dict:\n        data_keys = set(data.keys())\n        if \"build-system\" in data_keys:\n            data_keys.remove(\"build-system\")\n            data__buildsystem = data[\"build-system\"]\n            if not isinstance(data__buildsystem, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".build-system must be object\", value=data__buildsystem, name=\"\" + (name_prefix or \"data\") + \".build-system\", definition={'type': 'object', 'description': 'Table used to store build-related data', 'additionalProperties': False, 'properties': {'requires': {'type': 'array', '$$description': ['List of dependencies in the :pep:`508` format required to execute the build', 'system. Please notice that the resulting dependency graph', '**MUST NOT contain cycles**'], 'items': {'type': 'string'}}, 'build-backend': {'type': 'string', 'description': 'Python object that will be used to perform the build according to :pep:`517`', 'format': 'pep517-backend-reference'}, 'backend-path': {'type': 'array', '$$description': ['List of directories to be prepended to ``sys.path`` when loading the', 'back-end, and running its hooks'], 'items': {'type': 'string', '$comment': 'Should be a path (TODO: enforce it with format?)'}}}, 'required': ['requires']}, rule='type')\n            data__buildsystem_is_dict = isinstance(data__buildsystem, dict)\n            if data__buildsystem_is_dict:\n                data__buildsystem__missing_keys = set(['requires']) - data__buildsystem.keys()\n                if data__buildsystem__missing_keys:\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".build-system must contain \" + (str(sorted(data__buildsystem__missing_keys)) + \" properties\"), value=data__buildsystem, name=\"\" + (name_prefix or \"data\") + \".build-system\", definition={'type': 'object', 'description': 'Table used to store build-related data', 'additionalProperties': False, 'properties': {'requires': {'type': 'array', '$$description': ['List of dependencies in the :pep:`508` format required to execute the build', 'system. Please notice that the resulting dependency graph', '**MUST NOT contain cycles**'], 'items': {'type': 'string'}}, 'build-backend': {'type': 'string', 'description': 'Python object that will be used to perform the build according to :pep:`517`', 'format': 'pep517-backend-reference'}, 'backend-path': {'type': 'array', '$$description': ['List of directories to be prepended to ``sys.path`` when loading the', 'back-end, and running its hooks'], 'items': {'type': 'string', '$comment': 'Should be a path (TODO: enforce it with format?)'}}}, 'required': ['requires']}, rule='required')\n                data__buildsystem_keys = set(data__buildsystem.keys())\n                if \"requires\" in data__buildsystem_keys:\n                    data__buildsystem_keys.remove(\"requires\")\n                    data__buildsystem__requires = data__buildsystem[\"requires\"]\n                    if not isinstance(data__buildsystem__requires, (list, tuple)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".build-system.requires must be array\", value=data__buildsystem__requires, name=\"\" + (name_prefix or \"data\") + \".build-system.requires\", definition={'type': 'array', '$$description': ['List of dependencies in the :pep:`508` format required to execute the build', 'system. Please notice that the resulting dependency graph', '**MUST NOT contain cycles**'], 'items': {'type': 'string'}}, rule='type')\n                    data__buildsystem__requires_is_list = isinstance(data__buildsystem__requires, (list, tuple))\n                    if data__buildsystem__requires_is_list:\n                        data__buildsystem__requires_len = len(data__buildsystem__requires)\n                        for data__buildsystem__requires_x, data__buildsystem__requires_item in enumerate(data__buildsystem__requires):\n                            if not isinstance(data__buildsystem__requires_item, (str)):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".build-system.requires[{data__buildsystem__requires_x}]\".format(**locals()) + \" must be string\", value=data__buildsystem__requires_item, name=\"\" + (name_prefix or \"data\") + \".build-system.requires[{data__buildsystem__requires_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n                if \"build-backend\" in data__buildsystem_keys:\n                    data__buildsystem_keys.remove(\"build-backend\")\n                    data__buildsystem__buildbackend = data__buildsystem[\"build-backend\"]\n                    if not isinstance(data__buildsystem__buildbackend, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".build-system.build-backend must be string\", value=data__buildsystem__buildbackend, name=\"\" + (name_prefix or \"data\") + \".build-system.build-backend\", definition={'type': 'string', 'description': 'Python object that will be used to perform the build according to :pep:`517`', 'format': 'pep517-backend-reference'}, rule='type')\n                    if isinstance(data__buildsystem__buildbackend, str):\n                        if not custom_formats[\"pep517-backend-reference\"](data__buildsystem__buildbackend):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".build-system.build-backend must be pep517-backend-reference\", value=data__buildsystem__buildbackend, name=\"\" + (name_prefix or \"data\") + \".build-system.build-backend\", definition={'type': 'string', 'description': 'Python object that will be used to perform the build according to :pep:`517`', 'format': 'pep517-backend-reference'}, rule='format')\n                if \"backend-path\" in data__buildsystem_keys:\n                    data__buildsystem_keys.remove(\"backend-path\")\n                    data__buildsystem__backendpath = data__buildsystem[\"backend-path\"]\n                    if not isinstance(data__buildsystem__backendpath, (list, tuple)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".build-system.backend-path must be array\", value=data__buildsystem__backendpath, name=\"\" + (name_prefix or \"data\") + \".build-system.backend-path\", definition={'type': 'array', '$$description': ['List of directories to be prepended to ``sys.path`` when loading the', 'back-end, and running its hooks'], 'items': {'type': 'string', '$comment': 'Should be a path (TODO: enforce it with format?)'}}, rule='type')\n                    data__buildsystem__backendpath_is_list = isinstance(data__buildsystem__backendpath, (list, tuple))\n                    if data__buildsystem__backendpath_is_list:\n                        data__buildsystem__backendpath_len = len(data__buildsystem__backendpath)\n                        for data__buildsystem__backendpath_x, data__buildsystem__backendpath_item in enumerate(data__buildsystem__backendpath):\n                            if not isinstance(data__buildsystem__backendpath_item, (str)):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".build-system.backend-path[{data__buildsystem__backendpath_x}]\".format(**locals()) + \" must be string\", value=data__buildsystem__backendpath_item, name=\"\" + (name_prefix or \"data\") + \".build-system.backend-path[{data__buildsystem__backendpath_x}]\".format(**locals()) + \"\", definition={'type': 'string', '$comment': 'Should be a path (TODO: enforce it with format?)'}, rule='type')\n                if data__buildsystem_keys:\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".build-system must not contain \"+str(data__buildsystem_keys)+\" properties\", value=data__buildsystem, name=\"\" + (name_prefix or \"data\") + \".build-system\", definition={'type': 'object', 'description': 'Table used to store build-related data', 'additionalProperties': False, 'properties': {'requires': {'type': 'array', '$$description': ['List of dependencies in the :pep:`508` format required to execute the build', 'system. Please notice that the resulting dependency graph', '**MUST NOT contain cycles**'], 'items': {'type': 'string'}}, 'build-backend': {'type': 'string', 'description': 'Python object that will be used to perform the build according to :pep:`517`', 'format': 'pep517-backend-reference'}, 'backend-path': {'type': 'array', '$$description': ['List of directories to be prepended to ``sys.path`` when loading the', 'back-end, and running its hooks'], 'items': {'type': 'string', '$comment': 'Should be a path (TODO: enforce it with format?)'}}}, 'required': ['requires']}, rule='additionalProperties')\n        if \"project\" in data_keys:\n            data_keys.remove(\"project\")\n            data__project = data[\"project\"]\n            validate_https___packaging_python_org_en_latest_specifications_pyproject_toml(data__project, custom_formats, (name_prefix or \"data\") + \".project\")\n        if \"tool\" in data_keys:\n            data_keys.remove(\"tool\")\n            data__tool = data[\"tool\"]\n            if not isinstance(data__tool, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".tool must be object\", value=data__tool, name=\"\" + (name_prefix or \"data\") + \".tool\", definition={'type': 'object', 'properties': {'distutils': {'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://setuptools.pypa.io/en/latest/deprecated/distutils/configfile.html', 'title': '``tool.distutils`` table', '$$description': ['**EXPERIMENTAL** (NOT OFFICIALLY SUPPORTED): Use ``tool.distutils``', 'subtables to configure arguments for ``distutils`` commands.', 'Originally, ``distutils`` allowed developers to configure arguments for', '``setup.py`` commands via `distutils configuration files', '<https://setuptools.pypa.io/en/latest/deprecated/distutils/configfile.html>`_.', 'See also `the old Python docs <https://docs.python.org/3.11/install/>_`.'], 'type': 'object', 'properties': {'global': {'type': 'object', 'description': 'Global options applied to all ``distutils`` commands'}}, 'patternProperties': {'.+': {'type': 'object'}}, '$comment': 'TODO: Is there a practical way of making this schema more specific?'}, 'setuptools': {'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html', 'title': '``tool.setuptools`` table', '$$description': ['``setuptools``-specific configurations that can be set by users that require', 'customization.', 'These configurations are completely optional and probably can be skipped when', 'creating simple packages. They are equivalent to some of the `Keywords', '<https://setuptools.pypa.io/en/latest/references/keywords.html>`_', 'used by the ``setup.py`` file, and can be set via the ``tool.setuptools`` table.', 'It considers only ``setuptools`` `parameters', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#setuptools-specific-configuration>`_', 'that are not covered by :pep:`621`; and intentionally excludes ``dependency_links``', 'and ``setup_requires`` (incompatible with modern workflows/standards).'], 'type': 'object', 'additionalProperties': False, 'properties': {'platforms': {'type': 'array', 'items': {'type': 'string'}}, 'provides': {'$$description': ['Package and virtual package names contained within this package', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'obsoletes': {'$$description': ['Packages which this package renders obsolete', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'zip-safe': {'$$description': ['Whether the project can be safely installed and run from a zip file.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'boolean'}, 'script-files': {'$$description': ['Legacy way of defining scripts (entry-points are preferred).', 'Equivalent to the ``script`` keyword in ``setup.py``', '(it was renamed to avoid confusion with entry-point based ``project.scripts``', 'defined in :pep:`621`).', '**DISCOURAGED**: generic script wrappers are tricky and may not work properly.', 'Whenever possible, please use ``project.scripts`` instead.'], 'type': 'array', 'items': {'type': 'string'}, '$comment': 'TODO: is this field deprecated/should be removed?'}, 'eager-resources': {'$$description': ['Resources that should be extracted together, if any of them is needed,', 'or if any C extensions included in the project are imported.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'array', 'items': {'type': 'string'}}, 'packages': {'$$description': ['Packages that should be included in the distribution.', 'It can be given either as a list of package identifiers', 'or as a ``dict``-like structure with a single key ``find``', 'which corresponds to a dynamic call to', '``setuptools.config.expand.find_packages`` function.', 'The ``find`` key is associated with a nested ``dict``-like structure that can', 'contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,', 'mimicking the keyword arguments of the associated function.'], 'oneOf': [{'title': 'Array of Python package identifiers', 'type': 'array', 'items': {'$ref': '#/definitions/package-name'}}, {'$ref': '#/definitions/find-directive'}]}, 'package-dir': {'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'const': ''}, {'$ref': '#/definitions/package-name'}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, 'package-data': {'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'include-package-data': {'$$description': ['Automatically include any data files inside the package directories', 'that are specified by ``MANIFEST.in``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'boolean'}, 'exclude-package-data': {'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'namespace-packages': {'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'https://setuptools.pypa.io/en/latest/userguide/package_discovery.html', 'description': '**DEPRECATED**: use implicit namespaces instead (:pep:`420`).'}, 'py-modules': {'description': 'Modules that setuptools will manipulate', 'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'TODO: clarify the relationship with ``packages``'}, 'data-files': {'$$description': ['``dict``-like structure where each key represents a directory and', 'the value is a list of glob patterns that should be installed in them.', '**DISCOURAGED**: please notice this might not work as expected with wheels.', 'Whenever possible, consider using data files inside the package directories', '(or create a new namespace package that only contains data files).', 'See `data files support', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'cmdclass': {'$$description': ['Mapping of distutils-style command names to ``setuptools.Command`` subclasses', 'which in turn should be represented by strings with a qualified class name', '(i.e., \"dotted\" form with module), e.g.::\\n\\n', '    cmdclass = {mycmd = \"pkg.subpkg.module.CommandClass\"}\\n\\n', 'The command class should be a directly defined at the top-level of the', 'containing module (no class nesting).'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'string', 'format': 'python-qualified-identifier'}}}, 'license-files': {'type': 'array', 'items': {'type': 'string'}, '$$description': ['**PROVISIONAL**: list of glob patterns for all license files being distributed.', '(likely to become standard with :pep:`639`).', \"By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``\"], '$comment': 'TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?'}, 'dynamic': {'type': 'object', 'description': 'Instructions for loading :pep:`621`-related metadata dynamically', 'additionalProperties': False, 'properties': {'version': {'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.', 'Also ensure to set ``project.dynamic`` accordingly.'], 'oneOf': [{'$ref': '#/definitions/attr-directive'}, {'$ref': '#/definitions/file-directive'}]}, 'classifiers': {'$ref': '#/definitions/file-directive'}, 'description': {'$ref': '#/definitions/file-directive'}, 'entry-points': {'$ref': '#/definitions/file-directive'}, 'dependencies': {'$ref': '#/definitions/file-directive-for-dependencies'}, 'optional-dependencies': {'type': 'object', 'propertyNames': {'type': 'string', 'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'$ref': '#/definitions/file-directive-for-dependencies'}}}, 'readme': {'type': 'object', 'anyOf': [{'$ref': '#/definitions/file-directive'}, {'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'$ref': '#/definitions/file-directive/properties/file'}}, 'additionalProperties': False}], 'required': ['file']}}}}, 'definitions': {'package-name': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}, 'file-directive': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'file-directive-for-dependencies': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}, 'attr-directive': {'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, 'find-directive': {'$id': '#/definitions/find-directive', 'title': \"'find:' directive\", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}}}}}, rule='type')\n            data__tool_is_dict = isinstance(data__tool, dict)\n            if data__tool_is_dict:\n                data__tool_keys = set(data__tool.keys())\n                if \"distutils\" in data__tool_keys:\n                    data__tool_keys.remove(\"distutils\")\n                    data__tool__distutils = data__tool[\"distutils\"]\n                    validate_https___setuptools_pypa_io_en_latest_deprecated_distutils_configfile_html(data__tool__distutils, custom_formats, (name_prefix or \"data\") + \".tool.distutils\")\n                if \"setuptools\" in data__tool_keys:\n                    data__tool_keys.remove(\"setuptools\")\n                    data__tool__setuptools = data__tool[\"setuptools\"]\n                    validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html(data__tool__setuptools, custom_formats, (name_prefix or \"data\") + \".tool.setuptools\")\n        if data_keys:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must not contain \"+str(data_keys)+\" properties\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://packaging.python.org/en/latest/specifications/declaring-build-dependencies/', 'title': 'Data structure for ``pyproject.toml`` files', '$$description': ['File format containing build-time configurations for the Python ecosystem. ', ':pep:`517` initially defined a build-system independent format for source trees', 'which was complemented by :pep:`518` to provide a way of specifying dependencies ', 'for building Python projects.', 'Please notice the ``project`` table (as initially defined in  :pep:`621`) is not included', 'in this schema and should be considered separately.'], 'type': 'object', 'additionalProperties': False, 'properties': {'build-system': {'type': 'object', 'description': 'Table used to store build-related data', 'additionalProperties': False, 'properties': {'requires': {'type': 'array', '$$description': ['List of dependencies in the :pep:`508` format required to execute the build', 'system. Please notice that the resulting dependency graph', '**MUST NOT contain cycles**'], 'items': {'type': 'string'}}, 'build-backend': {'type': 'string', 'description': 'Python object that will be used to perform the build according to :pep:`517`', 'format': 'pep517-backend-reference'}, 'backend-path': {'type': 'array', '$$description': ['List of directories to be prepended to ``sys.path`` when loading the', 'back-end, and running its hooks'], 'items': {'type': 'string', '$comment': 'Should be a path (TODO: enforce it with format?)'}}}, 'required': ['requires']}, 'project': {'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://packaging.python.org/en/latest/specifications/pyproject-toml/', 'title': 'Package metadata stored in the ``project`` table', '$$description': ['Data structure for the **project** table inside ``pyproject.toml``', '(as initially defined in :pep:`621`)'], 'type': 'object', 'properties': {'name': {'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, 'version': {'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, 'description': {'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, 'readme': {'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', \"with meaning similar to the one defined in `core metadata's Description\", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, 'requires-python': {'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, 'license': {'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, 'authors': {'type': 'array', 'items': {'$ref': '#/definitions/author'}, '$$description': [\"The people or organizations considered to be the 'authors' of the project.\", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, 'maintainers': {'type': 'array', 'items': {'$ref': '#/definitions/author'}, '$$description': [\"The people or organizations considered to be the 'maintainers' of the project.\", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, 'keywords': {'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, 'classifiers': {'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, 'urls': {'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, 'scripts': {'$ref': '#/definitions/entry-point-group', '$$description': ['Instruct the installer to create command-line wrappers for the given', '`entry points <https://packaging.python.org/specifications/entry-points/>`_.']}, 'gui-scripts': {'$ref': '#/definitions/entry-point-group', '$$description': ['Instruct the installer to create GUI wrappers for the given', '`entry points <https://packaging.python.org/specifications/entry-points/>`_.', 'The difference between ``scripts`` and ``gui-scripts`` is only relevant in', 'Windows.']}, 'entry-points': {'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$ref': '#/definitions/entry-point-group'}}}, 'dependencies': {'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$ref': '#/definitions/dependency'}}, 'optional-dependencies': {'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$ref': '#/definitions/dependency'}}}}, 'dynamic': {'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}}, 'required': ['name'], 'additionalProperties': False, 'if': {'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as \"Required\", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, 'then': {'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, 'definitions': {'author': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, 'entry-point-group': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'dependency': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}, 'tool': {'type': 'object', 'properties': {'distutils': {'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://setuptools.pypa.io/en/latest/deprecated/distutils/configfile.html', 'title': '``tool.distutils`` table', '$$description': ['**EXPERIMENTAL** (NOT OFFICIALLY SUPPORTED): Use ``tool.distutils``', 'subtables to configure arguments for ``distutils`` commands.', 'Originally, ``distutils`` allowed developers to configure arguments for', '``setup.py`` commands via `distutils configuration files', '<https://setuptools.pypa.io/en/latest/deprecated/distutils/configfile.html>`_.', 'See also `the old Python docs <https://docs.python.org/3.11/install/>_`.'], 'type': 'object', 'properties': {'global': {'type': 'object', 'description': 'Global options applied to all ``distutils`` commands'}}, 'patternProperties': {'.+': {'type': 'object'}}, '$comment': 'TODO: Is there a practical way of making this schema more specific?'}, 'setuptools': {'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html', 'title': '``tool.setuptools`` table', '$$description': ['``setuptools``-specific configurations that can be set by users that require', 'customization.', 'These configurations are completely optional and probably can be skipped when', 'creating simple packages. They are equivalent to some of the `Keywords', '<https://setuptools.pypa.io/en/latest/references/keywords.html>`_', 'used by the ``setup.py`` file, and can be set via the ``tool.setuptools`` table.', 'It considers only ``setuptools`` `parameters', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#setuptools-specific-configuration>`_', 'that are not covered by :pep:`621`; and intentionally excludes ``dependency_links``', 'and ``setup_requires`` (incompatible with modern workflows/standards).'], 'type': 'object', 'additionalProperties': False, 'properties': {'platforms': {'type': 'array', 'items': {'type': 'string'}}, 'provides': {'$$description': ['Package and virtual package names contained within this package', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'obsoletes': {'$$description': ['Packages which this package renders obsolete', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'zip-safe': {'$$description': ['Whether the project can be safely installed and run from a zip file.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'boolean'}, 'script-files': {'$$description': ['Legacy way of defining scripts (entry-points are preferred).', 'Equivalent to the ``script`` keyword in ``setup.py``', '(it was renamed to avoid confusion with entry-point based ``project.scripts``', 'defined in :pep:`621`).', '**DISCOURAGED**: generic script wrappers are tricky and may not work properly.', 'Whenever possible, please use ``project.scripts`` instead.'], 'type': 'array', 'items': {'type': 'string'}, '$comment': 'TODO: is this field deprecated/should be removed?'}, 'eager-resources': {'$$description': ['Resources that should be extracted together, if any of them is needed,', 'or if any C extensions included in the project are imported.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'array', 'items': {'type': 'string'}}, 'packages': {'$$description': ['Packages that should be included in the distribution.', 'It can be given either as a list of package identifiers', 'or as a ``dict``-like structure with a single key ``find``', 'which corresponds to a dynamic call to', '``setuptools.config.expand.find_packages`` function.', 'The ``find`` key is associated with a nested ``dict``-like structure that can', 'contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,', 'mimicking the keyword arguments of the associated function.'], 'oneOf': [{'title': 'Array of Python package identifiers', 'type': 'array', 'items': {'$ref': '#/definitions/package-name'}}, {'$ref': '#/definitions/find-directive'}]}, 'package-dir': {'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'const': ''}, {'$ref': '#/definitions/package-name'}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, 'package-data': {'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'include-package-data': {'$$description': ['Automatically include any data files inside the package directories', 'that are specified by ``MANIFEST.in``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'boolean'}, 'exclude-package-data': {'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'namespace-packages': {'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'https://setuptools.pypa.io/en/latest/userguide/package_discovery.html', 'description': '**DEPRECATED**: use implicit namespaces instead (:pep:`420`).'}, 'py-modules': {'description': 'Modules that setuptools will manipulate', 'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'TODO: clarify the relationship with ``packages``'}, 'data-files': {'$$description': ['``dict``-like structure where each key represents a directory and', 'the value is a list of glob patterns that should be installed in them.', '**DISCOURAGED**: please notice this might not work as expected with wheels.', 'Whenever possible, consider using data files inside the package directories', '(or create a new namespace package that only contains data files).', 'See `data files support', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'cmdclass': {'$$description': ['Mapping of distutils-style command names to ``setuptools.Command`` subclasses', 'which in turn should be represented by strings with a qualified class name', '(i.e., \"dotted\" form with module), e.g.::\\n\\n', '    cmdclass = {mycmd = \"pkg.subpkg.module.CommandClass\"}\\n\\n', 'The command class should be a directly defined at the top-level of the', 'containing module (no class nesting).'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'string', 'format': 'python-qualified-identifier'}}}, 'license-files': {'type': 'array', 'items': {'type': 'string'}, '$$description': ['**PROVISIONAL**: list of glob patterns for all license files being distributed.', '(likely to become standard with :pep:`639`).', \"By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``\"], '$comment': 'TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?'}, 'dynamic': {'type': 'object', 'description': 'Instructions for loading :pep:`621`-related metadata dynamically', 'additionalProperties': False, 'properties': {'version': {'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.', 'Also ensure to set ``project.dynamic`` accordingly.'], 'oneOf': [{'$ref': '#/definitions/attr-directive'}, {'$ref': '#/definitions/file-directive'}]}, 'classifiers': {'$ref': '#/definitions/file-directive'}, 'description': {'$ref': '#/definitions/file-directive'}, 'entry-points': {'$ref': '#/definitions/file-directive'}, 'dependencies': {'$ref': '#/definitions/file-directive-for-dependencies'}, 'optional-dependencies': {'type': 'object', 'propertyNames': {'type': 'string', 'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'$ref': '#/definitions/file-directive-for-dependencies'}}}, 'readme': {'type': 'object', 'anyOf': [{'$ref': '#/definitions/file-directive'}, {'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'$ref': '#/definitions/file-directive/properties/file'}}, 'additionalProperties': False}], 'required': ['file']}}}}, 'definitions': {'package-name': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}, 'file-directive': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'file-directive-for-dependencies': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}, 'attr-directive': {'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, 'find-directive': {'$id': '#/definitions/find-directive', 'title': \"'find:' directive\", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}}}}}}, 'project': {'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://packaging.python.org/en/latest/specifications/pyproject-toml/', 'title': 'Package metadata stored in the ``project`` table', '$$description': ['Data structure for the **project** table inside ``pyproject.toml``', '(as initially defined in :pep:`621`)'], 'type': 'object', 'properties': {'name': {'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, 'version': {'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, 'description': {'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, 'readme': {'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', \"with meaning similar to the one defined in `core metadata's Description\", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, 'requires-python': {'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, 'license': {'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, 'authors': {'type': 'array', 'items': {'$ref': '#/definitions/author'}, '$$description': [\"The people or organizations considered to be the 'authors' of the project.\", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, 'maintainers': {'type': 'array', 'items': {'$ref': '#/definitions/author'}, '$$description': [\"The people or organizations considered to be the 'maintainers' of the project.\", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, 'keywords': {'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, 'classifiers': {'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, 'urls': {'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, 'scripts': {'$ref': '#/definitions/entry-point-group', '$$description': ['Instruct the installer to create command-line wrappers for the given', '`entry points <https://packaging.python.org/specifications/entry-points/>`_.']}, 'gui-scripts': {'$ref': '#/definitions/entry-point-group', '$$description': ['Instruct the installer to create GUI wrappers for the given', '`entry points <https://packaging.python.org/specifications/entry-points/>`_.', 'The difference between ``scripts`` and ``gui-scripts`` is only relevant in', 'Windows.']}, 'entry-points': {'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$ref': '#/definitions/entry-point-group'}}}, 'dependencies': {'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$ref': '#/definitions/dependency'}}, 'optional-dependencies': {'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$ref': '#/definitions/dependency'}}}}, 'dynamic': {'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}}, 'required': ['name'], 'additionalProperties': False, 'if': {'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as \"Required\", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, 'then': {'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, 'definitions': {'author': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, 'entry-point-group': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'dependency': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, rule='additionalProperties')\n    return data\n\ndef validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html(data, custom_formats={}, name_prefix=None):\n    if not isinstance(data, (dict)):\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be object\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html', 'title': '``tool.setuptools`` table', '$$description': ['``setuptools``-specific configurations that can be set by users that require', 'customization.', 'These configurations are completely optional and probably can be skipped when', 'creating simple packages. They are equivalent to some of the `Keywords', '<https://setuptools.pypa.io/en/latest/references/keywords.html>`_', 'used by the ``setup.py`` file, and can be set via the ``tool.setuptools`` table.', 'It considers only ``setuptools`` `parameters', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#setuptools-specific-configuration>`_', 'that are not covered by :pep:`621`; and intentionally excludes ``dependency_links``', 'and ``setup_requires`` (incompatible with modern workflows/standards).'], 'type': 'object', 'additionalProperties': False, 'properties': {'platforms': {'type': 'array', 'items': {'type': 'string'}}, 'provides': {'$$description': ['Package and virtual package names contained within this package', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'obsoletes': {'$$description': ['Packages which this package renders obsolete', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'zip-safe': {'$$description': ['Whether the project can be safely installed and run from a zip file.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'boolean'}, 'script-files': {'$$description': ['Legacy way of defining scripts (entry-points are preferred).', 'Equivalent to the ``script`` keyword in ``setup.py``', '(it was renamed to avoid confusion with entry-point based ``project.scripts``', 'defined in :pep:`621`).', '**DISCOURAGED**: generic script wrappers are tricky and may not work properly.', 'Whenever possible, please use ``project.scripts`` instead.'], 'type': 'array', 'items': {'type': 'string'}, '$comment': 'TODO: is this field deprecated/should be removed?'}, 'eager-resources': {'$$description': ['Resources that should be extracted together, if any of them is needed,', 'or if any C extensions included in the project are imported.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'array', 'items': {'type': 'string'}}, 'packages': {'$$description': ['Packages that should be included in the distribution.', 'It can be given either as a list of package identifiers', 'or as a ``dict``-like structure with a single key ``find``', 'which corresponds to a dynamic call to', '``setuptools.config.expand.find_packages`` function.', 'The ``find`` key is associated with a nested ``dict``-like structure that can', 'contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,', 'mimicking the keyword arguments of the associated function.'], 'oneOf': [{'title': 'Array of Python package identifiers', 'type': 'array', 'items': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}}, {'$id': '#/definitions/find-directive', 'title': \"'find:' directive\", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}]}, 'package-dir': {'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, 'package-data': {'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'include-package-data': {'$$description': ['Automatically include any data files inside the package directories', 'that are specified by ``MANIFEST.in``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'boolean'}, 'exclude-package-data': {'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'namespace-packages': {'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'https://setuptools.pypa.io/en/latest/userguide/package_discovery.html', 'description': '**DEPRECATED**: use implicit namespaces instead (:pep:`420`).'}, 'py-modules': {'description': 'Modules that setuptools will manipulate', 'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'TODO: clarify the relationship with ``packages``'}, 'data-files': {'$$description': ['``dict``-like structure where each key represents a directory and', 'the value is a list of glob patterns that should be installed in them.', '**DISCOURAGED**: please notice this might not work as expected with wheels.', 'Whenever possible, consider using data files inside the package directories', '(or create a new namespace package that only contains data files).', 'See `data files support', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'cmdclass': {'$$description': ['Mapping of distutils-style command names to ``setuptools.Command`` subclasses', 'which in turn should be represented by strings with a qualified class name', '(i.e., \"dotted\" form with module), e.g.::\\n\\n', '    cmdclass = {mycmd = \"pkg.subpkg.module.CommandClass\"}\\n\\n', 'The command class should be a directly defined at the top-level of the', 'containing module (no class nesting).'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'string', 'format': 'python-qualified-identifier'}}}, 'license-files': {'type': 'array', 'items': {'type': 'string'}, '$$description': ['**PROVISIONAL**: list of glob patterns for all license files being distributed.', '(likely to become standard with :pep:`639`).', \"By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``\"], '$comment': 'TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?'}, 'dynamic': {'type': 'object', 'description': 'Instructions for loading :pep:`621`-related metadata dynamically', 'additionalProperties': False, 'properties': {'version': {'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.', 'Also ensure to set ``project.dynamic`` accordingly.'], 'oneOf': [{'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, 'classifiers': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'description': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'entry-points': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'dependencies': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}, 'optional-dependencies': {'type': 'object', 'propertyNames': {'type': 'string', 'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}}}, 'readme': {'type': 'object', 'anyOf': [{'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'additionalProperties': False}], 'required': ['file']}}}}, 'definitions': {'package-name': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}, 'file-directive': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'file-directive-for-dependencies': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, 'attr-directive': {'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, 'find-directive': {'$id': '#/definitions/find-directive', 'title': \"'find:' directive\", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}}}, rule='type')\n    data_is_dict = isinstance(data, dict)\n    if data_is_dict:\n        data_keys = set(data.keys())\n        if \"platforms\" in data_keys:\n            data_keys.remove(\"platforms\")\n            data__platforms = data[\"platforms\"]\n            if not isinstance(data__platforms, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".platforms must be array\", value=data__platforms, name=\"\" + (name_prefix or \"data\") + \".platforms\", definition={'type': 'array', 'items': {'type': 'string'}}, rule='type')\n            data__platforms_is_list = isinstance(data__platforms, (list, tuple))\n            if data__platforms_is_list:\n                data__platforms_len = len(data__platforms)\n                for data__platforms_x, data__platforms_item in enumerate(data__platforms):\n                    if not isinstance(data__platforms_item, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".platforms[{data__platforms_x}]\".format(**locals()) + \" must be string\", value=data__platforms_item, name=\"\" + (name_prefix or \"data\") + \".platforms[{data__platforms_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n        if \"provides\" in data_keys:\n            data_keys.remove(\"provides\")\n            data__provides = data[\"provides\"]\n            if not isinstance(data__provides, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".provides must be array\", value=data__provides, name=\"\" + (name_prefix or \"data\") + \".provides\", definition={'$$description': ['Package and virtual package names contained within this package', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, rule='type')\n            data__provides_is_list = isinstance(data__provides, (list, tuple))\n            if data__provides_is_list:\n                data__provides_len = len(data__provides)\n                for data__provides_x, data__provides_item in enumerate(data__provides):\n                    if not isinstance(data__provides_item, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".provides[{data__provides_x}]\".format(**locals()) + \" must be string\", value=data__provides_item, name=\"\" + (name_prefix or \"data\") + \".provides[{data__provides_x}]\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'pep508-identifier'}, rule='type')\n                    if isinstance(data__provides_item, str):\n                        if not custom_formats[\"pep508-identifier\"](data__provides_item):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".provides[{data__provides_x}]\".format(**locals()) + \" must be pep508-identifier\", value=data__provides_item, name=\"\" + (name_prefix or \"data\") + \".provides[{data__provides_x}]\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'pep508-identifier'}, rule='format')\n        if \"obsoletes\" in data_keys:\n            data_keys.remove(\"obsoletes\")\n            data__obsoletes = data[\"obsoletes\"]\n            if not isinstance(data__obsoletes, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".obsoletes must be array\", value=data__obsoletes, name=\"\" + (name_prefix or \"data\") + \".obsoletes\", definition={'$$description': ['Packages which this package renders obsolete', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, rule='type')\n            data__obsoletes_is_list = isinstance(data__obsoletes, (list, tuple))\n            if data__obsoletes_is_list:\n                data__obsoletes_len = len(data__obsoletes)\n                for data__obsoletes_x, data__obsoletes_item in enumerate(data__obsoletes):\n                    if not isinstance(data__obsoletes_item, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".obsoletes[{data__obsoletes_x}]\".format(**locals()) + \" must be string\", value=data__obsoletes_item, name=\"\" + (name_prefix or \"data\") + \".obsoletes[{data__obsoletes_x}]\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'pep508-identifier'}, rule='type')\n                    if isinstance(data__obsoletes_item, str):\n                        if not custom_formats[\"pep508-identifier\"](data__obsoletes_item):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".obsoletes[{data__obsoletes_x}]\".format(**locals()) + \" must be pep508-identifier\", value=data__obsoletes_item, name=\"\" + (name_prefix or \"data\") + \".obsoletes[{data__obsoletes_x}]\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'pep508-identifier'}, rule='format')\n        if \"zip-safe\" in data_keys:\n            data_keys.remove(\"zip-safe\")\n            data__zipsafe = data[\"zip-safe\"]\n            if not isinstance(data__zipsafe, (bool)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".zip-safe must be boolean\", value=data__zipsafe, name=\"\" + (name_prefix or \"data\") + \".zip-safe\", definition={'$$description': ['Whether the project can be safely installed and run from a zip file.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'boolean'}, rule='type')\n        if \"script-files\" in data_keys:\n            data_keys.remove(\"script-files\")\n            data__scriptfiles = data[\"script-files\"]\n            if not isinstance(data__scriptfiles, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".script-files must be array\", value=data__scriptfiles, name=\"\" + (name_prefix or \"data\") + \".script-files\", definition={'$$description': ['Legacy way of defining scripts (entry-points are preferred).', 'Equivalent to the ``script`` keyword in ``setup.py``', '(it was renamed to avoid confusion with entry-point based ``project.scripts``', 'defined in :pep:`621`).', '**DISCOURAGED**: generic script wrappers are tricky and may not work properly.', 'Whenever possible, please use ``project.scripts`` instead.'], 'type': 'array', 'items': {'type': 'string'}, '$comment': 'TODO: is this field deprecated/should be removed?'}, rule='type')\n            data__scriptfiles_is_list = isinstance(data__scriptfiles, (list, tuple))\n            if data__scriptfiles_is_list:\n                data__scriptfiles_len = len(data__scriptfiles)\n                for data__scriptfiles_x, data__scriptfiles_item in enumerate(data__scriptfiles):\n                    if not isinstance(data__scriptfiles_item, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".script-files[{data__scriptfiles_x}]\".format(**locals()) + \" must be string\", value=data__scriptfiles_item, name=\"\" + (name_prefix or \"data\") + \".script-files[{data__scriptfiles_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n        if \"eager-resources\" in data_keys:\n            data_keys.remove(\"eager-resources\")\n            data__eagerresources = data[\"eager-resources\"]\n            if not isinstance(data__eagerresources, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".eager-resources must be array\", value=data__eagerresources, name=\"\" + (name_prefix or \"data\") + \".eager-resources\", definition={'$$description': ['Resources that should be extracted together, if any of them is needed,', 'or if any C extensions included in the project are imported.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'array', 'items': {'type': 'string'}}, rule='type')\n            data__eagerresources_is_list = isinstance(data__eagerresources, (list, tuple))\n            if data__eagerresources_is_list:\n                data__eagerresources_len = len(data__eagerresources)\n                for data__eagerresources_x, data__eagerresources_item in enumerate(data__eagerresources):\n                    if not isinstance(data__eagerresources_item, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".eager-resources[{data__eagerresources_x}]\".format(**locals()) + \" must be string\", value=data__eagerresources_item, name=\"\" + (name_prefix or \"data\") + \".eager-resources[{data__eagerresources_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n        if \"packages\" in data_keys:\n            data_keys.remove(\"packages\")\n            data__packages = data[\"packages\"]\n            data__packages_one_of_count1 = 0\n            if data__packages_one_of_count1 < 2:\n                try:\n                    if not isinstance(data__packages, (list, tuple)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".packages must be array\", value=data__packages, name=\"\" + (name_prefix or \"data\") + \".packages\", definition={'title': 'Array of Python package identifiers', 'type': 'array', 'items': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}}, rule='type')\n                    data__packages_is_list = isinstance(data__packages, (list, tuple))\n                    if data__packages_is_list:\n                        data__packages_len = len(data__packages)\n                        for data__packages_x, data__packages_item in enumerate(data__packages):\n                            validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_package_name(data__packages_item, custom_formats, (name_prefix or \"data\") + \".packages[{data__packages_x}]\".format(**locals()))\n                    data__packages_one_of_count1 += 1\n                except JsonSchemaValueException: pass\n            if data__packages_one_of_count1 < 2:\n                try:\n                    validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_find_directive(data__packages, custom_formats, (name_prefix or \"data\") + \".packages\")\n                    data__packages_one_of_count1 += 1\n                except JsonSchemaValueException: pass\n            if data__packages_one_of_count1 != 1:\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".packages must be valid exactly by one definition\" + (\" (\" + str(data__packages_one_of_count1) + \" matches found)\"), value=data__packages, name=\"\" + (name_prefix or \"data\") + \".packages\", definition={'$$description': ['Packages that should be included in the distribution.', 'It can be given either as a list of package identifiers', 'or as a ``dict``-like structure with a single key ``find``', 'which corresponds to a dynamic call to', '``setuptools.config.expand.find_packages`` function.', 'The ``find`` key is associated with a nested ``dict``-like structure that can', 'contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,', 'mimicking the keyword arguments of the associated function.'], 'oneOf': [{'title': 'Array of Python package identifiers', 'type': 'array', 'items': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}}, {'$id': '#/definitions/find-directive', 'title': \"'find:' directive\", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}]}, rule='oneOf')\n        if \"package-dir\" in data_keys:\n            data_keys.remove(\"package-dir\")\n            data__packagedir = data[\"package-dir\"]\n            if not isinstance(data__packagedir, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-dir must be object\", value=data__packagedir, name=\"\" + (name_prefix or \"data\") + \".package-dir\", definition={'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, rule='type')\n            data__packagedir_is_dict = isinstance(data__packagedir, dict)\n            if data__packagedir_is_dict:\n                data__packagedir_keys = set(data__packagedir.keys())\n                for data__packagedir_key, data__packagedir_val in data__packagedir.items():\n                    if REGEX_PATTERNS['^.*$'].search(data__packagedir_key):\n                        if data__packagedir_key in data__packagedir_keys:\n                            data__packagedir_keys.remove(data__packagedir_key)\n                        if not isinstance(data__packagedir_val, (str)):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-dir.{data__packagedir_key}\".format(**locals()) + \" must be string\", value=data__packagedir_val, name=\"\" + (name_prefix or \"data\") + \".package-dir.{data__packagedir_key}\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n                if data__packagedir_keys:\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-dir must not contain \"+str(data__packagedir_keys)+\" properties\", value=data__packagedir, name=\"\" + (name_prefix or \"data\") + \".package-dir\", definition={'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, rule='additionalProperties')\n                data__packagedir_len = len(data__packagedir)\n                if data__packagedir_len != 0:\n                    data__packagedir_property_names = True\n                    for data__packagedir_key in data__packagedir:\n                        try:\n                            data__packagedir_key_any_of_count2 = 0\n                            if not data__packagedir_key_any_of_count2:\n                                try:\n                                    if data__packagedir_key != \"\":\n                                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-dir must be same as const definition: \", value=data__packagedir_key, name=\"\" + (name_prefix or \"data\") + \".package-dir\", definition={'const': ''}, rule='const')\n                                    data__packagedir_key_any_of_count2 += 1\n                                except JsonSchemaValueException: pass\n                            if not data__packagedir_key_any_of_count2:\n                                try:\n                                    validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_package_name(data__packagedir_key, custom_formats, (name_prefix or \"data\") + \".package-dir\")\n                                    data__packagedir_key_any_of_count2 += 1\n                                except JsonSchemaValueException: pass\n                            if not data__packagedir_key_any_of_count2:\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-dir cannot be validated by any definition\", value=data__packagedir_key, name=\"\" + (name_prefix or \"data\") + \".package-dir\", definition={'anyOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}]}, rule='anyOf')\n                        except JsonSchemaValueException:\n                            data__packagedir_property_names = False\n                    if not data__packagedir_property_names:\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-dir must be named by propertyName definition\", value=data__packagedir, name=\"\" + (name_prefix or \"data\") + \".package-dir\", definition={'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, rule='propertyNames')\n        if \"package-data\" in data_keys:\n            data_keys.remove(\"package-data\")\n            data__packagedata = data[\"package-data\"]\n            if not isinstance(data__packagedata, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-data must be object\", value=data__packagedata, name=\"\" + (name_prefix or \"data\") + \".package-data\", definition={'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='type')\n            data__packagedata_is_dict = isinstance(data__packagedata, dict)\n            if data__packagedata_is_dict:\n                data__packagedata_keys = set(data__packagedata.keys())\n                for data__packagedata_key, data__packagedata_val in data__packagedata.items():\n                    if REGEX_PATTERNS['^.*$'].search(data__packagedata_key):\n                        if data__packagedata_key in data__packagedata_keys:\n                            data__packagedata_keys.remove(data__packagedata_key)\n                        if not isinstance(data__packagedata_val, (list, tuple)):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-data.{data__packagedata_key}\".format(**locals()) + \" must be array\", value=data__packagedata_val, name=\"\" + (name_prefix or \"data\") + \".package-data.{data__packagedata_key}\".format(**locals()) + \"\", definition={'type': 'array', 'items': {'type': 'string'}}, rule='type')\n                        data__packagedata_val_is_list = isinstance(data__packagedata_val, (list, tuple))\n                        if data__packagedata_val_is_list:\n                            data__packagedata_val_len = len(data__packagedata_val)\n                            for data__packagedata_val_x, data__packagedata_val_item in enumerate(data__packagedata_val):\n                                if not isinstance(data__packagedata_val_item, (str)):\n                                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-data.{data__packagedata_key}[{data__packagedata_val_x}]\".format(**locals()) + \" must be string\", value=data__packagedata_val_item, name=\"\" + (name_prefix or \"data\") + \".package-data.{data__packagedata_key}[{data__packagedata_val_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n                if data__packagedata_keys:\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-data must not contain \"+str(data__packagedata_keys)+\" properties\", value=data__packagedata, name=\"\" + (name_prefix or \"data\") + \".package-data\", definition={'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='additionalProperties')\n                data__packagedata_len = len(data__packagedata)\n                if data__packagedata_len != 0:\n                    data__packagedata_property_names = True\n                    for data__packagedata_key in data__packagedata:\n                        try:\n                            data__packagedata_key_any_of_count3 = 0\n                            if not data__packagedata_key_any_of_count3:\n                                try:\n                                    if not isinstance(data__packagedata_key, (str)):\n                                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-data must be string\", value=data__packagedata_key, name=\"\" + (name_prefix or \"data\") + \".package-data\", definition={'type': 'string', 'format': 'python-module-name'}, rule='type')\n                                    if isinstance(data__packagedata_key, str):\n                                        if not custom_formats[\"python-module-name\"](data__packagedata_key):\n                                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-data must be python-module-name\", value=data__packagedata_key, name=\"\" + (name_prefix or \"data\") + \".package-data\", definition={'type': 'string', 'format': 'python-module-name'}, rule='format')\n                                    data__packagedata_key_any_of_count3 += 1\n                                except JsonSchemaValueException: pass\n                            if not data__packagedata_key_any_of_count3:\n                                try:\n                                    if data__packagedata_key != \"*\":\n                                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-data must be same as const definition: *\", value=data__packagedata_key, name=\"\" + (name_prefix or \"data\") + \".package-data\", definition={'const': '*'}, rule='const')\n                                    data__packagedata_key_any_of_count3 += 1\n                                except JsonSchemaValueException: pass\n                            if not data__packagedata_key_any_of_count3:\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-data cannot be validated by any definition\", value=data__packagedata_key, name=\"\" + (name_prefix or \"data\") + \".package-data\", definition={'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, rule='anyOf')\n                        except JsonSchemaValueException:\n                            data__packagedata_property_names = False\n                    if not data__packagedata_property_names:\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".package-data must be named by propertyName definition\", value=data__packagedata, name=\"\" + (name_prefix or \"data\") + \".package-data\", definition={'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='propertyNames')\n        if \"include-package-data\" in data_keys:\n            data_keys.remove(\"include-package-data\")\n            data__includepackagedata = data[\"include-package-data\"]\n            if not isinstance(data__includepackagedata, (bool)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".include-package-data must be boolean\", value=data__includepackagedata, name=\"\" + (name_prefix or \"data\") + \".include-package-data\", definition={'$$description': ['Automatically include any data files inside the package directories', 'that are specified by ``MANIFEST.in``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'boolean'}, rule='type')\n        if \"exclude-package-data\" in data_keys:\n            data_keys.remove(\"exclude-package-data\")\n            data__excludepackagedata = data[\"exclude-package-data\"]\n            if not isinstance(data__excludepackagedata, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".exclude-package-data must be object\", value=data__excludepackagedata, name=\"\" + (name_prefix or \"data\") + \".exclude-package-data\", definition={'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='type')\n            data__excludepackagedata_is_dict = isinstance(data__excludepackagedata, dict)\n            if data__excludepackagedata_is_dict:\n                data__excludepackagedata_keys = set(data__excludepackagedata.keys())\n                for data__excludepackagedata_key, data__excludepackagedata_val in data__excludepackagedata.items():\n                    if REGEX_PATTERNS['^.*$'].search(data__excludepackagedata_key):\n                        if data__excludepackagedata_key in data__excludepackagedata_keys:\n                            data__excludepackagedata_keys.remove(data__excludepackagedata_key)\n                        if not isinstance(data__excludepackagedata_val, (list, tuple)):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".exclude-package-data.{data__excludepackagedata_key}\".format(**locals()) + \" must be array\", value=data__excludepackagedata_val, name=\"\" + (name_prefix or \"data\") + \".exclude-package-data.{data__excludepackagedata_key}\".format(**locals()) + \"\", definition={'type': 'array', 'items': {'type': 'string'}}, rule='type')\n                        data__excludepackagedata_val_is_list = isinstance(data__excludepackagedata_val, (list, tuple))\n                        if data__excludepackagedata_val_is_list:\n                            data__excludepackagedata_val_len = len(data__excludepackagedata_val)\n                            for data__excludepackagedata_val_x, data__excludepackagedata_val_item in enumerate(data__excludepackagedata_val):\n                                if not isinstance(data__excludepackagedata_val_item, (str)):\n                                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".exclude-package-data.{data__excludepackagedata_key}[{data__excludepackagedata_val_x}]\".format(**locals()) + \" must be string\", value=data__excludepackagedata_val_item, name=\"\" + (name_prefix or \"data\") + \".exclude-package-data.{data__excludepackagedata_key}[{data__excludepackagedata_val_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n                if data__excludepackagedata_keys:\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".exclude-package-data must not contain \"+str(data__excludepackagedata_keys)+\" properties\", value=data__excludepackagedata, name=\"\" + (name_prefix or \"data\") + \".exclude-package-data\", definition={'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='additionalProperties')\n                data__excludepackagedata_len = len(data__excludepackagedata)\n                if data__excludepackagedata_len != 0:\n                    data__excludepackagedata_property_names = True\n                    for data__excludepackagedata_key in data__excludepackagedata:\n                        try:\n                            data__excludepackagedata_key_any_of_count4 = 0\n                            if not data__excludepackagedata_key_any_of_count4:\n                                try:\n                                    if not isinstance(data__excludepackagedata_key, (str)):\n                                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".exclude-package-data must be string\", value=data__excludepackagedata_key, name=\"\" + (name_prefix or \"data\") + \".exclude-package-data\", definition={'type': 'string', 'format': 'python-module-name'}, rule='type')\n                                    if isinstance(data__excludepackagedata_key, str):\n                                        if not custom_formats[\"python-module-name\"](data__excludepackagedata_key):\n                                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".exclude-package-data must be python-module-name\", value=data__excludepackagedata_key, name=\"\" + (name_prefix or \"data\") + \".exclude-package-data\", definition={'type': 'string', 'format': 'python-module-name'}, rule='format')\n                                    data__excludepackagedata_key_any_of_count4 += 1\n                                except JsonSchemaValueException: pass\n                            if not data__excludepackagedata_key_any_of_count4:\n                                try:\n                                    if data__excludepackagedata_key != \"*\":\n                                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".exclude-package-data must be same as const definition: *\", value=data__excludepackagedata_key, name=\"\" + (name_prefix or \"data\") + \".exclude-package-data\", definition={'const': '*'}, rule='const')\n                                    data__excludepackagedata_key_any_of_count4 += 1\n                                except JsonSchemaValueException: pass\n                            if not data__excludepackagedata_key_any_of_count4:\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".exclude-package-data cannot be validated by any definition\", value=data__excludepackagedata_key, name=\"\" + (name_prefix or \"data\") + \".exclude-package-data\", definition={'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, rule='anyOf')\n                        except JsonSchemaValueException:\n                            data__excludepackagedata_property_names = False\n                    if not data__excludepackagedata_property_names:\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".exclude-package-data must be named by propertyName definition\", value=data__excludepackagedata, name=\"\" + (name_prefix or \"data\") + \".exclude-package-data\", definition={'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='propertyNames')\n        if \"namespace-packages\" in data_keys:\n            data_keys.remove(\"namespace-packages\")\n            data__namespacepackages = data[\"namespace-packages\"]\n            if not isinstance(data__namespacepackages, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".namespace-packages must be array\", value=data__namespacepackages, name=\"\" + (name_prefix or \"data\") + \".namespace-packages\", definition={'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'https://setuptools.pypa.io/en/latest/userguide/package_discovery.html', 'description': '**DEPRECATED**: use implicit namespaces instead (:pep:`420`).'}, rule='type')\n            data__namespacepackages_is_list = isinstance(data__namespacepackages, (list, tuple))\n            if data__namespacepackages_is_list:\n                data__namespacepackages_len = len(data__namespacepackages)\n                for data__namespacepackages_x, data__namespacepackages_item in enumerate(data__namespacepackages):\n                    if not isinstance(data__namespacepackages_item, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".namespace-packages[{data__namespacepackages_x}]\".format(**locals()) + \" must be string\", value=data__namespacepackages_item, name=\"\" + (name_prefix or \"data\") + \".namespace-packages[{data__namespacepackages_x}]\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'python-module-name'}, rule='type')\n                    if isinstance(data__namespacepackages_item, str):\n                        if not custom_formats[\"python-module-name\"](data__namespacepackages_item):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".namespace-packages[{data__namespacepackages_x}]\".format(**locals()) + \" must be python-module-name\", value=data__namespacepackages_item, name=\"\" + (name_prefix or \"data\") + \".namespace-packages[{data__namespacepackages_x}]\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'python-module-name'}, rule='format')\n        if \"py-modules\" in data_keys:\n            data_keys.remove(\"py-modules\")\n            data__pymodules = data[\"py-modules\"]\n            if not isinstance(data__pymodules, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".py-modules must be array\", value=data__pymodules, name=\"\" + (name_prefix or \"data\") + \".py-modules\", definition={'description': 'Modules that setuptools will manipulate', 'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'TODO: clarify the relationship with ``packages``'}, rule='type')\n            data__pymodules_is_list = isinstance(data__pymodules, (list, tuple))\n            if data__pymodules_is_list:\n                data__pymodules_len = len(data__pymodules)\n                for data__pymodules_x, data__pymodules_item in enumerate(data__pymodules):\n                    if not isinstance(data__pymodules_item, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".py-modules[{data__pymodules_x}]\".format(**locals()) + \" must be string\", value=data__pymodules_item, name=\"\" + (name_prefix or \"data\") + \".py-modules[{data__pymodules_x}]\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'python-module-name'}, rule='type')\n                    if isinstance(data__pymodules_item, str):\n                        if not custom_formats[\"python-module-name\"](data__pymodules_item):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".py-modules[{data__pymodules_x}]\".format(**locals()) + \" must be python-module-name\", value=data__pymodules_item, name=\"\" + (name_prefix or \"data\") + \".py-modules[{data__pymodules_x}]\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'python-module-name'}, rule='format')\n        if \"data-files\" in data_keys:\n            data_keys.remove(\"data-files\")\n            data__datafiles = data[\"data-files\"]\n            if not isinstance(data__datafiles, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".data-files must be object\", value=data__datafiles, name=\"\" + (name_prefix or \"data\") + \".data-files\", definition={'$$description': ['``dict``-like structure where each key represents a directory and', 'the value is a list of glob patterns that should be installed in them.', '**DISCOURAGED**: please notice this might not work as expected with wheels.', 'Whenever possible, consider using data files inside the package directories', '(or create a new namespace package that only contains data files).', 'See `data files support', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, rule='type')\n            data__datafiles_is_dict = isinstance(data__datafiles, dict)\n            if data__datafiles_is_dict:\n                data__datafiles_keys = set(data__datafiles.keys())\n                for data__datafiles_key, data__datafiles_val in data__datafiles.items():\n                    if REGEX_PATTERNS['^.*$'].search(data__datafiles_key):\n                        if data__datafiles_key in data__datafiles_keys:\n                            data__datafiles_keys.remove(data__datafiles_key)\n                        if not isinstance(data__datafiles_val, (list, tuple)):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".data-files.{data__datafiles_key}\".format(**locals()) + \" must be array\", value=data__datafiles_val, name=\"\" + (name_prefix or \"data\") + \".data-files.{data__datafiles_key}\".format(**locals()) + \"\", definition={'type': 'array', 'items': {'type': 'string'}}, rule='type')\n                        data__datafiles_val_is_list = isinstance(data__datafiles_val, (list, tuple))\n                        if data__datafiles_val_is_list:\n                            data__datafiles_val_len = len(data__datafiles_val)\n                            for data__datafiles_val_x, data__datafiles_val_item in enumerate(data__datafiles_val):\n                                if not isinstance(data__datafiles_val_item, (str)):\n                                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".data-files.{data__datafiles_key}[{data__datafiles_val_x}]\".format(**locals()) + \" must be string\", value=data__datafiles_val_item, name=\"\" + (name_prefix or \"data\") + \".data-files.{data__datafiles_key}[{data__datafiles_val_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n        if \"cmdclass\" in data_keys:\n            data_keys.remove(\"cmdclass\")\n            data__cmdclass = data[\"cmdclass\"]\n            if not isinstance(data__cmdclass, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".cmdclass must be object\", value=data__cmdclass, name=\"\" + (name_prefix or \"data\") + \".cmdclass\", definition={'$$description': ['Mapping of distutils-style command names to ``setuptools.Command`` subclasses', 'which in turn should be represented by strings with a qualified class name', '(i.e., \"dotted\" form with module), e.g.::\\n\\n', '    cmdclass = {mycmd = \"pkg.subpkg.module.CommandClass\"}\\n\\n', 'The command class should be a directly defined at the top-level of the', 'containing module (no class nesting).'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'string', 'format': 'python-qualified-identifier'}}}, rule='type')\n            data__cmdclass_is_dict = isinstance(data__cmdclass, dict)\n            if data__cmdclass_is_dict:\n                data__cmdclass_keys = set(data__cmdclass.keys())\n                for data__cmdclass_key, data__cmdclass_val in data__cmdclass.items():\n                    if REGEX_PATTERNS['^.*$'].search(data__cmdclass_key):\n                        if data__cmdclass_key in data__cmdclass_keys:\n                            data__cmdclass_keys.remove(data__cmdclass_key)\n                        if not isinstance(data__cmdclass_val, (str)):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".cmdclass.{data__cmdclass_key}\".format(**locals()) + \" must be string\", value=data__cmdclass_val, name=\"\" + (name_prefix or \"data\") + \".cmdclass.{data__cmdclass_key}\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'python-qualified-identifier'}, rule='type')\n                        if isinstance(data__cmdclass_val, str):\n                            if not custom_formats[\"python-qualified-identifier\"](data__cmdclass_val):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".cmdclass.{data__cmdclass_key}\".format(**locals()) + \" must be python-qualified-identifier\", value=data__cmdclass_val, name=\"\" + (name_prefix or \"data\") + \".cmdclass.{data__cmdclass_key}\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'python-qualified-identifier'}, rule='format')\n        if \"license-files\" in data_keys:\n            data_keys.remove(\"license-files\")\n            data__licensefiles = data[\"license-files\"]\n            if not isinstance(data__licensefiles, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".license-files must be array\", value=data__licensefiles, name=\"\" + (name_prefix or \"data\") + \".license-files\", definition={'type': 'array', 'items': {'type': 'string'}, '$$description': ['**PROVISIONAL**: list of glob patterns for all license files being distributed.', '(likely to become standard with :pep:`639`).', \"By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``\"], '$comment': 'TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?'}, rule='type')\n            data__licensefiles_is_list = isinstance(data__licensefiles, (list, tuple))\n            if data__licensefiles_is_list:\n                data__licensefiles_len = len(data__licensefiles)\n                for data__licensefiles_x, data__licensefiles_item in enumerate(data__licensefiles):\n                    if not isinstance(data__licensefiles_item, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".license-files[{data__licensefiles_x}]\".format(**locals()) + \" must be string\", value=data__licensefiles_item, name=\"\" + (name_prefix or \"data\") + \".license-files[{data__licensefiles_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n        if \"dynamic\" in data_keys:\n            data_keys.remove(\"dynamic\")\n            data__dynamic = data[\"dynamic\"]\n            if not isinstance(data__dynamic, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic must be object\", value=data__dynamic, name=\"\" + (name_prefix or \"data\") + \".dynamic\", definition={'type': 'object', 'description': 'Instructions for loading :pep:`621`-related metadata dynamically', 'additionalProperties': False, 'properties': {'version': {'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.', 'Also ensure to set ``project.dynamic`` accordingly.'], 'oneOf': [{'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, 'classifiers': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'description': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'entry-points': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'dependencies': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}, 'optional-dependencies': {'type': 'object', 'propertyNames': {'type': 'string', 'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}}}, 'readme': {'type': 'object', 'anyOf': [{'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'additionalProperties': False}], 'required': ['file']}}}, rule='type')\n            data__dynamic_is_dict = isinstance(data__dynamic, dict)\n            if data__dynamic_is_dict:\n                data__dynamic_keys = set(data__dynamic.keys())\n                if \"version\" in data__dynamic_keys:\n                    data__dynamic_keys.remove(\"version\")\n                    data__dynamic__version = data__dynamic[\"version\"]\n                    data__dynamic__version_one_of_count5 = 0\n                    if data__dynamic__version_one_of_count5 < 2:\n                        try:\n                            validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_attr_directive(data__dynamic__version, custom_formats, (name_prefix or \"data\") + \".dynamic.version\")\n                            data__dynamic__version_one_of_count5 += 1\n                        except JsonSchemaValueException: pass\n                    if data__dynamic__version_one_of_count5 < 2:\n                        try:\n                            validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive(data__dynamic__version, custom_formats, (name_prefix or \"data\") + \".dynamic.version\")\n                            data__dynamic__version_one_of_count5 += 1\n                        except JsonSchemaValueException: pass\n                    if data__dynamic__version_one_of_count5 != 1:\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.version must be valid exactly by one definition\" + (\" (\" + str(data__dynamic__version_one_of_count5) + \" matches found)\"), value=data__dynamic__version, name=\"\" + (name_prefix or \"data\") + \".dynamic.version\", definition={'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.', 'Also ensure to set ``project.dynamic`` accordingly.'], 'oneOf': [{'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, rule='oneOf')\n                if \"classifiers\" in data__dynamic_keys:\n                    data__dynamic_keys.remove(\"classifiers\")\n                    data__dynamic__classifiers = data__dynamic[\"classifiers\"]\n                    validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive(data__dynamic__classifiers, custom_formats, (name_prefix or \"data\") + \".dynamic.classifiers\")\n                if \"description\" in data__dynamic_keys:\n                    data__dynamic_keys.remove(\"description\")\n                    data__dynamic__description = data__dynamic[\"description\"]\n                    validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive(data__dynamic__description, custom_formats, (name_prefix or \"data\") + \".dynamic.description\")\n                if \"entry-points\" in data__dynamic_keys:\n                    data__dynamic_keys.remove(\"entry-points\")\n                    data__dynamic__entrypoints = data__dynamic[\"entry-points\"]\n                    validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive(data__dynamic__entrypoints, custom_formats, (name_prefix or \"data\") + \".dynamic.entry-points\")\n                if \"dependencies\" in data__dynamic_keys:\n                    data__dynamic_keys.remove(\"dependencies\")\n                    data__dynamic__dependencies = data__dynamic[\"dependencies\"]\n                    validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive_for_dependencies(data__dynamic__dependencies, custom_formats, (name_prefix or \"data\") + \".dynamic.dependencies\")\n                if \"optional-dependencies\" in data__dynamic_keys:\n                    data__dynamic_keys.remove(\"optional-dependencies\")\n                    data__dynamic__optionaldependencies = data__dynamic[\"optional-dependencies\"]\n                    if not isinstance(data__dynamic__optionaldependencies, (dict)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.optional-dependencies must be object\", value=data__dynamic__optionaldependencies, name=\"\" + (name_prefix or \"data\") + \".dynamic.optional-dependencies\", definition={'type': 'object', 'propertyNames': {'type': 'string', 'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}}}, rule='type')\n                    data__dynamic__optionaldependencies_is_dict = isinstance(data__dynamic__optionaldependencies, dict)\n                    if data__dynamic__optionaldependencies_is_dict:\n                        data__dynamic__optionaldependencies_keys = set(data__dynamic__optionaldependencies.keys())\n                        for data__dynamic__optionaldependencies_key, data__dynamic__optionaldependencies_val in data__dynamic__optionaldependencies.items():\n                            if REGEX_PATTERNS['.+'].search(data__dynamic__optionaldependencies_key):\n                                if data__dynamic__optionaldependencies_key in data__dynamic__optionaldependencies_keys:\n                                    data__dynamic__optionaldependencies_keys.remove(data__dynamic__optionaldependencies_key)\n                                validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive_for_dependencies(data__dynamic__optionaldependencies_val, custom_formats, (name_prefix or \"data\") + \".dynamic.optional-dependencies.{data__dynamic__optionaldependencies_key}\".format(**locals()))\n                        if data__dynamic__optionaldependencies_keys:\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.optional-dependencies must not contain \"+str(data__dynamic__optionaldependencies_keys)+\" properties\", value=data__dynamic__optionaldependencies, name=\"\" + (name_prefix or \"data\") + \".dynamic.optional-dependencies\", definition={'type': 'object', 'propertyNames': {'type': 'string', 'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}}}, rule='additionalProperties')\n                        data__dynamic__optionaldependencies_len = len(data__dynamic__optionaldependencies)\n                        if data__dynamic__optionaldependencies_len != 0:\n                            data__dynamic__optionaldependencies_property_names = True\n                            for data__dynamic__optionaldependencies_key in data__dynamic__optionaldependencies:\n                                try:\n                                    if not isinstance(data__dynamic__optionaldependencies_key, (str)):\n                                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.optional-dependencies must be string\", value=data__dynamic__optionaldependencies_key, name=\"\" + (name_prefix or \"data\") + \".dynamic.optional-dependencies\", definition={'type': 'string', 'format': 'pep508-identifier'}, rule='type')\n                                    if isinstance(data__dynamic__optionaldependencies_key, str):\n                                        if not custom_formats[\"pep508-identifier\"](data__dynamic__optionaldependencies_key):\n                                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.optional-dependencies must be pep508-identifier\", value=data__dynamic__optionaldependencies_key, name=\"\" + (name_prefix or \"data\") + \".dynamic.optional-dependencies\", definition={'type': 'string', 'format': 'pep508-identifier'}, rule='format')\n                                except JsonSchemaValueException:\n                                    data__dynamic__optionaldependencies_property_names = False\n                            if not data__dynamic__optionaldependencies_property_names:\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.optional-dependencies must be named by propertyName definition\", value=data__dynamic__optionaldependencies, name=\"\" + (name_prefix or \"data\") + \".dynamic.optional-dependencies\", definition={'type': 'object', 'propertyNames': {'type': 'string', 'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}}}, rule='propertyNames')\n                if \"readme\" in data__dynamic_keys:\n                    data__dynamic_keys.remove(\"readme\")\n                    data__dynamic__readme = data__dynamic[\"readme\"]\n                    if not isinstance(data__dynamic__readme, (dict)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.readme must be object\", value=data__dynamic__readme, name=\"\" + (name_prefix or \"data\") + \".dynamic.readme\", definition={'type': 'object', 'anyOf': [{'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'additionalProperties': False}], 'required': ['file']}, rule='type')\n                    data__dynamic__readme_any_of_count6 = 0\n                    if not data__dynamic__readme_any_of_count6:\n                        try:\n                            validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive(data__dynamic__readme, custom_formats, (name_prefix or \"data\") + \".dynamic.readme\")\n                            data__dynamic__readme_any_of_count6 += 1\n                        except JsonSchemaValueException: pass\n                    if not data__dynamic__readme_any_of_count6:\n                        try:\n                            if not isinstance(data__dynamic__readme, (dict)):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.readme must be object\", value=data__dynamic__readme, name=\"\" + (name_prefix or \"data\") + \".dynamic.readme\", definition={'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'additionalProperties': False}, rule='type')\n                            data__dynamic__readme_is_dict = isinstance(data__dynamic__readme, dict)\n                            if data__dynamic__readme_is_dict:\n                                data__dynamic__readme_keys = set(data__dynamic__readme.keys())\n                                if \"content-type\" in data__dynamic__readme_keys:\n                                    data__dynamic__readme_keys.remove(\"content-type\")\n                                    data__dynamic__readme__contenttype = data__dynamic__readme[\"content-type\"]\n                                    if not isinstance(data__dynamic__readme__contenttype, (str)):\n                                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.readme.content-type must be string\", value=data__dynamic__readme__contenttype, name=\"\" + (name_prefix or \"data\") + \".dynamic.readme.content-type\", definition={'type': 'string'}, rule='type')\n                                if \"file\" in data__dynamic__readme_keys:\n                                    data__dynamic__readme_keys.remove(\"file\")\n                                    data__dynamic__readme__file = data__dynamic__readme[\"file\"]\n                                    validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive_properties_file(data__dynamic__readme__file, custom_formats, (name_prefix or \"data\") + \".dynamic.readme.file\")\n                                if data__dynamic__readme_keys:\n                                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.readme must not contain \"+str(data__dynamic__readme_keys)+\" properties\", value=data__dynamic__readme, name=\"\" + (name_prefix or \"data\") + \".dynamic.readme\", definition={'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'additionalProperties': False}, rule='additionalProperties')\n                            data__dynamic__readme_any_of_count6 += 1\n                        except JsonSchemaValueException: pass\n                    if not data__dynamic__readme_any_of_count6:\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.readme cannot be validated by any definition\", value=data__dynamic__readme, name=\"\" + (name_prefix or \"data\") + \".dynamic.readme\", definition={'type': 'object', 'anyOf': [{'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'additionalProperties': False}], 'required': ['file']}, rule='anyOf')\n                    data__dynamic__readme_is_dict = isinstance(data__dynamic__readme, dict)\n                    if data__dynamic__readme_is_dict:\n                        data__dynamic__readme__missing_keys = set(['file']) - data__dynamic__readme.keys()\n                        if data__dynamic__readme__missing_keys:\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic.readme must contain \" + (str(sorted(data__dynamic__readme__missing_keys)) + \" properties\"), value=data__dynamic__readme, name=\"\" + (name_prefix or \"data\") + \".dynamic.readme\", definition={'type': 'object', 'anyOf': [{'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'additionalProperties': False}], 'required': ['file']}, rule='required')\n                if data__dynamic_keys:\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic must not contain \"+str(data__dynamic_keys)+\" properties\", value=data__dynamic, name=\"\" + (name_prefix or \"data\") + \".dynamic\", definition={'type': 'object', 'description': 'Instructions for loading :pep:`621`-related metadata dynamically', 'additionalProperties': False, 'properties': {'version': {'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.', 'Also ensure to set ``project.dynamic`` accordingly.'], 'oneOf': [{'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, 'classifiers': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'description': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'entry-points': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'dependencies': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}, 'optional-dependencies': {'type': 'object', 'propertyNames': {'type': 'string', 'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}}}, 'readme': {'type': 'object', 'anyOf': [{'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'additionalProperties': False}], 'required': ['file']}}}, rule='additionalProperties')\n        if data_keys:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must not contain \"+str(data_keys)+\" properties\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html', 'title': '``tool.setuptools`` table', '$$description': ['``setuptools``-specific configurations that can be set by users that require', 'customization.', 'These configurations are completely optional and probably can be skipped when', 'creating simple packages. They are equivalent to some of the `Keywords', '<https://setuptools.pypa.io/en/latest/references/keywords.html>`_', 'used by the ``setup.py`` file, and can be set via the ``tool.setuptools`` table.', 'It considers only ``setuptools`` `parameters', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#setuptools-specific-configuration>`_', 'that are not covered by :pep:`621`; and intentionally excludes ``dependency_links``', 'and ``setup_requires`` (incompatible with modern workflows/standards).'], 'type': 'object', 'additionalProperties': False, 'properties': {'platforms': {'type': 'array', 'items': {'type': 'string'}}, 'provides': {'$$description': ['Package and virtual package names contained within this package', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'obsoletes': {'$$description': ['Packages which this package renders obsolete', '**(not supported by pip)**'], 'type': 'array', 'items': {'type': 'string', 'format': 'pep508-identifier'}}, 'zip-safe': {'$$description': ['Whether the project can be safely installed and run from a zip file.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'boolean'}, 'script-files': {'$$description': ['Legacy way of defining scripts (entry-points are preferred).', 'Equivalent to the ``script`` keyword in ``setup.py``', '(it was renamed to avoid confusion with entry-point based ``project.scripts``', 'defined in :pep:`621`).', '**DISCOURAGED**: generic script wrappers are tricky and may not work properly.', 'Whenever possible, please use ``project.scripts`` instead.'], 'type': 'array', 'items': {'type': 'string'}, '$comment': 'TODO: is this field deprecated/should be removed?'}, 'eager-resources': {'$$description': ['Resources that should be extracted together, if any of them is needed,', 'or if any C extensions included in the project are imported.', '**OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and', '``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).'], 'type': 'array', 'items': {'type': 'string'}}, 'packages': {'$$description': ['Packages that should be included in the distribution.', 'It can be given either as a list of package identifiers', 'or as a ``dict``-like structure with a single key ``find``', 'which corresponds to a dynamic call to', '``setuptools.config.expand.find_packages`` function.', 'The ``find`` key is associated with a nested ``dict``-like structure that can', 'contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys,', 'mimicking the keyword arguments of the associated function.'], 'oneOf': [{'title': 'Array of Python package identifiers', 'type': 'array', 'items': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}}, {'$id': '#/definitions/find-directive', 'title': \"'find:' directive\", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}]}, 'package-dir': {'$$description': [':class:`dict`-like structure mapping from package names to directories where their', 'code can be found.', 'The empty string (as key) means that all packages are contained inside', 'the given directory will be included in the distribution.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'const': ''}, {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}]}, 'patternProperties': {'^.*$': {'type': 'string'}}}, 'package-data': {'$$description': ['Mapping from package names to lists of glob patterns.', 'Usually this option is not needed when using ``include-package-data = true``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'include-package-data': {'$$description': ['Automatically include any data files inside the package directories', 'that are specified by ``MANIFEST.in``', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'boolean'}, 'exclude-package-data': {'$$description': ['Mapping from package names to lists of glob patterns that should be excluded', 'For more information on how to include data files, check ``setuptools`` `docs', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'additionalProperties': False, 'propertyNames': {'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'const': '*'}]}, 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'namespace-packages': {'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'https://setuptools.pypa.io/en/latest/userguide/package_discovery.html', 'description': '**DEPRECATED**: use implicit namespaces instead (:pep:`420`).'}, 'py-modules': {'description': 'Modules that setuptools will manipulate', 'type': 'array', 'items': {'type': 'string', 'format': 'python-module-name'}, '$comment': 'TODO: clarify the relationship with ``packages``'}, 'data-files': {'$$description': ['``dict``-like structure where each key represents a directory and', 'the value is a list of glob patterns that should be installed in them.', '**DISCOURAGED**: please notice this might not work as expected with wheels.', 'Whenever possible, consider using data files inside the package directories', '(or create a new namespace package that only contains data files).', 'See `data files support', '<https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'array', 'items': {'type': 'string'}}}}, 'cmdclass': {'$$description': ['Mapping of distutils-style command names to ``setuptools.Command`` subclasses', 'which in turn should be represented by strings with a qualified class name', '(i.e., \"dotted\" form with module), e.g.::\\n\\n', '    cmdclass = {mycmd = \"pkg.subpkg.module.CommandClass\"}\\n\\n', 'The command class should be a directly defined at the top-level of the', 'containing module (no class nesting).'], 'type': 'object', 'patternProperties': {'^.*$': {'type': 'string', 'format': 'python-qualified-identifier'}}}, 'license-files': {'type': 'array', 'items': {'type': 'string'}, '$$description': ['**PROVISIONAL**: list of glob patterns for all license files being distributed.', '(likely to become standard with :pep:`639`).', \"By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``\"], '$comment': 'TODO: revise if PEP 639 is accepted. Probably ``project.license-files``?'}, 'dynamic': {'type': 'object', 'description': 'Instructions for loading :pep:`621`-related metadata dynamically', 'additionalProperties': False, 'properties': {'version': {'$$description': ['A version dynamically loaded via either the ``attr:`` or ``file:``', 'directives. Please make sure the given file or attribute respects :pep:`440`.', 'Also ensure to set ``project.dynamic`` accordingly.'], 'oneOf': [{'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, 'classifiers': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'description': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'entry-points': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'dependencies': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}, 'optional-dependencies': {'type': 'object', 'propertyNames': {'type': 'string', 'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'.+': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$ref': '#/definitions/file-directive'}]}}}, 'readme': {'type': 'object', 'anyOf': [{'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, {'type': 'object', 'properties': {'content-type': {'type': 'string'}, 'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'additionalProperties': False}], 'required': ['file']}}}}, 'definitions': {'package-name': {'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}, 'file-directive': {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, 'file-directive-for-dependencies': {'title': \"'file:' directive for dependencies\", 'allOf': [{'$$description': ['**BETA**: subset of the ``requirements.txt`` format', 'without ``pip`` flags and options', '(one :pep:`508`-compliant string per line,', 'lines that are blank or start with ``#`` are excluded).', 'See `dynamic metadata', '<https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#dynamic-metadata>`_.']}, {'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}]}, 'attr-directive': {'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, 'find-directive': {'$id': '#/definitions/find-directive', 'title': \"'find:' directive\", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}}}, rule='additionalProperties')\n    return data\n\ndef validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive_properties_file(data, custom_formats={}, name_prefix=None):\n    data_one_of_count7 = 0\n    if data_one_of_count7 < 2:\n        try:\n            if not isinstance(data, (str)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be string\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'type': 'string'}, rule='type')\n            data_one_of_count7 += 1\n        except JsonSchemaValueException: pass\n    if data_one_of_count7 < 2:\n        try:\n            if not isinstance(data, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be array\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'type': 'array', 'items': {'type': 'string'}}, rule='type')\n            data_is_list = isinstance(data, (list, tuple))\n            if data_is_list:\n                data_len = len(data)\n                for data_x, data_item in enumerate(data):\n                    if not isinstance(data_item, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \"[{data_x}]\".format(**locals()) + \" must be string\", value=data_item, name=\"\" + (name_prefix or \"data\") + \"[{data_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n            data_one_of_count7 += 1\n        except JsonSchemaValueException: pass\n    if data_one_of_count7 != 1:\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be valid exactly by one definition\" + (\" (\" + str(data_one_of_count7) + \" matches found)\"), value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}, rule='oneOf')\n    return data\n\ndef validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive_for_dependencies(data, custom_formats={}, name_prefix=None):\n    validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive(data, custom_formats, (name_prefix or \"data\") + \"\")\n    return data\n\ndef validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_file_directive(data, custom_formats={}, name_prefix=None):\n    if not isinstance(data, (dict)):\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be object\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, rule='type')\n    data_is_dict = isinstance(data, dict)\n    if data_is_dict:\n        data__missing_keys = set(['file']) - data.keys()\n        if data__missing_keys:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must contain \" + (str(sorted(data__missing_keys)) + \" properties\"), value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, rule='required')\n        data_keys = set(data.keys())\n        if \"file\" in data_keys:\n            data_keys.remove(\"file\")\n            data__file = data[\"file\"]\n            data__file_one_of_count8 = 0\n            if data__file_one_of_count8 < 2:\n                try:\n                    if not isinstance(data__file, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".file must be string\", value=data__file, name=\"\" + (name_prefix or \"data\") + \".file\", definition={'type': 'string'}, rule='type')\n                    data__file_one_of_count8 += 1\n                except JsonSchemaValueException: pass\n            if data__file_one_of_count8 < 2:\n                try:\n                    if not isinstance(data__file, (list, tuple)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".file must be array\", value=data__file, name=\"\" + (name_prefix or \"data\") + \".file\", definition={'type': 'array', 'items': {'type': 'string'}}, rule='type')\n                    data__file_is_list = isinstance(data__file, (list, tuple))\n                    if data__file_is_list:\n                        data__file_len = len(data__file)\n                        for data__file_x, data__file_item in enumerate(data__file):\n                            if not isinstance(data__file_item, (str)):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".file[{data__file_x}]\".format(**locals()) + \" must be string\", value=data__file_item, name=\"\" + (name_prefix or \"data\") + \".file[{data__file_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n                    data__file_one_of_count8 += 1\n                except JsonSchemaValueException: pass\n            if data__file_one_of_count8 != 1:\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".file must be valid exactly by one definition\" + (\" (\" + str(data__file_one_of_count8) + \" matches found)\"), value=data__file, name=\"\" + (name_prefix or \"data\") + \".file\", definition={'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}, rule='oneOf')\n        if data_keys:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must not contain \"+str(data_keys)+\" properties\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/file-directive', 'title': \"'file:' directive\", 'description': 'Value is read from a file (or list of files and then concatenated)', 'type': 'object', 'additionalProperties': False, 'properties': {'file': {'oneOf': [{'type': 'string'}, {'type': 'array', 'items': {'type': 'string'}}]}}, 'required': ['file']}, rule='additionalProperties')\n    return data\n\ndef validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_attr_directive(data, custom_formats={}, name_prefix=None):\n    if not isinstance(data, (dict)):\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be object\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, rule='type')\n    data_is_dict = isinstance(data, dict)\n    if data_is_dict:\n        data__missing_keys = set(['attr']) - data.keys()\n        if data__missing_keys:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must contain \" + (str(sorted(data__missing_keys)) + \" properties\"), value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, rule='required')\n        data_keys = set(data.keys())\n        if \"attr\" in data_keys:\n            data_keys.remove(\"attr\")\n            data__attr = data[\"attr\"]\n            if not isinstance(data__attr, (str)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".attr must be string\", value=data__attr, name=\"\" + (name_prefix or \"data\") + \".attr\", definition={'type': 'string', 'format': 'python-qualified-identifier'}, rule='type')\n            if isinstance(data__attr, str):\n                if not custom_formats[\"python-qualified-identifier\"](data__attr):\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".attr must be python-qualified-identifier\", value=data__attr, name=\"\" + (name_prefix or \"data\") + \".attr\", definition={'type': 'string', 'format': 'python-qualified-identifier'}, rule='format')\n        if data_keys:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must not contain \"+str(data_keys)+\" properties\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'title': \"'attr:' directive\", '$id': '#/definitions/attr-directive', '$$description': ['Value is read from a module attribute. Supports callables and iterables;', 'unsupported types are cast via ``str()``'], 'type': 'object', 'additionalProperties': False, 'properties': {'attr': {'type': 'string', 'format': 'python-qualified-identifier'}}, 'required': ['attr']}, rule='additionalProperties')\n    return data\n\ndef validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_find_directive(data, custom_formats={}, name_prefix=None):\n    if not isinstance(data, (dict)):\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be object\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/find-directive', 'title': \"'find:' directive\", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}, rule='type')\n    data_is_dict = isinstance(data, dict)\n    if data_is_dict:\n        data_keys = set(data.keys())\n        if \"find\" in data_keys:\n            data_keys.remove(\"find\")\n            data__find = data[\"find\"]\n            if not isinstance(data__find, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".find must be object\", value=data__find, name=\"\" + (name_prefix or \"data\") + \".find\", definition={'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}, rule='type')\n            data__find_is_dict = isinstance(data__find, dict)\n            if data__find_is_dict:\n                data__find_keys = set(data__find.keys())\n                if \"where\" in data__find_keys:\n                    data__find_keys.remove(\"where\")\n                    data__find__where = data__find[\"where\"]\n                    if not isinstance(data__find__where, (list, tuple)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".find.where must be array\", value=data__find__where, name=\"\" + (name_prefix or \"data\") + \".find.where\", definition={'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, rule='type')\n                    data__find__where_is_list = isinstance(data__find__where, (list, tuple))\n                    if data__find__where_is_list:\n                        data__find__where_len = len(data__find__where)\n                        for data__find__where_x, data__find__where_item in enumerate(data__find__where):\n                            if not isinstance(data__find__where_item, (str)):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".find.where[{data__find__where_x}]\".format(**locals()) + \" must be string\", value=data__find__where_item, name=\"\" + (name_prefix or \"data\") + \".find.where[{data__find__where_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n                if \"exclude\" in data__find_keys:\n                    data__find_keys.remove(\"exclude\")\n                    data__find__exclude = data__find[\"exclude\"]\n                    if not isinstance(data__find__exclude, (list, tuple)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".find.exclude must be array\", value=data__find__exclude, name=\"\" + (name_prefix or \"data\") + \".find.exclude\", definition={'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, rule='type')\n                    data__find__exclude_is_list = isinstance(data__find__exclude, (list, tuple))\n                    if data__find__exclude_is_list:\n                        data__find__exclude_len = len(data__find__exclude)\n                        for data__find__exclude_x, data__find__exclude_item in enumerate(data__find__exclude):\n                            if not isinstance(data__find__exclude_item, (str)):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".find.exclude[{data__find__exclude_x}]\".format(**locals()) + \" must be string\", value=data__find__exclude_item, name=\"\" + (name_prefix or \"data\") + \".find.exclude[{data__find__exclude_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n                if \"include\" in data__find_keys:\n                    data__find_keys.remove(\"include\")\n                    data__find__include = data__find[\"include\"]\n                    if not isinstance(data__find__include, (list, tuple)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".find.include must be array\", value=data__find__include, name=\"\" + (name_prefix or \"data\") + \".find.include\", definition={'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, rule='type')\n                    data__find__include_is_list = isinstance(data__find__include, (list, tuple))\n                    if data__find__include_is_list:\n                        data__find__include_len = len(data__find__include)\n                        for data__find__include_x, data__find__include_item in enumerate(data__find__include):\n                            if not isinstance(data__find__include_item, (str)):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".find.include[{data__find__include_x}]\".format(**locals()) + \" must be string\", value=data__find__include_item, name=\"\" + (name_prefix or \"data\") + \".find.include[{data__find__include_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n                if \"namespaces\" in data__find_keys:\n                    data__find_keys.remove(\"namespaces\")\n                    data__find__namespaces = data__find[\"namespaces\"]\n                    if not isinstance(data__find__namespaces, (bool)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".find.namespaces must be boolean\", value=data__find__namespaces, name=\"\" + (name_prefix or \"data\") + \".find.namespaces\", definition={'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}, rule='type')\n                if data__find_keys:\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".find must not contain \"+str(data__find_keys)+\" properties\", value=data__find, name=\"\" + (name_prefix or \"data\") + \".find\", definition={'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}, rule='additionalProperties')\n        if data_keys:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must not contain \"+str(data_keys)+\" properties\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/find-directive', 'title': \"'find:' directive\", 'type': 'object', 'additionalProperties': False, 'properties': {'find': {'type': 'object', '$$description': ['Dynamic `package discovery', '<https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.'], 'additionalProperties': False, 'properties': {'where': {'description': 'Directories to be searched for packages (Unix-style relative path)', 'type': 'array', 'items': {'type': 'string'}}, 'exclude': {'type': 'array', '$$description': ['Exclude packages that match the values listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'include': {'type': 'array', '$$description': ['Restrict the found packages to just the ones listed in this field.', \"Can container shell-style wildcards (e.g. ``'pkg.*'``)\"], 'items': {'type': 'string'}}, 'namespaces': {'type': 'boolean', '$$description': ['When ``True``, directories without a ``__init__.py`` file will also', 'be scanned for :pep:`420`-style implicit namespaces']}}}}}, rule='additionalProperties')\n    return data\n\ndef validate_https___setuptools_pypa_io_en_latest_userguide_pyproject_config_html__definitions_package_name(data, custom_formats={}, name_prefix=None):\n    if not isinstance(data, (str)):\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be string\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}, rule='type')\n    data_any_of_count9 = 0\n    if not data_any_of_count9:\n        try:\n            if not isinstance(data, (str)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be string\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'type': 'string', 'format': 'python-module-name'}, rule='type')\n            if isinstance(data, str):\n                if not custom_formats[\"python-module-name\"](data):\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be python-module-name\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'type': 'string', 'format': 'python-module-name'}, rule='format')\n            data_any_of_count9 += 1\n        except JsonSchemaValueException: pass\n    if not data_any_of_count9:\n        try:\n            if not isinstance(data, (str)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be string\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'type': 'string', 'format': 'pep561-stub-name'}, rule='type')\n            if isinstance(data, str):\n                if not custom_formats[\"pep561-stub-name\"](data):\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be pep561-stub-name\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'type': 'string', 'format': 'pep561-stub-name'}, rule='format')\n            data_any_of_count9 += 1\n        except JsonSchemaValueException: pass\n    if not data_any_of_count9:\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" cannot be validated by any definition\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/package-name', 'title': 'Valid package name', 'description': 'Valid package name (importable or :pep:`561`).', 'type': 'string', 'anyOf': [{'type': 'string', 'format': 'python-module-name'}, {'type': 'string', 'format': 'pep561-stub-name'}]}, rule='anyOf')\n    return data\n\ndef validate_https___setuptools_pypa_io_en_latest_deprecated_distutils_configfile_html(data, custom_formats={}, name_prefix=None):\n    if not isinstance(data, (dict)):\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be object\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://setuptools.pypa.io/en/latest/deprecated/distutils/configfile.html', 'title': '``tool.distutils`` table', '$$description': ['**EXPERIMENTAL** (NOT OFFICIALLY SUPPORTED): Use ``tool.distutils``', 'subtables to configure arguments for ``distutils`` commands.', 'Originally, ``distutils`` allowed developers to configure arguments for', '``setup.py`` commands via `distutils configuration files', '<https://setuptools.pypa.io/en/latest/deprecated/distutils/configfile.html>`_.', 'See also `the old Python docs <https://docs.python.org/3.11/install/>_`.'], 'type': 'object', 'properties': {'global': {'type': 'object', 'description': 'Global options applied to all ``distutils`` commands'}}, 'patternProperties': {'.+': {'type': 'object'}}, '$comment': 'TODO: Is there a practical way of making this schema more specific?'}, rule='type')\n    data_is_dict = isinstance(data, dict)\n    if data_is_dict:\n        data_keys = set(data.keys())\n        if \"global\" in data_keys:\n            data_keys.remove(\"global\")\n            data__global = data[\"global\"]\n            if not isinstance(data__global, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".global must be object\", value=data__global, name=\"\" + (name_prefix or \"data\") + \".global\", definition={'type': 'object', 'description': 'Global options applied to all ``distutils`` commands'}, rule='type')\n        for data_key, data_val in data.items():\n            if REGEX_PATTERNS['.+'].search(data_key):\n                if data_key in data_keys:\n                    data_keys.remove(data_key)\n                if not isinstance(data_val, (dict)):\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".{data_key}\".format(**locals()) + \" must be object\", value=data_val, name=\"\" + (name_prefix or \"data\") + \".{data_key}\".format(**locals()) + \"\", definition={'type': 'object'}, rule='type')\n    return data\n\ndef validate_https___packaging_python_org_en_latest_specifications_pyproject_toml(data, custom_formats={}, name_prefix=None):\n    if not isinstance(data, (dict)):\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be object\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://packaging.python.org/en/latest/specifications/pyproject-toml/', 'title': 'Package metadata stored in the ``project`` table', '$$description': ['Data structure for the **project** table inside ``pyproject.toml``', '(as initially defined in :pep:`621`)'], 'type': 'object', 'properties': {'name': {'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, 'version': {'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, 'description': {'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, 'readme': {'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', \"with meaning similar to the one defined in `core metadata's Description\", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, 'requires-python': {'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, 'license': {'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, 'authors': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': [\"The people or organizations considered to be the 'authors' of the project.\", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, 'maintainers': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': [\"The people or organizations considered to be the 'maintainers' of the project.\", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, 'keywords': {'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, 'classifiers': {'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, 'urls': {'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, 'scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'gui-scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'entry-points': {'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}}}, 'dependencies': {'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}, 'optional-dependencies': {'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, 'dynamic': {'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}}, 'required': ['name'], 'additionalProperties': False, 'if': {'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as \"Required\", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, 'then': {'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, 'definitions': {'author': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, 'entry-point-group': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'dependency': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}, rule='type')\n    data_is_dict = isinstance(data, dict)\n    if data_is_dict:\n        data__missing_keys = set(['name']) - data.keys()\n        if data__missing_keys:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must contain \" + (str(sorted(data__missing_keys)) + \" properties\"), value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://packaging.python.org/en/latest/specifications/pyproject-toml/', 'title': 'Package metadata stored in the ``project`` table', '$$description': ['Data structure for the **project** table inside ``pyproject.toml``', '(as initially defined in :pep:`621`)'], 'type': 'object', 'properties': {'name': {'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, 'version': {'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, 'description': {'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, 'readme': {'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', \"with meaning similar to the one defined in `core metadata's Description\", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, 'requires-python': {'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, 'license': {'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, 'authors': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': [\"The people or organizations considered to be the 'authors' of the project.\", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, 'maintainers': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': [\"The people or organizations considered to be the 'maintainers' of the project.\", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, 'keywords': {'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, 'classifiers': {'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, 'urls': {'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, 'scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'gui-scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'entry-points': {'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}}}, 'dependencies': {'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}, 'optional-dependencies': {'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, 'dynamic': {'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}}, 'required': ['name'], 'additionalProperties': False, 'if': {'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as \"Required\", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, 'then': {'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, 'definitions': {'author': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, 'entry-point-group': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'dependency': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}, rule='required')\n        data_keys = set(data.keys())\n        if \"name\" in data_keys:\n            data_keys.remove(\"name\")\n            data__name = data[\"name\"]\n            if not isinstance(data__name, (str)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".name must be string\", value=data__name, name=\"\" + (name_prefix or \"data\") + \".name\", definition={'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, rule='type')\n            if isinstance(data__name, str):\n                if not custom_formats[\"pep508-identifier\"](data__name):\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".name must be pep508-identifier\", value=data__name, name=\"\" + (name_prefix or \"data\") + \".name\", definition={'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, rule='format')\n        if \"version\" in data_keys:\n            data_keys.remove(\"version\")\n            data__version = data[\"version\"]\n            if not isinstance(data__version, (str)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".version must be string\", value=data__version, name=\"\" + (name_prefix or \"data\") + \".version\", definition={'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, rule='type')\n            if isinstance(data__version, str):\n                if not custom_formats[\"pep440\"](data__version):\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".version must be pep440\", value=data__version, name=\"\" + (name_prefix or \"data\") + \".version\", definition={'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, rule='format')\n        if \"description\" in data_keys:\n            data_keys.remove(\"description\")\n            data__description = data[\"description\"]\n            if not isinstance(data__description, (str)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".description must be string\", value=data__description, name=\"\" + (name_prefix or \"data\") + \".description\", definition={'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, rule='type')\n        if \"readme\" in data_keys:\n            data_keys.remove(\"readme\")\n            data__readme = data[\"readme\"]\n            data__readme_one_of_count10 = 0\n            if data__readme_one_of_count10 < 2:\n                try:\n                    if not isinstance(data__readme, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".readme must be string\", value=data__readme, name=\"\" + (name_prefix or \"data\") + \".readme\", definition={'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, rule='type')\n                    data__readme_one_of_count10 += 1\n                except JsonSchemaValueException: pass\n            if data__readme_one_of_count10 < 2:\n                try:\n                    if not isinstance(data__readme, (dict)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".readme must be object\", value=data__readme, name=\"\" + (name_prefix or \"data\") + \".readme\", definition={'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}, rule='type')\n                    data__readme_any_of_count11 = 0\n                    if not data__readme_any_of_count11:\n                        try:\n                            data__readme_is_dict = isinstance(data__readme, dict)\n                            if data__readme_is_dict:\n                                data__readme__missing_keys = set(['file']) - data__readme.keys()\n                                if data__readme__missing_keys:\n                                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".readme must contain \" + (str(sorted(data__readme__missing_keys)) + \" properties\"), value=data__readme, name=\"\" + (name_prefix or \"data\") + \".readme\", definition={'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, rule='required')\n                                data__readme_keys = set(data__readme.keys())\n                                if \"file\" in data__readme_keys:\n                                    data__readme_keys.remove(\"file\")\n                                    data__readme__file = data__readme[\"file\"]\n                                    if not isinstance(data__readme__file, (str)):\n                                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".readme.file must be string\", value=data__readme__file, name=\"\" + (name_prefix or \"data\") + \".readme.file\", definition={'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}, rule='type')\n                            data__readme_any_of_count11 += 1\n                        except JsonSchemaValueException: pass\n                    if not data__readme_any_of_count11:\n                        try:\n                            data__readme_is_dict = isinstance(data__readme, dict)\n                            if data__readme_is_dict:\n                                data__readme__missing_keys = set(['text']) - data__readme.keys()\n                                if data__readme__missing_keys:\n                                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".readme must contain \" + (str(sorted(data__readme__missing_keys)) + \" properties\"), value=data__readme, name=\"\" + (name_prefix or \"data\") + \".readme\", definition={'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}, rule='required')\n                                data__readme_keys = set(data__readme.keys())\n                                if \"text\" in data__readme_keys:\n                                    data__readme_keys.remove(\"text\")\n                                    data__readme__text = data__readme[\"text\"]\n                                    if not isinstance(data__readme__text, (str)):\n                                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".readme.text must be string\", value=data__readme__text, name=\"\" + (name_prefix or \"data\") + \".readme.text\", definition={'type': 'string', 'description': 'Full text describing the project.'}, rule='type')\n                            data__readme_any_of_count11 += 1\n                        except JsonSchemaValueException: pass\n                    if not data__readme_any_of_count11:\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".readme cannot be validated by any definition\", value=data__readme, name=\"\" + (name_prefix or \"data\") + \".readme\", definition={'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, rule='anyOf')\n                    data__readme_is_dict = isinstance(data__readme, dict)\n                    if data__readme_is_dict:\n                        data__readme__missing_keys = set(['content-type']) - data__readme.keys()\n                        if data__readme__missing_keys:\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".readme must contain \" + (str(sorted(data__readme__missing_keys)) + \" properties\"), value=data__readme, name=\"\" + (name_prefix or \"data\") + \".readme\", definition={'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}, rule='required')\n                        data__readme_keys = set(data__readme.keys())\n                        if \"content-type\" in data__readme_keys:\n                            data__readme_keys.remove(\"content-type\")\n                            data__readme__contenttype = data__readme[\"content-type\"]\n                            if not isinstance(data__readme__contenttype, (str)):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".readme.content-type must be string\", value=data__readme__contenttype, name=\"\" + (name_prefix or \"data\") + \".readme.content-type\", definition={'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}, rule='type')\n                    data__readme_one_of_count10 += 1\n                except JsonSchemaValueException: pass\n            if data__readme_one_of_count10 != 1:\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".readme must be valid exactly by one definition\" + (\" (\" + str(data__readme_one_of_count10) + \" matches found)\"), value=data__readme, name=\"\" + (name_prefix or \"data\") + \".readme\", definition={'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', \"with meaning similar to the one defined in `core metadata's Description\", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, rule='oneOf')\n        if \"requires-python\" in data_keys:\n            data_keys.remove(\"requires-python\")\n            data__requirespython = data[\"requires-python\"]\n            if not isinstance(data__requirespython, (str)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".requires-python must be string\", value=data__requirespython, name=\"\" + (name_prefix or \"data\") + \".requires-python\", definition={'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, rule='type')\n            if isinstance(data__requirespython, str):\n                if not custom_formats[\"pep508-versionspec\"](data__requirespython):\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".requires-python must be pep508-versionspec\", value=data__requirespython, name=\"\" + (name_prefix or \"data\") + \".requires-python\", definition={'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, rule='format')\n        if \"license\" in data_keys:\n            data_keys.remove(\"license\")\n            data__license = data[\"license\"]\n            data__license_one_of_count12 = 0\n            if data__license_one_of_count12 < 2:\n                try:\n                    data__license_is_dict = isinstance(data__license, dict)\n                    if data__license_is_dict:\n                        data__license__missing_keys = set(['file']) - data__license.keys()\n                        if data__license__missing_keys:\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".license must contain \" + (str(sorted(data__license__missing_keys)) + \" properties\"), value=data__license, name=\"\" + (name_prefix or \"data\") + \".license\", definition={'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, rule='required')\n                        data__license_keys = set(data__license.keys())\n                        if \"file\" in data__license_keys:\n                            data__license_keys.remove(\"file\")\n                            data__license__file = data__license[\"file\"]\n                            if not isinstance(data__license__file, (str)):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".license.file must be string\", value=data__license__file, name=\"\" + (name_prefix or \"data\") + \".license.file\", definition={'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}, rule='type')\n                    data__license_one_of_count12 += 1\n                except JsonSchemaValueException: pass\n            if data__license_one_of_count12 < 2:\n                try:\n                    data__license_is_dict = isinstance(data__license, dict)\n                    if data__license_is_dict:\n                        data__license__missing_keys = set(['text']) - data__license.keys()\n                        if data__license__missing_keys:\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".license must contain \" + (str(sorted(data__license__missing_keys)) + \" properties\"), value=data__license, name=\"\" + (name_prefix or \"data\") + \".license\", definition={'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}, rule='required')\n                        data__license_keys = set(data__license.keys())\n                        if \"text\" in data__license_keys:\n                            data__license_keys.remove(\"text\")\n                            data__license__text = data__license[\"text\"]\n                            if not isinstance(data__license__text, (str)):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".license.text must be string\", value=data__license__text, name=\"\" + (name_prefix or \"data\") + \".license.text\", definition={'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}, rule='type')\n                    data__license_one_of_count12 += 1\n                except JsonSchemaValueException: pass\n            if data__license_one_of_count12 != 1:\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".license must be valid exactly by one definition\" + (\" (\" + str(data__license_one_of_count12) + \" matches found)\"), value=data__license, name=\"\" + (name_prefix or \"data\") + \".license\", definition={'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, rule='oneOf')\n        if \"authors\" in data_keys:\n            data_keys.remove(\"authors\")\n            data__authors = data[\"authors\"]\n            if not isinstance(data__authors, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".authors must be array\", value=data__authors, name=\"\" + (name_prefix or \"data\") + \".authors\", definition={'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': [\"The people or organizations considered to be the 'authors' of the project.\", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, rule='type')\n            data__authors_is_list = isinstance(data__authors, (list, tuple))\n            if data__authors_is_list:\n                data__authors_len = len(data__authors)\n                for data__authors_x, data__authors_item in enumerate(data__authors):\n                    validate_https___packaging_python_org_en_latest_specifications_pyproject_toml___definitions_author(data__authors_item, custom_formats, (name_prefix or \"data\") + \".authors[{data__authors_x}]\".format(**locals()))\n        if \"maintainers\" in data_keys:\n            data_keys.remove(\"maintainers\")\n            data__maintainers = data[\"maintainers\"]\n            if not isinstance(data__maintainers, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".maintainers must be array\", value=data__maintainers, name=\"\" + (name_prefix or \"data\") + \".maintainers\", definition={'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': [\"The people or organizations considered to be the 'maintainers' of the project.\", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, rule='type')\n            data__maintainers_is_list = isinstance(data__maintainers, (list, tuple))\n            if data__maintainers_is_list:\n                data__maintainers_len = len(data__maintainers)\n                for data__maintainers_x, data__maintainers_item in enumerate(data__maintainers):\n                    validate_https___packaging_python_org_en_latest_specifications_pyproject_toml___definitions_author(data__maintainers_item, custom_formats, (name_prefix or \"data\") + \".maintainers[{data__maintainers_x}]\".format(**locals()))\n        if \"keywords\" in data_keys:\n            data_keys.remove(\"keywords\")\n            data__keywords = data[\"keywords\"]\n            if not isinstance(data__keywords, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".keywords must be array\", value=data__keywords, name=\"\" + (name_prefix or \"data\") + \".keywords\", definition={'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, rule='type')\n            data__keywords_is_list = isinstance(data__keywords, (list, tuple))\n            if data__keywords_is_list:\n                data__keywords_len = len(data__keywords)\n                for data__keywords_x, data__keywords_item in enumerate(data__keywords):\n                    if not isinstance(data__keywords_item, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".keywords[{data__keywords_x}]\".format(**locals()) + \" must be string\", value=data__keywords_item, name=\"\" + (name_prefix or \"data\") + \".keywords[{data__keywords_x}]\".format(**locals()) + \"\", definition={'type': 'string'}, rule='type')\n        if \"classifiers\" in data_keys:\n            data_keys.remove(\"classifiers\")\n            data__classifiers = data[\"classifiers\"]\n            if not isinstance(data__classifiers, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".classifiers must be array\", value=data__classifiers, name=\"\" + (name_prefix or \"data\") + \".classifiers\", definition={'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, rule='type')\n            data__classifiers_is_list = isinstance(data__classifiers, (list, tuple))\n            if data__classifiers_is_list:\n                data__classifiers_len = len(data__classifiers)\n                for data__classifiers_x, data__classifiers_item in enumerate(data__classifiers):\n                    if not isinstance(data__classifiers_item, (str)):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".classifiers[{data__classifiers_x}]\".format(**locals()) + \" must be string\", value=data__classifiers_item, name=\"\" + (name_prefix or \"data\") + \".classifiers[{data__classifiers_x}]\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, rule='type')\n                    if isinstance(data__classifiers_item, str):\n                        if not custom_formats[\"trove-classifier\"](data__classifiers_item):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".classifiers[{data__classifiers_x}]\".format(**locals()) + \" must be trove-classifier\", value=data__classifiers_item, name=\"\" + (name_prefix or \"data\") + \".classifiers[{data__classifiers_x}]\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, rule='format')\n        if \"urls\" in data_keys:\n            data_keys.remove(\"urls\")\n            data__urls = data[\"urls\"]\n            if not isinstance(data__urls, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".urls must be object\", value=data__urls, name=\"\" + (name_prefix or \"data\") + \".urls\", definition={'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, rule='type')\n            data__urls_is_dict = isinstance(data__urls, dict)\n            if data__urls_is_dict:\n                data__urls_keys = set(data__urls.keys())\n                for data__urls_key, data__urls_val in data__urls.items():\n                    if REGEX_PATTERNS['^.+$'].search(data__urls_key):\n                        if data__urls_key in data__urls_keys:\n                            data__urls_keys.remove(data__urls_key)\n                        if not isinstance(data__urls_val, (str)):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".urls.{data__urls_key}\".format(**locals()) + \" must be string\", value=data__urls_val, name=\"\" + (name_prefix or \"data\") + \".urls.{data__urls_key}\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'url'}, rule='type')\n                        if isinstance(data__urls_val, str):\n                            if not custom_formats[\"url\"](data__urls_val):\n                                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".urls.{data__urls_key}\".format(**locals()) + \" must be url\", value=data__urls_val, name=\"\" + (name_prefix or \"data\") + \".urls.{data__urls_key}\".format(**locals()) + \"\", definition={'type': 'string', 'format': 'url'}, rule='format')\n                if data__urls_keys:\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".urls must not contain \"+str(data__urls_keys)+\" properties\", value=data__urls, name=\"\" + (name_prefix or \"data\") + \".urls\", definition={'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, rule='additionalProperties')\n        if \"scripts\" in data_keys:\n            data_keys.remove(\"scripts\")\n            data__scripts = data[\"scripts\"]\n            validate_https___packaging_python_org_en_latest_specifications_pyproject_toml___definitions_entry_point_group(data__scripts, custom_formats, (name_prefix or \"data\") + \".scripts\")\n        if \"gui-scripts\" in data_keys:\n            data_keys.remove(\"gui-scripts\")\n            data__guiscripts = data[\"gui-scripts\"]\n            validate_https___packaging_python_org_en_latest_specifications_pyproject_toml___definitions_entry_point_group(data__guiscripts, custom_formats, (name_prefix or \"data\") + \".gui-scripts\")\n        if \"entry-points\" in data_keys:\n            data_keys.remove(\"entry-points\")\n            data__entrypoints = data[\"entry-points\"]\n            data__entrypoints_is_dict = isinstance(data__entrypoints, dict)\n            if data__entrypoints_is_dict:\n                data__entrypoints_keys = set(data__entrypoints.keys())\n                for data__entrypoints_key, data__entrypoints_val in data__entrypoints.items():\n                    if REGEX_PATTERNS['^.+$'].search(data__entrypoints_key):\n                        if data__entrypoints_key in data__entrypoints_keys:\n                            data__entrypoints_keys.remove(data__entrypoints_key)\n                        validate_https___packaging_python_org_en_latest_specifications_pyproject_toml___definitions_entry_point_group(data__entrypoints_val, custom_formats, (name_prefix or \"data\") + \".entry-points.{data__entrypoints_key}\".format(**locals()))\n                if data__entrypoints_keys:\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".entry-points must not contain \"+str(data__entrypoints_keys)+\" properties\", value=data__entrypoints, name=\"\" + (name_prefix or \"data\") + \".entry-points\", definition={'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}}}, rule='additionalProperties')\n                data__entrypoints_len = len(data__entrypoints)\n                if data__entrypoints_len != 0:\n                    data__entrypoints_property_names = True\n                    for data__entrypoints_key in data__entrypoints:\n                        try:\n                            if isinstance(data__entrypoints_key, str):\n                                if not custom_formats[\"python-entrypoint-group\"](data__entrypoints_key):\n                                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".entry-points must be python-entrypoint-group\", value=data__entrypoints_key, name=\"\" + (name_prefix or \"data\") + \".entry-points\", definition={'format': 'python-entrypoint-group'}, rule='format')\n                        except JsonSchemaValueException:\n                            data__entrypoints_property_names = False\n                    if not data__entrypoints_property_names:\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".entry-points must be named by propertyName definition\", value=data__entrypoints, name=\"\" + (name_prefix or \"data\") + \".entry-points\", definition={'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}}}, rule='propertyNames')\n        if \"dependencies\" in data_keys:\n            data_keys.remove(\"dependencies\")\n            data__dependencies = data[\"dependencies\"]\n            if not isinstance(data__dependencies, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dependencies must be array\", value=data__dependencies, name=\"\" + (name_prefix or \"data\") + \".dependencies\", definition={'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}, rule='type')\n            data__dependencies_is_list = isinstance(data__dependencies, (list, tuple))\n            if data__dependencies_is_list:\n                data__dependencies_len = len(data__dependencies)\n                for data__dependencies_x, data__dependencies_item in enumerate(data__dependencies):\n                    validate_https___packaging_python_org_en_latest_specifications_pyproject_toml___definitions_dependency(data__dependencies_item, custom_formats, (name_prefix or \"data\") + \".dependencies[{data__dependencies_x}]\".format(**locals()))\n        if \"optional-dependencies\" in data_keys:\n            data_keys.remove(\"optional-dependencies\")\n            data__optionaldependencies = data[\"optional-dependencies\"]\n            if not isinstance(data__optionaldependencies, (dict)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".optional-dependencies must be object\", value=data__optionaldependencies, name=\"\" + (name_prefix or \"data\") + \".optional-dependencies\", definition={'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, rule='type')\n            data__optionaldependencies_is_dict = isinstance(data__optionaldependencies, dict)\n            if data__optionaldependencies_is_dict:\n                data__optionaldependencies_keys = set(data__optionaldependencies.keys())\n                for data__optionaldependencies_key, data__optionaldependencies_val in data__optionaldependencies.items():\n                    if REGEX_PATTERNS['^.+$'].search(data__optionaldependencies_key):\n                        if data__optionaldependencies_key in data__optionaldependencies_keys:\n                            data__optionaldependencies_keys.remove(data__optionaldependencies_key)\n                        if not isinstance(data__optionaldependencies_val, (list, tuple)):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".optional-dependencies.{data__optionaldependencies_key}\".format(**locals()) + \" must be array\", value=data__optionaldependencies_val, name=\"\" + (name_prefix or \"data\") + \".optional-dependencies.{data__optionaldependencies_key}\".format(**locals()) + \"\", definition={'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}, rule='type')\n                        data__optionaldependencies_val_is_list = isinstance(data__optionaldependencies_val, (list, tuple))\n                        if data__optionaldependencies_val_is_list:\n                            data__optionaldependencies_val_len = len(data__optionaldependencies_val)\n                            for data__optionaldependencies_val_x, data__optionaldependencies_val_item in enumerate(data__optionaldependencies_val):\n                                validate_https___packaging_python_org_en_latest_specifications_pyproject_toml___definitions_dependency(data__optionaldependencies_val_item, custom_formats, (name_prefix or \"data\") + \".optional-dependencies.{data__optionaldependencies_key}[{data__optionaldependencies_val_x}]\".format(**locals()))\n                if data__optionaldependencies_keys:\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".optional-dependencies must not contain \"+str(data__optionaldependencies_keys)+\" properties\", value=data__optionaldependencies, name=\"\" + (name_prefix or \"data\") + \".optional-dependencies\", definition={'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, rule='additionalProperties')\n                data__optionaldependencies_len = len(data__optionaldependencies)\n                if data__optionaldependencies_len != 0:\n                    data__optionaldependencies_property_names = True\n                    for data__optionaldependencies_key in data__optionaldependencies:\n                        try:\n                            if isinstance(data__optionaldependencies_key, str):\n                                if not custom_formats[\"pep508-identifier\"](data__optionaldependencies_key):\n                                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".optional-dependencies must be pep508-identifier\", value=data__optionaldependencies_key, name=\"\" + (name_prefix or \"data\") + \".optional-dependencies\", definition={'format': 'pep508-identifier'}, rule='format')\n                        except JsonSchemaValueException:\n                            data__optionaldependencies_property_names = False\n                    if not data__optionaldependencies_property_names:\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".optional-dependencies must be named by propertyName definition\", value=data__optionaldependencies, name=\"\" + (name_prefix or \"data\") + \".optional-dependencies\", definition={'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, rule='propertyNames')\n        if \"dynamic\" in data_keys:\n            data_keys.remove(\"dynamic\")\n            data__dynamic = data[\"dynamic\"]\n            if not isinstance(data__dynamic, (list, tuple)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic must be array\", value=data__dynamic, name=\"\" + (name_prefix or \"data\") + \".dynamic\", definition={'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}, rule='type')\n            data__dynamic_is_list = isinstance(data__dynamic, (list, tuple))\n            if data__dynamic_is_list:\n                data__dynamic_len = len(data__dynamic)\n                for data__dynamic_x, data__dynamic_item in enumerate(data__dynamic):\n                    if data__dynamic_item not in ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']:\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic[{data__dynamic_x}]\".format(**locals()) + \" must be one of ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']\", value=data__dynamic_item, name=\"\" + (name_prefix or \"data\") + \".dynamic[{data__dynamic_x}]\".format(**locals()) + \"\", definition={'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}, rule='enum')\n        if data_keys:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must not contain \"+str(data_keys)+\" properties\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$schema': 'http://json-schema.org/draft-07/schema#', '$id': 'https://packaging.python.org/en/latest/specifications/pyproject-toml/', 'title': 'Package metadata stored in the ``project`` table', '$$description': ['Data structure for the **project** table inside ``pyproject.toml``', '(as initially defined in :pep:`621`)'], 'type': 'object', 'properties': {'name': {'type': 'string', 'description': 'The name (primary identifier) of the project. MUST be statically defined.', 'format': 'pep508-identifier'}, 'version': {'type': 'string', 'description': 'The version of the project as supported by :pep:`440`.', 'format': 'pep440'}, 'description': {'type': 'string', '$$description': ['The `summary description of the project', '<https://packaging.python.org/specifications/core-metadata/#summary>`_']}, 'readme': {'$$description': ['`Full/detailed description of the project in the form of a README', '<https://peps.python.org/pep-0621/#readme>`_', \"with meaning similar to the one defined in `core metadata's Description\", '<https://packaging.python.org/specifications/core-metadata/#description>`_'], 'oneOf': [{'type': 'string', '$$description': ['Relative path to a text file (UTF-8) containing the full description', 'of the project. If the file path ends in case-insensitive ``.md`` or', '``.rst`` suffixes, then the content-type is respectively', '``text/markdown`` or ``text/x-rst``']}, {'type': 'object', 'allOf': [{'anyOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to a text file containing the full description', 'of the project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', 'description': 'Full text describing the project.'}}, 'required': ['text']}]}, {'properties': {'content-type': {'type': 'string', '$$description': ['Content-type (:rfc:`1341`) of the full description', '(e.g. ``text/markdown``). The ``charset`` parameter is assumed', 'UTF-8 when not present.'], '$comment': 'TODO: add regex pattern or format?'}}, 'required': ['content-type']}]}]}, 'requires-python': {'type': 'string', 'format': 'pep508-versionspec', '$$description': ['`The Python version requirements of the project', '<https://packaging.python.org/specifications/core-metadata/#requires-python>`_.']}, 'license': {'description': '`Project license <https://peps.python.org/pep-0621/#license>`_.', 'oneOf': [{'properties': {'file': {'type': 'string', '$$description': ['Relative path to the file (UTF-8) which contains the license for the', 'project.']}}, 'required': ['file']}, {'properties': {'text': {'type': 'string', '$$description': ['The license of the project whose meaning is that of the', '`License field from the core metadata', '<https://packaging.python.org/specifications/core-metadata/#license>`_.']}}, 'required': ['text']}]}, 'authors': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': [\"The people or organizations considered to be the 'authors' of the project.\", 'The exact meaning is open to interpretation (e.g. original or primary authors,', 'current maintainers, or owners of the package).']}, 'maintainers': {'type': 'array', 'items': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, '$$description': [\"The people or organizations considered to be the 'maintainers' of the project.\", 'Similarly to ``authors``, the exact meaning is open to interpretation.']}, 'keywords': {'type': 'array', 'items': {'type': 'string'}, 'description': 'List of keywords to assist searching for the distribution in a larger catalog.'}, 'classifiers': {'type': 'array', 'items': {'type': 'string', 'format': 'trove-classifier', 'description': '`PyPI classifier <https://pypi.org/classifiers/>`_.'}, '$$description': ['`Trove classifiers <https://pypi.org/classifiers/>`_', 'which apply to the project.']}, 'urls': {'type': 'object', 'description': 'URLs associated with the project in the form ``label => value``.', 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', 'format': 'url'}}}, 'scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'gui-scripts': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'entry-points': {'$$description': ['Instruct the installer to expose the given modules/functions via', '``entry-point`` discovery mechanism (useful for plugins).', 'More information available in the `Python packaging guide', '<https://packaging.python.org/specifications/entry-points/>`_.'], 'propertyNames': {'format': 'python-entrypoint-group'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}}}, 'dependencies': {'type': 'array', 'description': 'Project (mandatory) dependencies.', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}, 'optional-dependencies': {'type': 'object', 'description': 'Optional dependency for the project', 'propertyNames': {'format': 'pep508-identifier'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'array', 'items': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}}, 'dynamic': {'type': 'array', '$$description': ['Specifies which fields are intentionally unspecified and expected to be', 'dynamically provided by build tools'], 'items': {'enum': ['version', 'description', 'readme', 'requires-python', 'license', 'authors', 'maintainers', 'keywords', 'classifiers', 'urls', 'scripts', 'gui-scripts', 'entry-points', 'dependencies', 'optional-dependencies']}}}, 'required': ['name'], 'additionalProperties': False, 'if': {'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as \"Required\", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, 'then': {'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, 'definitions': {'author': {'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, 'entry-point-group': {'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, 'dependency': {'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}}}, rule='additionalProperties')\n    try:\n        try:\n            data_is_dict = isinstance(data, dict)\n            if data_is_dict:\n                data__missing_keys = set(['dynamic']) - data.keys()\n                if data__missing_keys:\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must contain \" + (str(sorted(data__missing_keys)) + \" properties\"), value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, rule='required')\n                data_keys = set(data.keys())\n                if \"dynamic\" in data_keys:\n                    data_keys.remove(\"dynamic\")\n                    data__dynamic = data[\"dynamic\"]\n                    data__dynamic_is_list = isinstance(data__dynamic, (list, tuple))\n                    if data__dynamic_is_list:\n                        data__dynamic_contains = False\n                        for data__dynamic_key in data__dynamic:\n                            try:\n                                if data__dynamic_key != \"version\":\n                                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic must be same as const definition: version\", value=data__dynamic_key, name=\"\" + (name_prefix or \"data\") + \".dynamic\", definition={'const': 'version'}, rule='const')\n                                data__dynamic_contains = True\n                                break\n                            except JsonSchemaValueException: pass\n                        if not data__dynamic_contains:\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".dynamic must contain one of contains definition\", value=data__dynamic, name=\"\" + (name_prefix or \"data\") + \".dynamic\", definition={'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}, rule='contains')\n        except JsonSchemaValueException: pass\n        else:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must NOT match a disallowed definition\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'not': {'required': ['dynamic'], 'properties': {'dynamic': {'contains': {'const': 'version'}, '$$description': ['version is listed in ``dynamic``']}}}, '$$comment': ['According to :pep:`621`:', '    If the core metadata specification lists a field as \"Required\", then', '    the metadata MUST specify the field statically or list it in dynamic', 'In turn, `core metadata`_ defines:', '    The required fields are: Metadata-Version, Name, Version.', '    All the other fields are optional.', 'Since ``Metadata-Version`` is defined by the build back-end, ``name`` and', '``version`` are the only mandatory information in ``pyproject.toml``.', '.. _core metadata: https://packaging.python.org/specifications/core-metadata/']}, rule='not')\n    except JsonSchemaValueException:\n        pass\n    else:\n        data_is_dict = isinstance(data, dict)\n        if data_is_dict:\n            data__missing_keys = set(['version']) - data.keys()\n            if data__missing_keys:\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must contain \" + (str(sorted(data__missing_keys)) + \" properties\"), value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'required': ['version'], '$$description': ['version should be statically defined in the ``version`` field']}, rule='required')\n    return data\n\ndef validate_https___packaging_python_org_en_latest_specifications_pyproject_toml___definitions_dependency(data, custom_formats={}, name_prefix=None):\n    if not isinstance(data, (str)):\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be string\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}, rule='type')\n    if isinstance(data, str):\n        if not custom_formats[\"pep508\"](data):\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be pep508\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/dependency', 'title': 'Dependency', 'type': 'string', 'description': 'Project dependency specification according to PEP 508', 'format': 'pep508'}, rule='format')\n    return data\n\ndef validate_https___packaging_python_org_en_latest_specifications_pyproject_toml___definitions_entry_point_group(data, custom_formats={}, name_prefix=None):\n    if not isinstance(data, (dict)):\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be object\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, rule='type')\n    data_is_dict = isinstance(data, dict)\n    if data_is_dict:\n        data_keys = set(data.keys())\n        for data_key, data_val in data.items():\n            if REGEX_PATTERNS['^.+$'].search(data_key):\n                if data_key in data_keys:\n                    data_keys.remove(data_key)\n                if not isinstance(data_val, (str)):\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".{data_key}\".format(**locals()) + \" must be string\", value=data_val, name=\"\" + (name_prefix or \"data\") + \".{data_key}\".format(**locals()) + \"\", definition={'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}, rule='type')\n                if isinstance(data_val, str):\n                    if not custom_formats[\"python-entrypoint-reference\"](data_val):\n                        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".{data_key}\".format(**locals()) + \" must be python-entrypoint-reference\", value=data_val, name=\"\" + (name_prefix or \"data\") + \".{data_key}\".format(**locals()) + \"\", definition={'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}, rule='format')\n        if data_keys:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must not contain \"+str(data_keys)+\" properties\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, rule='additionalProperties')\n        data_len = len(data)\n        if data_len != 0:\n            data_property_names = True\n            for data_key in data:\n                try:\n                    if isinstance(data_key, str):\n                        if not custom_formats[\"python-entrypoint-name\"](data_key):\n                            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be python-entrypoint-name\", value=data_key, name=\"\" + (name_prefix or \"data\") + \"\", definition={'format': 'python-entrypoint-name'}, rule='format')\n                except JsonSchemaValueException:\n                    data_property_names = False\n            if not data_property_names:\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be named by propertyName definition\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/entry-point-group', 'title': 'Entry-points', 'type': 'object', '$$description': ['Entry-points are grouped together to indicate what sort of capabilities they', 'provide.', 'See the `packaging guides', '<https://packaging.python.org/specifications/entry-points/>`_', 'and `setuptools docs', '<https://setuptools.pypa.io/en/latest/userguide/entry_point.html>`_', 'for more information.'], 'propertyNames': {'format': 'python-entrypoint-name'}, 'additionalProperties': False, 'patternProperties': {'^.+$': {'type': 'string', '$$description': ['Reference to a Python object. It is either in the form', '``importable.module``, or ``importable.module:object.attr``.'], 'format': 'python-entrypoint-reference', '$comment': 'https://packaging.python.org/specifications/entry-points/'}}}, rule='propertyNames')\n    return data\n\ndef validate_https___packaging_python_org_en_latest_specifications_pyproject_toml___definitions_author(data, custom_formats={}, name_prefix=None):\n    if not isinstance(data, (dict)):\n        raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must be object\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, rule='type')\n    data_is_dict = isinstance(data, dict)\n    if data_is_dict:\n        data_keys = set(data.keys())\n        if \"name\" in data_keys:\n            data_keys.remove(\"name\")\n            data__name = data[\"name\"]\n            if not isinstance(data__name, (str)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".name must be string\", value=data__name, name=\"\" + (name_prefix or \"data\") + \".name\", definition={'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, rule='type')\n        if \"email\" in data_keys:\n            data_keys.remove(\"email\")\n            data__email = data[\"email\"]\n            if not isinstance(data__email, (str)):\n                raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".email must be string\", value=data__email, name=\"\" + (name_prefix or \"data\") + \".email\", definition={'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}, rule='type')\n            if isinstance(data__email, str):\n                if not REGEX_PATTERNS[\"idn-email_re_pattern\"].match(data__email):\n                    raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \".email must be idn-email\", value=data__email, name=\"\" + (name_prefix or \"data\") + \".email\", definition={'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}, rule='format')\n        if data_keys:\n            raise JsonSchemaValueException(\"\" + (name_prefix or \"data\") + \" must not contain \"+str(data_keys)+\" properties\", value=data, name=\"\" + (name_prefix or \"data\") + \"\", definition={'$id': '#/definitions/author', 'title': 'Author or Maintainer', '$comment': 'https://peps.python.org/pep-0621/#authors-maintainers', 'type': 'object', 'additionalProperties': False, 'properties': {'name': {'type': 'string', '$$description': ['MUST be a valid email name, i.e. whatever can be put as a name, before an', 'email, in :rfc:`822`.']}, 'email': {'type': 'string', 'format': 'idn-email', 'description': 'MUST be a valid email address'}}}, rule='additionalProperties')\n    return data\n", "setuptools/config/_validate_pyproject/fastjsonschema_exceptions.py": "import re\n\n\nSPLIT_RE = re.compile(r'[\\.\\[\\]]+')\n\n\nclass JsonSchemaException(ValueError):\n    \"\"\"\n    Base exception of ``fastjsonschema`` library.\n    \"\"\"\n\n\nclass JsonSchemaValueException(JsonSchemaException):\n    \"\"\"\n    Exception raised by validation function. Available properties:\n\n     * ``message`` containing human-readable information what is wrong (e.g. ``data.property[index] must be smaller than or equal to 42``),\n     * invalid ``value`` (e.g. ``60``),\n     * ``name`` of a path in the data structure (e.g. ``data.property[index]``),\n     * ``path`` as an array in the data structure (e.g. ``['data', 'property', 'index']``),\n     * the whole ``definition`` which the ``value`` has to fulfil (e.g. ``{'type': 'number', 'maximum': 42}``),\n     * ``rule`` which the ``value`` is breaking (e.g. ``maximum``)\n     * and ``rule_definition`` (e.g. ``42``).\n\n    .. versionchanged:: 2.14.0\n        Added all extra properties.\n    \"\"\"\n\n    def __init__(self, message, value=None, name=None, definition=None, rule=None):\n        super().__init__(message)\n        self.message = message\n        self.value = value\n        self.name = name\n        self.definition = definition\n        self.rule = rule\n\n    @property\n    def path(self):\n        return [item for item in SPLIT_RE.split(self.name) if item != '']\n\n    @property\n    def rule_definition(self):\n        if not self.rule or not self.definition:\n            return None\n        return self.definition.get(self.rule)\n\n\nclass JsonSchemaDefinitionException(JsonSchemaException):\n    \"\"\"\n    Exception raised by generator of validation function.\n    \"\"\"\n", "setuptools/config/_validate_pyproject/extra_validations.py": "\"\"\"The purpose of this module is implement PEP 621 validations that are\ndifficult to express as a JSON Schema (or that are not supported by the current\nJSON Schema library).\n\"\"\"\n\nfrom inspect import cleandoc\nfrom typing import Mapping, TypeVar\n\nfrom .error_reporting import ValidationError\n\nT = TypeVar(\"T\", bound=Mapping)\n\n\nclass RedefiningStaticFieldAsDynamic(ValidationError):\n    _DESC = \"\"\"According to PEP 621:\n\n    Build back-ends MUST raise an error if the metadata specifies a field\n    statically as well as being listed in dynamic.\n    \"\"\"\n    __doc__ = _DESC\n    _URL = (\n        \"https://packaging.python.org/en/latest/specifications/\"\n        \"pyproject-toml/#dynamic\"\n    )\n\n\ndef validate_project_dynamic(pyproject: T) -> T:\n    project_table = pyproject.get(\"project\", {})\n    dynamic = project_table.get(\"dynamic\", [])\n\n    for field in dynamic:\n        if field in project_table:\n            raise RedefiningStaticFieldAsDynamic(\n                message=f\"You cannot provide a value for `project.{field}` and \"\n                \"list it under `project.dynamic` at the same time\",\n                value={\n                    field: project_table[field],\n                    \"...\": \" # ...\",\n                    \"dynamic\": dynamic,\n                },\n                name=f\"data.project.{field}\",\n                definition={\n                    \"description\": cleandoc(RedefiningStaticFieldAsDynamic._DESC),\n                    \"see\": RedefiningStaticFieldAsDynamic._URL,\n                },\n                rule=\"PEP 621\",\n            )\n\n    return pyproject\n\n\nEXTRA_VALIDATIONS = (validate_project_dynamic,)\n", "setuptools/config/_validate_pyproject/formats.py": "\"\"\"\nThe functions in this module are used to validate schemas with the\n`format JSON Schema keyword\n<https://json-schema.org/understanding-json-schema/reference/string#format>`_.\n\nThe correspondence is given by replacing the ``_`` character in the name of the\nfunction with a ``-`` to obtain the format name and vice versa.\n\"\"\"\n\nimport builtins\nimport logging\nimport os\nimport re\nimport string\nimport typing\nfrom itertools import chain as _chain\n\nif typing.TYPE_CHECKING:\n    from typing_extensions import Literal\n\n_logger = logging.getLogger(__name__)\n\n# -------------------------------------------------------------------------------------\n# PEP 440\n\nVERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>alpha|a|beta|b|preview|pre|c|rc)\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\\.]?\n                (?P<post_l>post|rev|r)\n                [-_\\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\\.]?\n            (?P<dev_l>dev)\n            [-_\\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n\"\"\"\n\nVERSION_REGEX = re.compile(r\"^\\s*\" + VERSION_PATTERN + r\"\\s*$\", re.X | re.I)\n\n\ndef pep440(version: str) -> bool:\n    \"\"\"See :ref:`PyPA's version specification <pypa:version-specifiers>`\n    (initially introduced in :pep:`440`).\n    \"\"\"\n    return VERSION_REGEX.match(version) is not None\n\n\n# -------------------------------------------------------------------------------------\n# PEP 508\n\nPEP508_IDENTIFIER_PATTERN = r\"([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])\"\nPEP508_IDENTIFIER_REGEX = re.compile(f\"^{PEP508_IDENTIFIER_PATTERN}$\", re.I)\n\n\ndef pep508_identifier(name: str) -> bool:\n    \"\"\"See :ref:`PyPA's name specification <pypa:name-format>`\n    (initially introduced in :pep:`508#names`).\n    \"\"\"\n    return PEP508_IDENTIFIER_REGEX.match(name) is not None\n\n\ntry:\n    try:\n        from packaging import requirements as _req\n    except ImportError:  # pragma: no cover\n        # let's try setuptools vendored version\n        from setuptools._vendor.packaging import requirements as _req  # type: ignore\n\n    def pep508(value: str) -> bool:\n        \"\"\"See :ref:`PyPA's dependency specifiers <pypa:dependency-specifiers>`\n        (initially introduced in :pep:`508`).\n        \"\"\"\n        try:\n            _req.Requirement(value)\n            return True\n        except _req.InvalidRequirement:\n            return False\n\nexcept ImportError:  # pragma: no cover\n    _logger.warning(\n        \"Could not find an installation of `packaging`. Requirements, dependencies and \"\n        \"versions might not be validated. \"\n        \"To enforce validation, please install `packaging`.\"\n    )\n\n    def pep508(value: str) -> bool:\n        return True\n\n\ndef pep508_versionspec(value: str) -> bool:\n    \"\"\"Expression that can be used to specify/lock versions (including ranges)\n    See ``versionspec`` in :ref:`PyPA's dependency specifiers\n    <pypa:dependency-specifiers>` (initially introduced in :pep:`508`).\n    \"\"\"\n    if any(c in value for c in (\";\", \"]\", \"@\")):\n        # In PEP 508:\n        # conditional markers, extras and URL specs are not included in the\n        # versionspec\n        return False\n    # Let's pretend we have a dependency called `requirement` with the given\n    # version spec, then we can reuse the pep508 function for validation:\n    return pep508(f\"requirement{value}\")\n\n\n# -------------------------------------------------------------------------------------\n# PEP 517\n\n\ndef pep517_backend_reference(value: str) -> bool:\n    \"\"\"See PyPA's specification for defining build-backend references\n    introduced in :pep:`517#source-trees`.\n\n    This is similar to an entry-point reference (e.g., ``package.module:object``).\n    \"\"\"\n    module, _, obj = value.partition(\":\")\n    identifiers = (i.strip() for i in _chain(module.split(\".\"), obj.split(\".\")))\n    return all(python_identifier(i) for i in identifiers if i)\n\n\n# -------------------------------------------------------------------------------------\n# Classifiers - PEP 301\n\n\ndef _download_classifiers() -> str:\n    import ssl\n    from email.message import Message\n    from urllib.request import urlopen\n\n    url = \"https://pypi.org/pypi?:action=list_classifiers\"\n    context = ssl.create_default_context()\n    with urlopen(url, context=context) as response:  # noqa: S310 (audit URLs)\n        headers = Message()\n        headers[\"content_type\"] = response.getheader(\"content-type\", \"text/plain\")\n        return response.read().decode(headers.get_param(\"charset\", \"utf-8\"))  # type: ignore[no-any-return]\n\n\nclass _TroveClassifier:\n    \"\"\"The ``trove_classifiers`` package is the official way of validating classifiers,\n    however this package might not be always available.\n    As a workaround we can still download a list from PyPI.\n    We also don't want to be over strict about it, so simply skipping silently is an\n    option (classifiers will be validated anyway during the upload to PyPI).\n    \"\"\"\n\n    downloaded: typing.Union[None, \"Literal[False]\", typing.Set[str]]\n\n    def __init__(self) -> None:\n        self.downloaded = None\n        self._skip_download = False\n        # None => not cached yet\n        # False => cache not available\n        self.__name__ = \"trove_classifier\"  # Emulate a public function\n\n    def _disable_download(self) -> None:\n        # This is a private API. Only setuptools has the consent of using it.\n        self._skip_download = True\n\n    def __call__(self, value: str) -> bool:\n        if self.downloaded is False or self._skip_download is True:\n            return True\n\n        if os.getenv(\"NO_NETWORK\") or os.getenv(\"VALIDATE_PYPROJECT_NO_NETWORK\"):\n            self.downloaded = False\n            msg = (\n                \"Install ``trove-classifiers`` to ensure proper validation. \"\n                \"Skipping download of classifiers list from PyPI (NO_NETWORK).\"\n            )\n            _logger.debug(msg)\n            return True\n\n        if self.downloaded is None:\n            msg = (\n                \"Install ``trove-classifiers`` to ensure proper validation. \"\n                \"Meanwhile a list of classifiers will be downloaded from PyPI.\"\n            )\n            _logger.debug(msg)\n            try:\n                self.downloaded = set(_download_classifiers().splitlines())\n            except Exception:\n                self.downloaded = False\n                _logger.debug(\"Problem with download, skipping validation\")\n                return True\n\n        return value in self.downloaded or value.lower().startswith(\"private ::\")\n\n\ntry:\n    from trove_classifiers import classifiers as _trove_classifiers\n\n    def trove_classifier(value: str) -> bool:\n        \"\"\"See https://pypi.org/classifiers/\"\"\"\n        return value in _trove_classifiers or value.lower().startswith(\"private ::\")\n\nexcept ImportError:  # pragma: no cover\n    trove_classifier = _TroveClassifier()\n\n\n# -------------------------------------------------------------------------------------\n# Stub packages - PEP 561\n\n\ndef pep561_stub_name(value: str) -> bool:\n    \"\"\"Name of a directory containing type stubs.\n    It must follow the name scheme ``<package>-stubs`` as defined in\n    :pep:`561#stub-only-packages`.\n    \"\"\"\n    top, *children = value.split(\".\")\n    if not top.endswith(\"-stubs\"):\n        return False\n    return python_module_name(\".\".join([top[: -len(\"-stubs\")], *children]))\n\n\n# -------------------------------------------------------------------------------------\n# Non-PEP related\n\n\ndef url(value: str) -> bool:\n    \"\"\"Valid URL (validation uses :obj:`urllib.parse`).\n    For maximum compatibility please make sure to include a ``scheme`` prefix\n    in your URL (e.g. ``http://``).\n    \"\"\"\n    from urllib.parse import urlparse\n\n    try:\n        parts = urlparse(value)\n        if not parts.scheme:\n            _logger.warning(\n                \"For maximum compatibility please make sure to include a \"\n                \"`scheme` prefix in your URL (e.g. 'http://'). \"\n                f\"Given value: {value}\"\n            )\n            if not (value.startswith(\"/\") or value.startswith(\"\\\\\") or \"@\" in value):\n                parts = urlparse(f\"http://{value}\")\n\n        return bool(parts.scheme and parts.netloc)\n    except Exception:\n        return False\n\n\n# https://packaging.python.org/specifications/entry-points/\nENTRYPOINT_PATTERN = r\"[^\\[\\s=]([^=]*[^\\s=])?\"\nENTRYPOINT_REGEX = re.compile(f\"^{ENTRYPOINT_PATTERN}$\", re.I)\nRECOMMEDED_ENTRYPOINT_PATTERN = r\"[\\w.-]+\"\nRECOMMEDED_ENTRYPOINT_REGEX = re.compile(f\"^{RECOMMEDED_ENTRYPOINT_PATTERN}$\", re.I)\nENTRYPOINT_GROUP_PATTERN = r\"\\w+(\\.\\w+)*\"\nENTRYPOINT_GROUP_REGEX = re.compile(f\"^{ENTRYPOINT_GROUP_PATTERN}$\", re.I)\n\n\ndef python_identifier(value: str) -> bool:\n    \"\"\"Can be used as identifier in Python.\n    (Validation uses :obj:`str.isidentifier`).\n    \"\"\"\n    return value.isidentifier()\n\n\ndef python_qualified_identifier(value: str) -> bool:\n    \"\"\"\n    Python \"dotted identifier\", i.e. a sequence of :obj:`python_identifier`\n    concatenated with ``\".\"`` (e.g.: ``package.module.submodule``).\n    \"\"\"\n    if value.startswith(\".\") or value.endswith(\".\"):\n        return False\n    return all(python_identifier(m) for m in value.split(\".\"))\n\n\ndef python_module_name(value: str) -> bool:\n    \"\"\"Module name that can be used in an ``import``-statement in Python.\n    See :obj:`python_qualified_identifier`.\n    \"\"\"\n    return python_qualified_identifier(value)\n\n\ndef python_entrypoint_group(value: str) -> bool:\n    \"\"\"See ``Data model > group`` in the :ref:`PyPA's entry-points specification\n    <pypa:entry-points>`.\n    \"\"\"\n    return ENTRYPOINT_GROUP_REGEX.match(value) is not None\n\n\ndef python_entrypoint_name(value: str) -> bool:\n    \"\"\"See ``Data model > name`` in the :ref:`PyPA's entry-points specification\n    <pypa:entry-points>`.\n    \"\"\"\n    if not ENTRYPOINT_REGEX.match(value):\n        return False\n    if not RECOMMEDED_ENTRYPOINT_REGEX.match(value):\n        msg = f\"Entry point `{value}` does not follow recommended pattern: \"\n        msg += RECOMMEDED_ENTRYPOINT_PATTERN\n        _logger.warning(msg)\n    return True\n\n\ndef python_entrypoint_reference(value: str) -> bool:\n    \"\"\"Reference to a Python object using in the format::\n\n        importable.module:object.attr\n\n    See ``Data model >object reference`` in the :ref:`PyPA's entry-points specification\n    <pypa:entry-points>`.\n    \"\"\"\n    module, _, rest = value.partition(\":\")\n    if \"[\" in rest:\n        obj, _, extras_ = rest.partition(\"[\")\n        if extras_.strip()[-1] != \"]\":\n            return False\n        extras = (x.strip() for x in extras_.strip(string.whitespace + \"[]\").split(\",\"))\n        if not all(pep508_identifier(e) for e in extras):\n            return False\n        _logger.warning(f\"`{value}` - using extras for entry points is not recommended\")\n    else:\n        obj = rest\n\n    module_parts = module.split(\".\")\n    identifiers = _chain(module_parts, obj.split(\".\")) if rest else module_parts\n    return all(python_identifier(i.strip()) for i in identifiers)\n\n\ndef uint8(value: builtins.int) -> bool:\n    r\"\"\"Unsigned 8-bit integer (:math:`0 \\leq x < 2^8`)\"\"\"\n    return 0 <= value < 2**8\n\n\ndef uint16(value: builtins.int) -> bool:\n    r\"\"\"Unsigned 16-bit integer (:math:`0 \\leq x < 2^{16}`)\"\"\"\n    return 0 <= value < 2**16\n\n\ndef uint(value: builtins.int) -> bool:\n    r\"\"\"Unsigned 64-bit integer (:math:`0 \\leq x < 2^{64}`)\"\"\"\n    return 0 <= value < 2**64\n\n\ndef int(value: builtins.int) -> bool:\n    r\"\"\"Signed 64-bit integer (:math:`-2^{63} \\leq x < 2^{63}`)\"\"\"\n    return -(2**63) <= value < 2**63\n", "setuptools/config/_validate_pyproject/__init__.py": "from functools import reduce\nfrom typing import Any, Callable, Dict\n\nfrom . import formats\nfrom .error_reporting import detailed_errors, ValidationError\nfrom .extra_validations import EXTRA_VALIDATIONS\nfrom .fastjsonschema_exceptions import JsonSchemaException, JsonSchemaValueException\nfrom .fastjsonschema_validations import validate as _validate\n\n__all__ = [\n    \"validate\",\n    \"FORMAT_FUNCTIONS\",\n    \"EXTRA_VALIDATIONS\",\n    \"ValidationError\",\n    \"JsonSchemaException\",\n    \"JsonSchemaValueException\",\n]\n\n\nFORMAT_FUNCTIONS: Dict[str, Callable[[str], bool]] = {\n    fn.__name__.replace(\"_\", \"-\"): fn\n    for fn in formats.__dict__.values()\n    if callable(fn) and not fn.__name__.startswith(\"_\")\n}\n\n\ndef validate(data: Any) -> bool:\n    \"\"\"Validate the given ``data`` object using JSON Schema\n    This function raises ``ValidationError`` if ``data`` is invalid.\n    \"\"\"\n    with detailed_errors():\n        _validate(data, custom_formats=FORMAT_FUNCTIONS)\n        reduce(lambda acc, fn: fn(acc), EXTRA_VALIDATIONS, data)\n    return True\n", "setuptools/config/_validate_pyproject/error_reporting.py": "import io\nimport json\nimport logging\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nfrom textwrap import indent, wrap\nfrom typing import Any, Dict, Generator, Iterator, List, Optional, Sequence, Union, cast\n\nfrom .fastjsonschema_exceptions import JsonSchemaValueException\n\nif typing.TYPE_CHECKING:\n    import sys\n\n    if sys.version_info < (3, 11):\n        from typing_extensions import Self\n    else:\n        from typing import Self\n\n_logger = logging.getLogger(__name__)\n\n_MESSAGE_REPLACEMENTS = {\n    \"must be named by propertyName definition\": \"keys must be named by\",\n    \"one of contains definition\": \"at least one item that matches\",\n    \" same as const definition:\": \"\",\n    \"only specified items\": \"only items matching the definition\",\n}\n\n_SKIP_DETAILS = (\n    \"must not be empty\",\n    \"is always invalid\",\n    \"must not be there\",\n)\n\n_NEED_DETAILS = {\"anyOf\", \"oneOf\", \"allOf\", \"contains\", \"propertyNames\", \"not\", \"items\"}\n\n_CAMEL_CASE_SPLITTER = re.compile(r\"\\W+|([A-Z][^A-Z\\W]*)\")\n_IDENTIFIER = re.compile(r\"^[\\w_]+$\", re.I)\n\n_TOML_JARGON = {\n    \"object\": \"table\",\n    \"property\": \"key\",\n    \"properties\": \"keys\",\n    \"property names\": \"keys\",\n}\n\n_FORMATS_HELP = \"\"\"\nFor more details about `format` see\nhttps://validate-pyproject.readthedocs.io/en/latest/api/validate_pyproject.formats.html\n\"\"\"\n\n\nclass ValidationError(JsonSchemaValueException):\n    \"\"\"Report violations of a given JSON schema.\n\n    This class extends :exc:`~fastjsonschema.JsonSchemaValueException`\n    by adding the following properties:\n\n    - ``summary``: an improved version of the ``JsonSchemaValueException`` error message\n      with only the necessary information)\n\n    - ``details``: more contextual information about the error like the failing schema\n      itself and the value that violates the schema.\n\n    Depending on the level of the verbosity of the ``logging`` configuration\n    the exception message will be only ``summary`` (default) or a combination of\n    ``summary`` and ``details`` (when the logging level is set to :obj:`logging.DEBUG`).\n    \"\"\"\n\n    summary = \"\"\n    details = \"\"\n    _original_message = \"\"\n\n    @classmethod\n    def _from_jsonschema(cls, ex: JsonSchemaValueException) -> \"Self\":\n        formatter = _ErrorFormatting(ex)\n        obj = cls(str(formatter), ex.value, formatter.name, ex.definition, ex.rule)\n        debug_code = os.getenv(\"JSONSCHEMA_DEBUG_CODE_GENERATION\", \"false\").lower()\n        if debug_code != \"false\":  # pragma: no cover\n            obj.__cause__, obj.__traceback__ = ex.__cause__, ex.__traceback__\n        obj._original_message = ex.message\n        obj.summary = formatter.summary\n        obj.details = formatter.details\n        return obj\n\n\n@contextmanager\ndef detailed_errors() -> Generator[None, None, None]:\n    try:\n        yield\n    except JsonSchemaValueException as ex:\n        raise ValidationError._from_jsonschema(ex) from None\n\n\nclass _ErrorFormatting:\n    def __init__(self, ex: JsonSchemaValueException):\n        self.ex = ex\n        self.name = f\"`{self._simplify_name(ex.name)}`\"\n        self._original_message: str = self.ex.message.replace(ex.name, self.name)\n        self._summary = \"\"\n        self._details = \"\"\n\n    def __str__(self) -> str:\n        if _logger.getEffectiveLevel() <= logging.DEBUG and self.details:\n            return f\"{self.summary}\\n\\n{self.details}\"\n\n        return self.summary\n\n    @property\n    def summary(self) -> str:\n        if not self._summary:\n            self._summary = self._expand_summary()\n\n        return self._summary\n\n    @property\n    def details(self) -> str:\n        if not self._details:\n            self._details = self._expand_details()\n\n        return self._details\n\n    @staticmethod\n    def _simplify_name(name: str) -> str:\n        x = len(\"data.\")\n        return name[x:] if name.startswith(\"data.\") else name\n\n    def _expand_summary(self) -> str:\n        msg = self._original_message\n\n        for bad, repl in _MESSAGE_REPLACEMENTS.items():\n            msg = msg.replace(bad, repl)\n\n        if any(substring in msg for substring in _SKIP_DETAILS):\n            return msg\n\n        schema = self.ex.rule_definition\n        if self.ex.rule in _NEED_DETAILS and schema:\n            summary = _SummaryWriter(_TOML_JARGON)\n            return f\"{msg}:\\n\\n{indent(summary(schema), '    ')}\"\n\n        return msg\n\n    def _expand_details(self) -> str:\n        optional = []\n        definition = self.ex.definition or {}\n        desc_lines = definition.pop(\"$$description\", [])\n        desc = definition.pop(\"description\", None) or \" \".join(desc_lines)\n        if desc:\n            description = \"\\n\".join(\n                wrap(\n                    desc,\n                    width=80,\n                    initial_indent=\"    \",\n                    subsequent_indent=\"    \",\n                    break_long_words=False,\n                )\n            )\n            optional.append(f\"DESCRIPTION:\\n{description}\")\n        schema = json.dumps(definition, indent=4)\n        value = json.dumps(self.ex.value, indent=4)\n        defaults = [\n            f\"GIVEN VALUE:\\n{indent(value, '    ')}\",\n            f\"OFFENDING RULE: {self.ex.rule!r}\",\n            f\"DEFINITION:\\n{indent(schema, '    ')}\",\n        ]\n        msg = \"\\n\\n\".join(optional + defaults)\n        epilog = f\"\\n{_FORMATS_HELP}\" if \"format\" in msg.lower() else \"\"\n        return msg + epilog\n\n\nclass _SummaryWriter:\n    _IGNORE = frozenset((\"description\", \"default\", \"title\", \"examples\"))\n\n    def __init__(self, jargon: Optional[Dict[str, str]] = None):\n        self.jargon: Dict[str, str] = jargon or {}\n        # Clarify confusing terms\n        self._terms = {\n            \"anyOf\": \"at least one of the following\",\n            \"oneOf\": \"exactly one of the following\",\n            \"allOf\": \"all of the following\",\n            \"not\": \"(*NOT* the following)\",\n            \"prefixItems\": f\"{self._jargon('items')} (in order)\",\n            \"items\": \"items\",\n            \"contains\": \"contains at least one of\",\n            \"propertyNames\": (\n                f\"non-predefined acceptable {self._jargon('property names')}\"\n            ),\n            \"patternProperties\": f\"{self._jargon('properties')} named via pattern\",\n            \"const\": \"predefined value\",\n            \"enum\": \"one of\",\n        }\n        # Attributes that indicate that the definition is easy and can be done\n        # inline (e.g. string and number)\n        self._guess_inline_defs = [\n            \"enum\",\n            \"const\",\n            \"maxLength\",\n            \"minLength\",\n            \"pattern\",\n            \"format\",\n            \"minimum\",\n            \"maximum\",\n            \"exclusiveMinimum\",\n            \"exclusiveMaximum\",\n            \"multipleOf\",\n        ]\n\n    def _jargon(self, term: Union[str, List[str]]) -> Union[str, List[str]]:\n        if isinstance(term, list):\n            return [self.jargon.get(t, t) for t in term]\n        return self.jargon.get(term, term)\n\n    def __call__(\n        self,\n        schema: Union[dict, List[dict]],\n        prefix: str = \"\",\n        *,\n        _path: Sequence[str] = (),\n    ) -> str:\n        if isinstance(schema, list):\n            return self._handle_list(schema, prefix, _path)\n\n        filtered = self._filter_unecessary(schema, _path)\n        simple = self._handle_simple_dict(filtered, _path)\n        if simple:\n            return f\"{prefix}{simple}\"\n\n        child_prefix = self._child_prefix(prefix, \"  \")\n        item_prefix = self._child_prefix(prefix, \"- \")\n        indent = len(prefix) * \" \"\n        with io.StringIO() as buffer:\n            for i, (key, value) in enumerate(filtered.items()):\n                child_path = [*_path, key]\n                line_prefix = prefix if i == 0 else indent\n                buffer.write(f\"{line_prefix}{self._label(child_path)}:\")\n                # ^  just the first item should receive the complete prefix\n                if isinstance(value, dict):\n                    filtered = self._filter_unecessary(value, child_path)\n                    simple = self._handle_simple_dict(filtered, child_path)\n                    buffer.write(\n                        f\" {simple}\"\n                        if simple\n                        else f\"\\n{self(value, child_prefix, _path=child_path)}\"\n                    )\n                elif isinstance(value, list) and (\n                    key != \"type\" or self._is_property(child_path)\n                ):\n                    children = self._handle_list(value, item_prefix, child_path)\n                    sep = \" \" if children.startswith(\"[\") else \"\\n\"\n                    buffer.write(f\"{sep}{children}\")\n                else:\n                    buffer.write(f\" {self._value(value, child_path)}\\n\")\n            return buffer.getvalue()\n\n    def _is_unecessary(self, path: Sequence[str]) -> bool:\n        if self._is_property(path) or not path:  # empty path => instruction @ root\n            return False\n        key = path[-1]\n        return any(key.startswith(k) for k in \"$_\") or key in self._IGNORE\n\n    def _filter_unecessary(\n        self, schema: Dict[str, Any], path: Sequence[str]\n    ) -> Dict[str, Any]:\n        return {\n            key: value\n            for key, value in schema.items()\n            if not self._is_unecessary([*path, key])\n        }\n\n    def _handle_simple_dict(self, value: dict, path: Sequence[str]) -> Optional[str]:\n        inline = any(p in value for p in self._guess_inline_defs)\n        simple = not any(isinstance(v, (list, dict)) for v in value.values())\n        if inline or simple:\n            return f\"{{{', '.join(self._inline_attrs(value, path))}}}\\n\"\n        return None\n\n    def _handle_list(\n        self, schemas: list, prefix: str = \"\", path: Sequence[str] = ()\n    ) -> str:\n        if self._is_unecessary(path):\n            return \"\"\n\n        repr_ = repr(schemas)\n        if all(not isinstance(e, (dict, list)) for e in schemas) and len(repr_) < 60:\n            return f\"{repr_}\\n\"\n\n        item_prefix = self._child_prefix(prefix, \"- \")\n        return \"\".join(\n            self(v, item_prefix, _path=[*path, f\"[{i}]\"]) for i, v in enumerate(schemas)\n        )\n\n    def _is_property(self, path: Sequence[str]) -> bool:\n        \"\"\"Check if the given path can correspond to an arbitrarily named property\"\"\"\n        counter = 0\n        for key in path[-2::-1]:\n            if key not in {\"properties\", \"patternProperties\"}:\n                break\n            counter += 1\n\n        # If the counter if even, the path correspond to a JSON Schema keyword\n        # otherwise it can be any arbitrary string naming a property\n        return counter % 2 == 1\n\n    def _label(self, path: Sequence[str]) -> str:\n        *parents, key = path\n        if not self._is_property(path):\n            norm_key = _separate_terms(key)\n            return self._terms.get(key) or \" \".join(self._jargon(norm_key))\n\n        if parents[-1] == \"patternProperties\":\n            return f\"(regex {key!r})\"\n        return repr(key)  # property name\n\n    def _value(self, value: Any, path: Sequence[str]) -> str:\n        if path[-1] == \"type\" and not self._is_property(path):\n            type_ = self._jargon(value)\n            return (\n                f\"[{', '.join(type_)}]\" if isinstance(value, list) else cast(str, type_)\n            )\n        return repr(value)\n\n    def _inline_attrs(self, schema: dict, path: Sequence[str]) -> Iterator[str]:\n        for key, value in schema.items():\n            child_path = [*path, key]\n            yield f\"{self._label(child_path)}: {self._value(value, child_path)}\"\n\n    def _child_prefix(self, parent_prefix: str, child_prefix: str) -> str:\n        return len(parent_prefix) * \" \" + child_prefix\n\n\ndef _separate_terms(word: str) -> List[str]:\n    \"\"\"\n    >>> _separate_terms(\"FooBar-foo\")\n    ['foo', 'bar', 'foo']\n    \"\"\"\n    return [w.lower() for w in _CAMEL_CASE_SPLITTER.split(word) if w]\n", "pkg_resources/__init__.py": "# TODO: Add Generic type annotations to initialized collections.\n# For now we'd simply use implicit Any/Unknown which would add redundant annotations\n# mypy: disable-error-code=\"var-annotated\"\n\"\"\"\nPackage resource API\n--------------------\n\nA resource is a logical file contained within a package, or a logical\nsubdirectory thereof.  The package resource API expects resource names\nto have their path parts separated with ``/``, *not* whatever the local\npath separator is.  Do not use os.path operations to manipulate resource\nnames being passed into the API.\n\nThe package resource API is designed to work with normal filesystem packages,\n.egg files, and unpacked .egg files.  It can also work in a limited way with\n.zip files and with custom PEP 302 loaders that support the ``get_data()``\nmethod.\n\nThis module is deprecated. Users are directed to :mod:`importlib.resources`,\n:mod:`importlib.metadata` and :pypi:`packaging` instead.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\n\nif sys.version_info < (3, 8):  # noqa: UP036 # Check for unsupported versions\n    raise RuntimeError(\"Python 3.8 or later is required\")\n\nimport os\nimport io\nimport time\nimport re\nimport types\nfrom typing import (\n    Any,\n    Literal,\n    Dict,\n    Iterator,\n    Mapping,\n    MutableSequence,\n    NamedTuple,\n    NoReturn,\n    Tuple,\n    Union,\n    TYPE_CHECKING,\n    Protocol,\n    Callable,\n    Iterable,\n    TypeVar,\n    overload,\n)\nimport zipfile\nimport zipimport\nimport warnings\nimport stat\nimport functools\nimport pkgutil\nimport operator\nimport platform\nimport collections\nimport plistlib\nimport email.parser\nimport errno\nimport tempfile\nimport textwrap\nimport inspect\nimport ntpath\nimport posixpath\nimport importlib\nimport importlib.abc\nimport importlib.machinery\nfrom pkgutil import get_importer\n\nimport _imp\n\n# capture these to bypass sandboxing\nfrom os import utime\nfrom os import open as os_open\nfrom os.path import isdir, split\n\ntry:\n    from os import mkdir, rename, unlink\n\n    WRITE_SUPPORT = True\nexcept ImportError:\n    # no write support, probably under GAE\n    WRITE_SUPPORT = False\n\nfrom pkg_resources.extern.jaraco.text import (\n    yield_lines,\n    drop_comment,\n    join_continuation,\n)\nfrom pkg_resources.extern.packaging import markers as _packaging_markers\nfrom pkg_resources.extern.packaging import requirements as _packaging_requirements\nfrom pkg_resources.extern.packaging import utils as _packaging_utils\nfrom pkg_resources.extern.packaging import version as _packaging_version\nfrom pkg_resources.extern.platformdirs import user_cache_dir as _user_cache_dir\n\nif TYPE_CHECKING:\n    from _typeshed import BytesPath, StrPath, StrOrBytesPath\n    from typing_extensions import Self\n\nwarnings.warn(\n    \"pkg_resources is deprecated as an API. \"\n    \"See https://setuptools.pypa.io/en/latest/pkg_resources.html\",\n    DeprecationWarning,\n    stacklevel=2,\n)\n\n\n_T = TypeVar(\"_T\")\n_DistributionT = TypeVar(\"_DistributionT\", bound=\"Distribution\")\n# Type aliases\n_NestedStr = Union[str, Iterable[Union[str, Iterable[\"_NestedStr\"]]]]\n_InstallerTypeT = Callable[[\"Requirement\"], \"_DistributionT\"]\n_InstallerType = Callable[[\"Requirement\"], Union[\"Distribution\", None]]\n_PkgReqType = Union[str, \"Requirement\"]\n_EPDistType = Union[\"Distribution\", _PkgReqType]\n_MetadataType = Union[\"IResourceProvider\", None]\n_ResolvedEntryPoint = Any  # Can be any attribute in the module\n_ResourceStream = Any  # TODO / Incomplete: A readable file-like object\n# Any object works, but let's indicate we expect something like a module (optionally has __loader__ or __file__)\n_ModuleLike = Union[object, types.ModuleType]\n# Any: Should be _ModuleLike but we end up with issues where _ModuleLike doesn't have _ZipLoaderModule's __loader__\n_ProviderFactoryType = Callable[[Any], \"IResourceProvider\"]\n_DistFinderType = Callable[[_T, str, bool], Iterable[\"Distribution\"]]\n_NSHandlerType = Callable[[_T, str, str, types.ModuleType], Union[str, None]]\n_AdapterT = TypeVar(\n    \"_AdapterT\", _DistFinderType[Any], _ProviderFactoryType, _NSHandlerType[Any]\n)\n\n\n# Use _typeshed.importlib.LoaderProtocol once available https://github.com/python/typeshed/pull/11890\nclass _LoaderProtocol(Protocol):\n    def load_module(self, fullname: str, /) -> types.ModuleType: ...\n\n\nclass _ZipLoaderModule(Protocol):\n    __loader__: zipimport.zipimporter\n\n\n_PEP440_FALLBACK = re.compile(r\"^v?(?P<safe>(?:[0-9]+!)?[0-9]+(?:\\.[0-9]+)*)\", re.I)\n\n\nclass PEP440Warning(RuntimeWarning):\n    \"\"\"\n    Used when there is an issue with a version or specifier not complying with\n    PEP 440.\n    \"\"\"\n\n\nparse_version = _packaging_version.Version\n\n\n_state_vars: dict[str, str] = {}\n\n\ndef _declare_state(vartype: str, varname: str, initial_value: _T) -> _T:\n    _state_vars[varname] = vartype\n    return initial_value\n\n\ndef __getstate__() -> dict[str, Any]:\n    state = {}\n    g = globals()\n    for k, v in _state_vars.items():\n        state[k] = g['_sget_' + v](g[k])\n    return state\n\n\ndef __setstate__(state: dict[str, Any]) -> dict[str, Any]:\n    g = globals()\n    for k, v in state.items():\n        g['_sset_' + _state_vars[k]](k, g[k], v)\n    return state\n\n\ndef _sget_dict(val):\n    return val.copy()\n\n\ndef _sset_dict(key, ob, state):\n    ob.clear()\n    ob.update(state)\n\n\ndef _sget_object(val):\n    return val.__getstate__()\n\n\ndef _sset_object(key, ob, state):\n    ob.__setstate__(state)\n\n\n_sget_none = _sset_none = lambda *args: None\n\n\ndef get_supported_platform():\n    \"\"\"Return this platform's maximum compatible version.\n\n    distutils.util.get_platform() normally reports the minimum version\n    of macOS that would be required to *use* extensions produced by\n    distutils.  But what we want when checking compatibility is to know the\n    version of macOS that we are *running*.  To allow usage of packages that\n    explicitly require a newer version of macOS, we must also know the\n    current version of the OS.\n\n    If this condition occurs for any other platform with a version in its\n    platform strings, this function should be extended accordingly.\n    \"\"\"\n    plat = get_build_platform()\n    m = macosVersionString.match(plat)\n    if m is not None and sys.platform == \"darwin\":\n        try:\n            plat = 'macosx-%s-%s' % ('.'.join(_macos_vers()[:2]), m.group(3))\n        except ValueError:\n            # not macOS\n            pass\n    return plat\n\n\n__all__ = [\n    # Basic resource access and distribution/entry point discovery\n    'require',\n    'run_script',\n    'get_provider',\n    'get_distribution',\n    'load_entry_point',\n    'get_entry_map',\n    'get_entry_info',\n    'iter_entry_points',\n    'resource_string',\n    'resource_stream',\n    'resource_filename',\n    'resource_listdir',\n    'resource_exists',\n    'resource_isdir',\n    # Environmental control\n    'declare_namespace',\n    'working_set',\n    'add_activation_listener',\n    'find_distributions',\n    'set_extraction_path',\n    'cleanup_resources',\n    'get_default_cache',\n    # Primary implementation classes\n    'Environment',\n    'WorkingSet',\n    'ResourceManager',\n    'Distribution',\n    'Requirement',\n    'EntryPoint',\n    # Exceptions\n    'ResolutionError',\n    'VersionConflict',\n    'DistributionNotFound',\n    'UnknownExtra',\n    'ExtractionError',\n    # Warnings\n    'PEP440Warning',\n    # Parsing functions and string utilities\n    'parse_requirements',\n    'parse_version',\n    'safe_name',\n    'safe_version',\n    'get_platform',\n    'compatible_platforms',\n    'yield_lines',\n    'split_sections',\n    'safe_extra',\n    'to_filename',\n    'invalid_marker',\n    'evaluate_marker',\n    # filesystem utilities\n    'ensure_directory',\n    'normalize_path',\n    # Distribution \"precedence\" constants\n    'EGG_DIST',\n    'BINARY_DIST',\n    'SOURCE_DIST',\n    'CHECKOUT_DIST',\n    'DEVELOP_DIST',\n    # \"Provider\" interfaces, implementations, and registration/lookup APIs\n    'IMetadataProvider',\n    'IResourceProvider',\n    'FileMetadata',\n    'PathMetadata',\n    'EggMetadata',\n    'EmptyProvider',\n    'empty_provider',\n    'NullProvider',\n    'EggProvider',\n    'DefaultProvider',\n    'ZipProvider',\n    'register_finder',\n    'register_namespace_handler',\n    'register_loader_type',\n    'fixup_namespace_packages',\n    'get_importer',\n    # Warnings\n    'PkgResourcesDeprecationWarning',\n    # Deprecated/backward compatibility only\n    'run_main',\n    'AvailableDistributions',\n]\n\n\nclass ResolutionError(Exception):\n    \"\"\"Abstract base for dependency resolution errors\"\"\"\n\n    def __repr__(self):\n        return self.__class__.__name__ + repr(self.args)\n\n\nclass VersionConflict(ResolutionError):\n    \"\"\"\n    An already-installed version conflicts with the requested version.\n\n    Should be initialized with the installed Distribution and the requested\n    Requirement.\n    \"\"\"\n\n    _template = \"{self.dist} is installed but {self.req} is required\"\n\n    @property\n    def dist(self) -> Distribution:\n        return self.args[0]\n\n    @property\n    def req(self) -> Requirement:\n        return self.args[1]\n\n    def report(self):\n        return self._template.format(**locals())\n\n    def with_context(self, required_by: set[Distribution | str]):\n        \"\"\"\n        If required_by is non-empty, return a version of self that is a\n        ContextualVersionConflict.\n        \"\"\"\n        if not required_by:\n            return self\n        args = self.args + (required_by,)\n        return ContextualVersionConflict(*args)\n\n\nclass ContextualVersionConflict(VersionConflict):\n    \"\"\"\n    A VersionConflict that accepts a third parameter, the set of the\n    requirements that required the installed Distribution.\n    \"\"\"\n\n    _template = VersionConflict._template + ' by {self.required_by}'\n\n    @property\n    def required_by(self) -> set[str]:\n        return self.args[2]\n\n\nclass DistributionNotFound(ResolutionError):\n    \"\"\"A requested distribution was not found\"\"\"\n\n    _template = (\n        \"The '{self.req}' distribution was not found \"\n        \"and is required by {self.requirers_str}\"\n    )\n\n    @property\n    def req(self) -> Requirement:\n        return self.args[0]\n\n    @property\n    def requirers(self) -> set[str] | None:\n        return self.args[1]\n\n    @property\n    def requirers_str(self):\n        if not self.requirers:\n            return 'the application'\n        return ', '.join(self.requirers)\n\n    def report(self):\n        return self._template.format(**locals())\n\n    def __str__(self):\n        return self.report()\n\n\nclass UnknownExtra(ResolutionError):\n    \"\"\"Distribution doesn't have an \"extra feature\" of the given name\"\"\"\n\n\n_provider_factories: dict[type[_ModuleLike], _ProviderFactoryType] = {}\n\nPY_MAJOR = '{}.{}'.format(*sys.version_info)\nEGG_DIST = 3\nBINARY_DIST = 2\nSOURCE_DIST = 1\nCHECKOUT_DIST = 0\nDEVELOP_DIST = -1\n\n\ndef register_loader_type(\n    loader_type: type[_ModuleLike], provider_factory: _ProviderFactoryType\n):\n    \"\"\"Register `provider_factory` to make providers for `loader_type`\n\n    `loader_type` is the type or class of a PEP 302 ``module.__loader__``,\n    and `provider_factory` is a function that, passed a *module* object,\n    returns an ``IResourceProvider`` for that module.\n    \"\"\"\n    _provider_factories[loader_type] = provider_factory\n\n\n@overload\ndef get_provider(moduleOrReq: str) -> IResourceProvider: ...\n@overload\ndef get_provider(moduleOrReq: Requirement) -> Distribution: ...\ndef get_provider(moduleOrReq: str | Requirement) -> IResourceProvider | Distribution:\n    \"\"\"Return an IResourceProvider for the named module or requirement\"\"\"\n    if isinstance(moduleOrReq, Requirement):\n        return working_set.find(moduleOrReq) or require(str(moduleOrReq))[0]\n    try:\n        module = sys.modules[moduleOrReq]\n    except KeyError:\n        __import__(moduleOrReq)\n        module = sys.modules[moduleOrReq]\n    loader = getattr(module, '__loader__', None)\n    return _find_adapter(_provider_factories, loader)(module)\n\n\n@functools.lru_cache(maxsize=None)\ndef _macos_vers():\n    version = platform.mac_ver()[0]\n    # fallback for MacPorts\n    if version == '':\n        plist = '/System/Library/CoreServices/SystemVersion.plist'\n        if os.path.exists(plist):\n            with open(plist, 'rb') as fh:\n                plist_content = plistlib.load(fh)\n            if 'ProductVersion' in plist_content:\n                version = plist_content['ProductVersion']\n    return version.split('.')\n\n\ndef _macos_arch(machine):\n    return {'PowerPC': 'ppc', 'Power_Macintosh': 'ppc'}.get(machine, machine)\n\n\ndef get_build_platform():\n    \"\"\"Return this platform's string for platform-specific distributions\n\n    XXX Currently this is the same as ``distutils.util.get_platform()``, but it\n    needs some hacks for Linux and macOS.\n    \"\"\"\n    from sysconfig import get_platform\n\n    plat = get_platform()\n    if sys.platform == \"darwin\" and not plat.startswith('macosx-'):\n        try:\n            version = _macos_vers()\n            machine = os.uname()[4].replace(\" \", \"_\")\n            return \"macosx-%d.%d-%s\" % (\n                int(version[0]),\n                int(version[1]),\n                _macos_arch(machine),\n            )\n        except ValueError:\n            # if someone is running a non-Mac darwin system, this will fall\n            # through to the default implementation\n            pass\n    return plat\n\n\nmacosVersionString = re.compile(r\"macosx-(\\d+)\\.(\\d+)-(.*)\")\ndarwinVersionString = re.compile(r\"darwin-(\\d+)\\.(\\d+)\\.(\\d+)-(.*)\")\n# XXX backward compat\nget_platform = get_build_platform\n\n\ndef compatible_platforms(provided: str | None, required: str | None):\n    \"\"\"Can code for the `provided` platform run on the `required` platform?\n\n    Returns true if either platform is ``None``, or the platforms are equal.\n\n    XXX Needs compatibility checks for Linux and other unixy OSes.\n    \"\"\"\n    if provided is None or required is None or provided == required:\n        # easy case\n        return True\n\n    # macOS special cases\n    reqMac = macosVersionString.match(required)\n    if reqMac:\n        provMac = macosVersionString.match(provided)\n\n        # is this a Mac package?\n        if not provMac:\n            # this is backwards compatibility for packages built before\n            # setuptools 0.6. All packages built after this point will\n            # use the new macOS designation.\n            provDarwin = darwinVersionString.match(provided)\n            if provDarwin:\n                dversion = int(provDarwin.group(1))\n                macosversion = \"%s.%s\" % (reqMac.group(1), reqMac.group(2))\n                if (\n                    dversion == 7\n                    and macosversion >= \"10.3\"\n                    or dversion == 8\n                    and macosversion >= \"10.4\"\n                ):\n                    return True\n            # egg isn't macOS or legacy darwin\n            return False\n\n        # are they the same major version and machine type?\n        if provMac.group(1) != reqMac.group(1) or provMac.group(3) != reqMac.group(3):\n            return False\n\n        # is the required OS major update >= the provided one?\n        if int(provMac.group(2)) > int(reqMac.group(2)):\n            return False\n\n        return True\n\n    # XXX Linux and other platforms' special cases should go here\n    return False\n\n\n@overload\ndef get_distribution(dist: _DistributionT) -> _DistributionT: ...\n@overload\ndef get_distribution(dist: _PkgReqType) -> Distribution: ...\ndef get_distribution(dist: Distribution | _PkgReqType) -> Distribution:\n    \"\"\"Return a current distribution object for a Requirement or string\"\"\"\n    if isinstance(dist, str):\n        dist = Requirement.parse(dist)\n    if isinstance(dist, Requirement):\n        # Bad type narrowing, dist has to be a Requirement here, so get_provider has to return Distribution\n        dist = get_provider(dist)  # type: ignore[assignment]\n    if not isinstance(dist, Distribution):\n        raise TypeError(\"Expected str, Requirement, or Distribution\", dist)\n    return dist\n\n\ndef load_entry_point(dist: _EPDistType, group: str, name: str) -> _ResolvedEntryPoint:\n    \"\"\"Return `name` entry point of `group` for `dist` or raise ImportError\"\"\"\n    return get_distribution(dist).load_entry_point(group, name)\n\n\n@overload\ndef get_entry_map(\n    dist: _EPDistType, group: None = None\n) -> dict[str, dict[str, EntryPoint]]: ...\n@overload\ndef get_entry_map(dist: _EPDistType, group: str) -> dict[str, EntryPoint]: ...\ndef get_entry_map(dist: _EPDistType, group: str | None = None):\n    \"\"\"Return the entry point map for `group`, or the full entry map\"\"\"\n    return get_distribution(dist).get_entry_map(group)\n\n\ndef get_entry_info(dist: _EPDistType, group: str, name: str):\n    \"\"\"Return the EntryPoint object for `group`+`name`, or ``None``\"\"\"\n    return get_distribution(dist).get_entry_info(group, name)\n\n\nclass IMetadataProvider(Protocol):\n    def has_metadata(self, name: str) -> bool:\n        \"\"\"Does the package's distribution contain the named metadata?\"\"\"\n\n    def get_metadata(self, name: str) -> str:\n        \"\"\"The named metadata resource as a string\"\"\"\n\n    def get_metadata_lines(self, name: str) -> Iterator[str]:\n        \"\"\"Yield named metadata resource as list of non-blank non-comment lines\n\n        Leading and trailing whitespace is stripped from each line, and lines\n        with ``#`` as the first non-blank character are omitted.\"\"\"\n\n    def metadata_isdir(self, name: str) -> bool:\n        \"\"\"Is the named metadata a directory?  (like ``os.path.isdir()``)\"\"\"\n\n    def metadata_listdir(self, name: str) -> list[str]:\n        \"\"\"List of metadata names in the directory (like ``os.listdir()``)\"\"\"\n\n    def run_script(self, script_name: str, namespace: dict[str, Any]) -> None:\n        \"\"\"Execute the named script in the supplied namespace dictionary\"\"\"\n\n\nclass IResourceProvider(IMetadataProvider, Protocol):\n    \"\"\"An object that provides access to package resources\"\"\"\n\n    def get_resource_filename(\n        self, manager: ResourceManager, resource_name: str\n    ) -> str:\n        \"\"\"Return a true filesystem path for `resource_name`\n\n        `manager` must be a ``ResourceManager``\"\"\"\n\n    def get_resource_stream(\n        self, manager: ResourceManager, resource_name: str\n    ) -> _ResourceStream:\n        \"\"\"Return a readable file-like object for `resource_name`\n\n        `manager` must be a ``ResourceManager``\"\"\"\n\n    def get_resource_string(\n        self, manager: ResourceManager, resource_name: str\n    ) -> bytes:\n        \"\"\"Return the contents of `resource_name` as :obj:`bytes`\n\n        `manager` must be a ``ResourceManager``\"\"\"\n\n    def has_resource(self, resource_name: str) -> bool:\n        \"\"\"Does the package contain the named resource?\"\"\"\n\n    def resource_isdir(self, resource_name: str) -> bool:\n        \"\"\"Is the named resource a directory?  (like ``os.path.isdir()``)\"\"\"\n\n    def resource_listdir(self, resource_name: str) -> list[str]:\n        \"\"\"List of resource names in the directory (like ``os.listdir()``)\"\"\"\n\n\nclass WorkingSet:\n    \"\"\"A collection of active distributions on sys.path (or a similar list)\"\"\"\n\n    def __init__(self, entries: Iterable[str] | None = None):\n        \"\"\"Create working set from list of path entries (default=sys.path)\"\"\"\n        self.entries: list[str] = []\n        self.entry_keys = {}\n        self.by_key = {}\n        self.normalized_to_canonical_keys = {}\n        self.callbacks = []\n\n        if entries is None:\n            entries = sys.path\n\n        for entry in entries:\n            self.add_entry(entry)\n\n    @classmethod\n    def _build_master(cls):\n        \"\"\"\n        Prepare the master working set.\n        \"\"\"\n        ws = cls()\n        try:\n            from __main__ import __requires__\n        except ImportError:\n            # The main program does not list any requirements\n            return ws\n\n        # ensure the requirements are met\n        try:\n            ws.require(__requires__)\n        except VersionConflict:\n            return cls._build_from_requirements(__requires__)\n\n        return ws\n\n    @classmethod\n    def _build_from_requirements(cls, req_spec):\n        \"\"\"\n        Build a working set from a requirement spec. Rewrites sys.path.\n        \"\"\"\n        # try it without defaults already on sys.path\n        # by starting with an empty path\n        ws = cls([])\n        reqs = parse_requirements(req_spec)\n        dists = ws.resolve(reqs, Environment())\n        for dist in dists:\n            ws.add(dist)\n\n        # add any missing entries from sys.path\n        for entry in sys.path:\n            if entry not in ws.entries:\n                ws.add_entry(entry)\n\n        # then copy back to sys.path\n        sys.path[:] = ws.entries\n        return ws\n\n    def add_entry(self, entry: str):\n        \"\"\"Add a path item to ``.entries``, finding any distributions on it\n\n        ``find_distributions(entry, True)`` is used to find distributions\n        corresponding to the path entry, and they are added.  `entry` is\n        always appended to ``.entries``, even if it is already present.\n        (This is because ``sys.path`` can contain the same value more than\n        once, and the ``.entries`` of the ``sys.path`` WorkingSet should always\n        equal ``sys.path``.)\n        \"\"\"\n        self.entry_keys.setdefault(entry, [])\n        self.entries.append(entry)\n        for dist in find_distributions(entry, True):\n            self.add(dist, entry, False)\n\n    def __contains__(self, dist: Distribution) -> bool:\n        \"\"\"True if `dist` is the active distribution for its project\"\"\"\n        return self.by_key.get(dist.key) == dist\n\n    def find(self, req: Requirement) -> Distribution | None:\n        \"\"\"Find a distribution matching requirement `req`\n\n        If there is an active distribution for the requested project, this\n        returns it as long as it meets the version requirement specified by\n        `req`.  But, if there is an active distribution for the project and it\n        does *not* meet the `req` requirement, ``VersionConflict`` is raised.\n        If there is no active distribution for the requested project, ``None``\n        is returned.\n        \"\"\"\n        dist = self.by_key.get(req.key)\n\n        if dist is None:\n            canonical_key = self.normalized_to_canonical_keys.get(req.key)\n\n            if canonical_key is not None:\n                req.key = canonical_key\n                dist = self.by_key.get(canonical_key)\n\n        if dist is not None and dist not in req:\n            # XXX add more info\n            raise VersionConflict(dist, req)\n        return dist\n\n    def iter_entry_points(self, group: str, name: str | None = None):\n        \"\"\"Yield entry point objects from `group` matching `name`\n\n        If `name` is None, yields all entry points in `group` from all\n        distributions in the working set, otherwise only ones matching\n        both `group` and `name` are yielded (in distribution order).\n        \"\"\"\n        return (\n            entry\n            for dist in self\n            for entry in dist.get_entry_map(group).values()\n            if name is None or name == entry.name\n        )\n\n    def run_script(self, requires: str, script_name: str):\n        \"\"\"Locate distribution for `requires` and run `script_name` script\"\"\"\n        ns = sys._getframe(1).f_globals\n        name = ns['__name__']\n        ns.clear()\n        ns['__name__'] = name\n        self.require(requires)[0].run_script(script_name, ns)\n\n    def __iter__(self) -> Iterator[Distribution]:\n        \"\"\"Yield distributions for non-duplicate projects in the working set\n\n        The yield order is the order in which the items' path entries were\n        added to the working set.\n        \"\"\"\n        seen = set()\n        for item in self.entries:\n            if item not in self.entry_keys:\n                # workaround a cache issue\n                continue\n\n            for key in self.entry_keys[item]:\n                if key not in seen:\n                    seen.add(key)\n                    yield self.by_key[key]\n\n    def add(\n        self,\n        dist: Distribution,\n        entry: str | None = None,\n        insert: bool = True,\n        replace: bool = False,\n    ):\n        \"\"\"Add `dist` to working set, associated with `entry`\n\n        If `entry` is unspecified, it defaults to the ``.location`` of `dist`.\n        On exit from this routine, `entry` is added to the end of the working\n        set's ``.entries`` (if it wasn't already present).\n\n        `dist` is only added to the working set if it's for a project that\n        doesn't already have a distribution in the set, unless `replace=True`.\n        If it's added, any callbacks registered with the ``subscribe()`` method\n        will be called.\n        \"\"\"\n        if insert:\n            dist.insert_on(self.entries, entry, replace=replace)\n\n        if entry is None:\n            entry = dist.location\n        keys = self.entry_keys.setdefault(entry, [])\n        keys2 = self.entry_keys.setdefault(dist.location, [])\n        if not replace and dist.key in self.by_key:\n            # ignore hidden distros\n            return\n\n        self.by_key[dist.key] = dist\n        normalized_name = _packaging_utils.canonicalize_name(dist.key)\n        self.normalized_to_canonical_keys[normalized_name] = dist.key\n        if dist.key not in keys:\n            keys.append(dist.key)\n        if dist.key not in keys2:\n            keys2.append(dist.key)\n        self._added_new(dist)\n\n    @overload\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None,\n        installer: _InstallerTypeT[_DistributionT],\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[_DistributionT]: ...\n    @overload\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None = None,\n        *,\n        installer: _InstallerTypeT[_DistributionT],\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[_DistributionT]: ...\n    @overload\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None = None,\n        installer: _InstallerType | None = None,\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[Distribution]: ...\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None = None,\n        installer: _InstallerType | None | _InstallerTypeT[_DistributionT] = None,\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[Distribution] | list[_DistributionT]:\n        \"\"\"List all distributions needed to (recursively) meet `requirements`\n\n        `requirements` must be a sequence of ``Requirement`` objects.  `env`,\n        if supplied, should be an ``Environment`` instance.  If\n        not supplied, it defaults to all distributions available within any\n        entry or distribution in the working set.  `installer`, if supplied,\n        will be invoked with each requirement that cannot be met by an\n        already-installed distribution; it should return a ``Distribution`` or\n        ``None``.\n\n        Unless `replace_conflicting=True`, raises a VersionConflict exception\n        if\n        any requirements are found on the path that have the correct name but\n        the wrong version.  Otherwise, if an `installer` is supplied it will be\n        invoked to obtain the correct version of the requirement and activate\n        it.\n\n        `extras` is a list of the extras to be used with these requirements.\n        This is important because extra requirements may look like `my_req;\n        extra = \"my_extra\"`, which would otherwise be interpreted as a purely\n        optional requirement.  Instead, we want to be able to assert that these\n        requirements are truly required.\n        \"\"\"\n\n        # set up the stack\n        requirements = list(requirements)[::-1]\n        # set of processed requirements\n        processed = set()\n        # key -> dist\n        best = {}\n        to_activate = []\n\n        req_extras = _ReqExtras()\n\n        # Mapping of requirement to set of distributions that required it;\n        # useful for reporting info about conflicts.\n        required_by = collections.defaultdict(set)\n\n        while requirements:\n            # process dependencies breadth-first\n            req = requirements.pop(0)\n            if req in processed:\n                # Ignore cyclic or redundant dependencies\n                continue\n\n            if not req_extras.markers_pass(req, extras):\n                continue\n\n            dist = self._resolve_dist(\n                req, best, replace_conflicting, env, installer, required_by, to_activate\n            )\n\n            # push the new requirements onto the stack\n            new_requirements = dist.requires(req.extras)[::-1]\n            requirements.extend(new_requirements)\n\n            # Register the new requirements needed by req\n            for new_requirement in new_requirements:\n                required_by[new_requirement].add(req.project_name)\n                req_extras[new_requirement] = req.extras\n\n            processed.add(req)\n\n        # return list of distros to activate\n        return to_activate\n\n    def _resolve_dist(\n        self, req, best, replace_conflicting, env, installer, required_by, to_activate\n    ) -> Distribution:\n        dist = best.get(req.key)\n        if dist is None:\n            # Find the best distribution and add it to the map\n            dist = self.by_key.get(req.key)\n            if dist is None or (dist not in req and replace_conflicting):\n                ws = self\n                if env is None:\n                    if dist is None:\n                        env = Environment(self.entries)\n                    else:\n                        # Use an empty environment and workingset to avoid\n                        # any further conflicts with the conflicting\n                        # distribution\n                        env = Environment([])\n                        ws = WorkingSet([])\n                dist = best[req.key] = env.best_match(\n                    req, ws, installer, replace_conflicting=replace_conflicting\n                )\n                if dist is None:\n                    requirers = required_by.get(req, None)\n                    raise DistributionNotFound(req, requirers)\n            to_activate.append(dist)\n        if dist not in req:\n            # Oops, the \"best\" so far conflicts with a dependency\n            dependent_req = required_by[req]\n            raise VersionConflict(dist, req).with_context(dependent_req)\n        return dist\n\n    @overload\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None,\n        installer: _InstallerTypeT[_DistributionT],\n        fallback: bool = True,\n    ) -> tuple[list[_DistributionT], dict[Distribution, Exception]]: ...\n    @overload\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None = None,\n        *,\n        installer: _InstallerTypeT[_DistributionT],\n        fallback: bool = True,\n    ) -> tuple[list[_DistributionT], dict[Distribution, Exception]]: ...\n    @overload\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None = None,\n        installer: _InstallerType | None = None,\n        fallback: bool = True,\n    ) -> tuple[list[Distribution], dict[Distribution, Exception]]: ...\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None = None,\n        installer: _InstallerType | None | _InstallerTypeT[_DistributionT] = None,\n        fallback: bool = True,\n    ) -> tuple[\n        list[Distribution] | list[_DistributionT],\n        dict[Distribution, Exception],\n    ]:\n        \"\"\"Find all activatable distributions in `plugin_env`\n\n        Example usage::\n\n            distributions, errors = working_set.find_plugins(\n                Environment(plugin_dirlist)\n            )\n            # add plugins+libs to sys.path\n            map(working_set.add, distributions)\n            # display errors\n            print('Could not load', errors)\n\n        The `plugin_env` should be an ``Environment`` instance that contains\n        only distributions that are in the project's \"plugin directory\" or\n        directories. The `full_env`, if supplied, should be an ``Environment``\n        contains all currently-available distributions.  If `full_env` is not\n        supplied, one is created automatically from the ``WorkingSet`` this\n        method is called on, which will typically mean that every directory on\n        ``sys.path`` will be scanned for distributions.\n\n        `installer` is a standard installer callback as used by the\n        ``resolve()`` method. The `fallback` flag indicates whether we should\n        attempt to resolve older versions of a plugin if the newest version\n        cannot be resolved.\n\n        This method returns a 2-tuple: (`distributions`, `error_info`), where\n        `distributions` is a list of the distributions found in `plugin_env`\n        that were loadable, along with any other distributions that are needed\n        to resolve their dependencies.  `error_info` is a dictionary mapping\n        unloadable plugin distributions to an exception instance describing the\n        error that occurred. Usually this will be a ``DistributionNotFound`` or\n        ``VersionConflict`` instance.\n        \"\"\"\n\n        plugin_projects = list(plugin_env)\n        # scan project names in alphabetic order\n        plugin_projects.sort()\n\n        error_info: dict[Distribution, Exception] = {}\n        distributions: dict[Distribution, Exception | None] = {}\n\n        if full_env is None:\n            env = Environment(self.entries)\n            env += plugin_env\n        else:\n            env = full_env + plugin_env\n\n        shadow_set = self.__class__([])\n        # put all our entries in shadow_set\n        list(map(shadow_set.add, self))\n\n        for project_name in plugin_projects:\n            for dist in plugin_env[project_name]:\n                req = [dist.as_requirement()]\n\n                try:\n                    resolvees = shadow_set.resolve(req, env, installer)\n\n                except ResolutionError as v:\n                    # save error info\n                    error_info[dist] = v\n                    if fallback:\n                        # try the next older version of project\n                        continue\n                    else:\n                        # give up on this project, keep going\n                        break\n\n                else:\n                    list(map(shadow_set.add, resolvees))\n                    distributions.update(dict.fromkeys(resolvees))\n\n                    # success, no need to try any more versions of this project\n                    break\n\n        sorted_distributions = list(distributions)\n        sorted_distributions.sort()\n\n        return sorted_distributions, error_info\n\n    def require(self, *requirements: _NestedStr):\n        \"\"\"Ensure that distributions matching `requirements` are activated\n\n        `requirements` must be a string or a (possibly-nested) sequence\n        thereof, specifying the distributions and versions required.  The\n        return value is a sequence of the distributions that needed to be\n        activated to fulfill the requirements; all relevant distributions are\n        included, even if they were already activated in this working set.\n        \"\"\"\n        needed = self.resolve(parse_requirements(requirements))\n\n        for dist in needed:\n            self.add(dist)\n\n        return needed\n\n    def subscribe(\n        self, callback: Callable[[Distribution], object], existing: bool = True\n    ):\n        \"\"\"Invoke `callback` for all distributions\n\n        If `existing=True` (default),\n        call on all existing ones, as well.\n        \"\"\"\n        if callback in self.callbacks:\n            return\n        self.callbacks.append(callback)\n        if not existing:\n            return\n        for dist in self:\n            callback(dist)\n\n    def _added_new(self, dist):\n        for callback in self.callbacks:\n            callback(dist)\n\n    def __getstate__(self):\n        return (\n            self.entries[:],\n            self.entry_keys.copy(),\n            self.by_key.copy(),\n            self.normalized_to_canonical_keys.copy(),\n            self.callbacks[:],\n        )\n\n    def __setstate__(self, e_k_b_n_c):\n        entries, keys, by_key, normalized_to_canonical_keys, callbacks = e_k_b_n_c\n        self.entries = entries[:]\n        self.entry_keys = keys.copy()\n        self.by_key = by_key.copy()\n        self.normalized_to_canonical_keys = normalized_to_canonical_keys.copy()\n        self.callbacks = callbacks[:]\n\n\nclass _ReqExtras(Dict[\"Requirement\", Tuple[str, ...]]):\n    \"\"\"\n    Map each requirement to the extras that demanded it.\n    \"\"\"\n\n    def markers_pass(self, req: Requirement, extras: tuple[str, ...] | None = None):\n        \"\"\"\n        Evaluate markers for req against each extra that\n        demanded it.\n\n        Return False if the req has a marker and fails\n        evaluation. Otherwise, return True.\n        \"\"\"\n        extra_evals = (\n            req.marker.evaluate({'extra': extra})\n            for extra in self.get(req, ()) + (extras or (None,))\n        )\n        return not req.marker or any(extra_evals)\n\n\nclass Environment:\n    \"\"\"Searchable snapshot of distributions on a search path\"\"\"\n\n    def __init__(\n        self,\n        search_path: Iterable[str] | None = None,\n        platform: str | None = get_supported_platform(),\n        python: str | None = PY_MAJOR,\n    ):\n        \"\"\"Snapshot distributions available on a search path\n\n        Any distributions found on `search_path` are added to the environment.\n        `search_path` should be a sequence of ``sys.path`` items.  If not\n        supplied, ``sys.path`` is used.\n\n        `platform` is an optional string specifying the name of the platform\n        that platform-specific distributions must be compatible with.  If\n        unspecified, it defaults to the current platform.  `python` is an\n        optional string naming the desired version of Python (e.g. ``'3.6'``);\n        it defaults to the current version.\n\n        You may explicitly set `platform` (and/or `python`) to ``None`` if you\n        wish to map *all* distributions, not just those compatible with the\n        running platform or Python version.\n        \"\"\"\n        self._distmap = {}\n        self.platform = platform\n        self.python = python\n        self.scan(search_path)\n\n    def can_add(self, dist: Distribution):\n        \"\"\"Is distribution `dist` acceptable for this environment?\n\n        The distribution must match the platform and python version\n        requirements specified when this environment was created, or False\n        is returned.\n        \"\"\"\n        py_compat = (\n            self.python is None\n            or dist.py_version is None\n            or dist.py_version == self.python\n        )\n        return py_compat and compatible_platforms(dist.platform, self.platform)\n\n    def remove(self, dist: Distribution):\n        \"\"\"Remove `dist` from the environment\"\"\"\n        self._distmap[dist.key].remove(dist)\n\n    def scan(self, search_path: Iterable[str] | None = None):\n        \"\"\"Scan `search_path` for distributions usable in this environment\n\n        Any distributions found are added to the environment.\n        `search_path` should be a sequence of ``sys.path`` items.  If not\n        supplied, ``sys.path`` is used.  Only distributions conforming to\n        the platform/python version defined at initialization are added.\n        \"\"\"\n        if search_path is None:\n            search_path = sys.path\n\n        for item in search_path:\n            for dist in find_distributions(item):\n                self.add(dist)\n\n    def __getitem__(self, project_name: str) -> list[Distribution]:\n        \"\"\"Return a newest-to-oldest list of distributions for `project_name`\n\n        Uses case-insensitive `project_name` comparison, assuming all the\n        project's distributions use their project's name converted to all\n        lowercase as their key.\n\n        \"\"\"\n        distribution_key = project_name.lower()\n        return self._distmap.get(distribution_key, [])\n\n    def add(self, dist: Distribution):\n        \"\"\"Add `dist` if we ``can_add()`` it and it has not already been added\"\"\"\n        if self.can_add(dist) and dist.has_version():\n            dists = self._distmap.setdefault(dist.key, [])\n            if dist not in dists:\n                dists.append(dist)\n                dists.sort(key=operator.attrgetter('hashcmp'), reverse=True)\n\n    @overload\n    def best_match(\n        self,\n        req: Requirement,\n        working_set: WorkingSet,\n        installer: _InstallerTypeT[_DistributionT],\n        replace_conflicting: bool = False,\n    ) -> _DistributionT: ...\n    @overload\n    def best_match(\n        self,\n        req: Requirement,\n        working_set: WorkingSet,\n        installer: _InstallerType | None = None,\n        replace_conflicting: bool = False,\n    ) -> Distribution | None: ...\n    def best_match(\n        self,\n        req: Requirement,\n        working_set: WorkingSet,\n        installer: _InstallerType | None | _InstallerTypeT[_DistributionT] = None,\n        replace_conflicting: bool = False,\n    ) -> Distribution | None:\n        \"\"\"Find distribution best matching `req` and usable on `working_set`\n\n        This calls the ``find(req)`` method of the `working_set` to see if a\n        suitable distribution is already active.  (This may raise\n        ``VersionConflict`` if an unsuitable version of the project is already\n        active in the specified `working_set`.)  If a suitable distribution\n        isn't active, this method returns the newest distribution in the\n        environment that meets the ``Requirement`` in `req`.  If no suitable\n        distribution is found, and `installer` is supplied, then the result of\n        calling the environment's ``obtain(req, installer)`` method will be\n        returned.\n        \"\"\"\n        try:\n            dist = working_set.find(req)\n        except VersionConflict:\n            if not replace_conflicting:\n                raise\n            dist = None\n        if dist is not None:\n            return dist\n        for dist in self[req.key]:\n            if dist in req:\n                return dist\n        # try to download/install\n        return self.obtain(req, installer)\n\n    @overload\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: _InstallerTypeT[_DistributionT],\n    ) -> _DistributionT: ...\n    @overload\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: Callable[[Requirement], None] | None = None,\n    ) -> None: ...\n    @overload\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: _InstallerType | None = None,\n    ) -> Distribution | None: ...\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: Callable[[Requirement], None]\n        | _InstallerType\n        | None\n        | _InstallerTypeT[_DistributionT] = None,\n    ) -> Distribution | None:\n        \"\"\"Obtain a distribution matching `requirement` (e.g. via download)\n\n        Obtain a distro that matches requirement (e.g. via download).  In the\n        base ``Environment`` class, this routine just returns\n        ``installer(requirement)``, unless `installer` is None, in which case\n        None is returned instead.  This method is a hook that allows subclasses\n        to attempt other ways of obtaining a distribution before falling back\n        to the `installer` argument.\"\"\"\n        return installer(requirement) if installer else None\n\n    def __iter__(self) -> Iterator[str]:\n        \"\"\"Yield the unique project names of the available distributions\"\"\"\n        for key in self._distmap.keys():\n            if self[key]:\n                yield key\n\n    def __iadd__(self, other: Distribution | Environment):\n        \"\"\"In-place addition of a distribution or environment\"\"\"\n        if isinstance(other, Distribution):\n            self.add(other)\n        elif isinstance(other, Environment):\n            for project in other:\n                for dist in other[project]:\n                    self.add(dist)\n        else:\n            raise TypeError(\"Can't add %r to environment\" % (other,))\n        return self\n\n    def __add__(self, other: Distribution | Environment):\n        \"\"\"Add an environment or distribution to an environment\"\"\"\n        new = self.__class__([], platform=None, python=None)\n        for env in self, other:\n            new += env\n        return new\n\n\n# XXX backward compatibility\nAvailableDistributions = Environment\n\n\nclass ExtractionError(RuntimeError):\n    \"\"\"An error occurred extracting a resource\n\n    The following attributes are available from instances of this exception:\n\n    manager\n        The resource manager that raised this exception\n\n    cache_path\n        The base directory for resource extraction\n\n    original_error\n        The exception instance that caused extraction to fail\n    \"\"\"\n\n    manager: ResourceManager\n    cache_path: str\n    original_error: BaseException | None\n\n\nclass ResourceManager:\n    \"\"\"Manage resource extraction and packages\"\"\"\n\n    extraction_path: str | None = None\n\n    def __init__(self):\n        self.cached_files = {}\n\n    def resource_exists(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"Does the named resource exist?\"\"\"\n        return get_provider(package_or_requirement).has_resource(resource_name)\n\n    def resource_isdir(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"Is the named resource an existing directory?\"\"\"\n        return get_provider(package_or_requirement).resource_isdir(resource_name)\n\n    def resource_filename(\n        self, package_or_requirement: _PkgReqType, resource_name: str\n    ):\n        \"\"\"Return a true filesystem path for specified resource\"\"\"\n        return get_provider(package_or_requirement).get_resource_filename(\n            self, resource_name\n        )\n\n    def resource_stream(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"Return a readable file-like object for specified resource\"\"\"\n        return get_provider(package_or_requirement).get_resource_stream(\n            self, resource_name\n        )\n\n    def resource_string(\n        self, package_or_requirement: _PkgReqType, resource_name: str\n    ) -> bytes:\n        \"\"\"Return specified resource as :obj:`bytes`\"\"\"\n        return get_provider(package_or_requirement).get_resource_string(\n            self, resource_name\n        )\n\n    def resource_listdir(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"List the contents of the named resource directory\"\"\"\n        return get_provider(package_or_requirement).resource_listdir(resource_name)\n\n    def extraction_error(self) -> NoReturn:\n        \"\"\"Give an error message for problems extracting file(s)\"\"\"\n\n        old_exc = sys.exc_info()[1]\n        cache_path = self.extraction_path or get_default_cache()\n\n        tmpl = textwrap.dedent(\n            \"\"\"\n            Can't extract file(s) to egg cache\n\n            The following error occurred while trying to extract file(s)\n            to the Python egg cache:\n\n              {old_exc}\n\n            The Python egg cache directory is currently set to:\n\n              {cache_path}\n\n            Perhaps your account does not have write access to this directory?\n            You can change the cache directory by setting the PYTHON_EGG_CACHE\n            environment variable to point to an accessible directory.\n            \"\"\"\n        ).lstrip()\n        err = ExtractionError(tmpl.format(**locals()))\n        err.manager = self\n        err.cache_path = cache_path\n        err.original_error = old_exc\n        raise err\n\n    def get_cache_path(self, archive_name: str, names: Iterable[StrPath] = ()):\n        \"\"\"Return absolute location in cache for `archive_name` and `names`\n\n        The parent directory of the resulting path will be created if it does\n        not already exist.  `archive_name` should be the base filename of the\n        enclosing egg (which may not be the name of the enclosing zipfile!),\n        including its \".egg\" extension.  `names`, if provided, should be a\n        sequence of path name parts \"under\" the egg's extraction location.\n\n        This method should only be called by resource providers that need to\n        obtain an extraction location, and only for names they intend to\n        extract, as it tracks the generated names for possible cleanup later.\n        \"\"\"\n        extract_path = self.extraction_path or get_default_cache()\n        target_path = os.path.join(extract_path, archive_name + '-tmp', *names)\n        try:\n            _bypass_ensure_directory(target_path)\n        except Exception:\n            self.extraction_error()\n\n        self._warn_unsafe_extraction_path(extract_path)\n\n        self.cached_files[target_path] = True\n        return target_path\n\n    @staticmethod\n    def _warn_unsafe_extraction_path(path):\n        \"\"\"\n        If the default extraction path is overridden and set to an insecure\n        location, such as /tmp, it opens up an opportunity for an attacker to\n        replace an extracted file with an unauthorized payload. Warn the user\n        if a known insecure location is used.\n\n        See Distribute #375 for more details.\n        \"\"\"\n        if os.name == 'nt' and not path.startswith(os.environ['windir']):\n            # On Windows, permissions are generally restrictive by default\n            #  and temp directories are not writable by other users, so\n            #  bypass the warning.\n            return\n        mode = os.stat(path).st_mode\n        if mode & stat.S_IWOTH or mode & stat.S_IWGRP:\n            msg = (\n                \"Extraction path is writable by group/others \"\n                \"and vulnerable to attack when \"\n                \"used with get_resource_filename ({path}). \"\n                \"Consider a more secure \"\n                \"location (set with .set_extraction_path or the \"\n                \"PYTHON_EGG_CACHE environment variable).\"\n            ).format(**locals())\n            warnings.warn(msg, UserWarning)\n\n    def postprocess(self, tempname: StrOrBytesPath, filename: StrOrBytesPath):\n        \"\"\"Perform any platform-specific postprocessing of `tempname`\n\n        This is where Mac header rewrites should be done; other platforms don't\n        have anything special they should do.\n\n        Resource providers should call this method ONLY after successfully\n        extracting a compressed resource.  They must NOT call it on resources\n        that are already in the filesystem.\n\n        `tempname` is the current (temporary) name of the file, and `filename`\n        is the name it will be renamed to by the caller after this routine\n        returns.\n        \"\"\"\n\n        if os.name == 'posix':\n            # Make the resource executable\n            mode = ((os.stat(tempname).st_mode) | 0o555) & 0o7777\n            os.chmod(tempname, mode)\n\n    def set_extraction_path(self, path: str):\n        \"\"\"Set the base path where resources will be extracted to, if needed.\n\n        If you do not call this routine before any extractions take place, the\n        path defaults to the return value of ``get_default_cache()``.  (Which\n        is based on the ``PYTHON_EGG_CACHE`` environment variable, with various\n        platform-specific fallbacks.  See that routine's documentation for more\n        details.)\n\n        Resources are extracted to subdirectories of this path based upon\n        information given by the ``IResourceProvider``.  You may set this to a\n        temporary directory, but then you must call ``cleanup_resources()`` to\n        delete the extracted files when done.  There is no guarantee that\n        ``cleanup_resources()`` will be able to remove all extracted files.\n\n        (Note: you may not change the extraction path for a given resource\n        manager once resources have been extracted, unless you first call\n        ``cleanup_resources()``.)\n        \"\"\"\n        if self.cached_files:\n            raise ValueError(\"Can't change extraction path, files already extracted\")\n\n        self.extraction_path = path\n\n    def cleanup_resources(self, force: bool = False) -> list[str]:\n        \"\"\"\n        Delete all extracted resource files and directories, returning a list\n        of the file and directory names that could not be successfully removed.\n        This function does not have any concurrency protection, so it should\n        generally only be called when the extraction path is a temporary\n        directory exclusive to a single process.  This method is not\n        automatically called; you must call it explicitly or register it as an\n        ``atexit`` function if you wish to ensure cleanup of a temporary\n        directory used for extractions.\n        \"\"\"\n        # XXX\n        return []\n\n\ndef get_default_cache() -> str:\n    \"\"\"\n    Return the ``PYTHON_EGG_CACHE`` environment variable\n    or a platform-relevant user cache dir for an app\n    named \"Python-Eggs\".\n    \"\"\"\n    return os.environ.get('PYTHON_EGG_CACHE') or _user_cache_dir(appname='Python-Eggs')\n\n\ndef safe_name(name: str):\n    \"\"\"Convert an arbitrary string to a standard distribution name\n\n    Any runs of non-alphanumeric/. characters are replaced with a single '-'.\n    \"\"\"\n    return re.sub('[^A-Za-z0-9.]+', '-', name)\n\n\ndef safe_version(version: str):\n    \"\"\"\n    Convert an arbitrary string to a standard version string\n    \"\"\"\n    try:\n        # normalize the version\n        return str(_packaging_version.Version(version))\n    except _packaging_version.InvalidVersion:\n        version = version.replace(' ', '.')\n        return re.sub('[^A-Za-z0-9.]+', '-', version)\n\n\ndef _forgiving_version(version):\n    \"\"\"Fallback when ``safe_version`` is not safe enough\n    >>> parse_version(_forgiving_version('0.23ubuntu1'))\n    <Version('0.23.dev0+sanitized.ubuntu1')>\n    >>> parse_version(_forgiving_version('0.23-'))\n    <Version('0.23.dev0+sanitized')>\n    >>> parse_version(_forgiving_version('0.-_'))\n    <Version('0.dev0+sanitized')>\n    >>> parse_version(_forgiving_version('42.+?1'))\n    <Version('42.dev0+sanitized.1')>\n    >>> parse_version(_forgiving_version('hello world'))\n    <Version('0.dev0+sanitized.hello.world')>\n    \"\"\"\n    version = version.replace(' ', '.')\n    match = _PEP440_FALLBACK.search(version)\n    if match:\n        safe = match[\"safe\"]\n        rest = version[len(safe) :]\n    else:\n        safe = \"0\"\n        rest = version\n    local = f\"sanitized.{_safe_segment(rest)}\".strip(\".\")\n    return f\"{safe}.dev0+{local}\"\n\n\ndef _safe_segment(segment):\n    \"\"\"Convert an arbitrary string into a safe segment\"\"\"\n    segment = re.sub('[^A-Za-z0-9.]+', '-', segment)\n    segment = re.sub('-[^A-Za-z0-9]+', '-', segment)\n    return re.sub(r'\\.[^A-Za-z0-9]+', '.', segment).strip(\".-\")\n\n\ndef safe_extra(extra: str):\n    \"\"\"Convert an arbitrary string to a standard 'extra' name\n\n    Any runs of non-alphanumeric characters are replaced with a single '_',\n    and the result is always lowercased.\n    \"\"\"\n    return re.sub('[^A-Za-z0-9.-]+', '_', extra).lower()\n\n\ndef to_filename(name: str):\n    \"\"\"Convert a project or version name to its filename-escaped form\n\n    Any '-' characters are currently replaced with '_'.\n    \"\"\"\n    return name.replace('-', '_')\n\n\ndef invalid_marker(text: str):\n    \"\"\"\n    Validate text as a PEP 508 environment marker; return an exception\n    if invalid or False otherwise.\n    \"\"\"\n    try:\n        evaluate_marker(text)\n    except SyntaxError as e:\n        e.filename = None\n        e.lineno = None\n        return e\n    return False\n\n\ndef evaluate_marker(text: str, extra: str | None = None) -> bool:\n    \"\"\"\n    Evaluate a PEP 508 environment marker.\n    Return a boolean indicating the marker result in this environment.\n    Raise SyntaxError if marker is invalid.\n\n    This implementation uses the 'pyparsing' module.\n    \"\"\"\n    try:\n        marker = _packaging_markers.Marker(text)\n        return marker.evaluate()\n    except _packaging_markers.InvalidMarker as e:\n        raise SyntaxError(e) from e\n\n\nclass NullProvider:\n    \"\"\"Try to implement resources and metadata for arbitrary PEP 302 loaders\"\"\"\n\n    egg_name: str | None = None\n    egg_info: str | None = None\n    loader: _LoaderProtocol | None = None\n\n    def __init__(self, module: _ModuleLike):\n        self.loader = getattr(module, '__loader__', None)\n        self.module_path = os.path.dirname(getattr(module, '__file__', ''))\n\n    def get_resource_filename(self, manager: ResourceManager, resource_name: str):\n        return self._fn(self.module_path, resource_name)\n\n    def get_resource_stream(self, manager: ResourceManager, resource_name: str):\n        return io.BytesIO(self.get_resource_string(manager, resource_name))\n\n    def get_resource_string(\n        self, manager: ResourceManager, resource_name: str\n    ) -> bytes:\n        return self._get(self._fn(self.module_path, resource_name))\n\n    def has_resource(self, resource_name: str):\n        return self._has(self._fn(self.module_path, resource_name))\n\n    def _get_metadata_path(self, name):\n        return self._fn(self.egg_info, name)\n\n    def has_metadata(self, name: str) -> bool:\n        if not self.egg_info:\n            return False\n\n        path = self._get_metadata_path(name)\n        return self._has(path)\n\n    def get_metadata(self, name: str):\n        if not self.egg_info:\n            return \"\"\n        path = self._get_metadata_path(name)\n        value = self._get(path)\n        try:\n            return value.decode('utf-8')\n        except UnicodeDecodeError as exc:\n            # Include the path in the error message to simplify\n            # troubleshooting, and without changing the exception type.\n            exc.reason += ' in {} file at path: {}'.format(name, path)\n            raise\n\n    def get_metadata_lines(self, name: str) -> Iterator[str]:\n        return yield_lines(self.get_metadata(name))\n\n    def resource_isdir(self, resource_name: str):\n        return self._isdir(self._fn(self.module_path, resource_name))\n\n    def metadata_isdir(self, name: str) -> bool:\n        return bool(self.egg_info and self._isdir(self._fn(self.egg_info, name)))\n\n    def resource_listdir(self, resource_name: str):\n        return self._listdir(self._fn(self.module_path, resource_name))\n\n    def metadata_listdir(self, name: str) -> list[str]:\n        if self.egg_info:\n            return self._listdir(self._fn(self.egg_info, name))\n        return []\n\n    def run_script(self, script_name: str, namespace: dict[str, Any]):\n        script = 'scripts/' + script_name\n        if not self.has_metadata(script):\n            raise ResolutionError(\n                \"Script {script!r} not found in metadata at {self.egg_info!r}\".format(\n                    **locals()\n                ),\n            )\n\n        script_text = self.get_metadata(script).replace('\\r\\n', '\\n')\n        script_text = script_text.replace('\\r', '\\n')\n        script_filename = self._fn(self.egg_info, script)\n        namespace['__file__'] = script_filename\n        if os.path.exists(script_filename):\n            source = _read_utf8_with_fallback(script_filename)\n            code = compile(source, script_filename, 'exec')\n            exec(code, namespace, namespace)\n        else:\n            from linecache import cache\n\n            cache[script_filename] = (\n                len(script_text),\n                0,\n                script_text.split('\\n'),\n                script_filename,\n            )\n            script_code = compile(script_text, script_filename, 'exec')\n            exec(script_code, namespace, namespace)\n\n    def _has(self, path) -> bool:\n        raise NotImplementedError(\n            \"Can't perform this operation for unregistered loader type\"\n        )\n\n    def _isdir(self, path) -> bool:\n        raise NotImplementedError(\n            \"Can't perform this operation for unregistered loader type\"\n        )\n\n    def _listdir(self, path) -> list[str]:\n        raise NotImplementedError(\n            \"Can't perform this operation for unregistered loader type\"\n        )\n\n    def _fn(self, base: str | None, resource_name: str):\n        if base is None:\n            raise TypeError(\n                \"`base` parameter in `_fn` is `None`. Either override this method or check the parameter first.\"\n            )\n        self._validate_resource_path(resource_name)\n        if resource_name:\n            return os.path.join(base, *resource_name.split('/'))\n        return base\n\n    @staticmethod\n    def _validate_resource_path(path):\n        \"\"\"\n        Validate the resource paths according to the docs.\n        https://setuptools.pypa.io/en/latest/pkg_resources.html#basic-resource-access\n\n        >>> warned = getfixture('recwarn')\n        >>> warnings.simplefilter('always')\n        >>> vrp = NullProvider._validate_resource_path\n        >>> vrp('foo/bar.txt')\n        >>> bool(warned)\n        False\n        >>> vrp('../foo/bar.txt')\n        >>> bool(warned)\n        True\n        >>> warned.clear()\n        >>> vrp('/foo/bar.txt')\n        >>> bool(warned)\n        True\n        >>> vrp('foo/../../bar.txt')\n        >>> bool(warned)\n        True\n        >>> warned.clear()\n        >>> vrp('foo/f../bar.txt')\n        >>> bool(warned)\n        False\n\n        Windows path separators are straight-up disallowed.\n        >>> vrp(r'\\\\foo/bar.txt')\n        Traceback (most recent call last):\n        ...\n        ValueError: Use of .. or absolute path in a resource path \\\nis not allowed.\n\n        >>> vrp(r'C:\\\\foo/bar.txt')\n        Traceback (most recent call last):\n        ...\n        ValueError: Use of .. or absolute path in a resource path \\\nis not allowed.\n\n        Blank values are allowed\n\n        >>> vrp('')\n        >>> bool(warned)\n        False\n\n        Non-string values are not.\n\n        >>> vrp(None)\n        Traceback (most recent call last):\n        ...\n        AttributeError: ...\n        \"\"\"\n        invalid = (\n            os.path.pardir in path.split(posixpath.sep)\n            or posixpath.isabs(path)\n            or ntpath.isabs(path)\n            or path.startswith(\"\\\\\")\n        )\n        if not invalid:\n            return\n\n        msg = \"Use of .. or absolute path in a resource path is not allowed.\"\n\n        # Aggressively disallow Windows absolute paths\n        if (path.startswith(\"\\\\\") or ntpath.isabs(path)) and not posixpath.isabs(path):\n            raise ValueError(msg)\n\n        # for compatibility, warn; in future\n        # raise ValueError(msg)\n        issue_warning(\n            msg[:-1] + \" and will raise exceptions in a future release.\",\n            DeprecationWarning,\n        )\n\n    def _get(self, path) -> bytes:\n        if hasattr(self.loader, 'get_data') and self.loader:\n            # Already checked get_data exists\n            return self.loader.get_data(path)  # type: ignore[attr-defined]\n        raise NotImplementedError(\n            \"Can't perform this operation for loaders without 'get_data()'\"\n        )\n\n\nregister_loader_type(object, NullProvider)\n\n\ndef _parents(path):\n    \"\"\"\n    yield all parents of path including path\n    \"\"\"\n    last = None\n    while path != last:\n        yield path\n        last = path\n        path, _ = os.path.split(path)\n\n\nclass EggProvider(NullProvider):\n    \"\"\"Provider based on a virtual filesystem\"\"\"\n\n    def __init__(self, module: _ModuleLike):\n        super().__init__(module)\n        self._setup_prefix()\n\n    def _setup_prefix(self):\n        # Assume that metadata may be nested inside a \"basket\"\n        # of multiple eggs and use module_path instead of .archive.\n        eggs = filter(_is_egg_path, _parents(self.module_path))\n        egg = next(eggs, None)\n        egg and self._set_egg(egg)\n\n    def _set_egg(self, path: str):\n        self.egg_name = os.path.basename(path)\n        self.egg_info = os.path.join(path, 'EGG-INFO')\n        self.egg_root = path\n\n\nclass DefaultProvider(EggProvider):\n    \"\"\"Provides access to package resources in the filesystem\"\"\"\n\n    def _has(self, path) -> bool:\n        return os.path.exists(path)\n\n    def _isdir(self, path) -> bool:\n        return os.path.isdir(path)\n\n    def _listdir(self, path):\n        return os.listdir(path)\n\n    def get_resource_stream(self, manager: object, resource_name: str):\n        return open(self._fn(self.module_path, resource_name), 'rb')\n\n    def _get(self, path) -> bytes:\n        with open(path, 'rb') as stream:\n            return stream.read()\n\n    @classmethod\n    def _register(cls):\n        loader_names = (\n            'SourceFileLoader',\n            'SourcelessFileLoader',\n        )\n        for name in loader_names:\n            loader_cls = getattr(importlib.machinery, name, type(None))\n            register_loader_type(loader_cls, cls)\n\n\nDefaultProvider._register()\n\n\nclass EmptyProvider(NullProvider):\n    \"\"\"Provider that returns nothing for all requests\"\"\"\n\n    # A special case, we don't want all Providers inheriting from NullProvider to have a potentially None module_path\n    module_path: str | None = None  # type: ignore[assignment]\n\n    _isdir = _has = lambda self, path: False\n\n    def _get(self, path) -> bytes:\n        return b''\n\n    def _listdir(self, path):\n        return []\n\n    def __init__(self):\n        pass\n\n\nempty_provider = EmptyProvider()\n\n\nclass ZipManifests(Dict[str, \"MemoizedZipManifests.manifest_mod\"]):\n    \"\"\"\n    zip manifest builder\n    \"\"\"\n\n    # `path` could be `StrPath | IO[bytes]` but that violates the LSP for `MemoizedZipManifests.load`\n    @classmethod\n    def build(cls, path: str):\n        \"\"\"\n        Build a dictionary similar to the zipimport directory\n        caches, except instead of tuples, store ZipInfo objects.\n\n        Use a platform-specific path separator (os.sep) for the path keys\n        for compatibility with pypy on Windows.\n        \"\"\"\n        with zipfile.ZipFile(path) as zfile:\n            items = (\n                (\n                    name.replace('/', os.sep),\n                    zfile.getinfo(name),\n                )\n                for name in zfile.namelist()\n            )\n            return dict(items)\n\n    load = build\n\n\nclass MemoizedZipManifests(ZipManifests):\n    \"\"\"\n    Memoized zipfile manifests.\n    \"\"\"\n\n    class manifest_mod(NamedTuple):\n        manifest: dict[str, zipfile.ZipInfo]\n        mtime: float\n\n    def load(self, path: str) -> dict[str, zipfile.ZipInfo]:  # type: ignore[override] # ZipManifests.load is a classmethod\n        \"\"\"\n        Load a manifest at path or return a suitable manifest already loaded.\n        \"\"\"\n        path = os.path.normpath(path)\n        mtime = os.stat(path).st_mtime\n\n        if path not in self or self[path].mtime != mtime:\n            manifest = self.build(path)\n            self[path] = self.manifest_mod(manifest, mtime)\n\n        return self[path].manifest\n\n\nclass ZipProvider(EggProvider):\n    \"\"\"Resource support for zips and eggs\"\"\"\n\n    eagers: list[str] | None = None\n    _zip_manifests = MemoizedZipManifests()\n    # ZipProvider's loader should always be a zipimporter or equivalent\n    loader: zipimport.zipimporter\n\n    def __init__(self, module: _ZipLoaderModule):\n        super().__init__(module)\n        self.zip_pre = self.loader.archive + os.sep\n\n    def _zipinfo_name(self, fspath):\n        # Convert a virtual filename (full path to file) into a zipfile subpath\n        # usable with the zipimport directory cache for our target archive\n        fspath = fspath.rstrip(os.sep)\n        if fspath == self.loader.archive:\n            return ''\n        if fspath.startswith(self.zip_pre):\n            return fspath[len(self.zip_pre) :]\n        raise AssertionError(\"%s is not a subpath of %s\" % (fspath, self.zip_pre))\n\n    def _parts(self, zip_path):\n        # Convert a zipfile subpath into an egg-relative path part list.\n        # pseudo-fs path\n        fspath = self.zip_pre + zip_path\n        if fspath.startswith(self.egg_root + os.sep):\n            return fspath[len(self.egg_root) + 1 :].split(os.sep)\n        raise AssertionError(\"%s is not a subpath of %s\" % (fspath, self.egg_root))\n\n    @property\n    def zipinfo(self):\n        return self._zip_manifests.load(self.loader.archive)\n\n    def get_resource_filename(self, manager: ResourceManager, resource_name: str):\n        if not self.egg_name:\n            raise NotImplementedError(\n                \"resource_filename() only supported for .egg, not .zip\"\n            )\n        # no need to lock for extraction, since we use temp names\n        zip_path = self._resource_to_zip(resource_name)\n        eagers = self._get_eager_resources()\n        if '/'.join(self._parts(zip_path)) in eagers:\n            for name in eagers:\n                self._extract_resource(manager, self._eager_to_zip(name))\n        return self._extract_resource(manager, zip_path)\n\n    @staticmethod\n    def _get_date_and_size(zip_stat):\n        size = zip_stat.file_size\n        # ymdhms+wday, yday, dst\n        date_time = zip_stat.date_time + (0, 0, -1)\n        # 1980 offset already done\n        timestamp = time.mktime(date_time)\n        return timestamp, size\n\n    # FIXME: 'ZipProvider._extract_resource' is too complex (12)\n    def _extract_resource(self, manager: ResourceManager, zip_path) -> str:  # noqa: C901\n        if zip_path in self._index():\n            for name in self._index()[zip_path]:\n                last = self._extract_resource(manager, os.path.join(zip_path, name))\n            # return the extracted directory name\n            return os.path.dirname(last)\n\n        timestamp, size = self._get_date_and_size(self.zipinfo[zip_path])\n\n        if not WRITE_SUPPORT:\n            raise OSError(\n                '\"os.rename\" and \"os.unlink\" are not supported ' 'on this platform'\n            )\n        try:\n            if not self.egg_name:\n                raise OSError(\n                    '\"egg_name\" is empty. This likely means no egg could be found from the \"module_path\".'\n                )\n            real_path = manager.get_cache_path(self.egg_name, self._parts(zip_path))\n\n            if self._is_current(real_path, zip_path):\n                return real_path\n\n            outf, tmpnam = _mkstemp(\n                \".$extract\",\n                dir=os.path.dirname(real_path),\n            )\n            os.write(outf, self.loader.get_data(zip_path))\n            os.close(outf)\n            utime(tmpnam, (timestamp, timestamp))\n            manager.postprocess(tmpnam, real_path)\n\n            try:\n                rename(tmpnam, real_path)\n\n            except OSError:\n                if os.path.isfile(real_path):\n                    if self._is_current(real_path, zip_path):\n                        # the file became current since it was checked above,\n                        #  so proceed.\n                        return real_path\n                    # Windows, del old file and retry\n                    elif os.name == 'nt':\n                        unlink(real_path)\n                        rename(tmpnam, real_path)\n                        return real_path\n                raise\n\n        except OSError:\n            # report a user-friendly error\n            manager.extraction_error()\n\n        return real_path\n\n    def _is_current(self, file_path, zip_path):\n        \"\"\"\n        Return True if the file_path is current for this zip_path\n        \"\"\"\n        timestamp, size = self._get_date_and_size(self.zipinfo[zip_path])\n        if not os.path.isfile(file_path):\n            return False\n        stat = os.stat(file_path)\n        if stat.st_size != size or stat.st_mtime != timestamp:\n            return False\n        # check that the contents match\n        zip_contents = self.loader.get_data(zip_path)\n        with open(file_path, 'rb') as f:\n            file_contents = f.read()\n        return zip_contents == file_contents\n\n    def _get_eager_resources(self):\n        if self.eagers is None:\n            eagers = []\n            for name in ('native_libs.txt', 'eager_resources.txt'):\n                if self.has_metadata(name):\n                    eagers.extend(self.get_metadata_lines(name))\n            self.eagers = eagers\n        return self.eagers\n\n    def _index(self):\n        try:\n            return self._dirindex\n        except AttributeError:\n            ind = {}\n            for path in self.zipinfo:\n                parts = path.split(os.sep)\n                while parts:\n                    parent = os.sep.join(parts[:-1])\n                    if parent in ind:\n                        ind[parent].append(parts[-1])\n                        break\n                    else:\n                        ind[parent] = [parts.pop()]\n            self._dirindex = ind\n            return ind\n\n    def _has(self, fspath) -> bool:\n        zip_path = self._zipinfo_name(fspath)\n        return zip_path in self.zipinfo or zip_path in self._index()\n\n    def _isdir(self, fspath) -> bool:\n        return self._zipinfo_name(fspath) in self._index()\n\n    def _listdir(self, fspath):\n        return list(self._index().get(self._zipinfo_name(fspath), ()))\n\n    def _eager_to_zip(self, resource_name: str):\n        return self._zipinfo_name(self._fn(self.egg_root, resource_name))\n\n    def _resource_to_zip(self, resource_name: str):\n        return self._zipinfo_name(self._fn(self.module_path, resource_name))\n\n\nregister_loader_type(zipimport.zipimporter, ZipProvider)\n\n\nclass FileMetadata(EmptyProvider):\n    \"\"\"Metadata handler for standalone PKG-INFO files\n\n    Usage::\n\n        metadata = FileMetadata(\"/path/to/PKG-INFO\")\n\n    This provider rejects all data and metadata requests except for PKG-INFO,\n    which is treated as existing, and will be the contents of the file at\n    the provided location.\n    \"\"\"\n\n    def __init__(self, path: StrPath):\n        self.path = path\n\n    def _get_metadata_path(self, name):\n        return self.path\n\n    def has_metadata(self, name: str) -> bool:\n        return name == 'PKG-INFO' and os.path.isfile(self.path)\n\n    def get_metadata(self, name: str):\n        if name != 'PKG-INFO':\n            raise KeyError(\"No metadata except PKG-INFO is available\")\n\n        with open(self.path, encoding='utf-8', errors=\"replace\") as f:\n            metadata = f.read()\n        self._warn_on_replacement(metadata)\n        return metadata\n\n    def _warn_on_replacement(self, metadata):\n        replacement_char = '\ufffd'\n        if replacement_char in metadata:\n            tmpl = \"{self.path} could not be properly decoded in UTF-8\"\n            msg = tmpl.format(**locals())\n            warnings.warn(msg)\n\n    def get_metadata_lines(self, name: str) -> Iterator[str]:\n        return yield_lines(self.get_metadata(name))\n\n\nclass PathMetadata(DefaultProvider):\n    \"\"\"Metadata provider for egg directories\n\n    Usage::\n\n        # Development eggs:\n\n        egg_info = \"/path/to/PackageName.egg-info\"\n        base_dir = os.path.dirname(egg_info)\n        metadata = PathMetadata(base_dir, egg_info)\n        dist_name = os.path.splitext(os.path.basename(egg_info))[0]\n        dist = Distribution(basedir, project_name=dist_name, metadata=metadata)\n\n        # Unpacked egg directories:\n\n        egg_path = \"/path/to/PackageName-ver-pyver-etc.egg\"\n        metadata = PathMetadata(egg_path, os.path.join(egg_path,'EGG-INFO'))\n        dist = Distribution.from_filename(egg_path, metadata=metadata)\n    \"\"\"\n\n    def __init__(self, path: str, egg_info: str):\n        self.module_path = path\n        self.egg_info = egg_info\n\n\nclass EggMetadata(ZipProvider):\n    \"\"\"Metadata provider for .egg files\"\"\"\n\n    def __init__(self, importer: zipimport.zipimporter):\n        \"\"\"Create a metadata provider from a zipimporter\"\"\"\n\n        self.zip_pre = importer.archive + os.sep\n        self.loader = importer\n        if importer.prefix:\n            self.module_path = os.path.join(importer.archive, importer.prefix)\n        else:\n            self.module_path = importer.archive\n        self._setup_prefix()\n\n\n_distribution_finders: dict[type, _DistFinderType[Any]] = _declare_state(\n    'dict', '_distribution_finders', {}\n)\n\n\ndef register_finder(importer_type: type[_T], distribution_finder: _DistFinderType[_T]):\n    \"\"\"Register `distribution_finder` to find distributions in sys.path items\n\n    `importer_type` is the type or class of a PEP 302 \"Importer\" (sys.path item\n    handler), and `distribution_finder` is a callable that, passed a path\n    item and the importer instance, yields ``Distribution`` instances found on\n    that path item.  See ``pkg_resources.find_on_path`` for an example.\"\"\"\n    _distribution_finders[importer_type] = distribution_finder\n\n\ndef find_distributions(path_item: str, only: bool = False):\n    \"\"\"Yield distributions accessible via `path_item`\"\"\"\n    importer = get_importer(path_item)\n    finder = _find_adapter(_distribution_finders, importer)\n    return finder(importer, path_item, only)\n\n\ndef find_eggs_in_zip(\n    importer: zipimport.zipimporter, path_item: str, only: bool = False\n) -> Iterator[Distribution]:\n    \"\"\"\n    Find eggs in zip files; possibly multiple nested eggs.\n    \"\"\"\n    if importer.archive.endswith('.whl'):\n        # wheels are not supported with this finder\n        # they don't have PKG-INFO metadata, and won't ever contain eggs\n        return\n    metadata = EggMetadata(importer)\n    if metadata.has_metadata('PKG-INFO'):\n        yield Distribution.from_filename(path_item, metadata=metadata)\n    if only:\n        # don't yield nested distros\n        return\n    for subitem in metadata.resource_listdir(''):\n        if _is_egg_path(subitem):\n            subpath = os.path.join(path_item, subitem)\n            dists = find_eggs_in_zip(zipimport.zipimporter(subpath), subpath)\n            yield from dists\n        elif subitem.lower().endswith(('.dist-info', '.egg-info')):\n            subpath = os.path.join(path_item, subitem)\n            submeta = EggMetadata(zipimport.zipimporter(subpath))\n            submeta.egg_info = subpath\n            yield Distribution.from_location(path_item, subitem, submeta)\n\n\nregister_finder(zipimport.zipimporter, find_eggs_in_zip)\n\n\ndef find_nothing(\n    importer: object | None, path_item: str | None, only: bool | None = False\n):\n    return ()\n\n\nregister_finder(object, find_nothing)\n\n\ndef find_on_path(importer: object | None, path_item, only=False):\n    \"\"\"Yield distributions accessible on a sys.path directory\"\"\"\n    path_item = _normalize_cached(path_item)\n\n    if _is_unpacked_egg(path_item):\n        yield Distribution.from_filename(\n            path_item,\n            metadata=PathMetadata(path_item, os.path.join(path_item, 'EGG-INFO')),\n        )\n        return\n\n    entries = (os.path.join(path_item, child) for child in safe_listdir(path_item))\n\n    # scan for .egg and .egg-info in directory\n    for entry in sorted(entries):\n        fullpath = os.path.join(path_item, entry)\n        factory = dist_factory(path_item, entry, only)\n        yield from factory(fullpath)\n\n\ndef dist_factory(path_item, entry, only):\n    \"\"\"Return a dist_factory for the given entry.\"\"\"\n    lower = entry.lower()\n    is_egg_info = lower.endswith('.egg-info')\n    is_dist_info = lower.endswith('.dist-info') and os.path.isdir(\n        os.path.join(path_item, entry)\n    )\n    is_meta = is_egg_info or is_dist_info\n    return (\n        distributions_from_metadata\n        if is_meta\n        else find_distributions\n        if not only and _is_egg_path(entry)\n        else resolve_egg_link\n        if not only and lower.endswith('.egg-link')\n        else NoDists()\n    )\n\n\nclass NoDists:\n    \"\"\"\n    >>> bool(NoDists())\n    False\n\n    >>> list(NoDists()('anything'))\n    []\n    \"\"\"\n\n    def __bool__(self):\n        return False\n\n    def __call__(self, fullpath):\n        return iter(())\n\n\ndef safe_listdir(path: StrOrBytesPath):\n    \"\"\"\n    Attempt to list contents of path, but suppress some exceptions.\n    \"\"\"\n    try:\n        return os.listdir(path)\n    except (PermissionError, NotADirectoryError):\n        pass\n    except OSError as e:\n        # Ignore the directory if does not exist, not a directory or\n        # permission denied\n        if e.errno not in (errno.ENOTDIR, errno.EACCES, errno.ENOENT):\n            raise\n    return ()\n\n\ndef distributions_from_metadata(path: str):\n    root = os.path.dirname(path)\n    if os.path.isdir(path):\n        if len(os.listdir(path)) == 0:\n            # empty metadata dir; skip\n            return\n        metadata: _MetadataType = PathMetadata(root, path)\n    else:\n        metadata = FileMetadata(path)\n    entry = os.path.basename(path)\n    yield Distribution.from_location(\n        root,\n        entry,\n        metadata,\n        precedence=DEVELOP_DIST,\n    )\n\n\ndef non_empty_lines(path):\n    \"\"\"\n    Yield non-empty lines from file at path\n    \"\"\"\n    for line in _read_utf8_with_fallback(path).splitlines():\n        line = line.strip()\n        if line:\n            yield line\n\n\ndef resolve_egg_link(path):\n    \"\"\"\n    Given a path to an .egg-link, resolve distributions\n    present in the referenced path.\n    \"\"\"\n    referenced_paths = non_empty_lines(path)\n    resolved_paths = (\n        os.path.join(os.path.dirname(path), ref) for ref in referenced_paths\n    )\n    dist_groups = map(find_distributions, resolved_paths)\n    return next(dist_groups, ())\n\n\nif hasattr(pkgutil, 'ImpImporter'):\n    register_finder(pkgutil.ImpImporter, find_on_path)\n\nregister_finder(importlib.machinery.FileFinder, find_on_path)\n\n_namespace_handlers: dict[type, _NSHandlerType[Any]] = _declare_state(\n    'dict', '_namespace_handlers', {}\n)\n_namespace_packages: dict[str | None, list[str]] = _declare_state(\n    'dict', '_namespace_packages', {}\n)\n\n\ndef register_namespace_handler(\n    importer_type: type[_T], namespace_handler: _NSHandlerType[_T]\n):\n    \"\"\"Register `namespace_handler` to declare namespace packages\n\n    `importer_type` is the type or class of a PEP 302 \"Importer\" (sys.path item\n    handler), and `namespace_handler` is a callable like this::\n\n        def namespace_handler(importer, path_entry, moduleName, module):\n            # return a path_entry to use for child packages\n\n    Namespace handlers are only called if the importer object has already\n    agreed that it can handle the relevant path item, and they should only\n    return a subpath if the module __path__ does not already contain an\n    equivalent subpath.  For an example namespace handler, see\n    ``pkg_resources.file_ns_handler``.\n    \"\"\"\n    _namespace_handlers[importer_type] = namespace_handler\n\n\ndef _handle_ns(packageName, path_item):\n    \"\"\"Ensure that named package includes a subpath of path_item (if needed)\"\"\"\n\n    importer = get_importer(path_item)\n    if importer is None:\n        return None\n\n    # use find_spec (PEP 451) and fall-back to find_module (PEP 302)\n    try:\n        spec = importer.find_spec(packageName)\n    except AttributeError:\n        # capture warnings due to #1111\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            loader = importer.find_module(packageName)\n    else:\n        loader = spec.loader if spec else None\n\n    if loader is None:\n        return None\n    module = sys.modules.get(packageName)\n    if module is None:\n        module = sys.modules[packageName] = types.ModuleType(packageName)\n        module.__path__ = []\n        _set_parent_ns(packageName)\n    elif not hasattr(module, '__path__'):\n        raise TypeError(\"Not a package:\", packageName)\n    handler = _find_adapter(_namespace_handlers, importer)\n    subpath = handler(importer, path_item, packageName, module)\n    if subpath is not None:\n        path = module.__path__\n        path.append(subpath)\n        importlib.import_module(packageName)\n        _rebuild_mod_path(path, packageName, module)\n    return subpath\n\n\ndef _rebuild_mod_path(orig_path, package_name, module: types.ModuleType):\n    \"\"\"\n    Rebuild module.__path__ ensuring that all entries are ordered\n    corresponding to their sys.path order\n    \"\"\"\n    sys_path = [_normalize_cached(p) for p in sys.path]\n\n    def safe_sys_path_index(entry):\n        \"\"\"\n        Workaround for #520 and #513.\n        \"\"\"\n        try:\n            return sys_path.index(entry)\n        except ValueError:\n            return float('inf')\n\n    def position_in_sys_path(path):\n        \"\"\"\n        Return the ordinal of the path based on its position in sys.path\n        \"\"\"\n        path_parts = path.split(os.sep)\n        module_parts = package_name.count('.') + 1\n        parts = path_parts[:-module_parts]\n        return safe_sys_path_index(_normalize_cached(os.sep.join(parts)))\n\n    new_path = sorted(orig_path, key=position_in_sys_path)\n    new_path = [_normalize_cached(p) for p in new_path]\n\n    if isinstance(module.__path__, list):\n        module.__path__[:] = new_path\n    else:\n        module.__path__ = new_path\n\n\ndef declare_namespace(packageName: str):\n    \"\"\"Declare that package 'packageName' is a namespace package\"\"\"\n\n    msg = (\n        f\"Deprecated call to `pkg_resources.declare_namespace({packageName!r})`.\\n\"\n        \"Implementing implicit namespace packages (as specified in PEP 420) \"\n        \"is preferred to `pkg_resources.declare_namespace`. \"\n        \"See https://setuptools.pypa.io/en/latest/references/\"\n        \"keywords.html#keyword-namespace-packages\"\n    )\n    warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    _imp.acquire_lock()\n    try:\n        if packageName in _namespace_packages:\n            return\n\n        path: MutableSequence[str] = sys.path\n        parent, _, _ = packageName.rpartition('.')\n\n        if parent:\n            declare_namespace(parent)\n            if parent not in _namespace_packages:\n                __import__(parent)\n            try:\n                path = sys.modules[parent].__path__\n            except AttributeError as e:\n                raise TypeError(\"Not a package:\", parent) from e\n\n        # Track what packages are namespaces, so when new path items are added,\n        # they can be updated\n        _namespace_packages.setdefault(parent or None, []).append(packageName)\n        _namespace_packages.setdefault(packageName, [])\n\n        for path_item in path:\n            # Ensure all the parent's path items are reflected in the child,\n            # if they apply\n            _handle_ns(packageName, path_item)\n\n    finally:\n        _imp.release_lock()\n\n\ndef fixup_namespace_packages(path_item: str, parent: str | None = None):\n    \"\"\"Ensure that previously-declared namespace packages include path_item\"\"\"\n    _imp.acquire_lock()\n    try:\n        for package in _namespace_packages.get(parent, ()):\n            subpath = _handle_ns(package, path_item)\n            if subpath:\n                fixup_namespace_packages(subpath, package)\n    finally:\n        _imp.release_lock()\n\n\ndef file_ns_handler(\n    importer: object,\n    path_item: StrPath,\n    packageName: str,\n    module: types.ModuleType,\n):\n    \"\"\"Compute an ns-package subpath for a filesystem or zipfile importer\"\"\"\n\n    subpath = os.path.join(path_item, packageName.split('.')[-1])\n    normalized = _normalize_cached(subpath)\n    for item in module.__path__:\n        if _normalize_cached(item) == normalized:\n            break\n    else:\n        # Only return the path if it's not already there\n        return subpath\n\n\nif hasattr(pkgutil, 'ImpImporter'):\n    register_namespace_handler(pkgutil.ImpImporter, file_ns_handler)\n\nregister_namespace_handler(zipimport.zipimporter, file_ns_handler)\nregister_namespace_handler(importlib.machinery.FileFinder, file_ns_handler)\n\n\ndef null_ns_handler(\n    importer: object,\n    path_item: str | None,\n    packageName: str | None,\n    module: _ModuleLike | None,\n):\n    return None\n\n\nregister_namespace_handler(object, null_ns_handler)\n\n\n@overload\ndef normalize_path(filename: StrPath) -> str: ...\n@overload\ndef normalize_path(filename: BytesPath) -> bytes: ...\ndef normalize_path(filename: StrOrBytesPath):\n    \"\"\"Normalize a file/dir name for comparison purposes\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))\n\n\ndef _cygwin_patch(filename: StrOrBytesPath):  # pragma: nocover\n    \"\"\"\n    Contrary to POSIX 2008, on Cygwin, getcwd (3) contains\n    symlink components. Using\n    os.path.abspath() works around this limitation. A fix in os.getcwd()\n    would probably better, in Cygwin even more so, except\n    that this seems to be by design...\n    \"\"\"\n    return os.path.abspath(filename) if sys.platform == 'cygwin' else filename\n\n\nif TYPE_CHECKING:\n    # https://github.com/python/mypy/issues/16261\n    # https://github.com/python/typeshed/issues/6347\n    @overload\n    def _normalize_cached(filename: StrPath) -> str: ...\n    @overload\n    def _normalize_cached(filename: BytesPath) -> bytes: ...\n    def _normalize_cached(filename: StrOrBytesPath) -> str | bytes: ...\nelse:\n\n    @functools.lru_cache(maxsize=None)\n    def _normalize_cached(filename):\n        return normalize_path(filename)\n\n\ndef _is_egg_path(path):\n    \"\"\"\n    Determine if given path appears to be an egg.\n    \"\"\"\n    return _is_zip_egg(path) or _is_unpacked_egg(path)\n\n\ndef _is_zip_egg(path):\n    return (\n        path.lower().endswith('.egg')\n        and os.path.isfile(path)\n        and zipfile.is_zipfile(path)\n    )\n\n\ndef _is_unpacked_egg(path):\n    \"\"\"\n    Determine if given path appears to be an unpacked egg.\n    \"\"\"\n    return path.lower().endswith('.egg') and os.path.isfile(\n        os.path.join(path, 'EGG-INFO', 'PKG-INFO')\n    )\n\n\ndef _set_parent_ns(packageName):\n    parts = packageName.split('.')\n    name = parts.pop()\n    if parts:\n        parent = '.'.join(parts)\n        setattr(sys.modules[parent], name, sys.modules[packageName])\n\n\nMODULE = re.compile(r\"\\w+(\\.\\w+)*$\").match\nEGG_NAME = re.compile(\n    r\"\"\"\n    (?P<name>[^-]+) (\n        -(?P<ver>[^-]+) (\n            -py(?P<pyver>[^-]+) (\n                -(?P<plat>.+)\n            )?\n        )?\n    )?\n    \"\"\",\n    re.VERBOSE | re.IGNORECASE,\n).match\n\n\nclass EntryPoint:\n    \"\"\"Object representing an advertised importable object\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        module_name: str,\n        attrs: Iterable[str] = (),\n        extras: Iterable[str] = (),\n        dist: Distribution | None = None,\n    ):\n        if not MODULE(module_name):\n            raise ValueError(\"Invalid module name\", module_name)\n        self.name = name\n        self.module_name = module_name\n        self.attrs = tuple(attrs)\n        self.extras = tuple(extras)\n        self.dist = dist\n\n    def __str__(self):\n        s = \"%s = %s\" % (self.name, self.module_name)\n        if self.attrs:\n            s += ':' + '.'.join(self.attrs)\n        if self.extras:\n            s += ' [%s]' % ','.join(self.extras)\n        return s\n\n    def __repr__(self):\n        return \"EntryPoint.parse(%r)\" % str(self)\n\n    @overload\n    def load(\n        self,\n        require: Literal[True] = True,\n        env: Environment | None = None,\n        installer: _InstallerType | None = None,\n    ) -> _ResolvedEntryPoint: ...\n    @overload\n    def load(\n        self,\n        require: Literal[False],\n        *args: Any,\n        **kwargs: Any,\n    ) -> _ResolvedEntryPoint: ...\n    def load(\n        self,\n        require: bool = True,\n        *args: Environment | _InstallerType | None,\n        **kwargs: Environment | _InstallerType | None,\n    ) -> _ResolvedEntryPoint:\n        \"\"\"\n        Require packages for this EntryPoint, then resolve it.\n        \"\"\"\n        if not require or args or kwargs:\n            warnings.warn(\n                \"Parameters to load are deprecated.  Call .resolve and \"\n                \".require separately.\",\n                PkgResourcesDeprecationWarning,\n                stacklevel=2,\n            )\n        if require:\n            # We could pass `env` and `installer` directly,\n            # but keeping `*args` and `**kwargs` for backwards compatibility\n            self.require(*args, **kwargs)  # type: ignore\n        return self.resolve()\n\n    def resolve(self) -> _ResolvedEntryPoint:\n        \"\"\"\n        Resolve the entry point from its module and attrs.\n        \"\"\"\n        module = __import__(self.module_name, fromlist=['__name__'], level=0)\n        try:\n            return functools.reduce(getattr, self.attrs, module)\n        except AttributeError as exc:\n            raise ImportError(str(exc)) from exc\n\n    def require(\n        self,\n        env: Environment | None = None,\n        installer: _InstallerType | None = None,\n    ):\n        if not self.dist:\n            error_cls = UnknownExtra if self.extras else AttributeError\n            raise error_cls(\"Can't require() without a distribution\", self)\n\n        # Get the requirements for this entry point with all its extras and\n        # then resolve them. We have to pass `extras` along when resolving so\n        # that the working set knows what extras we want. Otherwise, for\n        # dist-info distributions, the working set will assume that the\n        # requirements for that extra are purely optional and skip over them.\n        reqs = self.dist.requires(self.extras)\n        items = working_set.resolve(reqs, env, installer, extras=self.extras)\n        list(map(working_set.add, items))\n\n    pattern = re.compile(\n        r'\\s*'\n        r'(?P<name>.+?)\\s*'\n        r'=\\s*'\n        r'(?P<module>[\\w.]+)\\s*'\n        r'(:\\s*(?P<attr>[\\w.]+))?\\s*'\n        r'(?P<extras>\\[.*\\])?\\s*$'\n    )\n\n    @classmethod\n    def parse(cls, src: str, dist: Distribution | None = None):\n        \"\"\"Parse a single entry point from string `src`\n\n        Entry point syntax follows the form::\n\n            name = some.module:some.attr [extra1, extra2]\n\n        The entry name and module name are required, but the ``:attrs`` and\n        ``[extras]`` parts are optional\n        \"\"\"\n        m = cls.pattern.match(src)\n        if not m:\n            msg = \"EntryPoint must be in 'name=module:attrs [extras]' format\"\n            raise ValueError(msg, src)\n        res = m.groupdict()\n        extras = cls._parse_extras(res['extras'])\n        attrs = res['attr'].split('.') if res['attr'] else ()\n        return cls(res['name'], res['module'], attrs, extras, dist)\n\n    @classmethod\n    def _parse_extras(cls, extras_spec):\n        if not extras_spec:\n            return ()\n        req = Requirement.parse('x' + extras_spec)\n        if req.specs:\n            raise ValueError()\n        return req.extras\n\n    @classmethod\n    def parse_group(\n        cls,\n        group: str,\n        lines: _NestedStr,\n        dist: Distribution | None = None,\n    ):\n        \"\"\"Parse an entry point group\"\"\"\n        if not MODULE(group):\n            raise ValueError(\"Invalid group name\", group)\n        this: dict[str, Self] = {}\n        for line in yield_lines(lines):\n            ep = cls.parse(line, dist)\n            if ep.name in this:\n                raise ValueError(\"Duplicate entry point\", group, ep.name)\n            this[ep.name] = ep\n        return this\n\n    @classmethod\n    def parse_map(\n        cls,\n        data: str | Iterable[str] | dict[str, str | Iterable[str]],\n        dist: Distribution | None = None,\n    ):\n        \"\"\"Parse a map of entry point groups\"\"\"\n        _data: Iterable[tuple[str | None, str | Iterable[str]]]\n        if isinstance(data, dict):\n            _data = data.items()\n        else:\n            _data = split_sections(data)\n        maps: dict[str, dict[str, Self]] = {}\n        for group, lines in _data:\n            if group is None:\n                if not lines:\n                    continue\n                raise ValueError(\"Entry points must be listed in groups\")\n            group = group.strip()\n            if group in maps:\n                raise ValueError(\"Duplicate group name\", group)\n            maps[group] = cls.parse_group(group, lines, dist)\n        return maps\n\n\ndef _version_from_file(lines):\n    \"\"\"\n    Given an iterable of lines from a Metadata file, return\n    the value of the Version field, if present, or None otherwise.\n    \"\"\"\n\n    def is_version_line(line):\n        return line.lower().startswith('version:')\n\n    version_lines = filter(is_version_line, lines)\n    line = next(iter(version_lines), '')\n    _, _, value = line.partition(':')\n    return safe_version(value.strip()) or None\n\n\nclass Distribution:\n    \"\"\"Wrap an actual or potential sys.path entry w/metadata\"\"\"\n\n    PKG_INFO = 'PKG-INFO'\n\n    def __init__(\n        self,\n        location: str | None = None,\n        metadata: _MetadataType = None,\n        project_name: str | None = None,\n        version: str | None = None,\n        py_version: str | None = PY_MAJOR,\n        platform: str | None = None,\n        precedence: int = EGG_DIST,\n    ):\n        self.project_name = safe_name(project_name or 'Unknown')\n        if version is not None:\n            self._version = safe_version(version)\n        self.py_version = py_version\n        self.platform = platform\n        self.location = location\n        self.precedence = precedence\n        self._provider = metadata or empty_provider\n\n    @classmethod\n    def from_location(\n        cls,\n        location: str,\n        basename: StrPath,\n        metadata: _MetadataType = None,\n        **kw: int,  # We could set `precedence` explicitly, but keeping this as `**kw` for full backwards and subclassing compatibility\n    ) -> Distribution:\n        project_name, version, py_version, platform = [None] * 4\n        basename, ext = os.path.splitext(basename)\n        if ext.lower() in _distributionImpl:\n            cls = _distributionImpl[ext.lower()]\n\n            match = EGG_NAME(basename)\n            if match:\n                project_name, version, py_version, platform = match.group(\n                    'name', 'ver', 'pyver', 'plat'\n                )\n        return cls(\n            location,\n            metadata,\n            project_name=project_name,\n            version=version,\n            py_version=py_version,\n            platform=platform,\n            **kw,\n        )._reload_version()\n\n    def _reload_version(self):\n        return self\n\n    @property\n    def hashcmp(self):\n        return (\n            self._forgiving_parsed_version,\n            self.precedence,\n            self.key,\n            self.location,\n            self.py_version or '',\n            self.platform or '',\n        )\n\n    def __hash__(self):\n        return hash(self.hashcmp)\n\n    def __lt__(self, other: Distribution):\n        return self.hashcmp < other.hashcmp\n\n    def __le__(self, other: Distribution):\n        return self.hashcmp <= other.hashcmp\n\n    def __gt__(self, other: Distribution):\n        return self.hashcmp > other.hashcmp\n\n    def __ge__(self, other: Distribution):\n        return self.hashcmp >= other.hashcmp\n\n    def __eq__(self, other: object):\n        if not isinstance(other, self.__class__):\n            # It's not a Distribution, so they are not equal\n            return False\n        return self.hashcmp == other.hashcmp\n\n    def __ne__(self, other: object):\n        return not self == other\n\n    # These properties have to be lazy so that we don't have to load any\n    # metadata until/unless it's actually needed.  (i.e., some distributions\n    # may not know their name or version without loading PKG-INFO)\n\n    @property\n    def key(self):\n        try:\n            return self._key\n        except AttributeError:\n            self._key = key = self.project_name.lower()\n            return key\n\n    @property\n    def parsed_version(self):\n        if not hasattr(self, \"_parsed_version\"):\n            try:\n                self._parsed_version = parse_version(self.version)\n            except _packaging_version.InvalidVersion as ex:\n                info = f\"(package: {self.project_name})\"\n                if hasattr(ex, \"add_note\"):\n                    ex.add_note(info)  # PEP 678\n                    raise\n                raise _packaging_version.InvalidVersion(f\"{str(ex)} {info}\") from None\n\n        return self._parsed_version\n\n    @property\n    def _forgiving_parsed_version(self):\n        try:\n            return self.parsed_version\n        except _packaging_version.InvalidVersion as ex:\n            self._parsed_version = parse_version(_forgiving_version(self.version))\n\n            notes = \"\\n\".join(getattr(ex, \"__notes__\", []))  # PEP 678\n            msg = f\"\"\"!!\\n\\n\n            *************************************************************************\n            {str(ex)}\\n{notes}\n\n            This is a long overdue deprecation.\n            For the time being, `pkg_resources` will use `{self._parsed_version}`\n            as a replacement to avoid breaking existing environments,\n            but no future compatibility is guaranteed.\n\n            If you maintain package {self.project_name} you should implement\n            the relevant changes to adequate the project to PEP 440 immediately.\n            *************************************************************************\n            \\n\\n!!\n            \"\"\"\n            warnings.warn(msg, DeprecationWarning)\n\n            return self._parsed_version\n\n    @property\n    def version(self):\n        try:\n            return self._version\n        except AttributeError as e:\n            version = self._get_version()\n            if version is None:\n                path = self._get_metadata_path_for_display(self.PKG_INFO)\n                msg = (\"Missing 'Version:' header and/or {} file at path: {}\").format(\n                    self.PKG_INFO, path\n                )\n                raise ValueError(msg, self) from e\n\n            return version\n\n    @property\n    def _dep_map(self):\n        \"\"\"\n        A map of extra to its list of (direct) requirements\n        for this distribution, including the null extra.\n        \"\"\"\n        try:\n            return self.__dep_map\n        except AttributeError:\n            self.__dep_map = self._filter_extras(self._build_dep_map())\n        return self.__dep_map\n\n    @staticmethod\n    def _filter_extras(dm: dict[str | None, list[Requirement]]):\n        \"\"\"\n        Given a mapping of extras to dependencies, strip off\n        environment markers and filter out any dependencies\n        not matching the markers.\n        \"\"\"\n        for extra in list(filter(None, dm)):\n            new_extra: str | None = extra\n            reqs = dm.pop(extra)\n            new_extra, _, marker = extra.partition(':')\n            fails_marker = marker and (\n                invalid_marker(marker) or not evaluate_marker(marker)\n            )\n            if fails_marker:\n                reqs = []\n            new_extra = safe_extra(new_extra) or None\n\n            dm.setdefault(new_extra, []).extend(reqs)\n        return dm\n\n    def _build_dep_map(self):\n        dm = {}\n        for name in 'requires.txt', 'depends.txt':\n            for extra, reqs in split_sections(self._get_metadata(name)):\n                dm.setdefault(extra, []).extend(parse_requirements(reqs))\n        return dm\n\n    def requires(self, extras: Iterable[str] = ()):\n        \"\"\"List of Requirements needed for this distro if `extras` are used\"\"\"\n        dm = self._dep_map\n        deps: list[Requirement] = []\n        deps.extend(dm.get(None, ()))\n        for ext in extras:\n            try:\n                deps.extend(dm[safe_extra(ext)])\n            except KeyError as e:\n                raise UnknownExtra(\n                    \"%s has no such extra feature %r\" % (self, ext)\n                ) from e\n        return deps\n\n    def _get_metadata_path_for_display(self, name):\n        \"\"\"\n        Return the path to the given metadata file, if available.\n        \"\"\"\n        try:\n            # We need to access _get_metadata_path() on the provider object\n            # directly rather than through this class's __getattr__()\n            # since _get_metadata_path() is marked private.\n            path = self._provider._get_metadata_path(name)\n\n        # Handle exceptions e.g. in case the distribution's metadata\n        # provider doesn't support _get_metadata_path().\n        except Exception:\n            return '[could not detect]'\n\n        return path\n\n    def _get_metadata(self, name):\n        if self.has_metadata(name):\n            yield from self.get_metadata_lines(name)\n\n    def _get_version(self):\n        lines = self._get_metadata(self.PKG_INFO)\n        return _version_from_file(lines)\n\n    def activate(self, path: list[str] | None = None, replace: bool = False):\n        \"\"\"Ensure distribution is importable on `path` (default=sys.path)\"\"\"\n        if path is None:\n            path = sys.path\n        self.insert_on(path, replace=replace)\n        if path is sys.path and self.location is not None:\n            fixup_namespace_packages(self.location)\n            for pkg in self._get_metadata('namespace_packages.txt'):\n                if pkg in sys.modules:\n                    declare_namespace(pkg)\n\n    def egg_name(self):\n        \"\"\"Return what this distribution's standard .egg filename should be\"\"\"\n        filename = \"%s-%s-py%s\" % (\n            to_filename(self.project_name),\n            to_filename(self.version),\n            self.py_version or PY_MAJOR,\n        )\n\n        if self.platform:\n            filename += '-' + self.platform\n        return filename\n\n    def __repr__(self):\n        if self.location:\n            return \"%s (%s)\" % (self, self.location)\n        else:\n            return str(self)\n\n    def __str__(self):\n        try:\n            version = getattr(self, 'version', None)\n        except ValueError:\n            version = None\n        version = version or \"[unknown version]\"\n        return \"%s %s\" % (self.project_name, version)\n\n    def __getattr__(self, attr):\n        \"\"\"Delegate all unrecognized public attributes to .metadata provider\"\"\"\n        if attr.startswith('_'):\n            raise AttributeError(attr)\n        return getattr(self._provider, attr)\n\n    def __dir__(self):\n        return list(\n            set(super().__dir__())\n            | set(attr for attr in self._provider.__dir__() if not attr.startswith('_'))\n        )\n\n    @classmethod\n    def from_filename(\n        cls,\n        filename: StrPath,\n        metadata: _MetadataType = None,\n        **kw: int,  # We could set `precedence` explicitly, but keeping this as `**kw` for full backwards and subclassing compatibility\n    ):\n        return cls.from_location(\n            _normalize_cached(filename), os.path.basename(filename), metadata, **kw\n        )\n\n    def as_requirement(self):\n        \"\"\"Return a ``Requirement`` that matches this distribution exactly\"\"\"\n        if isinstance(self.parsed_version, _packaging_version.Version):\n            spec = \"%s==%s\" % (self.project_name, self.parsed_version)\n        else:\n            spec = \"%s===%s\" % (self.project_name, self.parsed_version)\n\n        return Requirement.parse(spec)\n\n    def load_entry_point(self, group: str, name: str) -> _ResolvedEntryPoint:\n        \"\"\"Return the `name` entry point of `group` or raise ImportError\"\"\"\n        ep = self.get_entry_info(group, name)\n        if ep is None:\n            raise ImportError(\"Entry point %r not found\" % ((group, name),))\n        return ep.load()\n\n    @overload\n    def get_entry_map(self, group: None = None) -> dict[str, dict[str, EntryPoint]]: ...\n    @overload\n    def get_entry_map(self, group: str) -> dict[str, EntryPoint]: ...\n    def get_entry_map(self, group: str | None = None):\n        \"\"\"Return the entry point map for `group`, or the full entry map\"\"\"\n        if not hasattr(self, \"_ep_map\"):\n            self._ep_map = EntryPoint.parse_map(\n                self._get_metadata('entry_points.txt'), self\n            )\n        if group is not None:\n            return self._ep_map.get(group, {})\n        return self._ep_map\n\n    def get_entry_info(self, group: str, name: str):\n        \"\"\"Return the EntryPoint object for `group`+`name`, or ``None``\"\"\"\n        return self.get_entry_map(group).get(name)\n\n    # FIXME: 'Distribution.insert_on' is too complex (13)\n    def insert_on(  # noqa: C901\n        self,\n        path: list[str],\n        loc=None,\n        replace: bool = False,\n    ):\n        \"\"\"Ensure self.location is on path\n\n        If replace=False (default):\n            - If location is already in path anywhere, do nothing.\n            - Else:\n              - If it's an egg and its parent directory is on path,\n                insert just ahead of the parent.\n              - Else: add to the end of path.\n        If replace=True:\n            - If location is already on path anywhere (not eggs)\n              or higher priority than its parent (eggs)\n              do nothing.\n            - Else:\n              - If it's an egg and its parent directory is on path,\n                insert just ahead of the parent,\n                removing any lower-priority entries.\n              - Else: add it to the front of path.\n        \"\"\"\n\n        loc = loc or self.location\n        if not loc:\n            return\n\n        nloc = _normalize_cached(loc)\n        bdir = os.path.dirname(nloc)\n        npath = [(p and _normalize_cached(p) or p) for p in path]\n\n        for p, item in enumerate(npath):\n            if item == nloc:\n                if replace:\n                    break\n                else:\n                    # don't modify path (even removing duplicates) if\n                    # found and not replace\n                    return\n            elif item == bdir and self.precedence == EGG_DIST:\n                # if it's an .egg, give it precedence over its directory\n                # UNLESS it's already been added to sys.path and replace=False\n                if (not replace) and nloc in npath[p:]:\n                    return\n                if path is sys.path:\n                    self.check_version_conflict()\n                path.insert(p, loc)\n                npath.insert(p, nloc)\n                break\n        else:\n            if path is sys.path:\n                self.check_version_conflict()\n            if replace:\n                path.insert(0, loc)\n            else:\n                path.append(loc)\n            return\n\n        # p is the spot where we found or inserted loc; now remove duplicates\n        while True:\n            try:\n                np = npath.index(nloc, p + 1)\n            except ValueError:\n                break\n            else:\n                del npath[np], path[np]\n                # ha!\n                p = np\n\n        return\n\n    def check_version_conflict(self):\n        if self.key == 'setuptools':\n            # ignore the inevitable setuptools self-conflicts  :(\n            return\n\n        nsp = dict.fromkeys(self._get_metadata('namespace_packages.txt'))\n        loc = normalize_path(self.location)\n        for modname in self._get_metadata('top_level.txt'):\n            if (\n                modname not in sys.modules\n                or modname in nsp\n                or modname in _namespace_packages\n            ):\n                continue\n            if modname in ('pkg_resources', 'setuptools', 'site'):\n                continue\n            fn = getattr(sys.modules[modname], '__file__', None)\n            if fn and (\n                normalize_path(fn).startswith(loc) or fn.startswith(self.location)\n            ):\n                continue\n            issue_warning(\n                \"Module %s was already imported from %s, but %s is being added\"\n                \" to sys.path\" % (modname, fn, self.location),\n            )\n\n    def has_version(self):\n        try:\n            self.version\n        except ValueError:\n            issue_warning(\"Unbuilt egg for \" + repr(self))\n            return False\n        except SystemError:\n            # TODO: remove this except clause when python/cpython#103632 is fixed.\n            return False\n        return True\n\n    def clone(self, **kw: str | int | IResourceProvider | None):\n        \"\"\"Copy this distribution, substituting in any changed keyword args\"\"\"\n        names = 'project_name version py_version platform location precedence'\n        for attr in names.split():\n            kw.setdefault(attr, getattr(self, attr, None))\n        kw.setdefault('metadata', self._provider)\n        # Unsafely unpacking. But keeping **kw for backwards and subclassing compatibility\n        return self.__class__(**kw)  # type:ignore[arg-type]\n\n    @property\n    def extras(self):\n        return [dep for dep in self._dep_map if dep]\n\n\nclass EggInfoDistribution(Distribution):\n    def _reload_version(self):\n        \"\"\"\n        Packages installed by distutils (e.g. numpy or scipy),\n        which uses an old safe_version, and so\n        their version numbers can get mangled when\n        converted to filenames (e.g., 1.11.0.dev0+2329eae to\n        1.11.0.dev0_2329eae). These distributions will not be\n        parsed properly\n        downstream by Distribution and safe_version, so\n        take an extra step and try to get the version number from\n        the metadata file itself instead of the filename.\n        \"\"\"\n        md_version = self._get_version()\n        if md_version:\n            self._version = md_version\n        return self\n\n\nclass DistInfoDistribution(Distribution):\n    \"\"\"\n    Wrap an actual or potential sys.path entry\n    w/metadata, .dist-info style.\n    \"\"\"\n\n    PKG_INFO = 'METADATA'\n    EQEQ = re.compile(r\"([\\(,])\\s*(\\d.*?)\\s*([,\\)])\")\n\n    @property\n    def _parsed_pkg_info(self):\n        \"\"\"Parse and cache metadata\"\"\"\n        try:\n            return self._pkg_info\n        except AttributeError:\n            metadata = self.get_metadata(self.PKG_INFO)\n            self._pkg_info = email.parser.Parser().parsestr(metadata)\n            return self._pkg_info\n\n    @property\n    def _dep_map(self):\n        try:\n            return self.__dep_map\n        except AttributeError:\n            self.__dep_map = self._compute_dependencies()\n            return self.__dep_map\n\n    def _compute_dependencies(self) -> dict[str | None, list[Requirement]]:\n        \"\"\"Recompute this distribution's dependencies.\"\"\"\n        self.__dep_map: dict[str | None, list[Requirement]] = {None: []}\n\n        reqs: list[Requirement] = []\n        # Including any condition expressions\n        for req in self._parsed_pkg_info.get_all('Requires-Dist') or []:\n            reqs.extend(parse_requirements(req))\n\n        def reqs_for_extra(extra):\n            for req in reqs:\n                if not req.marker or req.marker.evaluate({'extra': extra}):\n                    yield req\n\n        common = types.MappingProxyType(dict.fromkeys(reqs_for_extra(None)))\n        self.__dep_map[None].extend(common)\n\n        for extra in self._parsed_pkg_info.get_all('Provides-Extra') or []:\n            s_extra = safe_extra(extra.strip())\n            self.__dep_map[s_extra] = [\n                r for r in reqs_for_extra(extra) if r not in common\n            ]\n\n        return self.__dep_map\n\n\n_distributionImpl = {\n    '.egg': Distribution,\n    '.egg-info': EggInfoDistribution,\n    '.dist-info': DistInfoDistribution,\n}\n\n\ndef issue_warning(*args, **kw):\n    level = 1\n    g = globals()\n    try:\n        # find the first stack frame that is *not* code in\n        # the pkg_resources module, to use for the warning\n        while sys._getframe(level).f_globals is g:\n            level += 1\n    except ValueError:\n        pass\n    warnings.warn(stacklevel=level + 1, *args, **kw)\n\n\ndef parse_requirements(strs: _NestedStr):\n    \"\"\"\n    Yield ``Requirement`` objects for each specification in `strs`.\n\n    `strs` must be a string, or a (possibly-nested) iterable thereof.\n    \"\"\"\n    return map(Requirement, join_continuation(map(drop_comment, yield_lines(strs))))\n\n\nclass RequirementParseError(_packaging_requirements.InvalidRequirement):\n    \"Compatibility wrapper for InvalidRequirement\"\n\n\nclass Requirement(_packaging_requirements.Requirement):\n    def __init__(self, requirement_string: str):\n        \"\"\"DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!\"\"\"\n        super().__init__(requirement_string)\n        self.unsafe_name = self.name\n        project_name = safe_name(self.name)\n        self.project_name, self.key = project_name, project_name.lower()\n        self.specs = [(spec.operator, spec.version) for spec in self.specifier]\n        # packaging.requirements.Requirement uses a set for its extras. We use a variable-length tuple\n        self.extras: tuple[str] = tuple(map(safe_extra, self.extras))\n        self.hashCmp = (\n            self.key,\n            self.url,\n            self.specifier,\n            frozenset(self.extras),\n            str(self.marker) if self.marker else None,\n        )\n        self.__hash = hash(self.hashCmp)\n\n    def __eq__(self, other: object):\n        return isinstance(other, Requirement) and self.hashCmp == other.hashCmp\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __contains__(self, item: Distribution | str | tuple[str, ...]) -> bool:\n        if isinstance(item, Distribution):\n            if item.key != self.key:\n                return False\n\n            item = item.version\n\n        # Allow prereleases always in order to match the previous behavior of\n        # this method. In the future this should be smarter and follow PEP 440\n        # more accurately.\n        return self.specifier.contains(item, prereleases=True)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return \"Requirement.parse(%r)\" % str(self)\n\n    @staticmethod\n    def parse(s: str | Iterable[str]):\n        (req,) = parse_requirements(s)\n        return req\n\n\ndef _always_object(classes):\n    \"\"\"\n    Ensure object appears in the mro even\n    for old-style classes.\n    \"\"\"\n    if object not in classes:\n        return classes + (object,)\n    return classes\n\n\ndef _find_adapter(registry: Mapping[type, _AdapterT], ob: object) -> _AdapterT:\n    \"\"\"Return an adapter factory for `ob` from `registry`\"\"\"\n    types = _always_object(inspect.getmro(getattr(ob, '__class__', type(ob))))\n    for t in types:\n        if t in registry:\n            return registry[t]\n    # _find_adapter would previously return None, and immediately be called.\n    # So we're raising a TypeError to keep backward compatibility if anyone depended on that behaviour.\n    raise TypeError(f\"Could not find adapter for {registry} and {ob}\")\n\n\ndef ensure_directory(path: StrOrBytesPath):\n    \"\"\"Ensure that the parent directory of `path` exists\"\"\"\n    dirname = os.path.dirname(path)\n    os.makedirs(dirname, exist_ok=True)\n\n\ndef _bypass_ensure_directory(path):\n    \"\"\"Sandbox-bypassing version of ensure_directory()\"\"\"\n    if not WRITE_SUPPORT:\n        raise OSError('\"os.mkdir\" not supported on this platform.')\n    dirname, filename = split(path)\n    if dirname and filename and not isdir(dirname):\n        _bypass_ensure_directory(dirname)\n        try:\n            mkdir(dirname, 0o755)\n        except FileExistsError:\n            pass\n\n\ndef split_sections(s: _NestedStr) -> Iterator[tuple[str | None, list[str]]]:\n    \"\"\"Split a string or iterable thereof into (section, content) pairs\n\n    Each ``section`` is a stripped version of the section header (\"[section]\")\n    and each ``content`` is a list of stripped lines excluding blank lines and\n    comment-only lines.  If there are any such lines before the first section\n    header, they're returned in a first ``section`` of ``None``.\n    \"\"\"\n    section = None\n    content = []\n    for line in yield_lines(s):\n        if line.startswith(\"[\"):\n            if line.endswith(\"]\"):\n                if section or content:\n                    yield section, content\n                section = line[1:-1].strip()\n                content = []\n            else:\n                raise ValueError(\"Invalid section heading\", line)\n        else:\n            content.append(line)\n\n    # wrap up last segment\n    yield section, content\n\n\ndef _mkstemp(*args, **kw):\n    old_open = os.open\n    try:\n        # temporarily bypass sandboxing\n        os.open = os_open\n        return tempfile.mkstemp(*args, **kw)\n    finally:\n        # and then put it back\n        os.open = old_open\n\n\n# Silence the PEP440Warning by default, so that end users don't get hit by it\n# randomly just because they use pkg_resources. We want to append the rule\n# because we want earlier uses of filterwarnings to take precedence over this\n# one.\nwarnings.filterwarnings(\"ignore\", category=PEP440Warning, append=True)\n\n\nclass PkgResourcesDeprecationWarning(Warning):\n    \"\"\"\n    Base class for warning about deprecations in ``pkg_resources``\n\n    This class is not derived from ``DeprecationWarning``, and as such is\n    visible by default.\n    \"\"\"\n\n\n# Ported from ``setuptools`` to avoid introducing an import inter-dependency:\n_LOCALE_ENCODING = \"locale\" if sys.version_info >= (3, 10) else None\n\n\ndef _read_utf8_with_fallback(file: str, fallback_encoding=_LOCALE_ENCODING) -> str:\n    \"\"\"See setuptools.unicode_utils._read_utf8_with_fallback\"\"\"\n    try:\n        with open(file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n    except UnicodeDecodeError:  # pragma: no cover\n        msg = f\"\"\"\\\n        ********************************************************************************\n        `encoding=\"utf-8\"` fails with {file!r}, trying `encoding={fallback_encoding!r}`.\n\n        This fallback behaviour is considered **deprecated** and future versions of\n        `setuptools/pkg_resources` may not implement it.\n\n        Please encode {file!r} with \"utf-8\" to ensure future builds will succeed.\n\n        If this file was produced by `setuptools` itself, cleaning up the cached files\n        and re-building/re-installing the package with a newer version of `setuptools`\n        (e.g. by updating `build-system.requires` in its `pyproject.toml`)\n        might solve the problem.\n        ********************************************************************************\n        \"\"\"\n        # TODO: Add a deadline?\n        #       See comment in setuptools.unicode_utils._Utf8EncodingNeeded\n        warnings.warn(msg, PkgResourcesDeprecationWarning, stacklevel=2)\n        with open(file, \"r\", encoding=fallback_encoding) as f:\n            return f.read()\n\n\n# from jaraco.functools 1.3\ndef _call_aside(f, *args, **kwargs):\n    f(*args, **kwargs)\n    return f\n\n\n@_call_aside\ndef _initialize(g=globals()):\n    \"Set up global resource manager (deliberately not state-saved)\"\n    manager = ResourceManager()\n    g['_manager'] = manager\n    g.update(\n        (name, getattr(manager, name))\n        for name in dir(manager)\n        if not name.startswith('_')\n    )\n\n\n@_call_aside\ndef _initialize_master_working_set():\n    \"\"\"\n    Prepare the master working set and make the ``require()``\n    API available.\n\n    This function has explicit effects on the global state\n    of pkg_resources. It is intended to be invoked once at\n    the initialization of this module.\n\n    Invocation by other packages is unsupported and done\n    at their own risk.\n    \"\"\"\n    working_set = _declare_state('object', 'working_set', WorkingSet._build_master())\n\n    require = working_set.require\n    iter_entry_points = working_set.iter_entry_points\n    add_activation_listener = working_set.subscribe\n    run_script = working_set.run_script\n    # backward compatibility\n    run_main = run_script\n    # Activate all distributions already on sys.path with replace=False and\n    # ensure that all distributions added to the working set in the future\n    # (e.g. by calling ``require()``) will get activated as well,\n    # with higher priority (replace=True).\n    tuple(dist.activate(replace=False) for dist in working_set)\n    add_activation_listener(\n        lambda dist: dist.activate(replace=True),\n        existing=False,\n    )\n    working_set.entries = []\n    # match order\n    list(map(working_set.add_entry, sys.path))\n    globals().update(locals())\n\n\nif TYPE_CHECKING:\n    # All of these are set by the @_call_aside methods above\n    __resource_manager = ResourceManager()  # Won't exist at runtime\n    resource_exists = __resource_manager.resource_exists\n    resource_isdir = __resource_manager.resource_isdir\n    resource_filename = __resource_manager.resource_filename\n    resource_stream = __resource_manager.resource_stream\n    resource_string = __resource_manager.resource_string\n    resource_listdir = __resource_manager.resource_listdir\n    set_extraction_path = __resource_manager.set_extraction_path\n    cleanup_resources = __resource_manager.cleanup_resources\n\n    working_set = WorkingSet()\n    require = working_set.require\n    iter_entry_points = working_set.iter_entry_points\n    add_activation_listener = working_set.subscribe\n    run_script = working_set.run_script\n    run_main = run_script\n", "pkg_resources/_vendor/zipp.py": "import io\nimport posixpath\nimport zipfile\nimport itertools\nimport contextlib\nimport sys\nimport pathlib\n\nif sys.version_info < (3, 7):\n    from collections import OrderedDict\nelse:\n    OrderedDict = dict\n\n\n__all__ = ['Path']\n\n\ndef _parents(path):\n    \"\"\"\n    Given a path with elements separated by\n    posixpath.sep, generate all parents of that path.\n\n    >>> list(_parents('b/d'))\n    ['b']\n    >>> list(_parents('/b/d/'))\n    ['/b']\n    >>> list(_parents('b/d/f/'))\n    ['b/d', 'b']\n    >>> list(_parents('b'))\n    []\n    >>> list(_parents(''))\n    []\n    \"\"\"\n    return itertools.islice(_ancestry(path), 1, None)\n\n\ndef _ancestry(path):\n    \"\"\"\n    Given a path with elements separated by\n    posixpath.sep, generate all elements of that path\n\n    >>> list(_ancestry('b/d'))\n    ['b/d', 'b']\n    >>> list(_ancestry('/b/d/'))\n    ['/b/d', '/b']\n    >>> list(_ancestry('b/d/f/'))\n    ['b/d/f', 'b/d', 'b']\n    >>> list(_ancestry('b'))\n    ['b']\n    >>> list(_ancestry(''))\n    []\n    \"\"\"\n    path = path.rstrip(posixpath.sep)\n    while path and path != posixpath.sep:\n        yield path\n        path, tail = posixpath.split(path)\n\n\n_dedupe = OrderedDict.fromkeys\n\"\"\"Deduplicate an iterable in original order\"\"\"\n\n\ndef _difference(minuend, subtrahend):\n    \"\"\"\n    Return items in minuend not in subtrahend, retaining order\n    with O(1) lookup.\n    \"\"\"\n    return itertools.filterfalse(set(subtrahend).__contains__, minuend)\n\n\nclass CompleteDirs(zipfile.ZipFile):\n    \"\"\"\n    A ZipFile subclass that ensures that implied directories\n    are always included in the namelist.\n    \"\"\"\n\n    @staticmethod\n    def _implied_dirs(names):\n        parents = itertools.chain.from_iterable(map(_parents, names))\n        as_dirs = (p + posixpath.sep for p in parents)\n        return _dedupe(_difference(as_dirs, names))\n\n    def namelist(self):\n        names = super(CompleteDirs, self).namelist()\n        return names + list(self._implied_dirs(names))\n\n    def _name_set(self):\n        return set(self.namelist())\n\n    def resolve_dir(self, name):\n        \"\"\"\n        If the name represents a directory, return that name\n        as a directory (with the trailing slash).\n        \"\"\"\n        names = self._name_set()\n        dirname = name + '/'\n        dir_match = name not in names and dirname in names\n        return dirname if dir_match else name\n\n    @classmethod\n    def make(cls, source):\n        \"\"\"\n        Given a source (filename or zipfile), return an\n        appropriate CompleteDirs subclass.\n        \"\"\"\n        if isinstance(source, CompleteDirs):\n            return source\n\n        if not isinstance(source, zipfile.ZipFile):\n            return cls(_pathlib_compat(source))\n\n        # Only allow for FastLookup when supplied zipfile is read-only\n        if 'r' not in source.mode:\n            cls = CompleteDirs\n\n        source.__class__ = cls\n        return source\n\n\nclass FastLookup(CompleteDirs):\n    \"\"\"\n    ZipFile subclass to ensure implicit\n    dirs exist and are resolved rapidly.\n    \"\"\"\n\n    def namelist(self):\n        with contextlib.suppress(AttributeError):\n            return self.__names\n        self.__names = super(FastLookup, self).namelist()\n        return self.__names\n\n    def _name_set(self):\n        with contextlib.suppress(AttributeError):\n            return self.__lookup\n        self.__lookup = super(FastLookup, self)._name_set()\n        return self.__lookup\n\n\ndef _pathlib_compat(path):\n    \"\"\"\n    For path-like objects, convert to a filename for compatibility\n    on Python 3.6.1 and earlier.\n    \"\"\"\n    try:\n        return path.__fspath__()\n    except AttributeError:\n        return str(path)\n\n\nclass Path:\n    \"\"\"\n    A pathlib-compatible interface for zip files.\n\n    Consider a zip file with this structure::\n\n        .\n        \u251c\u2500\u2500 a.txt\n        \u2514\u2500\u2500 b\n            \u251c\u2500\u2500 c.txt\n            \u2514\u2500\u2500 d\n                \u2514\u2500\u2500 e.txt\n\n    >>> data = io.BytesIO()\n    >>> zf = zipfile.ZipFile(data, 'w')\n    >>> zf.writestr('a.txt', 'content of a')\n    >>> zf.writestr('b/c.txt', 'content of c')\n    >>> zf.writestr('b/d/e.txt', 'content of e')\n    >>> zf.filename = 'mem/abcde.zip'\n\n    Path accepts the zipfile object itself or a filename\n\n    >>> root = Path(zf)\n\n    From there, several path operations are available.\n\n    Directory iteration (including the zip file itself):\n\n    >>> a, b = root.iterdir()\n    >>> a\n    Path('mem/abcde.zip', 'a.txt')\n    >>> b\n    Path('mem/abcde.zip', 'b/')\n\n    name property:\n\n    >>> b.name\n    'b'\n\n    join with divide operator:\n\n    >>> c = b / 'c.txt'\n    >>> c\n    Path('mem/abcde.zip', 'b/c.txt')\n    >>> c.name\n    'c.txt'\n\n    Read text:\n\n    >>> c.read_text()\n    'content of c'\n\n    existence:\n\n    >>> c.exists()\n    True\n    >>> (b / 'missing.txt').exists()\n    False\n\n    Coercion to string:\n\n    >>> import os\n    >>> str(c).replace(os.sep, posixpath.sep)\n    'mem/abcde.zip/b/c.txt'\n\n    At the root, ``name``, ``filename``, and ``parent``\n    resolve to the zipfile. Note these attributes are not\n    valid and will raise a ``ValueError`` if the zipfile\n    has no filename.\n\n    >>> root.name\n    'abcde.zip'\n    >>> str(root.filename).replace(os.sep, posixpath.sep)\n    'mem/abcde.zip'\n    >>> str(root.parent)\n    'mem'\n    \"\"\"\n\n    __repr = \"{self.__class__.__name__}({self.root.filename!r}, {self.at!r})\"\n\n    def __init__(self, root, at=\"\"):\n        \"\"\"\n        Construct a Path from a ZipFile or filename.\n\n        Note: When the source is an existing ZipFile object,\n        its type (__class__) will be mutated to a\n        specialized type. If the caller wishes to retain the\n        original type, the caller should either create a\n        separate ZipFile object or pass a filename.\n        \"\"\"\n        self.root = FastLookup.make(root)\n        self.at = at\n\n    def open(self, mode='r', *args, pwd=None, **kwargs):\n        \"\"\"\n        Open this entry as text or binary following the semantics\n        of ``pathlib.Path.open()`` by passing arguments through\n        to io.TextIOWrapper().\n        \"\"\"\n        if self.is_dir():\n            raise IsADirectoryError(self)\n        zip_mode = mode[0]\n        if not self.exists() and zip_mode == 'r':\n            raise FileNotFoundError(self)\n        stream = self.root.open(self.at, zip_mode, pwd=pwd)\n        if 'b' in mode:\n            if args or kwargs:\n                raise ValueError(\"encoding args invalid for binary operation\")\n            return stream\n        return io.TextIOWrapper(stream, *args, **kwargs)\n\n    @property\n    def name(self):\n        return pathlib.Path(self.at).name or self.filename.name\n\n    @property\n    def suffix(self):\n        return pathlib.Path(self.at).suffix or self.filename.suffix\n\n    @property\n    def suffixes(self):\n        return pathlib.Path(self.at).suffixes or self.filename.suffixes\n\n    @property\n    def stem(self):\n        return pathlib.Path(self.at).stem or self.filename.stem\n\n    @property\n    def filename(self):\n        return pathlib.Path(self.root.filename).joinpath(self.at)\n\n    def read_text(self, *args, **kwargs):\n        with self.open('r', *args, **kwargs) as strm:\n            return strm.read()\n\n    def read_bytes(self):\n        with self.open('rb') as strm:\n            return strm.read()\n\n    def _is_child(self, path):\n        return posixpath.dirname(path.at.rstrip(\"/\")) == self.at.rstrip(\"/\")\n\n    def _next(self, at):\n        return self.__class__(self.root, at)\n\n    def is_dir(self):\n        return not self.at or self.at.endswith(\"/\")\n\n    def is_file(self):\n        return self.exists() and not self.is_dir()\n\n    def exists(self):\n        return self.at in self.root._name_set()\n\n    def iterdir(self):\n        if not self.is_dir():\n            raise ValueError(\"Can't listdir a file\")\n        subs = map(self._next, self.root.namelist())\n        return filter(self._is_child, subs)\n\n    def __str__(self):\n        return posixpath.join(self.root.filename, self.at)\n\n    def __repr__(self):\n        return self.__repr.format(self=self)\n\n    def joinpath(self, *other):\n        next = posixpath.join(self.at, *map(_pathlib_compat, other))\n        return self._next(self.root.resolve_dir(next))\n\n    __truediv__ = joinpath\n\n    @property\n    def parent(self):\n        if not self.at:\n            return self.filename.parent\n        parent_at = posixpath.dirname(self.at.rstrip('/'))\n        if parent_at:\n            parent_at += '/'\n        return self._next(parent_at)\n", "pkg_resources/_vendor/__init__.py": "", "pkg_resources/_vendor/jaraco/__init__.py": "", "pkg_resources/_vendor/jaraco/context.py": "from __future__ import annotations\n\nimport contextlib\nimport functools\nimport operator\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport urllib.request\nimport warnings\nfrom typing import Iterator\n\n\nif sys.version_info < (3, 12):\n    from pkg_resources.extern.backports import tarfile\nelse:\n    import tarfile\n\n\n@contextlib.contextmanager\ndef pushd(dir: str | os.PathLike) -> Iterator[str | os.PathLike]:\n    \"\"\"\n    >>> tmp_path = getfixture('tmp_path')\n    >>> with pushd(tmp_path):\n    ...     assert os.getcwd() == os.fspath(tmp_path)\n    >>> assert os.getcwd() != os.fspath(tmp_path)\n    \"\"\"\n\n    orig = os.getcwd()\n    os.chdir(dir)\n    try:\n        yield dir\n    finally:\n        os.chdir(orig)\n\n\n@contextlib.contextmanager\ndef tarball(\n    url, target_dir: str | os.PathLike | None = None\n) -> Iterator[str | os.PathLike]:\n    \"\"\"\n    Get a tarball, extract it, yield, then clean up.\n\n    >>> import urllib.request\n    >>> url = getfixture('tarfile_served')\n    >>> target = getfixture('tmp_path') / 'out'\n    >>> tb = tarball(url, target_dir=target)\n    >>> import pathlib\n    >>> with tb as extracted:\n    ...     contents = pathlib.Path(extracted, 'contents.txt').read_text(encoding='utf-8')\n    >>> assert not os.path.exists(extracted)\n    \"\"\"\n    if target_dir is None:\n        target_dir = os.path.basename(url).replace('.tar.gz', '').replace('.tgz', '')\n    # In the tar command, use --strip-components=1 to strip the first path and\n    #  then\n    #  use -C to cause the files to be extracted to {target_dir}. This ensures\n    #  that we always know where the files were extracted.\n    os.mkdir(target_dir)\n    try:\n        req = urllib.request.urlopen(url)\n        with tarfile.open(fileobj=req, mode='r|*') as tf:\n            tf.extractall(path=target_dir, filter=strip_first_component)\n        yield target_dir\n    finally:\n        shutil.rmtree(target_dir)\n\n\ndef strip_first_component(\n    member: tarfile.TarInfo,\n    path,\n) -> tarfile.TarInfo:\n    _, member.name = member.name.split('/', 1)\n    return member\n\n\ndef _compose(*cmgrs):\n    \"\"\"\n    Compose any number of dependent context managers into a single one.\n\n    The last, innermost context manager may take arbitrary arguments, but\n    each successive context manager should accept the result from the\n    previous as a single parameter.\n\n    Like :func:`jaraco.functools.compose`, behavior works from right to\n    left, so the context manager should be indicated from outermost to\n    innermost.\n\n    Example, to create a context manager to change to a temporary\n    directory:\n\n    >>> temp_dir_as_cwd = _compose(pushd, temp_dir)\n    >>> with temp_dir_as_cwd() as dir:\n    ...     assert os.path.samefile(os.getcwd(), dir)\n    \"\"\"\n\n    def compose_two(inner, outer):\n        def composed(*args, **kwargs):\n            with inner(*args, **kwargs) as saved, outer(saved) as res:\n                yield res\n\n        return contextlib.contextmanager(composed)\n\n    return functools.reduce(compose_two, reversed(cmgrs))\n\n\ntarball_cwd = _compose(pushd, tarball)\n\n\n@contextlib.contextmanager\ndef tarball_context(*args, **kwargs):\n    warnings.warn(\n        \"tarball_context is deprecated. Use tarball or tarball_cwd instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    pushd_ctx = kwargs.pop('pushd', pushd)\n    with tarball(*args, **kwargs) as tball, pushd_ctx(tball) as dir:\n        yield dir\n\n\ndef infer_compression(url):\n    \"\"\"\n    Given a URL or filename, infer the compression code for tar.\n\n    >>> infer_compression('http://foo/bar.tar.gz')\n    'z'\n    >>> infer_compression('http://foo/bar.tgz')\n    'z'\n    >>> infer_compression('file.bz')\n    'j'\n    >>> infer_compression('file.xz')\n    'J'\n    \"\"\"\n    warnings.warn(\n        \"infer_compression is deprecated with no replacement\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    # cheat and just assume it's the last two characters\n    compression_indicator = url[-2:]\n    mapping = dict(gz='z', bz='j', xz='J')\n    # Assume 'z' (gzip) if no match\n    return mapping.get(compression_indicator, 'z')\n\n\n@contextlib.contextmanager\ndef temp_dir(remover=shutil.rmtree):\n    \"\"\"\n    Create a temporary directory context. Pass a custom remover\n    to override the removal behavior.\n\n    >>> import pathlib\n    >>> with temp_dir() as the_dir:\n    ...     assert os.path.isdir(the_dir)\n    ...     _ = pathlib.Path(the_dir).joinpath('somefile').write_text('contents', encoding='utf-8')\n    >>> assert not os.path.exists(the_dir)\n    \"\"\"\n    temp_dir = tempfile.mkdtemp()\n    try:\n        yield temp_dir\n    finally:\n        remover(temp_dir)\n\n\n@contextlib.contextmanager\ndef repo_context(url, branch=None, quiet=True, dest_ctx=temp_dir):\n    \"\"\"\n    Check out the repo indicated by url.\n\n    If dest_ctx is supplied, it should be a context manager\n    to yield the target directory for the check out.\n    \"\"\"\n    exe = 'git' if 'git' in url else 'hg'\n    with dest_ctx() as repo_dir:\n        cmd = [exe, 'clone', url, repo_dir]\n        if branch:\n            cmd.extend(['--branch', branch])\n        devnull = open(os.path.devnull, 'w')\n        stdout = devnull if quiet else None\n        subprocess.check_call(cmd, stdout=stdout)\n        yield repo_dir\n\n\ndef null():\n    \"\"\"\n    A null context suitable to stand in for a meaningful context.\n\n    >>> with null() as value:\n    ...     assert value is None\n\n    This context is most useful when dealing with two or more code\n    branches but only some need a context. Wrap the others in a null\n    context to provide symmetry across all options.\n    \"\"\"\n    warnings.warn(\n        \"null is deprecated. Use contextlib.nullcontext\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return contextlib.nullcontext()\n\n\nclass ExceptionTrap:\n    \"\"\"\n    A context manager that will catch certain exceptions and provide an\n    indication they occurred.\n\n    >>> with ExceptionTrap() as trap:\n    ...     raise Exception()\n    >>> bool(trap)\n    True\n\n    >>> with ExceptionTrap() as trap:\n    ...     pass\n    >>> bool(trap)\n    False\n\n    >>> with ExceptionTrap(ValueError) as trap:\n    ...     raise ValueError(\"1 + 1 is not 3\")\n    >>> bool(trap)\n    True\n    >>> trap.value\n    ValueError('1 + 1 is not 3')\n    >>> trap.tb\n    <traceback object at ...>\n\n    >>> with ExceptionTrap(ValueError) as trap:\n    ...     raise Exception()\n    Traceback (most recent call last):\n    ...\n    Exception\n\n    >>> bool(trap)\n    False\n    \"\"\"\n\n    exc_info = None, None, None\n\n    def __init__(self, exceptions=(Exception,)):\n        self.exceptions = exceptions\n\n    def __enter__(self):\n        return self\n\n    @property\n    def type(self):\n        return self.exc_info[0]\n\n    @property\n    def value(self):\n        return self.exc_info[1]\n\n    @property\n    def tb(self):\n        return self.exc_info[2]\n\n    def __exit__(self, *exc_info):\n        type = exc_info[0]\n        matches = type and issubclass(type, self.exceptions)\n        if matches:\n            self.exc_info = exc_info\n        return matches\n\n    def __bool__(self):\n        return bool(self.type)\n\n    def raises(self, func, *, _test=bool):\n        \"\"\"\n        Wrap func and replace the result with the truth\n        value of the trap (True if an exception occurred).\n\n        First, give the decorator an alias to support Python 3.8\n        Syntax.\n\n        >>> raises = ExceptionTrap(ValueError).raises\n\n        Now decorate a function that always fails.\n\n        >>> @raises\n        ... def fail():\n        ...     raise ValueError('failed')\n        >>> fail()\n        True\n        \"\"\"\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with ExceptionTrap(self.exceptions) as trap:\n                func(*args, **kwargs)\n            return _test(trap)\n\n        return wrapper\n\n    def passes(self, func):\n        \"\"\"\n        Wrap func and replace the result with the truth\n        value of the trap (True if no exception).\n\n        First, give the decorator an alias to support Python 3.8\n        Syntax.\n\n        >>> passes = ExceptionTrap(ValueError).passes\n\n        Now decorate a function that always fails.\n\n        >>> @passes\n        ... def fail():\n        ...     raise ValueError('failed')\n\n        >>> fail()\n        False\n        \"\"\"\n        return self.raises(func, _test=operator.not_)\n\n\nclass suppress(contextlib.suppress, contextlib.ContextDecorator):\n    \"\"\"\n    A version of contextlib.suppress with decorator support.\n\n    >>> @suppress(KeyError)\n    ... def key_error():\n    ...     {}['']\n    >>> key_error()\n    \"\"\"\n\n\nclass on_interrupt(contextlib.ContextDecorator):\n    \"\"\"\n    Replace a KeyboardInterrupt with SystemExit(1)\n\n    >>> def do_interrupt():\n    ...     raise KeyboardInterrupt()\n    >>> on_interrupt('error')(do_interrupt)()\n    Traceback (most recent call last):\n    ...\n    SystemExit: 1\n    >>> on_interrupt('error', code=255)(do_interrupt)()\n    Traceback (most recent call last):\n    ...\n    SystemExit: 255\n    >>> on_interrupt('suppress')(do_interrupt)()\n    >>> with __import__('pytest').raises(KeyboardInterrupt):\n    ...     on_interrupt('ignore')(do_interrupt)()\n    \"\"\"\n\n    def __init__(self, action='error', /, code=1):\n        self.action = action\n        self.code = code\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exctype, excinst, exctb):\n        if exctype is not KeyboardInterrupt or self.action == 'ignore':\n            return\n        elif self.action == 'error':\n            raise SystemExit(self.code) from excinst\n        return self.action == 'suppress'\n", "pkg_resources/_vendor/jaraco/text/__init__.py": "import re\nimport itertools\nimport textwrap\nimport functools\n\ntry:\n    from importlib.resources import files  # type: ignore\nexcept ImportError:  # pragma: nocover\n    from pkg_resources.extern.importlib_resources import files  # type: ignore\n\nfrom pkg_resources.extern.jaraco.functools import compose, method_cache\nfrom pkg_resources.extern.jaraco.context import ExceptionTrap\n\n\ndef substitution(old, new):\n    \"\"\"\n    Return a function that will perform a substitution on a string\n    \"\"\"\n    return lambda s: s.replace(old, new)\n\n\ndef multi_substitution(*substitutions):\n    \"\"\"\n    Take a sequence of pairs specifying substitutions, and create\n    a function that performs those substitutions.\n\n    >>> multi_substitution(('foo', 'bar'), ('bar', 'baz'))('foo')\n    'baz'\n    \"\"\"\n    substitutions = itertools.starmap(substitution, substitutions)\n    # compose function applies last function first, so reverse the\n    #  substitutions to get the expected order.\n    substitutions = reversed(tuple(substitutions))\n    return compose(*substitutions)\n\n\nclass FoldedCase(str):\n    \"\"\"\n    A case insensitive string class; behaves just like str\n    except compares equal when the only variation is case.\n\n    >>> s = FoldedCase('hello world')\n\n    >>> s == 'Hello World'\n    True\n\n    >>> 'Hello World' == s\n    True\n\n    >>> s != 'Hello World'\n    False\n\n    >>> s.index('O')\n    4\n\n    >>> s.split('O')\n    ['hell', ' w', 'rld']\n\n    >>> sorted(map(FoldedCase, ['GAMMA', 'alpha', 'Beta']))\n    ['alpha', 'Beta', 'GAMMA']\n\n    Sequence membership is straightforward.\n\n    >>> \"Hello World\" in [s]\n    True\n    >>> s in [\"Hello World\"]\n    True\n\n    You may test for set inclusion, but candidate and elements\n    must both be folded.\n\n    >>> FoldedCase(\"Hello World\") in {s}\n    True\n    >>> s in {FoldedCase(\"Hello World\")}\n    True\n\n    String inclusion works as long as the FoldedCase object\n    is on the right.\n\n    >>> \"hello\" in FoldedCase(\"Hello World\")\n    True\n\n    But not if the FoldedCase object is on the left:\n\n    >>> FoldedCase('hello') in 'Hello World'\n    False\n\n    In that case, use ``in_``:\n\n    >>> FoldedCase('hello').in_('Hello World')\n    True\n\n    >>> FoldedCase('hello') > FoldedCase('Hello')\n    False\n    \"\"\"\n\n    def __lt__(self, other):\n        return self.lower() < other.lower()\n\n    def __gt__(self, other):\n        return self.lower() > other.lower()\n\n    def __eq__(self, other):\n        return self.lower() == other.lower()\n\n    def __ne__(self, other):\n        return self.lower() != other.lower()\n\n    def __hash__(self):\n        return hash(self.lower())\n\n    def __contains__(self, other):\n        return super().lower().__contains__(other.lower())\n\n    def in_(self, other):\n        \"Does self appear in other?\"\n        return self in FoldedCase(other)\n\n    # cache lower since it's likely to be called frequently.\n    @method_cache\n    def lower(self):\n        return super().lower()\n\n    def index(self, sub):\n        return self.lower().index(sub.lower())\n\n    def split(self, splitter=' ', maxsplit=0):\n        pattern = re.compile(re.escape(splitter), re.I)\n        return pattern.split(self, maxsplit)\n\n\n# Python 3.8 compatibility\n_unicode_trap = ExceptionTrap(UnicodeDecodeError)\n\n\n@_unicode_trap.passes\ndef is_decodable(value):\n    r\"\"\"\n    Return True if the supplied value is decodable (using the default\n    encoding).\n\n    >>> is_decodable(b'\\xff')\n    False\n    >>> is_decodable(b'\\x32')\n    True\n    \"\"\"\n    value.decode()\n\n\ndef is_binary(value):\n    r\"\"\"\n    Return True if the value appears to be binary (that is, it's a byte\n    string and isn't decodable).\n\n    >>> is_binary(b'\\xff')\n    True\n    >>> is_binary('\\xff')\n    False\n    \"\"\"\n    return isinstance(value, bytes) and not is_decodable(value)\n\n\ndef trim(s):\n    r\"\"\"\n    Trim something like a docstring to remove the whitespace that\n    is common due to indentation and formatting.\n\n    >>> trim(\"\\n\\tfoo = bar\\n\\t\\tbar = baz\\n\")\n    'foo = bar\\n\\tbar = baz'\n    \"\"\"\n    return textwrap.dedent(s).strip()\n\n\ndef wrap(s):\n    \"\"\"\n    Wrap lines of text, retaining existing newlines as\n    paragraph markers.\n\n    >>> print(wrap(lorem_ipsum))\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n    eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad\n    minim veniam, quis nostrud exercitation ullamco laboris nisi ut\n    aliquip ex ea commodo consequat. Duis aute irure dolor in\n    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla\n    pariatur. Excepteur sint occaecat cupidatat non proident, sunt in\n    culpa qui officia deserunt mollit anim id est laborum.\n    <BLANKLINE>\n    Curabitur pretium tincidunt lacus. Nulla gravida orci a odio. Nullam\n    varius, turpis et commodo pharetra, est eros bibendum elit, nec luctus\n    magna felis sollicitudin mauris. Integer in mauris eu nibh euismod\n    gravida. Duis ac tellus et risus vulputate vehicula. Donec lobortis\n    risus a elit. Etiam tempor. Ut ullamcorper, ligula eu tempor congue,\n    eros est euismod turpis, id tincidunt sapien risus a quam. Maecenas\n    fermentum consequat mi. Donec fermentum. Pellentesque malesuada nulla\n    a mi. Duis sapien sem, aliquet nec, commodo eget, consequat quis,\n    neque. Aliquam faucibus, elit ut dictum aliquet, felis nisl adipiscing\n    sapien, sed malesuada diam lacus eget erat. Cras mollis scelerisque\n    nunc. Nullam arcu. Aliquam consequat. Curabitur augue lorem, dapibus\n    quis, laoreet et, pretium ac, nisi. Aenean magna nisl, mollis quis,\n    molestie eu, feugiat in, orci. In hac habitasse platea dictumst.\n    \"\"\"\n    paragraphs = s.splitlines()\n    wrapped = ('\\n'.join(textwrap.wrap(para)) for para in paragraphs)\n    return '\\n\\n'.join(wrapped)\n\n\ndef unwrap(s):\n    r\"\"\"\n    Given a multi-line string, return an unwrapped version.\n\n    >>> wrapped = wrap(lorem_ipsum)\n    >>> wrapped.count('\\n')\n    20\n    >>> unwrapped = unwrap(wrapped)\n    >>> unwrapped.count('\\n')\n    1\n    >>> print(unwrapped)\n    Lorem ipsum dolor sit amet, consectetur adipiscing ...\n    Curabitur pretium tincidunt lacus. Nulla gravida orci ...\n\n    \"\"\"\n    paragraphs = re.split(r'\\n\\n+', s)\n    cleaned = (para.replace('\\n', ' ') for para in paragraphs)\n    return '\\n'.join(cleaned)\n\n\n\n\nclass Splitter(object):\n    \"\"\"object that will split a string with the given arguments for each call\n\n    >>> s = Splitter(',')\n    >>> s('hello, world, this is your, master calling')\n    ['hello', ' world', ' this is your', ' master calling']\n    \"\"\"\n\n    def __init__(self, *args):\n        self.args = args\n\n    def __call__(self, s):\n        return s.split(*self.args)\n\n\ndef indent(string, prefix=' ' * 4):\n    \"\"\"\n    >>> indent('foo')\n    '    foo'\n    \"\"\"\n    return prefix + string\n\n\nclass WordSet(tuple):\n    \"\"\"\n    Given an identifier, return the words that identifier represents,\n    whether in camel case, underscore-separated, etc.\n\n    >>> WordSet.parse(\"camelCase\")\n    ('camel', 'Case')\n\n    >>> WordSet.parse(\"under_sep\")\n    ('under', 'sep')\n\n    Acronyms should be retained\n\n    >>> WordSet.parse(\"firstSNL\")\n    ('first', 'SNL')\n\n    >>> WordSet.parse(\"you_and_I\")\n    ('you', 'and', 'I')\n\n    >>> WordSet.parse(\"A simple test\")\n    ('A', 'simple', 'test')\n\n    Multiple caps should not interfere with the first cap of another word.\n\n    >>> WordSet.parse(\"myABCClass\")\n    ('my', 'ABC', 'Class')\n\n    The result is a WordSet, so you can get the form you need.\n\n    >>> WordSet.parse(\"myABCClass\").underscore_separated()\n    'my_ABC_Class'\n\n    >>> WordSet.parse('a-command').camel_case()\n    'ACommand'\n\n    >>> WordSet.parse('someIdentifier').lowered().space_separated()\n    'some identifier'\n\n    Slices of the result should return another WordSet.\n\n    >>> WordSet.parse('taken-out-of-context')[1:].underscore_separated()\n    'out_of_context'\n\n    >>> WordSet.from_class_name(WordSet()).lowered().space_separated()\n    'word set'\n\n    >>> example = WordSet.parse('figured it out')\n    >>> example.headless_camel_case()\n    'figuredItOut'\n    >>> example.dash_separated()\n    'figured-it-out'\n\n    \"\"\"\n\n    _pattern = re.compile('([A-Z]?[a-z]+)|([A-Z]+(?![a-z]))')\n\n    def capitalized(self):\n        return WordSet(word.capitalize() for word in self)\n\n    def lowered(self):\n        return WordSet(word.lower() for word in self)\n\n    def camel_case(self):\n        return ''.join(self.capitalized())\n\n    def headless_camel_case(self):\n        words = iter(self)\n        first = next(words).lower()\n        new_words = itertools.chain((first,), WordSet(words).camel_case())\n        return ''.join(new_words)\n\n    def underscore_separated(self):\n        return '_'.join(self)\n\n    def dash_separated(self):\n        return '-'.join(self)\n\n    def space_separated(self):\n        return ' '.join(self)\n\n    def trim_right(self, item):\n        \"\"\"\n        Remove the item from the end of the set.\n\n        >>> WordSet.parse('foo bar').trim_right('foo')\n        ('foo', 'bar')\n        >>> WordSet.parse('foo bar').trim_right('bar')\n        ('foo',)\n        >>> WordSet.parse('').trim_right('bar')\n        ()\n        \"\"\"\n        return self[:-1] if self and self[-1] == item else self\n\n    def trim_left(self, item):\n        \"\"\"\n        Remove the item from the beginning of the set.\n\n        >>> WordSet.parse('foo bar').trim_left('foo')\n        ('bar',)\n        >>> WordSet.parse('foo bar').trim_left('bar')\n        ('foo', 'bar')\n        >>> WordSet.parse('').trim_left('bar')\n        ()\n        \"\"\"\n        return self[1:] if self and self[0] == item else self\n\n    def trim(self, item):\n        \"\"\"\n        >>> WordSet.parse('foo bar').trim('foo')\n        ('bar',)\n        \"\"\"\n        return self.trim_left(item).trim_right(item)\n\n    def __getitem__(self, item):\n        result = super(WordSet, self).__getitem__(item)\n        if isinstance(item, slice):\n            result = WordSet(result)\n        return result\n\n    @classmethod\n    def parse(cls, identifier):\n        matches = cls._pattern.finditer(identifier)\n        return WordSet(match.group(0) for match in matches)\n\n    @classmethod\n    def from_class_name(cls, subject):\n        return cls.parse(subject.__class__.__name__)\n\n\n# for backward compatibility\nwords = WordSet.parse\n\n\ndef simple_html_strip(s):\n    r\"\"\"\n    Remove HTML from the string `s`.\n\n    >>> str(simple_html_strip(''))\n    ''\n\n    >>> print(simple_html_strip('A <bold>stormy</bold> day in paradise'))\n    A stormy day in paradise\n\n    >>> print(simple_html_strip('Somebody <!-- do not --> tell the truth.'))\n    Somebody  tell the truth.\n\n    >>> print(simple_html_strip('What about<br/>\\nmultiple lines?'))\n    What about\n    multiple lines?\n    \"\"\"\n    html_stripper = re.compile('(<!--.*?-->)|(<[^>]*>)|([^<]+)', re.DOTALL)\n    texts = (match.group(3) or '' for match in html_stripper.finditer(s))\n    return ''.join(texts)\n\n\nclass SeparatedValues(str):\n    \"\"\"\n    A string separated by a separator. Overrides __iter__ for getting\n    the values.\n\n    >>> list(SeparatedValues('a,b,c'))\n    ['a', 'b', 'c']\n\n    Whitespace is stripped and empty values are discarded.\n\n    >>> list(SeparatedValues(' a,   b   , c,  '))\n    ['a', 'b', 'c']\n    \"\"\"\n\n    separator = ','\n\n    def __iter__(self):\n        parts = self.split(self.separator)\n        return filter(None, (part.strip() for part in parts))\n\n\nclass Stripper:\n    r\"\"\"\n    Given a series of lines, find the common prefix and strip it from them.\n\n    >>> lines = [\n    ...     'abcdefg\\n',\n    ...     'abc\\n',\n    ...     'abcde\\n',\n    ... ]\n    >>> res = Stripper.strip_prefix(lines)\n    >>> res.prefix\n    'abc'\n    >>> list(res.lines)\n    ['defg\\n', '\\n', 'de\\n']\n\n    If no prefix is common, nothing should be stripped.\n\n    >>> lines = [\n    ...     'abcd\\n',\n    ...     '1234\\n',\n    ... ]\n    >>> res = Stripper.strip_prefix(lines)\n    >>> res.prefix = ''\n    >>> list(res.lines)\n    ['abcd\\n', '1234\\n']\n    \"\"\"\n\n    def __init__(self, prefix, lines):\n        self.prefix = prefix\n        self.lines = map(self, lines)\n\n    @classmethod\n    def strip_prefix(cls, lines):\n        prefix_lines, lines = itertools.tee(lines)\n        prefix = functools.reduce(cls.common_prefix, prefix_lines)\n        return cls(prefix, lines)\n\n    def __call__(self, line):\n        if not self.prefix:\n            return line\n        null, prefix, rest = line.partition(self.prefix)\n        return rest\n\n    @staticmethod\n    def common_prefix(s1, s2):\n        \"\"\"\n        Return the common prefix of two lines.\n        \"\"\"\n        index = min(len(s1), len(s2))\n        while s1[:index] != s2[:index]:\n            index -= 1\n        return s1[:index]\n\n\ndef remove_prefix(text, prefix):\n    \"\"\"\n    Remove the prefix from the text if it exists.\n\n    >>> remove_prefix('underwhelming performance', 'underwhelming ')\n    'performance'\n\n    >>> remove_prefix('something special', 'sample')\n    'something special'\n    \"\"\"\n    null, prefix, rest = text.rpartition(prefix)\n    return rest\n\n\ndef remove_suffix(text, suffix):\n    \"\"\"\n    Remove the suffix from the text if it exists.\n\n    >>> remove_suffix('name.git', '.git')\n    'name'\n\n    >>> remove_suffix('something special', 'sample')\n    'something special'\n    \"\"\"\n    rest, suffix, null = text.partition(suffix)\n    return rest\n\n\ndef normalize_newlines(text):\n    r\"\"\"\n    Replace alternate newlines with the canonical newline.\n\n    >>> normalize_newlines('Lorem Ipsum\\u2029')\n    'Lorem Ipsum\\n'\n    >>> normalize_newlines('Lorem Ipsum\\r\\n')\n    'Lorem Ipsum\\n'\n    >>> normalize_newlines('Lorem Ipsum\\x85')\n    'Lorem Ipsum\\n'\n    \"\"\"\n    newlines = ['\\r\\n', '\\r', '\\n', '\\u0085', '\\u2028', '\\u2029']\n    pattern = '|'.join(newlines)\n    return re.sub(pattern, '\\n', text)\n\n\ndef _nonblank(str):\n    return str and not str.startswith('#')\n\n\n@functools.singledispatch\ndef yield_lines(iterable):\n    r\"\"\"\n    Yield valid lines of a string or iterable.\n\n    >>> list(yield_lines(''))\n    []\n    >>> list(yield_lines(['foo', 'bar']))\n    ['foo', 'bar']\n    >>> list(yield_lines('foo\\nbar'))\n    ['foo', 'bar']\n    >>> list(yield_lines('\\nfoo\\n#bar\\nbaz #comment'))\n    ['foo', 'baz #comment']\n    >>> list(yield_lines(['foo\\nbar', 'baz', 'bing\\n\\n\\n']))\n    ['foo', 'bar', 'baz', 'bing']\n    \"\"\"\n    return itertools.chain.from_iterable(map(yield_lines, iterable))\n\n\n@yield_lines.register(str)\ndef _(text):\n    return filter(_nonblank, map(str.strip, text.splitlines()))\n\n\ndef drop_comment(line):\n    \"\"\"\n    Drop comments.\n\n    >>> drop_comment('foo # bar')\n    'foo'\n\n    A hash without a space may be in a URL.\n\n    >>> drop_comment('http://example.com/foo#bar')\n    'http://example.com/foo#bar'\n    \"\"\"\n    return line.partition(' #')[0]\n\n\ndef join_continuation(lines):\n    r\"\"\"\n    Join lines continued by a trailing backslash.\n\n    >>> list(join_continuation(['foo \\\\', 'bar', 'baz']))\n    ['foobar', 'baz']\n    >>> list(join_continuation(['foo \\\\', 'bar', 'baz']))\n    ['foobar', 'baz']\n    >>> list(join_continuation(['foo \\\\', 'bar \\\\', 'baz']))\n    ['foobarbaz']\n\n    Not sure why, but...\n    The character preceeding the backslash is also elided.\n\n    >>> list(join_continuation(['goo\\\\', 'dly']))\n    ['godly']\n\n    A terrible idea, but...\n    If no line is available to continue, suppress the lines.\n\n    >>> list(join_continuation(['foo', 'bar\\\\', 'baz\\\\']))\n    ['foo']\n    \"\"\"\n    lines = iter(lines)\n    for item in lines:\n        while item.endswith('\\\\'):\n            try:\n                item = item[:-2].strip() + next(lines)\n            except StopIteration:\n                return\n        yield item\n", "pkg_resources/_vendor/jaraco/functools/__init__.py": "import collections.abc\nimport functools\nimport inspect\nimport itertools\nimport operator\nimport time\nimport types\nimport warnings\n\nimport pkg_resources.extern.more_itertools\n\n\ndef compose(*funcs):\n    \"\"\"\n    Compose any number of unary functions into a single unary function.\n\n    >>> import textwrap\n    >>> expected = str.strip(textwrap.dedent(compose.__doc__))\n    >>> strip_and_dedent = compose(str.strip, textwrap.dedent)\n    >>> strip_and_dedent(compose.__doc__) == expected\n    True\n\n    Compose also allows the innermost function to take arbitrary arguments.\n\n    >>> round_three = lambda x: round(x, ndigits=3)\n    >>> f = compose(round_three, int.__truediv__)\n    >>> [f(3*x, x+1) for x in range(1,10)]\n    [1.5, 2.0, 2.25, 2.4, 2.5, 2.571, 2.625, 2.667, 2.7]\n    \"\"\"\n\n    def compose_two(f1, f2):\n        return lambda *args, **kwargs: f1(f2(*args, **kwargs))\n\n    return functools.reduce(compose_two, funcs)\n\n\ndef once(func):\n    \"\"\"\n    Decorate func so it's only ever called the first time.\n\n    This decorator can ensure that an expensive or non-idempotent function\n    will not be expensive on subsequent calls and is idempotent.\n\n    >>> add_three = once(lambda a: a+3)\n    >>> add_three(3)\n    6\n    >>> add_three(9)\n    6\n    >>> add_three('12')\n    6\n\n    To reset the stored value, simply clear the property ``saved_result``.\n\n    >>> del add_three.saved_result\n    >>> add_three(9)\n    12\n    >>> add_three(8)\n    12\n\n    Or invoke 'reset()' on it.\n\n    >>> add_three.reset()\n    >>> add_three(-3)\n    0\n    >>> add_three(0)\n    0\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        if not hasattr(wrapper, 'saved_result'):\n            wrapper.saved_result = func(*args, **kwargs)\n        return wrapper.saved_result\n\n    wrapper.reset = lambda: vars(wrapper).__delitem__('saved_result')\n    return wrapper\n\n\ndef method_cache(method, cache_wrapper=functools.lru_cache()):\n    \"\"\"\n    Wrap lru_cache to support storing the cache data in the object instances.\n\n    Abstracts the common paradigm where the method explicitly saves an\n    underscore-prefixed protected property on first call and returns that\n    subsequently.\n\n    >>> class MyClass:\n    ...     calls = 0\n    ...\n    ...     @method_cache\n    ...     def method(self, value):\n    ...         self.calls += 1\n    ...         return value\n\n    >>> a = MyClass()\n    >>> a.method(3)\n    3\n    >>> for x in range(75):\n    ...     res = a.method(x)\n    >>> a.calls\n    75\n\n    Note that the apparent behavior will be exactly like that of lru_cache\n    except that the cache is stored on each instance, so values in one\n    instance will not flush values from another, and when an instance is\n    deleted, so are the cached values for that instance.\n\n    >>> b = MyClass()\n    >>> for x in range(35):\n    ...     res = b.method(x)\n    >>> b.calls\n    35\n    >>> a.method(0)\n    0\n    >>> a.calls\n    75\n\n    Note that if method had been decorated with ``functools.lru_cache()``,\n    a.calls would have been 76 (due to the cached value of 0 having been\n    flushed by the 'b' instance).\n\n    Clear the cache with ``.cache_clear()``\n\n    >>> a.method.cache_clear()\n\n    Same for a method that hasn't yet been called.\n\n    >>> c = MyClass()\n    >>> c.method.cache_clear()\n\n    Another cache wrapper may be supplied:\n\n    >>> cache = functools.lru_cache(maxsize=2)\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\n    >>> a = MyClass()\n    >>> a.method2()\n    3\n\n    Caution - do not subsequently wrap the method with another decorator, such\n    as ``@property``, which changes the semantics of the function.\n\n    See also\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\n    for another implementation and additional justification.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        # it's the first call, replace the method with a cached, bound method\n        bound_method = types.MethodType(method, self)\n        cached_method = cache_wrapper(bound_method)\n        setattr(self, method.__name__, cached_method)\n        return cached_method(*args, **kwargs)\n\n    # Support cache clear even before cache has been created.\n    wrapper.cache_clear = lambda: None\n\n    return _special_method_cache(method, cache_wrapper) or wrapper\n\n\ndef _special_method_cache(method, cache_wrapper):\n    \"\"\"\n    Because Python treats special methods differently, it's not\n    possible to use instance attributes to implement the cached\n    methods.\n\n    Instead, install the wrapper method under a different name\n    and return a simple proxy to that wrapper.\n\n    https://github.com/jaraco/jaraco.functools/issues/5\n    \"\"\"\n    name = method.__name__\n    special_names = '__getattr__', '__getitem__'\n\n    if name not in special_names:\n        return None\n\n    wrapper_name = '__cached' + name\n\n    def proxy(self, /, *args, **kwargs):\n        if wrapper_name not in vars(self):\n            bound = types.MethodType(method, self)\n            cache = cache_wrapper(bound)\n            setattr(self, wrapper_name, cache)\n        else:\n            cache = getattr(self, wrapper_name)\n        return cache(*args, **kwargs)\n\n    return proxy\n\n\ndef apply(transform):\n    \"\"\"\n    Decorate a function with a transform function that is\n    invoked on results returned from the decorated function.\n\n    >>> @apply(reversed)\n    ... def get_numbers(start):\n    ...     \"doc for get_numbers\"\n    ...     return range(start, start+3)\n    >>> list(get_numbers(4))\n    [6, 5, 4]\n    >>> get_numbers.__doc__\n    'doc for get_numbers'\n    \"\"\"\n\n    def wrap(func):\n        return functools.wraps(func)(compose(transform, func))\n\n    return wrap\n\n\ndef result_invoke(action):\n    r\"\"\"\n    Decorate a function with an action function that is\n    invoked on the results returned from the decorated\n    function (for its side effect), then return the original\n    result.\n\n    >>> @result_invoke(print)\n    ... def add_two(a, b):\n    ...     return a + b\n    >>> x = add_two(2, 3)\n    5\n    >>> x\n    5\n    \"\"\"\n\n    def wrap(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            action(result)\n            return result\n\n        return wrapper\n\n    return wrap\n\n\ndef invoke(f, /, *args, **kwargs):\n    \"\"\"\n    Call a function for its side effect after initialization.\n\n    The benefit of using the decorator instead of simply invoking a function\n    after defining it is that it makes explicit the author's intent for the\n    function to be called immediately. Whereas if one simply calls the\n    function immediately, it's less obvious if that was intentional or\n    incidental. It also avoids repeating the name - the two actions, defining\n    the function and calling it immediately are modeled separately, but linked\n    by the decorator construct.\n\n    The benefit of having a function construct (opposed to just invoking some\n    behavior inline) is to serve as a scope in which the behavior occurs. It\n    avoids polluting the global namespace with local variables, provides an\n    anchor on which to attach documentation (docstring), keeps the behavior\n    logically separated (instead of conceptually separated or not separated at\n    all), and provides potential to re-use the behavior for testing or other\n    purposes.\n\n    This function is named as a pithy way to communicate, \"call this function\n    primarily for its side effect\", or \"while defining this function, also\n    take it aside and call it\". It exists because there's no Python construct\n    for \"define and call\" (nor should there be, as decorators serve this need\n    just fine). The behavior happens immediately and synchronously.\n\n    >>> @invoke\n    ... def func(): print(\"called\")\n    called\n    >>> func()\n    called\n\n    Use functools.partial to pass parameters to the initial call\n\n    >>> @functools.partial(invoke, name='bingo')\n    ... def func(name): print('called with', name)\n    called with bingo\n    \"\"\"\n    f(*args, **kwargs)\n    return f\n\n\nclass Throttler:\n    \"\"\"Rate-limit a function (or other callable).\"\"\"\n\n    def __init__(self, func, max_rate=float('Inf')):\n        if isinstance(func, Throttler):\n            func = func.func\n        self.func = func\n        self.max_rate = max_rate\n        self.reset()\n\n    def reset(self):\n        self.last_called = 0\n\n    def __call__(self, *args, **kwargs):\n        self._wait()\n        return self.func(*args, **kwargs)\n\n    def _wait(self):\n        \"\"\"Ensure at least 1/max_rate seconds from last call.\"\"\"\n        elapsed = time.time() - self.last_called\n        must_wait = 1 / self.max_rate - elapsed\n        time.sleep(max(0, must_wait))\n        self.last_called = time.time()\n\n    def __get__(self, obj, owner=None):\n        return first_invoke(self._wait, functools.partial(self.func, obj))\n\n\ndef first_invoke(func1, func2):\n    \"\"\"\n    Return a function that when invoked will invoke func1 without\n    any parameters (for its side effect) and then invoke func2\n    with whatever parameters were passed, returning its result.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        func1()\n        return func2(*args, **kwargs)\n\n    return wrapper\n\n\nmethod_caller = first_invoke(\n    lambda: warnings.warn(\n        '`jaraco.functools.method_caller` is deprecated, '\n        'use `operator.methodcaller` instead',\n        DeprecationWarning,\n        stacklevel=3,\n    ),\n    operator.methodcaller,\n)\n\n\ndef retry_call(func, cleanup=lambda: None, retries=0, trap=()):\n    \"\"\"\n    Given a callable func, trap the indicated exceptions\n    for up to 'retries' times, invoking cleanup on the\n    exception. On the final attempt, allow any exceptions\n    to propagate.\n    \"\"\"\n    attempts = itertools.count() if retries == float('inf') else range(retries)\n    for _ in attempts:\n        try:\n            return func()\n        except trap:\n            cleanup()\n\n    return func()\n\n\ndef retry(*r_args, **r_kwargs):\n    \"\"\"\n    Decorator wrapper for retry_call. Accepts arguments to retry_call\n    except func and then returns a decorator for the decorated function.\n\n    Ex:\n\n    >>> @retry(retries=3)\n    ... def my_func(a, b):\n    ...     \"this is my funk\"\n    ...     print(a, b)\n    >>> my_func.__doc__\n    'this is my funk'\n    \"\"\"\n\n    def decorate(func):\n        @functools.wraps(func)\n        def wrapper(*f_args, **f_kwargs):\n            bound = functools.partial(func, *f_args, **f_kwargs)\n            return retry_call(bound, *r_args, **r_kwargs)\n\n        return wrapper\n\n    return decorate\n\n\ndef print_yielded(func):\n    \"\"\"\n    Convert a generator into a function that prints all yielded elements.\n\n    >>> @print_yielded\n    ... def x():\n    ...     yield 3; yield None\n    >>> x()\n    3\n    None\n    \"\"\"\n    print_all = functools.partial(map, print)\n    print_results = compose(more_itertools.consume, print_all, func)\n    return functools.wraps(func)(print_results)\n\n\ndef pass_none(func):\n    \"\"\"\n    Wrap func so it's not called if its first param is None.\n\n    >>> print_text = pass_none(print)\n    >>> print_text('text')\n    text\n    >>> print_text(None)\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(param, /, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n        return None\n\n    return wrapper\n\n\ndef assign_params(func, namespace):\n    \"\"\"\n    Assign parameters from namespace where func solicits.\n\n    >>> def func(x, y=3):\n    ...     print(x, y)\n    >>> assigned = assign_params(func, dict(x=2, z=4))\n    >>> assigned()\n    2 3\n\n    The usual errors are raised if a function doesn't receive\n    its required parameters:\n\n    >>> assigned = assign_params(func, dict(y=3, z=4))\n    >>> assigned()\n    Traceback (most recent call last):\n    TypeError: func() ...argument...\n\n    It even works on methods:\n\n    >>> class Handler:\n    ...     def meth(self, arg):\n    ...         print(arg)\n    >>> assign_params(Handler().meth, dict(arg='crystal', foo='clear'))()\n    crystal\n    \"\"\"\n    sig = inspect.signature(func)\n    params = sig.parameters.keys()\n    call_ns = {k: namespace[k] for k in params if k in namespace}\n    return functools.partial(func, **call_ns)\n\n\ndef save_method_args(method):\n    \"\"\"\n    Wrap a method such that when it is called, the args and kwargs are\n    saved on the method.\n\n    >>> class MyClass:\n    ...     @save_method_args\n    ...     def method(self, a, b):\n    ...         print(a, b)\n    >>> my_ob = MyClass()\n    >>> my_ob.method(1, 2)\n    1 2\n    >>> my_ob._saved_method.args\n    (1, 2)\n    >>> my_ob._saved_method.kwargs\n    {}\n    >>> my_ob.method(a=3, b='foo')\n    3 foo\n    >>> my_ob._saved_method.args\n    ()\n    >>> my_ob._saved_method.kwargs == dict(a=3, b='foo')\n    True\n\n    The arguments are stored on the instance, allowing for\n    different instance to save different args.\n\n    >>> your_ob = MyClass()\n    >>> your_ob.method({str('x'): 3}, b=[4])\n    {'x': 3} [4]\n    >>> your_ob._saved_method.args\n    ({'x': 3},)\n    >>> my_ob._saved_method.args\n    ()\n    \"\"\"\n    args_and_kwargs = collections.namedtuple('args_and_kwargs', 'args kwargs')\n\n    @functools.wraps(method)\n    def wrapper(self, /, *args, **kwargs):\n        attr_name = '_saved_' + method.__name__\n        attr = args_and_kwargs(args, kwargs)\n        setattr(self, attr_name, attr)\n        return method(self, *args, **kwargs)\n\n    return wrapper\n\n\ndef except_(*exceptions, replace=None, use=None):\n    \"\"\"\n    Replace the indicated exceptions, if raised, with the indicated\n    literal replacement or evaluated expression (if present).\n\n    >>> safe_int = except_(ValueError)(int)\n    >>> safe_int('five')\n    >>> safe_int('5')\n    5\n\n    Specify a literal replacement with ``replace``.\n\n    >>> safe_int_r = except_(ValueError, replace=0)(int)\n    >>> safe_int_r('five')\n    0\n\n    Provide an expression to ``use`` to pass through particular parameters.\n\n    >>> safe_int_pt = except_(ValueError, use='args[0]')(int)\n    >>> safe_int_pt('five')\n    'five'\n\n    \"\"\"\n\n    def decorate(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except exceptions:\n                try:\n                    return eval(use)\n                except TypeError:\n                    return replace\n\n        return wrapper\n\n    return decorate\n\n\ndef identity(x):\n    \"\"\"\n    Return the argument.\n\n    >>> o = object()\n    >>> identity(o) is o\n    True\n    \"\"\"\n    return x\n\n\ndef bypass_when(check, *, _op=identity):\n    \"\"\"\n    Decorate a function to return its parameter when ``check``.\n\n    >>> bypassed = []  # False\n\n    >>> @bypass_when(bypassed)\n    ... def double(x):\n    ...     return x * 2\n    >>> double(2)\n    4\n    >>> bypassed[:] = [object()]  # True\n    >>> double(2)\n    2\n    \"\"\"\n\n    def decorate(func):\n        @functools.wraps(func)\n        def wrapper(param, /):\n            return param if _op(check) else func(param)\n\n        return wrapper\n\n    return decorate\n\n\ndef bypass_unless(check):\n    \"\"\"\n    Decorate a function to return its parameter unless ``check``.\n\n    >>> enabled = [object()]  # True\n\n    >>> @bypass_unless(enabled)\n    ... def double(x):\n    ...     return x * 2\n    >>> double(2)\n    4\n    >>> del enabled[:]  # False\n    >>> double(2)\n    2\n    \"\"\"\n    return bypass_when(check, _op=operator.not_)\n\n\n@functools.singledispatch\ndef _splat_inner(args, func):\n    \"\"\"Splat args to func.\"\"\"\n    return func(*args)\n\n\n@_splat_inner.register\ndef _(args: collections.abc.Mapping, func):\n    \"\"\"Splat kargs to func as kwargs.\"\"\"\n    return func(**args)\n\n\ndef splat(func):\n    \"\"\"\n    Wrap func to expect its parameters to be passed positionally in a tuple.\n\n    Has a similar effect to that of ``itertools.starmap`` over\n    simple ``map``.\n\n    >>> pairs = [(-1, 1), (0, 2)]\n    >>> pkg_resources.extern.more_itertools.consume(itertools.starmap(print, pairs))\n    -1 1\n    0 2\n    >>> pkg_resources.extern.more_itertools.consume(map(splat(print), pairs))\n    -1 1\n    0 2\n\n    The approach generalizes to other iterators that don't have a \"star\"\n    equivalent, such as a \"starfilter\".\n\n    >>> list(filter(splat(operator.add), pairs))\n    [(0, 2)]\n\n    Splat also accepts a mapping argument.\n\n    >>> def is_nice(msg, code):\n    ...     return \"smile\" in msg or code == 0\n    >>> msgs = [\n    ...     dict(msg='smile!', code=20),\n    ...     dict(msg='error :(', code=1),\n    ...     dict(msg='unknown', code=0),\n    ... ]\n    >>> for msg in filter(splat(is_nice), msgs):\n    ...     print(msg)\n    {'msg': 'smile!', 'code': 20}\n    {'msg': 'unknown', 'code': 0}\n    \"\"\"\n    return functools.wraps(func)(functools.partial(_splat_inner, func=func))\n", "pkg_resources/_vendor/importlib_resources/_itertools.py": "from itertools import filterfalse\n\nfrom typing import (\n    Callable,\n    Iterable,\n    Iterator,\n    Optional,\n    Set,\n    TypeVar,\n    Union,\n)\n\n# Type and type variable definitions\n_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\ndef unique_everseen(\n    iterable: Iterable[_T], key: Optional[Callable[[_T], _U]] = None\n) -> Iterator[_T]:\n    \"List unique elements, preserving order. Remember all elements ever seen.\"\n    # unique_everseen('AAAABBBCCDAABBB') --> A B C D\n    # unique_everseen('ABBCcAD', str.lower) --> A B C D\n    seen: Set[Union[_T, _U]] = set()\n    seen_add = seen.add\n    if key is None:\n        for element in filterfalse(seen.__contains__, iterable):\n            seen_add(element)\n            yield element\n    else:\n        for element in iterable:\n            k = key(element)\n            if k not in seen:\n                seen_add(k)\n                yield element\n", "pkg_resources/_vendor/importlib_resources/_common.py": "import os\nimport pathlib\nimport tempfile\nimport functools\nimport contextlib\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport itertools\n\nfrom typing import Union, Optional, cast\nfrom .abc import ResourceReader, Traversable\n\nfrom ._compat import wrap_spec\n\nPackage = Union[types.ModuleType, str]\nAnchor = Package\n\n\ndef package_to_anchor(func):\n    \"\"\"\n    Replace 'package' parameter as 'anchor' and warn about the change.\n\n    Other errors should fall through.\n\n    >>> files('a', 'b')\n    Traceback (most recent call last):\n    TypeError: files() takes from 0 to 1 positional arguments but 2 were given\n    \"\"\"\n    undefined = object()\n\n    @functools.wraps(func)\n    def wrapper(anchor=undefined, package=undefined):\n        if package is not undefined:\n            if anchor is not undefined:\n                return func(anchor, package)\n            warnings.warn(\n                \"First parameter to files is renamed to 'anchor'\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            return func(package)\n        elif anchor is undefined:\n            return func()\n        return func(anchor)\n\n    return wrapper\n\n\n@package_to_anchor\ndef files(anchor: Optional[Anchor] = None) -> Traversable:\n    \"\"\"\n    Get a Traversable resource for an anchor.\n    \"\"\"\n    return from_package(resolve(anchor))\n\n\ndef get_resource_reader(package: types.ModuleType) -> Optional[ResourceReader]:\n    \"\"\"\n    Return the package's loader if it's a ResourceReader.\n    \"\"\"\n    # We can't use\n    # a issubclass() check here because apparently abc.'s __subclasscheck__()\n    # hook wants to create a weak reference to the object, but\n    # zipimport.zipimporter does not support weak references, resulting in a\n    # TypeError.  That seems terrible.\n    spec = package.__spec__\n    reader = getattr(spec.loader, 'get_resource_reader', None)  # type: ignore\n    if reader is None:\n        return None\n    return reader(spec.name)  # type: ignore\n\n\n@functools.singledispatch\ndef resolve(cand: Optional[Anchor]) -> types.ModuleType:\n    return cast(types.ModuleType, cand)\n\n\n@resolve.register\ndef _(cand: str) -> types.ModuleType:\n    return importlib.import_module(cand)\n\n\n@resolve.register\ndef _(cand: None) -> types.ModuleType:\n    return resolve(_infer_caller().f_globals['__name__'])\n\n\ndef _infer_caller():\n    \"\"\"\n    Walk the stack and find the frame of the first caller not in this module.\n    \"\"\"\n\n    def is_this_file(frame_info):\n        return frame_info.filename == __file__\n\n    def is_wrapper(frame_info):\n        return frame_info.function == 'wrapper'\n\n    not_this_file = itertools.filterfalse(is_this_file, inspect.stack())\n    # also exclude 'wrapper' due to singledispatch in the call stack\n    callers = itertools.filterfalse(is_wrapper, not_this_file)\n    return next(callers).frame\n\n\ndef from_package(package: types.ModuleType):\n    \"\"\"\n    Return a Traversable object for the given package.\n\n    \"\"\"\n    spec = wrap_spec(package)\n    reader = spec.loader.get_resource_reader(spec.name)\n    return reader.files()\n\n\n@contextlib.contextmanager\ndef _tempfile(\n    reader,\n    suffix='',\n    # gh-93353: Keep a reference to call os.remove() in late Python\n    # finalization.\n    *,\n    _os_remove=os.remove,\n):\n    # Not using tempfile.NamedTemporaryFile as it leads to deeper 'try'\n    # blocks due to the need to close the temporary file to work on Windows\n    # properly.\n    fd, raw_path = tempfile.mkstemp(suffix=suffix)\n    try:\n        try:\n            os.write(fd, reader())\n        finally:\n            os.close(fd)\n        del reader\n        yield pathlib.Path(raw_path)\n    finally:\n        try:\n            _os_remove(raw_path)\n        except FileNotFoundError:\n            pass\n\n\ndef _temp_file(path):\n    return _tempfile(path.read_bytes, suffix=path.name)\n\n\ndef _is_present_dir(path: Traversable) -> bool:\n    \"\"\"\n    Some Traversables implement ``is_dir()`` to raise an\n    exception (i.e. ``FileNotFoundError``) when the\n    directory doesn't exist. This function wraps that call\n    to always return a boolean and only return True\n    if there's a dir and it exists.\n    \"\"\"\n    with contextlib.suppress(FileNotFoundError):\n        return path.is_dir()\n    return False\n\n\n@functools.singledispatch\ndef as_file(path):\n    \"\"\"\n    Given a Traversable object, return that object as a\n    path on the local file system in a context manager.\n    \"\"\"\n    return _temp_dir(path) if _is_present_dir(path) else _temp_file(path)\n\n\n@as_file.register(pathlib.Path)\n@contextlib.contextmanager\ndef _(path):\n    \"\"\"\n    Degenerate behavior for pathlib.Path objects.\n    \"\"\"\n    yield path\n\n\n@contextlib.contextmanager\ndef _temp_path(dir: tempfile.TemporaryDirectory):\n    \"\"\"\n    Wrap tempfile.TemporyDirectory to return a pathlib object.\n    \"\"\"\n    with dir as result:\n        yield pathlib.Path(result)\n\n\n@contextlib.contextmanager\ndef _temp_dir(path):\n    \"\"\"\n    Given a traversable dir, recursively replicate the whole tree\n    to the file system in a context manager.\n    \"\"\"\n    assert path.is_dir()\n    with _temp_path(tempfile.TemporaryDirectory()) as temp_dir:\n        yield _write_contents(temp_dir, path)\n\n\ndef _write_contents(target, source):\n    child = target.joinpath(source.name)\n    if source.is_dir():\n        child.mkdir()\n        for item in source.iterdir():\n            _write_contents(child, item)\n    else:\n        child.write_bytes(source.read_bytes())\n    return child\n", "pkg_resources/_vendor/importlib_resources/simple.py": "\"\"\"\nInterface adapters for low-level readers.\n\"\"\"\n\nimport abc\nimport io\nimport itertools\nfrom typing import BinaryIO, List\n\nfrom .abc import Traversable, TraversableResources\n\n\nclass SimpleReader(abc.ABC):\n    \"\"\"\n    The minimum, low-level interface required from a resource\n    provider.\n    \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def package(self) -> str:\n        \"\"\"\n        The name of the package for which this reader loads resources.\n        \"\"\"\n\n    @abc.abstractmethod\n    def children(self) -> List['SimpleReader']:\n        \"\"\"\n        Obtain an iterable of SimpleReader for available\n        child containers (e.g. directories).\n        \"\"\"\n\n    @abc.abstractmethod\n    def resources(self) -> List[str]:\n        \"\"\"\n        Obtain available named resources for this virtual package.\n        \"\"\"\n\n    @abc.abstractmethod\n    def open_binary(self, resource: str) -> BinaryIO:\n        \"\"\"\n        Obtain a File-like for a named resource.\n        \"\"\"\n\n    @property\n    def name(self):\n        return self.package.split('.')[-1]\n\n\nclass ResourceContainer(Traversable):\n    \"\"\"\n    Traversable container for a package's resources via its reader.\n    \"\"\"\n\n    def __init__(self, reader: SimpleReader):\n        self.reader = reader\n\n    def is_dir(self):\n        return True\n\n    def is_file(self):\n        return False\n\n    def iterdir(self):\n        files = (ResourceHandle(self, name) for name in self.reader.resources)\n        dirs = map(ResourceContainer, self.reader.children())\n        return itertools.chain(files, dirs)\n\n    def open(self, *args, **kwargs):\n        raise IsADirectoryError()\n\n\nclass ResourceHandle(Traversable):\n    \"\"\"\n    Handle to a named resource in a ResourceReader.\n    \"\"\"\n\n    def __init__(self, parent: ResourceContainer, name: str):\n        self.parent = parent\n        self.name = name  # type: ignore\n\n    def is_file(self):\n        return True\n\n    def is_dir(self):\n        return False\n\n    def open(self, mode='r', *args, **kwargs):\n        stream = self.parent.reader.open_binary(self.name)\n        if 'b' not in mode:\n            stream = io.TextIOWrapper(*args, **kwargs)\n        return stream\n\n    def joinpath(self, name):\n        raise RuntimeError(\"Cannot traverse into a resource\")\n\n\nclass TraversableReader(TraversableResources, SimpleReader):\n    \"\"\"\n    A TraversableResources based on SimpleReader. Resource providers\n    may derive from this class to provide the TraversableResources\n    interface by supplying the SimpleReader interface.\n    \"\"\"\n\n    def files(self):\n        return ResourceContainer(self)\n", "pkg_resources/_vendor/importlib_resources/abc.py": "import abc\nimport io\nimport itertools\nimport pathlib\nfrom typing import Any, BinaryIO, Iterable, Iterator, NoReturn, Text, Optional\n\nfrom ._compat import runtime_checkable, Protocol, StrPath\n\n\n__all__ = [\"ResourceReader\", \"Traversable\", \"TraversableResources\"]\n\n\nclass ResourceReader(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for loaders to provide resource reading support.\"\"\"\n\n    @abc.abstractmethod\n    def open_resource(self, resource: Text) -> BinaryIO:\n        \"\"\"Return an opened, file-like object for binary reading.\n\n        The 'resource' argument is expected to represent only a file name.\n        If the resource cannot be found, FileNotFoundError is raised.\n        \"\"\"\n        # This deliberately raises FileNotFoundError instead of\n        # NotImplementedError so that if this method is accidentally called,\n        # it'll still do the right thing.\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def resource_path(self, resource: Text) -> Text:\n        \"\"\"Return the file system path to the specified resource.\n\n        The 'resource' argument is expected to represent only a file name.\n        If the resource does not exist on the file system, raise\n        FileNotFoundError.\n        \"\"\"\n        # This deliberately raises FileNotFoundError instead of\n        # NotImplementedError so that if this method is accidentally called,\n        # it'll still do the right thing.\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def is_resource(self, path: Text) -> bool:\n        \"\"\"Return True if the named 'path' is a resource.\n\n        Files are resources, directories are not.\n        \"\"\"\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def contents(self) -> Iterable[str]:\n        \"\"\"Return an iterable of entries in `package`.\"\"\"\n        raise FileNotFoundError\n\n\nclass TraversalError(Exception):\n    pass\n\n\n@runtime_checkable\nclass Traversable(Protocol):\n    \"\"\"\n    An object with a subset of pathlib.Path methods suitable for\n    traversing directories and opening files.\n\n    Any exceptions that occur when accessing the backing resource\n    may propagate unaltered.\n    \"\"\"\n\n    @abc.abstractmethod\n    def iterdir(self) -> Iterator[\"Traversable\"]:\n        \"\"\"\n        Yield Traversable objects in self\n        \"\"\"\n\n    def read_bytes(self) -> bytes:\n        \"\"\"\n        Read contents of self as bytes\n        \"\"\"\n        with self.open('rb') as strm:\n            return strm.read()\n\n    def read_text(self, encoding: Optional[str] = None) -> str:\n        \"\"\"\n        Read contents of self as text\n        \"\"\"\n        with self.open(encoding=encoding) as strm:\n            return strm.read()\n\n    @abc.abstractmethod\n    def is_dir(self) -> bool:\n        \"\"\"\n        Return True if self is a directory\n        \"\"\"\n\n    @abc.abstractmethod\n    def is_file(self) -> bool:\n        \"\"\"\n        Return True if self is a file\n        \"\"\"\n\n    def joinpath(self, *descendants: StrPath) -> \"Traversable\":\n        \"\"\"\n        Return Traversable resolved with any descendants applied.\n\n        Each descendant should be a path segment relative to self\n        and each may contain multiple levels separated by\n        ``posixpath.sep`` (``/``).\n        \"\"\"\n        if not descendants:\n            return self\n        names = itertools.chain.from_iterable(\n            path.parts for path in map(pathlib.PurePosixPath, descendants)\n        )\n        target = next(names)\n        matches = (\n            traversable for traversable in self.iterdir() if traversable.name == target\n        )\n        try:\n            match = next(matches)\n        except StopIteration:\n            raise TraversalError(\n                \"Target not found during traversal.\", target, list(names)\n            )\n        return match.joinpath(*names)\n\n    def __truediv__(self, child: StrPath) -> \"Traversable\":\n        \"\"\"\n        Return Traversable child in self\n        \"\"\"\n        return self.joinpath(child)\n\n    @abc.abstractmethod\n    def open(self, mode='r', *args, **kwargs):\n        \"\"\"\n        mode may be 'r' or 'rb' to open as text or binary. Return a handle\n        suitable for reading (same as pathlib.Path.open).\n\n        When opening as text, accepts encoding parameters such as those\n        accepted by io.TextIOWrapper.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        The base name of this object without any parent references.\n        \"\"\"\n\n\nclass TraversableResources(ResourceReader):\n    \"\"\"\n    The required interface for providing traversable\n    resources.\n    \"\"\"\n\n    @abc.abstractmethod\n    def files(self) -> \"Traversable\":\n        \"\"\"Return a Traversable object for the loaded package.\"\"\"\n\n    def open_resource(self, resource: StrPath) -> io.BufferedReader:\n        return self.files().joinpath(resource).open('rb')\n\n    def resource_path(self, resource: Any) -> NoReturn:\n        raise FileNotFoundError(resource)\n\n    def is_resource(self, path: StrPath) -> bool:\n        return self.files().joinpath(path).is_file()\n\n    def contents(self) -> Iterator[str]:\n        return (item.name for item in self.files().iterdir())\n", "pkg_resources/_vendor/importlib_resources/readers.py": "import collections\nimport pathlib\nimport operator\n\nfrom . import abc\n\nfrom ._itertools import unique_everseen\nfrom ._compat import ZipPath\n\n\ndef remove_duplicates(items):\n    return iter(collections.OrderedDict.fromkeys(items))\n\n\nclass FileReader(abc.TraversableResources):\n    def __init__(self, loader):\n        self.path = pathlib.Path(loader.path).parent\n\n    def resource_path(self, resource):\n        \"\"\"\n        Return the file system path to prevent\n        `resources.path()` from creating a temporary\n        copy.\n        \"\"\"\n        return str(self.path.joinpath(resource))\n\n    def files(self):\n        return self.path\n\n\nclass ZipReader(abc.TraversableResources):\n    def __init__(self, loader, module):\n        _, _, name = module.rpartition('.')\n        self.prefix = loader.prefix.replace('\\\\', '/') + name + '/'\n        self.archive = loader.archive\n\n    def open_resource(self, resource):\n        try:\n            return super().open_resource(resource)\n        except KeyError as exc:\n            raise FileNotFoundError(exc.args[0])\n\n    def is_resource(self, path):\n        # workaround for `zipfile.Path.is_file` returning true\n        # for non-existent paths.\n        target = self.files().joinpath(path)\n        return target.is_file() and target.exists()\n\n    def files(self):\n        return ZipPath(self.archive, self.prefix)\n\n\nclass MultiplexedPath(abc.Traversable):\n    \"\"\"\n    Given a series of Traversable objects, implement a merged\n    version of the interface across all objects. Useful for\n    namespace packages which may be multihomed at a single\n    name.\n    \"\"\"\n\n    def __init__(self, *paths):\n        self._paths = list(map(pathlib.Path, remove_duplicates(paths)))\n        if not self._paths:\n            message = 'MultiplexedPath must contain at least one path'\n            raise FileNotFoundError(message)\n        if not all(path.is_dir() for path in self._paths):\n            raise NotADirectoryError('MultiplexedPath only supports directories')\n\n    def iterdir(self):\n        files = (file for path in self._paths for file in path.iterdir())\n        return unique_everseen(files, key=operator.attrgetter('name'))\n\n    def read_bytes(self):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    def read_text(self, *args, **kwargs):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    def is_dir(self):\n        return True\n\n    def is_file(self):\n        return False\n\n    def joinpath(self, *descendants):\n        try:\n            return super().joinpath(*descendants)\n        except abc.TraversalError:\n            # One of the paths did not resolve (a directory does not exist).\n            # Just return something that will not exist.\n            return self._paths[0].joinpath(*descendants)\n\n    def open(self, *args, **kwargs):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    @property\n    def name(self):\n        return self._paths[0].name\n\n    def __repr__(self):\n        paths = ', '.join(f\"'{path}'\" for path in self._paths)\n        return f'MultiplexedPath({paths})'\n\n\nclass NamespaceReader(abc.TraversableResources):\n    def __init__(self, namespace_path):\n        if 'NamespacePath' not in str(namespace_path):\n            raise ValueError('Invalid path')\n        self.path = MultiplexedPath(*list(namespace_path))\n\n    def resource_path(self, resource):\n        \"\"\"\n        Return the file system path to prevent\n        `resources.path()` from creating a temporary\n        copy.\n        \"\"\"\n        return str(self.path.joinpath(resource))\n\n    def files(self):\n        return self.path\n", "pkg_resources/_vendor/importlib_resources/_legacy.py": "import functools\nimport os\nimport pathlib\nimport types\nimport warnings\n\nfrom typing import Union, Iterable, ContextManager, BinaryIO, TextIO, Any\n\nfrom . import _common\n\nPackage = Union[types.ModuleType, str]\nResource = str\n\n\ndef deprecated(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        warnings.warn(\n            f\"{func.__name__} is deprecated. Use files() instead. \"\n            \"Refer to https://importlib-resources.readthedocs.io\"\n            \"/en/latest/using.html#migrating-from-legacy for migration advice.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return func(*args, **kwargs)\n\n    return wrapper\n\n\ndef normalize_path(path: Any) -> str:\n    \"\"\"Normalize a path by ensuring it is a string.\n\n    If the resulting string contains path separators, an exception is raised.\n    \"\"\"\n    str_path = str(path)\n    parent, file_name = os.path.split(str_path)\n    if parent:\n        raise ValueError(f'{path!r} must be only a file name')\n    return file_name\n\n\n@deprecated\ndef open_binary(package: Package, resource: Resource) -> BinaryIO:\n    \"\"\"Return a file-like object opened for binary reading of the resource.\"\"\"\n    return (_common.files(package) / normalize_path(resource)).open('rb')\n\n\n@deprecated\ndef read_binary(package: Package, resource: Resource) -> bytes:\n    \"\"\"Return the binary contents of the resource.\"\"\"\n    return (_common.files(package) / normalize_path(resource)).read_bytes()\n\n\n@deprecated\ndef open_text(\n    package: Package,\n    resource: Resource,\n    encoding: str = 'utf-8',\n    errors: str = 'strict',\n) -> TextIO:\n    \"\"\"Return a file-like object opened for text reading of the resource.\"\"\"\n    return (_common.files(package) / normalize_path(resource)).open(\n        'r', encoding=encoding, errors=errors\n    )\n\n\n@deprecated\ndef read_text(\n    package: Package,\n    resource: Resource,\n    encoding: str = 'utf-8',\n    errors: str = 'strict',\n) -> str:\n    \"\"\"Return the decoded string of the resource.\n\n    The decoding-related arguments have the same semantics as those of\n    bytes.decode().\n    \"\"\"\n    with open_text(package, resource, encoding, errors) as fp:\n        return fp.read()\n\n\n@deprecated\ndef contents(package: Package) -> Iterable[str]:\n    \"\"\"Return an iterable of entries in `package`.\n\n    Note that not all entries are resources.  Specifically, directories are\n    not considered resources.  Use `is_resource()` on each entry returned here\n    to check if it is a resource or not.\n    \"\"\"\n    return [path.name for path in _common.files(package).iterdir()]\n\n\n@deprecated\ndef is_resource(package: Package, name: str) -> bool:\n    \"\"\"True if `name` is a resource inside `package`.\n\n    Directories are *not* resources.\n    \"\"\"\n    resource = normalize_path(name)\n    return any(\n        traversable.name == resource and traversable.is_file()\n        for traversable in _common.files(package).iterdir()\n    )\n\n\n@deprecated\ndef path(\n    package: Package,\n    resource: Resource,\n) -> ContextManager[pathlib.Path]:\n    \"\"\"A context manager providing a file path object to the resource.\n\n    If the resource does not already exist on its own on the file system,\n    a temporary file will be created. If the file was created, the file\n    will be deleted upon exiting the context manager (no exception is\n    raised if the file was deleted prior to the context manager\n    exiting).\n    \"\"\"\n    return _common.as_file(_common.files(package) / normalize_path(resource))\n", "pkg_resources/_vendor/importlib_resources/_adapters.py": "from contextlib import suppress\nfrom io import TextIOWrapper\n\nfrom . import abc\n\n\nclass SpecLoaderAdapter:\n    \"\"\"\n    Adapt a package spec to adapt the underlying loader.\n    \"\"\"\n\n    def __init__(self, spec, adapter=lambda spec: spec.loader):\n        self.spec = spec\n        self.loader = adapter(spec)\n\n    def __getattr__(self, name):\n        return getattr(self.spec, name)\n\n\nclass TraversableResourcesLoader:\n    \"\"\"\n    Adapt a loader to provide TraversableResources.\n    \"\"\"\n\n    def __init__(self, spec):\n        self.spec = spec\n\n    def get_resource_reader(self, name):\n        return CompatibilityFiles(self.spec)._native()\n\n\ndef _io_wrapper(file, mode='r', *args, **kwargs):\n    if mode == 'r':\n        return TextIOWrapper(file, *args, **kwargs)\n    elif mode == 'rb':\n        return file\n    raise ValueError(\n        \"Invalid mode value '{}', only 'r' and 'rb' are supported\".format(mode)\n    )\n\n\nclass CompatibilityFiles:\n    \"\"\"\n    Adapter for an existing or non-existent resource reader\n    to provide a compatibility .files().\n    \"\"\"\n\n    class SpecPath(abc.Traversable):\n        \"\"\"\n        Path tied to a module spec.\n        Can be read and exposes the resource reader children.\n        \"\"\"\n\n        def __init__(self, spec, reader):\n            self._spec = spec\n            self._reader = reader\n\n        def iterdir(self):\n            if not self._reader:\n                return iter(())\n            return iter(\n                CompatibilityFiles.ChildPath(self._reader, path)\n                for path in self._reader.contents()\n            )\n\n        def is_file(self):\n            return False\n\n        is_dir = is_file\n\n        def joinpath(self, other):\n            if not self._reader:\n                return CompatibilityFiles.OrphanPath(other)\n            return CompatibilityFiles.ChildPath(self._reader, other)\n\n        @property\n        def name(self):\n            return self._spec.name\n\n        def open(self, mode='r', *args, **kwargs):\n            return _io_wrapper(self._reader.open_resource(None), mode, *args, **kwargs)\n\n    class ChildPath(abc.Traversable):\n        \"\"\"\n        Path tied to a resource reader child.\n        Can be read but doesn't expose any meaningful children.\n        \"\"\"\n\n        def __init__(self, reader, name):\n            self._reader = reader\n            self._name = name\n\n        def iterdir(self):\n            return iter(())\n\n        def is_file(self):\n            return self._reader.is_resource(self.name)\n\n        def is_dir(self):\n            return not self.is_file()\n\n        def joinpath(self, other):\n            return CompatibilityFiles.OrphanPath(self.name, other)\n\n        @property\n        def name(self):\n            return self._name\n\n        def open(self, mode='r', *args, **kwargs):\n            return _io_wrapper(\n                self._reader.open_resource(self.name), mode, *args, **kwargs\n            )\n\n    class OrphanPath(abc.Traversable):\n        \"\"\"\n        Orphan path, not tied to a module spec or resource reader.\n        Can't be read and doesn't expose any meaningful children.\n        \"\"\"\n\n        def __init__(self, *path_parts):\n            if len(path_parts) < 1:\n                raise ValueError('Need at least one path part to construct a path')\n            self._path = path_parts\n\n        def iterdir(self):\n            return iter(())\n\n        def is_file(self):\n            return False\n\n        is_dir = is_file\n\n        def joinpath(self, other):\n            return CompatibilityFiles.OrphanPath(*self._path, other)\n\n        @property\n        def name(self):\n            return self._path[-1]\n\n        def open(self, mode='r', *args, **kwargs):\n            raise FileNotFoundError(\"Can't open orphan path\")\n\n    def __init__(self, spec):\n        self.spec = spec\n\n    @property\n    def _reader(self):\n        with suppress(AttributeError):\n            return self.spec.loader.get_resource_reader(self.spec.name)\n\n    def _native(self):\n        \"\"\"\n        Return the native reader if it supports files().\n        \"\"\"\n        reader = self._reader\n        return reader if hasattr(reader, 'files') else self\n\n    def __getattr__(self, attr):\n        return getattr(self._reader, attr)\n\n    def files(self):\n        return CompatibilityFiles.SpecPath(self.spec, self._reader)\n\n\ndef wrap_spec(package):\n    \"\"\"\n    Construct a package spec with traversable compatibility\n    on the spec/loader/reader.\n    \"\"\"\n    return SpecLoaderAdapter(package.__spec__, TraversableResourcesLoader)\n", "pkg_resources/_vendor/importlib_resources/_compat.py": "# flake8: noqa\n\nimport abc\nimport os\nimport sys\nimport pathlib\nfrom contextlib import suppress\nfrom typing import Union\n\n\nif sys.version_info >= (3, 10):\n    from zipfile import Path as ZipPath  # type: ignore\nelse:\n    from ..zipp import Path as ZipPath  # type: ignore\n\n\ntry:\n    from typing import runtime_checkable  # type: ignore\nexcept ImportError:\n\n    def runtime_checkable(cls):  # type: ignore\n        return cls\n\n\ntry:\n    from typing import Protocol  # type: ignore\nexcept ImportError:\n    Protocol = abc.ABC  # type: ignore\n\n\nclass TraversableResourcesLoader:\n    \"\"\"\n    Adapt loaders to provide TraversableResources and other\n    compatibility.\n\n    Used primarily for Python 3.9 and earlier where the native\n    loaders do not yet implement TraversableResources.\n    \"\"\"\n\n    def __init__(self, spec):\n        self.spec = spec\n\n    @property\n    def path(self):\n        return self.spec.origin\n\n    def get_resource_reader(self, name):\n        from . import readers, _adapters\n\n        def _zip_reader(spec):\n            with suppress(AttributeError):\n                return readers.ZipReader(spec.loader, spec.name)\n\n        def _namespace_reader(spec):\n            with suppress(AttributeError, ValueError):\n                return readers.NamespaceReader(spec.submodule_search_locations)\n\n        def _available_reader(spec):\n            with suppress(AttributeError):\n                return spec.loader.get_resource_reader(spec.name)\n\n        def _native_reader(spec):\n            reader = _available_reader(spec)\n            return reader if hasattr(reader, 'files') else None\n\n        def _file_reader(spec):\n            try:\n                path = pathlib.Path(self.path)\n            except TypeError:\n                return None\n            if path.exists():\n                return readers.FileReader(self)\n\n        return (\n            # native reader if it supplies 'files'\n            _native_reader(self.spec)\n            or\n            # local ZipReader if a zip module\n            _zip_reader(self.spec)\n            or\n            # local NamespaceReader if a namespace module\n            _namespace_reader(self.spec)\n            or\n            # local FileReader\n            _file_reader(self.spec)\n            # fallback - adapt the spec ResourceReader to TraversableReader\n            or _adapters.CompatibilityFiles(self.spec)\n        )\n\n\ndef wrap_spec(package):\n    \"\"\"\n    Construct a package spec with traversable compatibility\n    on the spec/loader/reader.\n\n    Supersedes _adapters.wrap_spec to use TraversableResourcesLoader\n    from above for older Python compatibility (<3.10).\n    \"\"\"\n    from . import _adapters\n\n    return _adapters.SpecLoaderAdapter(package.__spec__, TraversableResourcesLoader)\n\n\nif sys.version_info >= (3, 9):\n    StrPath = Union[str, os.PathLike[str]]\nelse:\n    # PathLike is only subscriptable at runtime in 3.9+\n    StrPath = Union[str, \"os.PathLike[str]\"]\n", "pkg_resources/_vendor/importlib_resources/__init__.py": "\"\"\"Read resources contained within a package.\"\"\"\n\nfrom ._common import (\n    as_file,\n    files,\n    Package,\n)\n\nfrom ._legacy import (\n    contents,\n    open_binary,\n    read_binary,\n    open_text,\n    read_text,\n    is_resource,\n    path,\n    Resource,\n)\n\nfrom .abc import ResourceReader\n\n\n__all__ = [\n    'Package',\n    'Resource',\n    'ResourceReader',\n    'as_file',\n    'contents',\n    'files',\n    'is_resource',\n    'open_binary',\n    'open_text',\n    'path',\n    'read_binary',\n    'read_text',\n]\n", "pkg_resources/_vendor/platformdirs/windows.py": "from __future__ import annotations\n\nimport ctypes\nimport os\nimport sys\nfrom functools import lru_cache\nfrom typing import Callable\n\nfrom .api import PlatformDirsABC\n\n\nclass Windows(PlatformDirsABC):\n    \"\"\"`MSDN on where to store app data files\n    <http://support.microsoft.com/default.aspx?scid=kb;en-us;310294#XSLTH3194121123120121120120>`_.\n    Makes use of the\n    `appname <platformdirs.api.PlatformDirsABC.appname>`,\n    `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`,\n    `version <platformdirs.api.PlatformDirsABC.version>`,\n    `roaming <platformdirs.api.PlatformDirsABC.roaming>`,\n    `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory tied to the user, e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\$appauthor\\\\$appname`` (not roaming) or\n         ``%USERPROFILE%\\\\AppData\\\\Roaming\\\\$appauthor\\\\$appname`` (roaming)\n        \"\"\"\n        const = \"CSIDL_APPDATA\" if self.roaming else \"CSIDL_LOCAL_APPDATA\"\n        path = os.path.normpath(get_win_folder(const))\n        return self._append_parts(path)\n\n    def _append_parts(self, path: str, *, opinion_value: str | None = None) -> str:\n        params = []\n        if self.appname:\n            if self.appauthor is not False:\n                author = self.appauthor or self.appname\n                params.append(author)\n            params.append(self.appname)\n            if opinion_value is not None and self.opinion:\n                params.append(opinion_value)\n            if self.version:\n                params.append(self.version)\n        return os.path.join(path, *params)\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users, e.g. ``C:\\\\ProgramData\\\\$appauthor\\\\$appname``\"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_COMMON_APPDATA\"))\n        return self._append_parts(path)\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `site_data_dir`\"\"\"\n        return self.site_data_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory tied to the user (if opinionated with ``Cache`` folder within ``$appname``) e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\$appauthor\\\\$appname\\\\Cache\\\\$version``\n        \"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_LOCAL_APPDATA\"))\n        return self._append_parts(path, opinion_value=\"Cache\")\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\"\n        :return: log directory tied to the user, same as `user_data_dir` if not opinionated else ``Logs`` in it\n        \"\"\"\n        path = self.user_data_dir\n        if self.opinion:\n            path = os.path.join(path, \"Logs\")\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\"\n        :return: documents directory tied to the user e.g. ``%USERPROFILE%\\\\Documents``\n        \"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_PERSONAL\"))\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\Temp\\\\$appauthor\\\\$appname``\n        \"\"\"\n        path = os.path.normpath(os.path.join(get_win_folder(\"CSIDL_LOCAL_APPDATA\"), \"Temp\"))\n        return self._append_parts(path)\n\n\ndef get_win_folder_from_env_vars(csidl_name: str) -> str:\n    \"\"\"Get folder from environment variables.\"\"\"\n    if csidl_name == \"CSIDL_PERSONAL\":  # does not have an environment name\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Documents\")\n\n    env_var_name = {\n        \"CSIDL_APPDATA\": \"APPDATA\",\n        \"CSIDL_COMMON_APPDATA\": \"ALLUSERSPROFILE\",\n        \"CSIDL_LOCAL_APPDATA\": \"LOCALAPPDATA\",\n    }.get(csidl_name)\n    if env_var_name is None:\n        raise ValueError(f\"Unknown CSIDL name: {csidl_name}\")\n    result = os.environ.get(env_var_name)\n    if result is None:\n        raise ValueError(f\"Unset environment variable: {env_var_name}\")\n    return result\n\n\ndef get_win_folder_from_registry(csidl_name: str) -> str:\n    \"\"\"Get folder from the registry.\n\n    This is a fallback technique at best. I'm not sure if using the\n    registry for this guarantees us the correct answer for all CSIDL_*\n    names.\n    \"\"\"\n    shell_folder_name = {\n        \"CSIDL_APPDATA\": \"AppData\",\n        \"CSIDL_COMMON_APPDATA\": \"Common AppData\",\n        \"CSIDL_LOCAL_APPDATA\": \"Local AppData\",\n        \"CSIDL_PERSONAL\": \"Personal\",\n    }.get(csidl_name)\n    if shell_folder_name is None:\n        raise ValueError(f\"Unknown CSIDL name: {csidl_name}\")\n    if sys.platform != \"win32\":  # only needed for mypy type checker to know that this code runs only on Windows\n        raise NotImplementedError\n    import winreg\n\n    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r\"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\")\n    directory, _ = winreg.QueryValueEx(key, shell_folder_name)\n    return str(directory)\n\n\ndef get_win_folder_via_ctypes(csidl_name: str) -> str:\n    \"\"\"Get folder with ctypes.\"\"\"\n    csidl_const = {\n        \"CSIDL_APPDATA\": 26,\n        \"CSIDL_COMMON_APPDATA\": 35,\n        \"CSIDL_LOCAL_APPDATA\": 28,\n        \"CSIDL_PERSONAL\": 5,\n    }.get(csidl_name)\n    if csidl_const is None:\n        raise ValueError(f\"Unknown CSIDL name: {csidl_name}\")\n\n    buf = ctypes.create_unicode_buffer(1024)\n    windll = getattr(ctypes, \"windll\")  # noqa: B009 # using getattr to avoid false positive with mypy type checker\n    windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)\n\n    # Downgrade to short path name if it has highbit chars.\n    if any(ord(c) > 255 for c in buf):\n        buf2 = ctypes.create_unicode_buffer(1024)\n        if windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):\n            buf = buf2\n\n    return buf.value\n\n\ndef _pick_get_win_folder() -> Callable[[str], str]:\n    if hasattr(ctypes, \"windll\"):\n        return get_win_folder_via_ctypes\n    try:\n        import winreg  # noqa: F401\n    except ImportError:\n        return get_win_folder_from_env_vars\n    else:\n        return get_win_folder_from_registry\n\n\nget_win_folder = lru_cache(maxsize=None)(_pick_get_win_folder())\n\n__all__ = [\n    \"Windows\",\n]\n", "pkg_resources/_vendor/platformdirs/macos.py": "from __future__ import annotations\n\nimport os\n\nfrom .api import PlatformDirsABC\n\n\nclass MacOS(PlatformDirsABC):\n    \"\"\"\n    Platform directories for the macOS operating system. Follows the guidance from `Apple documentation\n    <https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/MacOSXDirectories/MacOSXDirectories.html>`_.\n    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>` and\n    `version <platformdirs.api.PlatformDirsABC.version>`.\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user, e.g. ``~/Library/Application Support/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Application Support/\"))\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users, e.g. ``/Library/Application Support/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(\"/Library/Application Support\")\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user, e.g. ``~/Library/Preferences/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Preferences/\"))\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, e.g. ``/Library/Preferences/$appname``\"\"\"\n        return self._append_app_name_and_version(\"/Library/Preferences\")\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user, e.g. ``~/Library/Caches/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Caches\"))\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user, e.g. ``~/Library/Logs/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Logs\"))\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user, e.g. ``~/Documents``\"\"\"\n        return os.path.expanduser(\"~/Documents\")\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory tied to the user, e.g. ``~/Library/Caches/TemporaryItems/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Caches/TemporaryItems\"))\n\n\n__all__ = [\n    \"MacOS\",\n]\n", "pkg_resources/_vendor/platformdirs/api.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\n\nif sys.version_info >= (3, 8):  # pragma: no branch\n    from typing import Literal  # pragma: no cover\n\n\nclass PlatformDirsABC(ABC):\n    \"\"\"\n    Abstract base class for platform directories.\n    \"\"\"\n\n    def __init__(\n        self,\n        appname: str | None = None,\n        appauthor: str | None | Literal[False] = None,\n        version: str | None = None,\n        roaming: bool = False,\n        multipath: bool = False,\n        opinion: bool = True,\n    ):\n        \"\"\"\n        Create a new platform directory.\n\n        :param appname: See `appname`.\n        :param appauthor: See `appauthor`.\n        :param version: See `version`.\n        :param roaming: See `roaming`.\n        :param multipath: See `multipath`.\n        :param opinion: See `opinion`.\n        \"\"\"\n        self.appname = appname  #: The name of application.\n        self.appauthor = appauthor\n        \"\"\"\n        The name of the app author or distributing body for this application. Typically, it is the owning company name.\n        Defaults to `appname`. You may pass ``False`` to disable it.\n        \"\"\"\n        self.version = version\n        \"\"\"\n        An optional version path element to append to the path. You might want to use this if you want multiple versions\n        of your app to be able to run independently. If used, this would typically be ``<major>.<minor>``.\n        \"\"\"\n        self.roaming = roaming\n        \"\"\"\n        Whether to use the roaming appdata directory on Windows. That means that for users on a Windows network setup\n        for roaming profiles, this user data will be synced on login (see\n        `here <http://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx>`_).\n        \"\"\"\n        self.multipath = multipath\n        \"\"\"\n        An optional parameter only applicable to Unix/Linux which indicates that the entire list of data dirs should be\n        returned. By default, the first item would only be returned.\n        \"\"\"\n        self.opinion = opinion  #: A flag to indicating to use opinionated values.\n\n    def _append_app_name_and_version(self, *base: str) -> str:\n        params = list(base[1:])\n        if self.appname:\n            params.append(self.appname)\n            if self.version:\n                params.append(self.version)\n        return os.path.join(base[0], *params)\n\n    @property\n    @abstractmethod\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users\"\"\"\n\n    @property\n    @abstractmethod\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users\"\"\"\n\n    @property\n    @abstractmethod\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory tied to the user\"\"\"\n\n    @property\n    def user_data_path(self) -> Path:\n        \"\"\":return: data path tied to the user\"\"\"\n        return Path(self.user_data_dir)\n\n    @property\n    def site_data_path(self) -> Path:\n        \"\"\":return: data path shared by users\"\"\"\n        return Path(self.site_data_dir)\n\n    @property\n    def user_config_path(self) -> Path:\n        \"\"\":return: config path tied to the user\"\"\"\n        return Path(self.user_config_dir)\n\n    @property\n    def site_config_path(self) -> Path:\n        \"\"\":return: config path shared by the users\"\"\"\n        return Path(self.site_config_dir)\n\n    @property\n    def user_cache_path(self) -> Path:\n        \"\"\":return: cache path tied to the user\"\"\"\n        return Path(self.user_cache_dir)\n\n    @property\n    def user_state_path(self) -> Path:\n        \"\"\":return: state path tied to the user\"\"\"\n        return Path(self.user_state_dir)\n\n    @property\n    def user_log_path(self) -> Path:\n        \"\"\":return: log path tied to the user\"\"\"\n        return Path(self.user_log_dir)\n\n    @property\n    def user_documents_path(self) -> Path:\n        \"\"\":return: documents path tied to the user\"\"\"\n        return Path(self.user_documents_dir)\n\n    @property\n    def user_runtime_path(self) -> Path:\n        \"\"\":return: runtime path tied to the user\"\"\"\n        return Path(self.user_runtime_dir)\n", "pkg_resources/_vendor/platformdirs/unix.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom configparser import ConfigParser\nfrom pathlib import Path\n\nfrom .api import PlatformDirsABC\n\nif sys.platform.startswith(\"linux\"):  # pragma: no branch # no op check, only to please the type checker\n    from os import getuid\nelse:\n\n    def getuid() -> int:\n        raise RuntimeError(\"should only be used on Linux\")\n\n\nclass Unix(PlatformDirsABC):\n    \"\"\"\n    On Unix/Linux, we follow the\n    `XDG Basedir Spec <https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html>`_. The spec allows\n    overriding directories with environment variables. The examples show are the default values, alongside the name of\n    the environment variable that overrides them. Makes use of the\n    `appname <platformdirs.api.PlatformDirsABC.appname>`,\n    `version <platformdirs.api.PlatformDirsABC.version>`,\n    `multipath <platformdirs.api.PlatformDirsABC.multipath>`,\n    `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory tied to the user, e.g. ``~/.local/share/$appname/$version`` or\n         ``$XDG_DATA_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_DATA_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.local/share\")\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\"\n        :return: data directories shared by users (if `multipath <platformdirs.api.PlatformDirsABC.multipath>` is\n         enabled and ``XDG_DATA_DIR`` is set and a multi path the response is also a multi path separated by the OS\n         path separator), e.g. ``/usr/local/share/$appname/$version`` or ``/usr/share/$appname/$version``\n        \"\"\"\n        # XDG default for $XDG_DATA_DIRS; only first, if multipath is False\n        path = os.environ.get(\"XDG_DATA_DIRS\", \"\")\n        if not path.strip():\n            path = f\"/usr/local/share{os.pathsep}/usr/share\"\n        return self._with_multi_path(path)\n\n    def _with_multi_path(self, path: str) -> str:\n        path_list = path.split(os.pathsep)\n        if not self.multipath:\n            path_list = path_list[0:1]\n        path_list = [self._append_app_name_and_version(os.path.expanduser(p)) for p in path_list]\n        return os.pathsep.join(path_list)\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\"\n        :return: config directory tied to the user, e.g. ``~/.config/$appname/$version`` or\n         ``$XDG_CONFIG_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_CONFIG_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.config\")\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\"\n        :return: config directories shared by users (if `multipath <platformdirs.api.PlatformDirsABC.multipath>`\n         is enabled and ``XDG_DATA_DIR`` is set and a multi path the response is also a multi path separated by the OS\n         path separator), e.g. ``/etc/xdg/$appname/$version``\n        \"\"\"\n        # XDG default for $XDG_CONFIG_DIRS only first, if multipath is False\n        path = os.environ.get(\"XDG_CONFIG_DIRS\", \"\")\n        if not path.strip():\n            path = \"/etc/xdg\"\n        return self._with_multi_path(path)\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory tied to the user, e.g. ``~/.cache/$appname/$version`` or\n         ``~/$XDG_CACHE_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_CACHE_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.cache\")\n        return self._append_app_name_and_version(path)\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\"\n        :return: state directory tied to the user, e.g. ``~/.local/state/$appname/$version`` or\n         ``$XDG_STATE_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_STATE_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.local/state\")\n        return self._append_app_name_and_version(path)\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\"\n        :return: log directory tied to the user, same as `user_state_dir` if not opinionated else ``log`` in it\n        \"\"\"\n        path = self.user_state_dir\n        if self.opinion:\n            path = os.path.join(path, \"log\")\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\"\n        :return: documents directory tied to the user, e.g. ``~/Documents``\n        \"\"\"\n        documents_dir = _get_user_dirs_folder(\"XDG_DOCUMENTS_DIR\")\n        if documents_dir is None:\n            documents_dir = os.environ.get(\"XDG_DOCUMENTS_DIR\", \"\").strip()\n            if not documents_dir:\n                documents_dir = os.path.expanduser(\"~/Documents\")\n\n        return documents_dir\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, e.g. ``/run/user/$(id -u)/$appname/$version`` or\n         ``$XDG_RUNTIME_DIR/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_RUNTIME_DIR\", \"\")\n        if not path.strip():\n            path = f\"/run/user/{getuid()}\"\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_data_path(self) -> Path:\n        \"\"\":return: data path shared by users. Only return first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_data_dir)\n\n    @property\n    def site_config_path(self) -> Path:\n        \"\"\":return: config path shared by the users. Only return first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_config_dir)\n\n    def _first_item_as_path_if_multipath(self, directory: str) -> Path:\n        if self.multipath:\n            # If multipath is True, the first path is returned.\n            directory = directory.split(os.pathsep)[0]\n        return Path(directory)\n\n\ndef _get_user_dirs_folder(key: str) -> str | None:\n    \"\"\"Return directory from user-dirs.dirs config file. See https://freedesktop.org/wiki/Software/xdg-user-dirs/\"\"\"\n    user_dirs_config_path = os.path.join(Unix().user_config_dir, \"user-dirs.dirs\")\n    if os.path.exists(user_dirs_config_path):\n        parser = ConfigParser()\n\n        with open(user_dirs_config_path) as stream:\n            # Add fake section header, so ConfigParser doesn't complain\n            parser.read_string(f\"[top]\\n{stream.read()}\")\n\n        if key not in parser[\"top\"]:\n            return None\n\n        path = parser[\"top\"][key].strip('\"')\n        # Handle relative home paths\n        path = path.replace(\"$HOME\", os.path.expanduser(\"~\"))\n        return path\n\n    return None\n\n\n__all__ = [\n    \"Unix\",\n]\n", "pkg_resources/_vendor/platformdirs/version.py": "# file generated by setuptools_scm\n# don't change, don't track in version control\n__version__ = version = '2.6.2'\n__version_tuple__ = version_tuple = (2, 6, 2)\n", "pkg_resources/_vendor/platformdirs/__main__.py": "from __future__ import annotations\n\nfrom platformdirs import PlatformDirs, __version__\n\nPROPS = (\n    \"user_data_dir\",\n    \"user_config_dir\",\n    \"user_cache_dir\",\n    \"user_state_dir\",\n    \"user_log_dir\",\n    \"user_documents_dir\",\n    \"user_runtime_dir\",\n    \"site_data_dir\",\n    \"site_config_dir\",\n)\n\n\ndef main() -> None:\n    app_name = \"MyApp\"\n    app_author = \"MyCompany\"\n\n    print(f\"-- platformdirs {__version__} --\")\n\n    print(\"-- app dirs (with optional 'version')\")\n    dirs = PlatformDirs(app_name, app_author, version=\"1.0\")\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")\n\n    print(\"\\n-- app dirs (without optional 'version')\")\n    dirs = PlatformDirs(app_name, app_author)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")\n\n    print(\"\\n-- app dirs (without optional 'appauthor')\")\n    dirs = PlatformDirs(app_name)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")\n\n    print(\"\\n-- app dirs (with disabled 'appauthor')\")\n    dirs = PlatformDirs(app_name, appauthor=False)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "pkg_resources/_vendor/platformdirs/__init__.py": "\"\"\"\nUtilities for determining application-specific dirs. See <https://github.com/platformdirs/platformdirs> for details and\nusage.\n\"\"\"\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom pathlib import Path\n\nif sys.version_info >= (3, 8):  # pragma: no cover (py38+)\n    from typing import Literal\nelse:  # pragma: no cover (py38+)\n    from ..typing_extensions import Literal\n\nfrom .api import PlatformDirsABC\nfrom .version import __version__\nfrom .version import __version_tuple__ as __version_info__\n\n\ndef _set_platform_dir_class() -> type[PlatformDirsABC]:\n    if sys.platform == \"win32\":\n        from .windows import Windows as Result\n    elif sys.platform == \"darwin\":\n        from .macos import MacOS as Result\n    else:\n        from .unix import Unix as Result\n\n    if os.getenv(\"ANDROID_DATA\") == \"/data\" and os.getenv(\"ANDROID_ROOT\") == \"/system\":\n\n        if os.getenv(\"SHELL\") or os.getenv(\"PREFIX\"):\n            return Result\n\n        from .android import _android_folder\n\n        if _android_folder() is not None:\n            from .android import Android\n\n            return Android  # return to avoid redefinition of result\n\n    return Result\n\n\nPlatformDirs = _set_platform_dir_class()  #: Currently active platform\nAppDirs = PlatformDirs  #: Backwards compatibility with appdirs\n\n\ndef user_data_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.version>`.\n    :returns: data directory tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, roaming=roaming).user_data_dir\n\n\ndef site_data_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :returns: data directory shared by users\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, multipath=multipath).site_data_dir\n\n\ndef user_config_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.version>`.\n    :returns: config directory tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, roaming=roaming).user_config_dir\n\n\ndef site_config_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :returns: config directory shared by the users\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, multipath=multipath).site_config_dir\n\n\ndef user_cache_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :returns: cache directory tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, opinion=opinion).user_cache_dir\n\n\ndef user_state_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.version>`.\n    :returns: state directory tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, roaming=roaming).user_state_dir\n\n\ndef user_log_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :returns: log directory tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, opinion=opinion).user_log_dir\n\n\ndef user_documents_dir() -> str:\n    \"\"\"\n    :returns: documents directory tied to the user\n    \"\"\"\n    return PlatformDirs().user_documents_dir\n\n\ndef user_runtime_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :returns: runtime directory tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, opinion=opinion).user_runtime_dir\n\n\ndef user_data_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.version>`.\n    :returns: data path tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, roaming=roaming).user_data_path\n\n\ndef site_data_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `multipath <platformdirs.api.PlatformDirsABC.multipath>`.\n    :returns: data path shared by users\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, multipath=multipath).site_data_path\n\n\ndef user_config_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.version>`.\n    :returns: config path tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, roaming=roaming).user_config_path\n\n\ndef site_config_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :returns: config path shared by the users\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, multipath=multipath).site_config_path\n\n\ndef user_cache_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :returns: cache path tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, opinion=opinion).user_cache_path\n\n\ndef user_state_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.version>`.\n    :returns: state path tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, roaming=roaming).user_state_path\n\n\ndef user_log_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :returns: log path tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, opinion=opinion).user_log_path\n\n\ndef user_documents_path() -> Path:\n    \"\"\"\n    :returns: documents path tied to the user\n    \"\"\"\n    return PlatformDirs().user_documents_path\n\n\ndef user_runtime_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :returns: runtime path tied to the user\n    \"\"\"\n    return PlatformDirs(appname=appname, appauthor=appauthor, version=version, opinion=opinion).user_runtime_path\n\n\n__all__ = [\n    \"__version__\",\n    \"__version_info__\",\n    \"PlatformDirs\",\n    \"AppDirs\",\n    \"PlatformDirsABC\",\n    \"user_data_dir\",\n    \"user_config_dir\",\n    \"user_cache_dir\",\n    \"user_state_dir\",\n    \"user_log_dir\",\n    \"user_documents_dir\",\n    \"user_runtime_dir\",\n    \"site_data_dir\",\n    \"site_config_dir\",\n    \"user_data_path\",\n    \"user_config_path\",\n    \"user_cache_path\",\n    \"user_state_path\",\n    \"user_log_path\",\n    \"user_documents_path\",\n    \"user_runtime_path\",\n    \"site_data_path\",\n    \"site_config_path\",\n]\n", "pkg_resources/_vendor/platformdirs/android.py": "from __future__ import annotations\n\nimport os\nimport re\nimport sys\nfrom functools import lru_cache\nfrom typing import cast\n\nfrom .api import PlatformDirsABC\n\n\nclass Android(PlatformDirsABC):\n    \"\"\"\n    Follows the guidance `from here <https://android.stackexchange.com/a/216132>`_. Makes use of the\n    `appname <platformdirs.api.PlatformDirsABC.appname>` and\n    `version <platformdirs.api.PlatformDirsABC.version>`.\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user, e.g. ``/data/user/<userid>/<packagename>/files/<AppName>``\"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"files\")\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\"\n        :return: config directory tied to the user, e.g. ``/data/user/<userid>/<packagename>/shared_prefs/<AppName>``\n        \"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"shared_prefs\")\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `user_config_dir`\"\"\"\n        return self.user_config_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user, e.g. e.g. ``/data/user/<userid>/<packagename>/cache/<AppName>``\"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"cache\")\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\"\n        :return: log directory tied to the user, same as `user_cache_dir` if not opinionated else ``log`` in it,\n          e.g. ``/data/user/<userid>/<packagename>/cache/<AppName>/log``\n        \"\"\"\n        path = self.user_cache_dir\n        if self.opinion:\n            path = os.path.join(path, \"log\")\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\"\n        :return: documents directory tied to the user e.g. ``/storage/emulated/0/Documents``\n        \"\"\"\n        return _android_documents_folder()\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, same as `user_cache_dir` if not opinionated else ``tmp`` in it,\n          e.g. ``/data/user/<userid>/<packagename>/cache/<AppName>/tmp``\n        \"\"\"\n        path = self.user_cache_dir\n        if self.opinion:\n            path = os.path.join(path, \"tmp\")\n        return path\n\n\n@lru_cache(maxsize=1)\ndef _android_folder() -> str | None:\n    \"\"\":return: base folder for the Android OS or None if cannot be found\"\"\"\n    try:\n        # First try to get path to android app via pyjnius\n        from jnius import autoclass\n\n        Context = autoclass(\"android.content.Context\")  # noqa: N806\n        result: str | None = Context.getFilesDir().getParentFile().getAbsolutePath()\n    except Exception:\n        # if fails find an android folder looking path on the sys.path\n        pattern = re.compile(r\"/data/(data|user/\\d+)/(.+)/files\")\n        for path in sys.path:\n            if pattern.match(path):\n                result = path.split(\"/files\")[0]\n                break\n        else:\n            result = None\n    return result\n\n\n@lru_cache(maxsize=1)\ndef _android_documents_folder() -> str:\n    \"\"\":return: documents folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass\n\n        Context = autoclass(\"android.content.Context\")  # noqa: N806\n        Environment = autoclass(\"android.os.Environment\")  # noqa: N806\n        documents_dir: str = Context.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS).getAbsolutePath()\n    except Exception:\n        documents_dir = \"/storage/emulated/0/Documents\"\n\n    return documents_dir\n\n\n__all__ = [\n    \"Android\",\n]\n", "pkg_resources/_vendor/packaging/tags.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport logging\nimport platform\nimport re\nimport struct\nimport subprocess\nimport sys\nimport sysconfig\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom typing import (\n    Dict,\n    FrozenSet,\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    Sequence,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom . import _manylinux, _musllinux\n\nlogger = logging.getLogger(__name__)\n\nPythonVersion = Sequence[int]\nMacVersion = Tuple[int, int]\n\nINTERPRETER_SHORT_NAMES: Dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}\n\n\n_32_BIT_INTERPRETER = struct.calcsize(\"P\") == 4\n\n\nclass Tag:\n    \"\"\"\n    A representation of the tag triple for a wheel.\n\n    Instances are considered immutable and thus are hashable. Equality checking\n    is also supported.\n    \"\"\"\n\n    __slots__ = [\"_interpreter\", \"_abi\", \"_platform\", \"_hash\"]\n\n    def __init__(self, interpreter: str, abi: str, platform: str) -> None:\n        self._interpreter = interpreter.lower()\n        self._abi = abi.lower()\n        self._platform = platform.lower()\n        # The __hash__ of every single element in a Set[Tag] will be evaluated each time\n        # that a set calls its `.disjoint()` method, which may be called hundreds of\n        # times when scanning a page of links for packages with tags matching that\n        # Set[Tag]. Pre-computing the value here produces significant speedups for\n        # downstream consumers.\n        self._hash = hash((self._interpreter, self._abi, self._platform))\n\n    @property\n    def interpreter(self) -> str:\n        return self._interpreter\n\n    @property\n    def abi(self) -> str:\n        return self._abi\n\n    @property\n    def platform(self) -> str:\n        return self._platform\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Tag):\n            return NotImplemented\n\n        return (\n            (self._hash == other._hash)  # Short-circuit ASAP for perf reasons.\n            and (self._platform == other._platform)\n            and (self._abi == other._abi)\n            and (self._interpreter == other._interpreter)\n        )\n\n    def __hash__(self) -> int:\n        return self._hash\n\n    def __str__(self) -> str:\n        return f\"{self._interpreter}-{self._abi}-{self._platform}\"\n\n    def __repr__(self) -> str:\n        return f\"<{self} @ {id(self)}>\"\n\n\ndef parse_tag(tag: str) -> FrozenSet[Tag]:\n    \"\"\"\n    Parses the provided tag (e.g. `py3-none-any`) into a frozenset of Tag instances.\n\n    Returning a set is required due to the possibility that the tag is a\n    compressed tag set.\n    \"\"\"\n    tags = set()\n    interpreters, abis, platforms = tag.split(\"-\")\n    for interpreter in interpreters.split(\".\"):\n        for abi in abis.split(\".\"):\n            for platform_ in platforms.split(\".\"):\n                tags.add(Tag(interpreter, abi, platform_))\n    return frozenset(tags)\n\n\ndef _get_config_var(name: str, warn: bool = False) -> Union[int, str, None]:\n    value: Union[int, str, None] = sysconfig.get_config_var(name)\n    if value is None and warn:\n        logger.debug(\n            \"Config variable '%s' is unset, Python ABI tag may be incorrect\", name\n        )\n    return value\n\n\ndef _normalize_string(string: str) -> str:\n    return string.replace(\".\", \"_\").replace(\"-\", \"_\").replace(\" \", \"_\")\n\n\ndef _is_threaded_cpython(abis: List[str]) -> bool:\n    \"\"\"\n    Determine if the ABI corresponds to a threaded (`--disable-gil`) build.\n\n    The threaded builds are indicated by a \"t\" in the abiflags.\n    \"\"\"\n    if len(abis) == 0:\n        return False\n    # expect e.g., cp313\n    m = re.match(r\"cp\\d+(.*)\", abis[0])\n    if not m:\n        return False\n    abiflags = m.group(1)\n    return \"t\" in abiflags\n\n\ndef _abi3_applies(python_version: PythonVersion, threading: bool) -> bool:\n    \"\"\"\n    Determine if the Python version supports abi3.\n\n    PEP 384 was first implemented in Python 3.2. The threaded (`--disable-gil`)\n    builds do not support abi3.\n    \"\"\"\n    return len(python_version) > 1 and tuple(python_version) >= (3, 2) and not threading\n\n\ndef _cpython_abis(py_version: PythonVersion, warn: bool = False) -> List[str]:\n    py_version = tuple(py_version)  # To allow for version comparison.\n    abis = []\n    version = _version_nodot(py_version[:2])\n    threading = debug = pymalloc = ucs4 = \"\"\n    with_debug = _get_config_var(\"Py_DEBUG\", warn)\n    has_refcount = hasattr(sys, \"gettotalrefcount\")\n    # Windows doesn't set Py_DEBUG, so checking for support of debug-compiled\n    # extension modules is the best option.\n    # https://github.com/pypa/pip/issues/3383#issuecomment-173267692\n    has_ext = \"_d.pyd\" in EXTENSION_SUFFIXES\n    if with_debug or (with_debug is None and (has_refcount or has_ext)):\n        debug = \"d\"\n    if py_version >= (3, 13) and _get_config_var(\"Py_GIL_DISABLED\", warn):\n        threading = \"t\"\n    if py_version < (3, 8):\n        with_pymalloc = _get_config_var(\"WITH_PYMALLOC\", warn)\n        if with_pymalloc or with_pymalloc is None:\n            pymalloc = \"m\"\n        if py_version < (3, 3):\n            unicode_size = _get_config_var(\"Py_UNICODE_SIZE\", warn)\n            if unicode_size == 4 or (\n                unicode_size is None and sys.maxunicode == 0x10FFFF\n            ):\n                ucs4 = \"u\"\n    elif debug:\n        # Debug builds can also load \"normal\" extension modules.\n        # We can also assume no UCS-4 or pymalloc requirement.\n        abis.append(f\"cp{version}{threading}\")\n    abis.insert(0, f\"cp{version}{threading}{debug}{pymalloc}{ucs4}\")\n    return abis\n\n\ndef cpython_tags(\n    python_version: Optional[PythonVersion] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a CPython interpreter.\n\n    The tags consist of:\n    - cp<python_version>-<abi>-<platform>\n    - cp<python_version>-abi3-<platform>\n    - cp<python_version>-none-<platform>\n    - cp<less than python_version>-abi3-<platform>  # Older Python versions down to 3.2.\n\n    If python_version only specifies a major version then user-provided ABIs and\n    the 'none' ABItag will be used.\n\n    If 'abi3' or 'none' are specified in 'abis' then they will be yielded at\n    their normal position and not at the beginning.\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n\n    interpreter = f\"cp{_version_nodot(python_version[:2])}\"\n\n    if abis is None:\n        if len(python_version) > 1:\n            abis = _cpython_abis(python_version, warn)\n        else:\n            abis = []\n    abis = list(abis)\n    # 'abi3' and 'none' are explicitly handled later.\n    for explicit_abi in (\"abi3\", \"none\"):\n        try:\n            abis.remove(explicit_abi)\n        except ValueError:\n            pass\n\n    platforms = list(platforms or platform_tags())\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n    threading = _is_threaded_cpython(abis)\n    use_abi3 = _abi3_applies(python_version, threading)\n    if use_abi3:\n        yield from (Tag(interpreter, \"abi3\", platform_) for platform_ in platforms)\n    yield from (Tag(interpreter, \"none\", platform_) for platform_ in platforms)\n\n    if use_abi3:\n        for minor_version in range(python_version[1] - 1, 1, -1):\n            for platform_ in platforms:\n                interpreter = \"cp{version}\".format(\n                    version=_version_nodot((python_version[0], minor_version))\n                )\n                yield Tag(interpreter, \"abi3\", platform_)\n\n\ndef _generic_abi() -> List[str]:\n    \"\"\"\n    Return the ABI tag based on EXT_SUFFIX.\n    \"\"\"\n    # The following are examples of `EXT_SUFFIX`.\n    # We want to keep the parts which are related to the ABI and remove the\n    # parts which are related to the platform:\n    # - linux:   '.cpython-310-x86_64-linux-gnu.so' => cp310\n    # - mac:     '.cpython-310-darwin.so'           => cp310\n    # - win:     '.cp310-win_amd64.pyd'             => cp310\n    # - win:     '.pyd'                             => cp37 (uses _cpython_abis())\n    # - pypy:    '.pypy38-pp73-x86_64-linux-gnu.so' => pypy38_pp73\n    # - graalpy: '.graalpy-38-native-x86_64-darwin.dylib'\n    #                                               => graalpy_38_native\n\n    ext_suffix = _get_config_var(\"EXT_SUFFIX\", warn=True)\n    if not isinstance(ext_suffix, str) or ext_suffix[0] != \".\":\n        raise SystemError(\"invalid sysconfig.get_config_var('EXT_SUFFIX')\")\n    parts = ext_suffix.split(\".\")\n    if len(parts) < 3:\n        # CPython3.7 and earlier uses \".pyd\" on Windows.\n        return _cpython_abis(sys.version_info[:2])\n    soabi = parts[1]\n    if soabi.startswith(\"cpython\"):\n        # non-windows\n        abi = \"cp\" + soabi.split(\"-\")[1]\n    elif soabi.startswith(\"cp\"):\n        # windows\n        abi = soabi.split(\"-\")[0]\n    elif soabi.startswith(\"pypy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:2])\n    elif soabi.startswith(\"graalpy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:3])\n    elif soabi:\n        # pyston, ironpython, others?\n        abi = soabi\n    else:\n        return []\n    return [_normalize_string(abi)]\n\n\ndef generic_tags(\n    interpreter: Optional[str] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a generic interpreter.\n\n    The tags consist of:\n    - <interpreter>-<abi>-<platform>\n\n    The \"none\" ABI will be added if it was not explicitly provided.\n    \"\"\"\n    if not interpreter:\n        interp_name = interpreter_name()\n        interp_version = interpreter_version(warn=warn)\n        interpreter = \"\".join([interp_name, interp_version])\n    if abis is None:\n        abis = _generic_abi()\n    else:\n        abis = list(abis)\n    platforms = list(platforms or platform_tags())\n    if \"none\" not in abis:\n        abis.append(\"none\")\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n\ndef _py_interpreter_range(py_version: PythonVersion) -> Iterator[str]:\n    \"\"\"\n    Yields Python versions in descending order.\n\n    After the latest version, the major-only version will be yielded, and then\n    all previous versions of that major version.\n    \"\"\"\n    if len(py_version) > 1:\n        yield f\"py{_version_nodot(py_version[:2])}\"\n    yield f\"py{py_version[0]}\"\n    if len(py_version) > 1:\n        for minor in range(py_version[1] - 1, -1, -1):\n            yield f\"py{_version_nodot((py_version[0], minor))}\"\n\n\ndef compatible_tags(\n    python_version: Optional[PythonVersion] = None,\n    interpreter: Optional[str] = None,\n    platforms: Optional[Iterable[str]] = None,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the sequence of tags that are compatible with a specific version of Python.\n\n    The tags consist of:\n    - py*-none-<platform>\n    - <interpreter>-none-any  # ... if `interpreter` is provided.\n    - py*-none-any\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n    platforms = list(platforms or platform_tags())\n    for version in _py_interpreter_range(python_version):\n        for platform_ in platforms:\n            yield Tag(version, \"none\", platform_)\n    if interpreter:\n        yield Tag(interpreter, \"none\", \"any\")\n    for version in _py_interpreter_range(python_version):\n        yield Tag(version, \"none\", \"any\")\n\n\ndef _mac_arch(arch: str, is_32bit: bool = _32_BIT_INTERPRETER) -> str:\n    if not is_32bit:\n        return arch\n\n    if arch.startswith(\"ppc\"):\n        return \"ppc\"\n\n    return \"i386\"\n\n\ndef _mac_binary_formats(version: MacVersion, cpu_arch: str) -> List[str]:\n    formats = [cpu_arch]\n    if cpu_arch == \"x86_64\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat64\", \"fat32\"])\n\n    elif cpu_arch == \"i386\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat32\", \"fat\"])\n\n    elif cpu_arch == \"ppc64\":\n        # TODO: Need to care about 32-bit PPC for ppc64 through 10.2?\n        if version > (10, 5) or version < (10, 4):\n            return []\n        formats.append(\"fat64\")\n\n    elif cpu_arch == \"ppc\":\n        if version > (10, 6):\n            return []\n        formats.extend([\"fat32\", \"fat\"])\n\n    if cpu_arch in {\"arm64\", \"x86_64\"}:\n        formats.append(\"universal2\")\n\n    if cpu_arch in {\"x86_64\", \"i386\", \"ppc64\", \"ppc\", \"intel\"}:\n        formats.append(\"universal\")\n\n    return formats\n\n\ndef mac_platforms(\n    version: Optional[MacVersion] = None, arch: Optional[str] = None\n) -> Iterator[str]:\n    \"\"\"\n    Yields the platform tags for a macOS system.\n\n    The `version` parameter is a two-item tuple specifying the macOS version to\n    generate platform tags for. The `arch` parameter is the CPU architecture to\n    generate platform tags for. Both parameters default to the appropriate value\n    for the current system.\n    \"\"\"\n    version_str, _, cpu_arch = platform.mac_ver()\n    if version is None:\n        version = cast(\"MacVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n        if version == (10, 16):\n            # When built against an older macOS SDK, Python will report macOS 10.16\n            # instead of the real version.\n            version_str = subprocess.run(\n                [\n                    sys.executable,\n                    \"-sS\",\n                    \"-c\",\n                    \"import platform; print(platform.mac_ver()[0])\",\n                ],\n                check=True,\n                env={\"SYSTEM_VERSION_COMPAT\": \"0\"},\n                stdout=subprocess.PIPE,\n                text=True,\n            ).stdout\n            version = cast(\"MacVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n    else:\n        version = version\n    if arch is None:\n        arch = _mac_arch(cpu_arch)\n    else:\n        arch = arch\n\n    if (10, 0) <= version and version < (11, 0):\n        # Prior to Mac OS 11, each yearly release of Mac OS bumped the\n        # \"minor\" version number.  The major version was always 10.\n        for minor_version in range(version[1], -1, -1):\n            compat_version = 10, minor_version\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=10, minor=minor_version, binary_format=binary_format\n                )\n\n    if version >= (11, 0):\n        # Starting with Mac OS 11, each yearly release bumps the major version\n        # number.   The minor versions are now the midyear updates.\n        for major_version in range(version[0], 10, -1):\n            compat_version = major_version, 0\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=major_version, minor=0, binary_format=binary_format\n                )\n\n    if version >= (11, 0):\n        # Mac OS 11 on x86_64 is compatible with binaries from previous releases.\n        # Arm64 support was introduced in 11.0, so no Arm binaries from previous\n        # releases exist.\n        #\n        # However, the \"universal2\" binary format can have a\n        # macOS version earlier than 11.0 when the x86_64 part of the binary supports\n        # that version of macOS.\n        if arch == \"x86_64\":\n            for minor_version in range(16, 3, -1):\n                compat_version = 10, minor_version\n                binary_formats = _mac_binary_formats(compat_version, arch)\n                for binary_format in binary_formats:\n                    yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                        major=compat_version[0],\n                        minor=compat_version[1],\n                        binary_format=binary_format,\n                    )\n        else:\n            for minor_version in range(16, 3, -1):\n                compat_version = 10, minor_version\n                binary_format = \"universal2\"\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=compat_version[0],\n                    minor=compat_version[1],\n                    binary_format=binary_format,\n                )\n\n\ndef _linux_platforms(is_32bit: bool = _32_BIT_INTERPRETER) -> Iterator[str]:\n    linux = _normalize_string(sysconfig.get_platform())\n    if not linux.startswith(\"linux_\"):\n        # we should never be here, just yield the sysconfig one and return\n        yield linux\n        return\n    if is_32bit:\n        if linux == \"linux_x86_64\":\n            linux = \"linux_i686\"\n        elif linux == \"linux_aarch64\":\n            linux = \"linux_armv8l\"\n    _, arch = linux.split(\"_\", 1)\n    archs = {\"armv8l\": [\"armv8l\", \"armv7l\"]}.get(arch, [arch])\n    yield from _manylinux.platform_tags(archs)\n    yield from _musllinux.platform_tags(archs)\n    for arch in archs:\n        yield f\"linux_{arch}\"\n\n\ndef _generic_platforms() -> Iterator[str]:\n    yield _normalize_string(sysconfig.get_platform())\n\n\ndef platform_tags() -> Iterator[str]:\n    \"\"\"\n    Provides the platform tags for this installation.\n    \"\"\"\n    if platform.system() == \"Darwin\":\n        return mac_platforms()\n    elif platform.system() == \"Linux\":\n        return _linux_platforms()\n    else:\n        return _generic_platforms()\n\n\ndef interpreter_name() -> str:\n    \"\"\"\n    Returns the name of the running interpreter.\n\n    Some implementations have a reserved, two-letter abbreviation which will\n    be returned when appropriate.\n    \"\"\"\n    name = sys.implementation.name\n    return INTERPRETER_SHORT_NAMES.get(name) or name\n\n\ndef interpreter_version(*, warn: bool = False) -> str:\n    \"\"\"\n    Returns the version of the running interpreter.\n    \"\"\"\n    version = _get_config_var(\"py_version_nodot\", warn=warn)\n    if version:\n        version = str(version)\n    else:\n        version = _version_nodot(sys.version_info[:2])\n    return version\n\n\ndef _version_nodot(version: PythonVersion) -> str:\n    return \"\".join(map(str, version))\n\n\ndef sys_tags(*, warn: bool = False) -> Iterator[Tag]:\n    \"\"\"\n    Returns the sequence of tag triples for the running interpreter.\n\n    The order of the sequence corresponds to priority order for the\n    interpreter, from most to least important.\n    \"\"\"\n\n    interp_name = interpreter_name()\n    if interp_name == \"cp\":\n        yield from cpython_tags(warn=warn)\n    else:\n        yield from generic_tags()\n\n    if interp_name == \"pp\":\n        interp = \"pp3\"\n    elif interp_name == \"cp\":\n        interp = \"cp\" + interpreter_version(warn=warn)\n    else:\n        interp = None\n    yield from compatible_tags(interpreter=interp)\n", "pkg_resources/_vendor/packaging/_musllinux.py": "\"\"\"PEP 656 support.\n\nThis module implements logic to detect if the currently running Python is\nlinked against musl, and what musl version is used.\n\"\"\"\n\nimport functools\nimport re\nimport subprocess\nimport sys\nfrom typing import Iterator, NamedTuple, Optional, Sequence\n\nfrom ._elffile import ELFFile\n\n\nclass _MuslVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _parse_musl_version(output: str) -> Optional[_MuslVersion]:\n    lines = [n for n in (n.strip() for n in output.splitlines()) if n]\n    if len(lines) < 2 or lines[0][:4] != \"musl\":\n        return None\n    m = re.match(r\"Version (\\d+)\\.(\\d+)\", lines[1])\n    if not m:\n        return None\n    return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))\n\n\n@functools.lru_cache()\ndef _get_musl_version(executable: str) -> Optional[_MuslVersion]:\n    \"\"\"Detect currently-running musl runtime version.\n\n    This is done by checking the specified executable's dynamic linking\n    information, and invoking the loader to parse its output for a version\n    string. If the loader is musl, the output would be something like::\n\n        musl libc (x86_64)\n        Version 1.2.2\n        Dynamic Program Loader\n    \"\"\"\n    try:\n        with open(executable, \"rb\") as f:\n            ld = ELFFile(f).interpreter\n    except (OSError, TypeError, ValueError):\n        return None\n    if ld is None or \"musl\" not in ld:\n        return None\n    proc = subprocess.run([ld], stderr=subprocess.PIPE, text=True)\n    return _parse_musl_version(proc.stderr)\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate musllinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be musllinux-compatible.\n\n    :returns: An iterator of compatible musllinux tags.\n    \"\"\"\n    sys_musl = _get_musl_version(sys.executable)\n    if sys_musl is None:  # Python not dynamically linked against musl.\n        return\n    for arch in archs:\n        for minor in range(sys_musl.minor, -1, -1):\n            yield f\"musllinux_{sys_musl.major}_{minor}_{arch}\"\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import sysconfig\n\n    plat = sysconfig.get_platform()\n    assert plat.startswith(\"linux-\"), \"not linux\"\n\n    print(\"plat:\", plat)\n    print(\"musl:\", _get_musl_version(sys.executable))\n    print(\"tags:\", end=\" \")\n    for t in platform_tags(re.sub(r\"[.-]\", \"_\", plat.split(\"-\", 1)[-1])):\n        print(t, end=\"\\n      \")\n", "pkg_resources/_vendor/packaging/_manylinux.py": "import collections\nimport contextlib\nimport functools\nimport os\nimport re\nimport sys\nimport warnings\nfrom typing import Dict, Generator, Iterator, NamedTuple, Optional, Sequence, Tuple\n\nfrom ._elffile import EIClass, EIData, ELFFile, EMachine\n\nEF_ARM_ABIMASK = 0xFF000000\nEF_ARM_ABI_VER5 = 0x05000000\nEF_ARM_ABI_FLOAT_HARD = 0x00000400\n\n\n# `os.PathLike` not a generic type until Python 3.9, so sticking with `str`\n# as the type for `path` until then.\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[Optional[ELFFile], None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None\n\n\ndef _is_linux_armhf(executable: str) -> bool:\n    # hard-float ABI can be detected from the ELF header of the running\n    # process\n    # https://static.docs.arm.com/ihi0044/g/aaelf32.pdf\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.Arm\n            and f.flags & EF_ARM_ABIMASK == EF_ARM_ABI_VER5\n            and f.flags & EF_ARM_ABI_FLOAT_HARD == EF_ARM_ABI_FLOAT_HARD\n        )\n\n\ndef _is_linux_i686(executable: str) -> bool:\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.I386\n        )\n\n\ndef _have_compatible_abi(executable: str, archs: Sequence[str]) -> bool:\n    if \"armv7l\" in archs:\n        return _is_linux_armhf(executable)\n    if \"i686\" in archs:\n        return _is_linux_i686(executable)\n    allowed_archs = {\n        \"x86_64\",\n        \"aarch64\",\n        \"ppc64\",\n        \"ppc64le\",\n        \"s390x\",\n        \"loongarch64\",\n        \"riscv64\",\n    }\n    return any(arch in allowed_archs for arch in archs)\n\n\n# If glibc ever changes its major version, we need to know what the last\n# minor version was, so we can build the complete list of all versions.\n# For now, guess what the highest minor version might be, assume it will\n# be 50 for testing. Once this actually happens, update the dictionary\n# with the actual value.\n_LAST_GLIBC_MINOR: Dict[int, int] = collections.defaultdict(lambda: 50)\n\n\nclass _GLibCVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _glibc_version_string_confstr() -> Optional[str]:\n    \"\"\"\n    Primary implementation of glibc_version_string using os.confstr.\n    \"\"\"\n    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely\n    # to be broken or missing. This strategy is used in the standard library\n    # platform module.\n    # https://github.com/python/cpython/blob/fcf1d003bf4f0100c/Lib/platform.py#L175-L183\n    try:\n        # Should be a string like \"glibc 2.17\".\n        version_string: Optional[str] = os.confstr(\"CS_GNU_LIBC_VERSION\")\n        assert version_string is not None\n        _, version = version_string.rsplit()\n    except (AssertionError, AttributeError, OSError, ValueError):\n        # os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)...\n        return None\n    return version\n\n\ndef _glibc_version_string_ctypes() -> Optional[str]:\n    \"\"\"\n    Fallback implementation of glibc_version_string using ctypes.\n    \"\"\"\n    try:\n        import ctypes\n    except ImportError:\n        return None\n\n    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen\n    # manpage says, \"If filename is NULL, then the returned handle is for the\n    # main program\". This way we can let the linker do the work to figure out\n    # which libc our process is actually using.\n    #\n    # We must also handle the special case where the executable is not a\n    # dynamically linked executable. This can occur when using musl libc,\n    # for example. In this situation, dlopen() will error, leading to an\n    # OSError. Interestingly, at least in the case of musl, there is no\n    # errno set on the OSError. The single string argument used to construct\n    # OSError comes from libc itself and is therefore not portable to\n    # hard code here. In any case, failure to call dlopen() means we\n    # can proceed, so we bail on our attempt.\n    try:\n        process_namespace = ctypes.CDLL(None)\n    except OSError:\n        return None\n\n    try:\n        gnu_get_libc_version = process_namespace.gnu_get_libc_version\n    except AttributeError:\n        # Symbol doesn't exist -> therefore, we are not linked to\n        # glibc.\n        return None\n\n    # Call gnu_get_libc_version, which returns a string like \"2.5\"\n    gnu_get_libc_version.restype = ctypes.c_char_p\n    version_str: str = gnu_get_libc_version()\n    # py2 / py3 compatibility:\n    if not isinstance(version_str, str):\n        version_str = version_str.decode(\"ascii\")\n\n    return version_str\n\n\ndef _glibc_version_string() -> Optional[str]:\n    \"\"\"Returns glibc version string, or None if not using glibc.\"\"\"\n    return _glibc_version_string_confstr() or _glibc_version_string_ctypes()\n\n\ndef _parse_glibc_version(version_str: str) -> Tuple[int, int]:\n    \"\"\"Parse glibc version.\n\n    We use a regexp instead of str.split because we want to discard any\n    random junk that might come after the minor version -- this might happen\n    in patched/forked versions of glibc (e.g. Linaro's version of glibc\n    uses version strings like \"2.20-2014.11\"). See gh-3588.\n    \"\"\"\n    m = re.match(r\"(?P<major>[0-9]+)\\.(?P<minor>[0-9]+)\", version_str)\n    if not m:\n        warnings.warn(\n            f\"Expected glibc version with 2 components major.minor,\"\n            f\" got: {version_str}\",\n            RuntimeWarning,\n        )\n        return -1, -1\n    return int(m.group(\"major\")), int(m.group(\"minor\"))\n\n\n@functools.lru_cache()\ndef _get_glibc_version() -> Tuple[int, int]:\n    version_str = _glibc_version_string()\n    if version_str is None:\n        return (-1, -1)\n    return _parse_glibc_version(version_str)\n\n\n# From PEP 513, PEP 600\ndef _is_compatible(arch: str, version: _GLibCVersion) -> bool:\n    sys_glibc = _get_glibc_version()\n    if sys_glibc < version:\n        return False\n    # Check for presence of _manylinux module.\n    try:\n        import _manylinux\n    except ImportError:\n        return True\n    if hasattr(_manylinux, \"manylinux_compatible\"):\n        result = _manylinux.manylinux_compatible(version[0], version[1], arch)\n        if result is not None:\n            return bool(result)\n        return True\n    if version == _GLibCVersion(2, 5):\n        if hasattr(_manylinux, \"manylinux1_compatible\"):\n            return bool(_manylinux.manylinux1_compatible)\n    if version == _GLibCVersion(2, 12):\n        if hasattr(_manylinux, \"manylinux2010_compatible\"):\n            return bool(_manylinux.manylinux2010_compatible)\n    if version == _GLibCVersion(2, 17):\n        if hasattr(_manylinux, \"manylinux2014_compatible\"):\n            return bool(_manylinux.manylinux2014_compatible)\n    return True\n\n\n_LEGACY_MANYLINUX_MAP = {\n    # CentOS 7 w/ glibc 2.17 (PEP 599)\n    (2, 17): \"manylinux2014\",\n    # CentOS 6 w/ glibc 2.12 (PEP 571)\n    (2, 12): \"manylinux2010\",\n    # CentOS 5 w/ glibc 2.5 (PEP 513)\n    (2, 5): \"manylinux1\",\n}\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate manylinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be manylinux-compatible.\n\n    :returns: An iterator of compatible manylinux tags.\n    \"\"\"\n    if not _have_compatible_abi(sys.executable, archs):\n        return\n    # Oldest glibc to be supported regardless of architecture is (2, 17).\n    too_old_glibc2 = _GLibCVersion(2, 16)\n    if set(archs) & {\"x86_64\", \"i686\"}:\n        # On x86/i686 also oldest glibc to be supported is (2, 5).\n        too_old_glibc2 = _GLibCVersion(2, 4)\n    current_glibc = _GLibCVersion(*_get_glibc_version())\n    glibc_max_list = [current_glibc]\n    # We can assume compatibility across glibc major versions.\n    # https://sourceware.org/bugzilla/show_bug.cgi?id=24636\n    #\n    # Build a list of maximum glibc versions so that we can\n    # output the canonical list of all glibc from current_glibc\n    # down to too_old_glibc2, including all intermediary versions.\n    for glibc_major in range(current_glibc.major - 1, 1, -1):\n        glibc_minor = _LAST_GLIBC_MINOR[glibc_major]\n        glibc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))\n    for arch in archs:\n        for glibc_max in glibc_max_list:\n            if glibc_max.major == too_old_glibc2.major:\n                min_minor = too_old_glibc2.minor\n            else:\n                # For other glibc major versions oldest supported is (x, 0).\n                min_minor = -1\n            for glibc_minor in range(glibc_max.minor, min_minor, -1):\n                glibc_version = _GLibCVersion(glibc_max.major, glibc_minor)\n                tag = \"manylinux_{}_{}\".format(*glibc_version)\n                if _is_compatible(arch, glibc_version):\n                    yield f\"{tag}_{arch}\"\n                # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.\n                if glibc_version in _LEGACY_MANYLINUX_MAP:\n                    legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]\n                    if _is_compatible(arch, glibc_version):\n                        yield f\"{legacy_tag}_{arch}\"\n", "pkg_resources/_vendor/packaging/_tokenizer.py": "import contextlib\nimport re\nfrom dataclasses import dataclass\nfrom typing import Dict, Iterator, NoReturn, Optional, Tuple, Union\n\nfrom .specifiers import Specifier\n\n\n@dataclass\nclass Token:\n    name: str\n    text: str\n    position: int\n\n\nclass ParserSyntaxError(Exception):\n    \"\"\"The provided source text could not be parsed correctly.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        source: str,\n        span: Tuple[int, int],\n    ) -> None:\n        self.span = span\n        self.message = message\n        self.source = source\n\n        super().__init__()\n\n    def __str__(self) -> str:\n        marker = \" \" * self.span[0] + \"~\" * (self.span[1] - self.span[0]) + \"^\"\n        return \"\\n    \".join([self.message, self.source, marker])\n\n\nDEFAULT_RULES: \"Dict[str, Union[str, re.Pattern[str]]]\" = {\n    \"LEFT_PARENTHESIS\": r\"\\(\",\n    \"RIGHT_PARENTHESIS\": r\"\\)\",\n    \"LEFT_BRACKET\": r\"\\[\",\n    \"RIGHT_BRACKET\": r\"\\]\",\n    \"SEMICOLON\": r\";\",\n    \"COMMA\": r\",\",\n    \"QUOTED_STRING\": re.compile(\n        r\"\"\"\n            (\n                ('[^']*')\n                |\n                (\"[^\"]*\")\n            )\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"OP\": r\"(===|==|~=|!=|<=|>=|<|>)\",\n    \"BOOLOP\": r\"\\b(or|and)\\b\",\n    \"IN\": r\"\\bin\\b\",\n    \"NOT\": r\"\\bnot\\b\",\n    \"VARIABLE\": re.compile(\n        r\"\"\"\n            \\b(\n                python_version\n                |python_full_version\n                |os[._]name\n                |sys[._]platform\n                |platform_(release|system)\n                |platform[._](version|machine|python_implementation)\n                |python_implementation\n                |implementation_(name|version)\n                |extra\n            )\\b\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"SPECIFIER\": re.compile(\n        Specifier._operator_regex_str + Specifier._version_regex_str,\n        re.VERBOSE | re.IGNORECASE,\n    ),\n    \"AT\": r\"\\@\",\n    \"URL\": r\"[^ \\t]+\",\n    \"IDENTIFIER\": r\"\\b[a-zA-Z0-9][a-zA-Z0-9._-]*\\b\",\n    \"VERSION_PREFIX_TRAIL\": r\"\\.\\*\",\n    \"VERSION_LOCAL_LABEL_TRAIL\": r\"\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*\",\n    \"WS\": r\"[ \\t]+\",\n    \"END\": r\"$\",\n}\n\n\nclass Tokenizer:\n    \"\"\"Context-sensitive token parsing.\n\n    Provides methods to examine the input stream to check whether the next token\n    matches.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        *,\n        rules: \"Dict[str, Union[str, re.Pattern[str]]]\",\n    ) -> None:\n        self.source = source\n        self.rules: Dict[str, re.Pattern[str]] = {\n            name: re.compile(pattern) for name, pattern in rules.items()\n        }\n        self.next_token: Optional[Token] = None\n        self.position = 0\n\n    def consume(self, name: str) -> None:\n        \"\"\"Move beyond provided token name, if at current position.\"\"\"\n        if self.check(name):\n            self.read()\n\n    def check(self, name: str, *, peek: bool = False) -> bool:\n        \"\"\"Check whether the next token has the provided name.\n\n        By default, if the check succeeds, the token *must* be read before\n        another check. If `peek` is set to `True`, the token is not loaded and\n        would need to be checked again.\n        \"\"\"\n        assert (\n            self.next_token is None\n        ), f\"Cannot check for {name!r}, already have {self.next_token!r}\"\n        assert name in self.rules, f\"Unknown token name: {name!r}\"\n\n        expression = self.rules[name]\n\n        match = expression.match(self.source, self.position)\n        if match is None:\n            return False\n        if not peek:\n            self.next_token = Token(name, match[0], self.position)\n        return True\n\n    def expect(self, name: str, *, expected: str) -> Token:\n        \"\"\"Expect a certain token name next, failing with a syntax error otherwise.\n\n        The token is *not* read.\n        \"\"\"\n        if not self.check(name):\n            raise self.raise_syntax_error(f\"Expected {expected}\")\n        return self.read()\n\n    def read(self) -> Token:\n        \"\"\"Consume the next token and return it.\"\"\"\n        token = self.next_token\n        assert token is not None\n\n        self.position += len(token.text)\n        self.next_token = None\n\n        return token\n\n    def raise_syntax_error(\n        self,\n        message: str,\n        *,\n        span_start: Optional[int] = None,\n        span_end: Optional[int] = None,\n    ) -> NoReturn:\n        \"\"\"Raise ParserSyntaxError at the given position.\"\"\"\n        span = (\n            self.position if span_start is None else span_start,\n            self.position if span_end is None else span_end,\n        )\n        raise ParserSyntaxError(\n            message,\n            source=self.source,\n            span=span,\n        )\n\n    @contextlib.contextmanager\n    def enclosing_tokens(\n        self, open_token: str, close_token: str, *, around: str\n    ) -> Iterator[None]:\n        if self.check(open_token):\n            open_position = self.position\n            self.read()\n        else:\n            open_position = None\n\n        yield\n\n        if open_position is None:\n            return\n\n        if not self.check(close_token):\n            self.raise_syntax_error(\n                f\"Expected matching {close_token} for {open_token}, after {around}\",\n                span_start=open_position,\n            )\n\n        self.read()\n", "pkg_resources/_vendor/packaging/_structures.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nclass InfinityType:\n    def __repr__(self) -> str:\n        return \"Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return False\n\n    def __le__(self, other: object) -> bool:\n        return False\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return True\n\n    def __ge__(self, other: object) -> bool:\n        return True\n\n    def __neg__(self: object) -> \"NegativeInfinityType\":\n        return NegativeInfinity\n\n\nInfinity = InfinityType()\n\n\nclass NegativeInfinityType:\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return True\n\n    def __le__(self, other: object) -> bool:\n        return True\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return False\n\n    def __ge__(self, other: object) -> bool:\n        return False\n\n    def __neg__(self: object) -> InfinityType:\n        return Infinity\n\n\nNegativeInfinity = NegativeInfinityType()\n", "pkg_resources/_vendor/packaging/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport re\nfrom typing import FrozenSet, NewType, Tuple, Union, cast\n\nfrom .tags import Tag, parse_tag\nfrom .version import InvalidVersion, Version\n\nBuildTag = Union[Tuple[()], Tuple[int, str]]\nNormalizedName = NewType(\"NormalizedName\", str)\n\n\nclass InvalidName(ValueError):\n    \"\"\"\n    An invalid distribution name; users should refer to the packaging user guide.\n    \"\"\"\n\n\nclass InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\n\n\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n\n\n# Core metadata spec for `Name`\n_validate_regex = re.compile(\n    r\"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$\", re.IGNORECASE\n)\n_canonicalize_regex = re.compile(r\"[-_.]+\")\n_normalized_regex = re.compile(r\"^([a-z0-9]|[a-z0-9]([a-z0-9-](?!--))*[a-z0-9])$\")\n# PEP 427: The build number must start with a digit.\n_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\n\n\ndef canonicalize_name(name: str, *, validate: bool = False) -> NormalizedName:\n    if validate and not _validate_regex.match(name):\n        raise InvalidName(f\"name is invalid: {name!r}\")\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\n\n\ndef is_normalized_name(name: str) -> bool:\n    return _normalized_regex.match(name) is not None\n\n\ndef canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    This is very similar to Version.__str__, but has one subtle difference\n    with the way it handles the release segment.\n    \"\"\"\n    if isinstance(version, str):\n        try:\n            parsed = Version(version)\n        except InvalidVersion:\n            # Legacy versions cannot be normalized\n            return version\n    else:\n        parsed = version\n\n    parts = []\n\n    # Epoch\n    if parsed.epoch != 0:\n        parts.append(f\"{parsed.epoch}!\")\n\n    # Release segment\n    release_segment = \".\".join(str(x) for x in parsed.release)\n    if strip_trailing_zero:\n        # NB: This strips trailing '.0's to normalize\n        release_segment = re.sub(r\"(\\.0)+$\", \"\", release_segment)\n    parts.append(release_segment)\n\n    # Pre-release\n    if parsed.pre is not None:\n        parts.append(\"\".join(str(x) for x in parsed.pre))\n\n    # Post-release\n    if parsed.post is not None:\n        parts.append(f\".post{parsed.post}\")\n\n    # Development release\n    if parsed.dev is not None:\n        parts.append(f\".dev{parsed.dev}\")\n\n    # Local version segment\n    if parsed.local is not None:\n        parts.append(f\"+{parsed.local}\")\n\n    return \"\".join(parts)\n\n\ndef parse_wheel_filename(\n    filename: str,\n) -> Tuple[NormalizedName, Version, BuildTag, FrozenSet[Tag]]:\n    if not filename.endswith(\".whl\"):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (extension must be '.whl'): {filename}\"\n        )\n\n    filename = filename[:-4]\n    dashes = filename.count(\"-\")\n    if dashes not in (4, 5):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (wrong number of parts): {filename}\"\n        )\n\n    parts = filename.split(\"-\", dashes - 2)\n    name_part = parts[0]\n    # See PEP 427 for the rules on escaping the project name.\n    if \"__\" in name_part or re.match(r\"^[\\w\\d._]*$\", name_part, re.UNICODE) is None:\n        raise InvalidWheelFilename(f\"Invalid project name: {filename}\")\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(parts[1])\n    except InvalidVersion as e:\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (invalid version): {filename}\"\n        ) from e\n\n    if dashes == 5:\n        build_part = parts[2]\n        build_match = _build_tag_regex.match(build_part)\n        if build_match is None:\n            raise InvalidWheelFilename(\n                f\"Invalid build number: {build_part} in '{filename}'\"\n            )\n        build = cast(BuildTag, (int(build_match.group(1)), build_match.group(2)))\n    else:\n        build = ()\n    tags = parse_tag(parts[-1])\n    return (name, version, build, tags)\n\n\ndef parse_sdist_filename(filename: str) -> Tuple[NormalizedName, Version]:\n    if filename.endswith(\".tar.gz\"):\n        file_stem = filename[: -len(\".tar.gz\")]\n    elif filename.endswith(\".zip\"):\n        file_stem = filename[: -len(\".zip\")]\n    else:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (extension must be '.tar.gz' or '.zip'):\"\n            f\" {filename}\"\n        )\n\n    # We are requiring a PEP 440 version, which cannot contain dashes,\n    # so we split on the last dash.\n    name_part, sep, version_part = file_stem.rpartition(\"-\")\n    if not sep:\n        raise InvalidSdistFilename(f\"Invalid sdist filename: {filename}\")\n\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(version_part)\n    except InvalidVersion as e:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (invalid version): {filename}\"\n        ) from e\n\n    return (name, version)\n", "pkg_resources/_vendor/packaging/version.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.version import parse, Version\n\"\"\"\n\nimport itertools\nimport re\nfrom typing import Any, Callable, NamedTuple, Optional, SupportsInt, Tuple, Union\n\nfrom ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType\n\n__all__ = [\"VERSION_PATTERN\", \"parse\", \"Version\", \"InvalidVersion\"]\n\nLocalType = Tuple[Union[int, str], ...]\n\nCmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]\nCmpLocalType = Union[\n    NegativeInfinityType,\n    Tuple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], ...],\n]\nCmpKey = Tuple[\n    int,\n    Tuple[int, ...],\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpLocalType,\n]\nVersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n\n\nclass _Version(NamedTuple):\n    epoch: int\n    release: Tuple[int, ...]\n    dev: Optional[Tuple[str, int]]\n    pre: Optional[Tuple[str, int]]\n    post: Optional[Tuple[str, int]]\n    local: Optional[LocalType]\n\n\ndef parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"\n    return Version(version)\n\n\nclass InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.\n\n    >>> Version(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.version.InvalidVersion: Invalid version: 'invalid'\n    \"\"\"\n\n\nclass _BaseVersion:\n    _key: Tuple[Any, ...]\n\n    def __hash__(self) -> int:\n        return hash(self._key)\n\n    # Please keep the duplicated `isinstance` check\n    # in the six comparisons hereunder\n    # unless you find a way to avoid adding overhead function calls.\n    def __lt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key < other._key\n\n    def __le__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key <= other._key\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key == other._key\n\n    def __ge__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key >= other._key\n\n    def __gt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key > other._key\n\n    def __ne__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key != other._key\n\n\n# Deliberately not anchored to the start and end of the string, to make it\n# easier for 3rd party code to reuse\n_VERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>alpha|a|beta|b|preview|pre|c|rc)\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\\.]?\n                (?P<post_l>post|rev|r)\n                [-_\\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\\.]?\n            (?P<dev_l>dev)\n            [-_\\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n\"\"\"\n\nVERSION_PATTERN = _VERSION_PATTERN\n\"\"\"\nA string containing the regular expression used to match a valid version.\n\nThe pattern is not anchored at either end, and is intended for embedding in larger\nexpressions (for example, matching a version number as part of a file name). The\nregular expression should be compiled with the ``re.VERBOSE`` and ``re.IGNORECASE``\nflags set.\n\n:meta hide-value:\n\"\"\"\n\n\nclass Version(_BaseVersion):\n    \"\"\"This class abstracts handling of a project's versions.\n\n    A :class:`Version` instance is comparison aware and can be compared and\n    sorted using the standard Python interfaces.\n\n    >>> v1 = Version(\"1.0a5\")\n    >>> v2 = Version(\"1.0\")\n    >>> v1\n    <Version('1.0a5')>\n    >>> v2\n    <Version('1.0')>\n    >>> v1 < v2\n    True\n    >>> v1 == v2\n    False\n    >>> v1 > v2\n    False\n    >>> v1 >= v2\n    False\n    >>> v1 <= v2\n    True\n    \"\"\"\n\n    _regex = re.compile(r\"^\\s*\" + VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE)\n    _key: CmpKey\n\n    def __init__(self, version: str) -> None:\n        \"\"\"Initialize a Version object.\n\n        :param version:\n            The string representation of a version which will be parsed and normalized\n            before use.\n        :raises InvalidVersion:\n            If the ``version`` does not conform to PEP 440 in any way then this\n            exception will be raised.\n        \"\"\"\n\n        # Validate the version and parse it into pieces\n        match = self._regex.search(version)\n        if not match:\n            raise InvalidVersion(f\"Invalid version: '{version}'\")\n\n        # Store the parsed out pieces of the version\n        self._version = _Version(\n            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,\n            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),\n            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),\n            post=_parse_letter_version(\n                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")\n            ),\n            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),\n            local=_parse_local_version(match.group(\"local\")),\n        )\n\n        # Generate a key which will be used for sorting\n        self._key = _cmpkey(\n            self._version.epoch,\n            self._version.release,\n            self._version.pre,\n            self._version.post,\n            self._version.dev,\n            self._version.local,\n        )\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Version that shows all internal state.\n\n        >>> Version('1.0.0')\n        <Version('1.0.0')>\n        \"\"\"\n        return f\"<Version('{self}')>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the version that can be rounded-tripped.\n\n        >>> str(Version(\"1.0a5\"))\n        '1.0a5'\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        # Pre-release\n        if self.pre is not None:\n            parts.append(\"\".join(str(x) for x in self.pre))\n\n        # Post-release\n        if self.post is not None:\n            parts.append(f\".post{self.post}\")\n\n        # Development release\n        if self.dev is not None:\n            parts.append(f\".dev{self.dev}\")\n\n        # Local version segment\n        if self.local is not None:\n            parts.append(f\"+{self.local}\")\n\n        return \"\".join(parts)\n\n    @property\n    def epoch(self) -> int:\n        \"\"\"The epoch of the version.\n\n        >>> Version(\"2.0.0\").epoch\n        0\n        >>> Version(\"1!2.0.0\").epoch\n        1\n        \"\"\"\n        return self._version.epoch\n\n    @property\n    def release(self) -> Tuple[int, ...]:\n        \"\"\"The components of the \"release\" segment of the version.\n\n        >>> Version(\"1.2.3\").release\n        (1, 2, 3)\n        >>> Version(\"2.0.0\").release\n        (2, 0, 0)\n        >>> Version(\"1!2.0.0.post0\").release\n        (2, 0, 0)\n\n        Includes trailing zeroes but not the epoch or any pre-release / development /\n        post-release suffixes.\n        \"\"\"\n        return self._version.release\n\n    @property\n    def pre(self) -> Optional[Tuple[str, int]]:\n        \"\"\"The pre-release segment of the version.\n\n        >>> print(Version(\"1.2.3\").pre)\n        None\n        >>> Version(\"1.2.3a1\").pre\n        ('a', 1)\n        >>> Version(\"1.2.3b1\").pre\n        ('b', 1)\n        >>> Version(\"1.2.3rc1\").pre\n        ('rc', 1)\n        \"\"\"\n        return self._version.pre\n\n    @property\n    def post(self) -> Optional[int]:\n        \"\"\"The post-release number of the version.\n\n        >>> print(Version(\"1.2.3\").post)\n        None\n        >>> Version(\"1.2.3.post1\").post\n        1\n        \"\"\"\n        return self._version.post[1] if self._version.post else None\n\n    @property\n    def dev(self) -> Optional[int]:\n        \"\"\"The development number of the version.\n\n        >>> print(Version(\"1.2.3\").dev)\n        None\n        >>> Version(\"1.2.3.dev1\").dev\n        1\n        \"\"\"\n        return self._version.dev[1] if self._version.dev else None\n\n    @property\n    def local(self) -> Optional[str]:\n        \"\"\"The local version segment of the version.\n\n        >>> print(Version(\"1.2.3\").local)\n        None\n        >>> Version(\"1.2.3+abc\").local\n        'abc'\n        \"\"\"\n        if self._version.local:\n            return \".\".join(str(x) for x in self._version.local)\n        else:\n            return None\n\n    @property\n    def public(self) -> str:\n        \"\"\"The public portion of the version.\n\n        >>> Version(\"1.2.3\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc.dev1\").public\n        '1.2.3'\n        \"\"\"\n        return str(self).split(\"+\", 1)[0]\n\n    @property\n    def base_version(self) -> str:\n        \"\"\"The \"base version\" of the version.\n\n        >>> Version(\"1.2.3\").base_version\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").base_version\n        '1.2.3'\n        >>> Version(\"1!1.2.3+abc.dev1\").base_version\n        '1!1.2.3'\n\n        The \"base version\" is the public version of the project without any pre or post\n        release markers.\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        return \"\".join(parts)\n\n    @property\n    def is_prerelease(self) -> bool:\n        \"\"\"Whether this version is a pre-release.\n\n        >>> Version(\"1.2.3\").is_prerelease\n        False\n        >>> Version(\"1.2.3a1\").is_prerelease\n        True\n        >>> Version(\"1.2.3b1\").is_prerelease\n        True\n        >>> Version(\"1.2.3rc1\").is_prerelease\n        True\n        >>> Version(\"1.2.3dev1\").is_prerelease\n        True\n        \"\"\"\n        return self.dev is not None or self.pre is not None\n\n    @property\n    def is_postrelease(self) -> bool:\n        \"\"\"Whether this version is a post-release.\n\n        >>> Version(\"1.2.3\").is_postrelease\n        False\n        >>> Version(\"1.2.3.post1\").is_postrelease\n        True\n        \"\"\"\n        return self.post is not None\n\n    @property\n    def is_devrelease(self) -> bool:\n        \"\"\"Whether this version is a development release.\n\n        >>> Version(\"1.2.3\").is_devrelease\n        False\n        >>> Version(\"1.2.3.dev1\").is_devrelease\n        True\n        \"\"\"\n        return self.dev is not None\n\n    @property\n    def major(self) -> int:\n        \"\"\"The first item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").major\n        1\n        \"\"\"\n        return self.release[0] if len(self.release) >= 1 else 0\n\n    @property\n    def minor(self) -> int:\n        \"\"\"The second item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").minor\n        2\n        >>> Version(\"1\").minor\n        0\n        \"\"\"\n        return self.release[1] if len(self.release) >= 2 else 0\n\n    @property\n    def micro(self) -> int:\n        \"\"\"The third item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").micro\n        3\n        >>> Version(\"1\").micro\n        0\n        \"\"\"\n        return self.release[2] if len(self.release) >= 3 else 0\n\n\ndef _parse_letter_version(\n    letter: Optional[str], number: Union[str, bytes, SupportsInt, None]\n) -> Optional[Tuple[str, int]]:\n\n    if letter:\n        # We consider there to be an implicit 0 in a pre-release if there is\n        # not a numeral associated with it.\n        if number is None:\n            number = 0\n\n        # We normalize any letters to their lower case form\n        letter = letter.lower()\n\n        # We consider some words to be alternate spellings of other words and\n        # in those cases we want to normalize the spellings to our preferred\n        # spelling.\n        if letter == \"alpha\":\n            letter = \"a\"\n        elif letter == \"beta\":\n            letter = \"b\"\n        elif letter in [\"c\", \"pre\", \"preview\"]:\n            letter = \"rc\"\n        elif letter in [\"rev\", \"r\"]:\n            letter = \"post\"\n\n        return letter, int(number)\n    if not letter and number:\n        # We assume if we are given a number, but we are not given a letter\n        # then this is using the implicit post release syntax (e.g. 1.0-1)\n        letter = \"post\"\n\n        return letter, int(number)\n\n    return None\n\n\n_local_version_separators = re.compile(r\"[\\._-]\")\n\n\ndef _parse_local_version(local: Optional[str]) -> Optional[LocalType]:\n    \"\"\"\n    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").\n    \"\"\"\n    if local is not None:\n        return tuple(\n            part.lower() if not part.isdigit() else int(part)\n            for part in _local_version_separators.split(local)\n        )\n    return None\n\n\ndef _cmpkey(\n    epoch: int,\n    release: Tuple[int, ...],\n    pre: Optional[Tuple[str, int]],\n    post: Optional[Tuple[str, int]],\n    dev: Optional[Tuple[str, int]],\n    local: Optional[LocalType],\n) -> CmpKey:\n\n    # When we compare a release version, we want to compare it with all of the\n    # trailing zeros removed. So we'll use a reverse the list, drop all the now\n    # leading zeros until we come to something non zero, then take the rest\n    # re-reverse it back into the correct order and make it a tuple and use\n    # that for our sorting key.\n    _release = tuple(\n        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))\n    )\n\n    # We need to \"trick\" the sorting algorithm to put 1.0.dev0 before 1.0a0.\n    # We'll do this by abusing the pre segment, but we _only_ want to do this\n    # if there is not a pre or a post segment. If we have one of those then\n    # the normal sorting rules will handle this case correctly.\n    if pre is None and post is None and dev is not None:\n        _pre: CmpPrePostDevType = NegativeInfinity\n    # Versions without a pre-release (except as noted above) should sort after\n    # those with one.\n    elif pre is None:\n        _pre = Infinity\n    else:\n        _pre = pre\n\n    # Versions without a post segment should sort before those with one.\n    if post is None:\n        _post: CmpPrePostDevType = NegativeInfinity\n\n    else:\n        _post = post\n\n    # Versions without a development segment should sort after those with one.\n    if dev is None:\n        _dev: CmpPrePostDevType = Infinity\n\n    else:\n        _dev = dev\n\n    if local is None:\n        # Versions without a local segment should sort before those with one.\n        _local: CmpLocalType = NegativeInfinity\n    else:\n        # Versions with a local segment need that segment parsed to implement\n        # the sorting rules in PEP440.\n        # - Alpha numeric segments sort before numeric segments\n        # - Alpha numeric segments sort lexicographically\n        # - Numeric segments sort numerically\n        # - Shorter versions sort before longer versions when the prefixes\n        #   match exactly\n        _local = tuple(\n            (i, \"\") if isinstance(i, int) else (NegativeInfinity, i) for i in local\n        )\n\n    return epoch, _release, _pre, _post, _dev, _local\n", "pkg_resources/_vendor/packaging/_elffile.py": "\"\"\"\nELF file parser.\n\nThis provides a class ``ELFFile`` that parses an ELF executable in a similar\ninterface to ``ZipFile``. Only the read interface is implemented.\n\nBased on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca\nELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html\n\"\"\"\n\nimport enum\nimport os\nimport struct\nfrom typing import IO, Optional, Tuple\n\n\nclass ELFInvalid(ValueError):\n    pass\n\n\nclass EIClass(enum.IntEnum):\n    C32 = 1\n    C64 = 2\n\n\nclass EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\n\n\nclass EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40\n    X8664 = 62\n    AArc64 = 183\n\n\nclass ELFFile:\n    \"\"\"\n    Representation of an ELF executable.\n    \"\"\"\n\n    def __init__(self, f: IO[bytes]) -> None:\n        self._f = f\n\n        try:\n            ident = self._read(\"16B\")\n        except struct.error:\n            raise ELFInvalid(\"unable to parse identification\")\n        magic = bytes(ident[:4])\n        if magic != b\"\\x7fELF\":\n            raise ELFInvalid(f\"invalid magic: {magic!r}\")\n\n        self.capacity = ident[4]  # Format for program header (bitness).\n        self.encoding = ident[5]  # Data structure encoding (endianness).\n\n        try:\n            # e_fmt: Format for program header.\n            # p_fmt: Format for section header.\n            # p_idx: Indexes to find p_type, p_offset, and p_filesz.\n            e_fmt, self._p_fmt, self._p_idx = {\n                (1, 1): (\"<HHIIIIIHHH\", \"<IIIIIIII\", (0, 1, 4)),  # 32-bit LSB.\n                (1, 2): (\">HHIIIIIHHH\", \">IIIIIIII\", (0, 1, 4)),  # 32-bit MSB.\n                (2, 1): (\"<HHIQQQIHHH\", \"<IIQQQQQQ\", (0, 2, 5)),  # 64-bit LSB.\n                (2, 2): (\">HHIQQQIHHH\", \">IIQQQQQQ\", (0, 2, 5)),  # 64-bit MSB.\n            }[(self.capacity, self.encoding)]\n        except KeyError:\n            raise ELFInvalid(\n                f\"unrecognized capacity ({self.capacity}) or \"\n                f\"encoding ({self.encoding})\"\n            )\n\n        try:\n            (\n                _,\n                self.machine,  # Architecture type.\n                _,\n                _,\n                self._e_phoff,  # Offset of program header.\n                _,\n                self.flags,  # Processor-specific flags.\n                _,\n                self._e_phentsize,  # Size of section.\n                self._e_phnum,  # Number of sections.\n            ) = self._read(e_fmt)\n        except struct.error as e:\n            raise ELFInvalid(\"unable to parse machine and section information\") from e\n\n    def _read(self, fmt: str) -> Tuple[int, ...]:\n        return struct.unpack(fmt, self._f.read(struct.calcsize(fmt)))\n\n    @property\n    def interpreter(self) -> Optional[str]:\n        \"\"\"\n        The path recorded in the ``PT_INTERP`` section header.\n        \"\"\"\n        for index in range(self._e_phnum):\n            self._f.seek(self._e_phoff + self._e_phentsize * index)\n            try:\n                data = self._read(self._p_fmt)\n            except struct.error:\n                continue\n            if data[self._p_idx[0]] != 3:  # Not PT_INTERP.\n                continue\n            self._f.seek(data[self._p_idx[1]])\n            return os.fsdecode(self._f.read(data[self._p_idx[2]])).strip(\"\\0\")\n        return None\n", "pkg_resources/_vendor/packaging/requirements.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom typing import Any, Iterator, Optional, Set\n\nfrom ._parser import parse_requirement as _parse_requirement\nfrom ._tokenizer import ParserSyntaxError\nfrom .markers import Marker, _normalize_extra_values\nfrom .specifiers import SpecifierSet\nfrom .utils import canonicalize_name\n\n\nclass InvalidRequirement(ValueError):\n    \"\"\"\n    An invalid requirement was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass Requirement:\n    \"\"\"Parse a requirement.\n\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"\n\n    # TODO: Can we test whether something is contained within a requirement?\n    #       If so how do we do that? Do we need to test against the _name_ of\n    #       the thing as well as the version? What about the markers?\n    # TODO: Can we normalize the name and extra name?\n\n    def __init__(self, requirement_string: str) -> None:\n        try:\n            parsed = _parse_requirement(requirement_string)\n        except ParserSyntaxError as e:\n            raise InvalidRequirement(str(e)) from e\n\n        self.name: str = parsed.name\n        self.url: Optional[str] = parsed.url or None\n        self.extras: Set[str] = set(parsed.extras or [])\n        self.specifier: SpecifierSet = SpecifierSet(parsed.specifier)\n        self.marker: Optional[Marker] = None\n        if parsed.marker is not None:\n            self.marker = Marker.__new__(Marker)\n            self.marker._markers = _normalize_extra_values(parsed.marker)\n\n    def _iter_parts(self, name: str) -> Iterator[str]:\n        yield name\n\n        if self.extras:\n            formatted_extras = \",\".join(sorted(self.extras))\n            yield f\"[{formatted_extras}]\"\n\n        if self.specifier:\n            yield str(self.specifier)\n\n        if self.url:\n            yield f\"@ {self.url}\"\n            if self.marker:\n                yield \" \"\n\n        if self.marker:\n            yield f\"; {self.marker}\"\n\n    def __str__(self) -> str:\n        return \"\".join(self._iter_parts(self.name))\n\n    def __repr__(self) -> str:\n        return f\"<Requirement('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.__class__.__name__,\n                *self._iter_parts(canonicalize_name(self.name)),\n            )\n        )\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Requirement):\n            return NotImplemented\n\n        return (\n            canonicalize_name(self.name) == canonicalize_name(other.name)\n            and self.extras == other.extras\n            and self.specifier == other.specifier\n            and self.url == other.url\n            and self.marker == other.marker\n        )\n", "pkg_resources/_vendor/packaging/_parser.py": "\"\"\"Handwritten parser of dependency specifiers.\n\nThe docstring for each __parse_* function contains ENBF-inspired grammar representing\nthe implementation.\n\"\"\"\n\nimport ast\nfrom typing import Any, List, NamedTuple, Optional, Tuple, Union\n\nfrom ._tokenizer import DEFAULT_RULES, Tokenizer\n\n\nclass Node:\n    def __init__(self, value: str) -> None:\n        self.value = value\n\n    def __str__(self) -> str:\n        return self.value\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}('{self}')>\"\n\n    def serialize(self) -> str:\n        raise NotImplementedError\n\n\nclass Variable(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nclass Value(Node):\n    def serialize(self) -> str:\n        return f'\"{self}\"'\n\n\nclass Op(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nMarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]\n# mypy does not support recursive type definition\n# https://github.com/python/mypy/issues/731\nMarkerAtom = Any\nMarkerList = List[Any]\n\n\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: List[str]\n    specifier: str\n    marker: Optional[MarkerList]\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier\n# --------------------------------------------------------------------------------------\ndef parse_requirement(source: str) -> ParsedRequirement:\n    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:\n    \"\"\"\n    requirement = WS? IDENTIFIER WS? extras WS? requirement_details\n    \"\"\"\n    tokenizer.consume(\"WS\")\n\n    name_token = tokenizer.expect(\n        \"IDENTIFIER\", expected=\"package name at the start of dependency specifier\"\n    )\n    name = name_token.text\n    tokenizer.consume(\"WS\")\n\n    extras = _parse_extras(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    url, specifier, marker = _parse_requirement_details(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of dependency specifier\")\n\n    return ParsedRequirement(name, url, extras, specifier, marker)\n\n\ndef _parse_requirement_details(\n    tokenizer: Tokenizer,\n) -> Tuple[str, str, Optional[MarkerList]]:\n    \"\"\"\n    requirement_details = AT URL (WS requirement_marker?)?\n                        | specifier WS? (requirement_marker)?\n    \"\"\"\n\n    specifier = \"\"\n    url = \"\"\n    marker = None\n\n    if tokenizer.check(\"AT\"):\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        url_start = tokenizer.position\n        url = tokenizer.expect(\"URL\", expected=\"URL after @\").text\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        tokenizer.expect(\"WS\", expected=\"whitespace after URL\")\n\n        # The input might end after whitespace.\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer, span_start=url_start, after=\"URL and whitespace\"\n        )\n    else:\n        specifier_start = tokenizer.position\n        specifier = _parse_specifier(tokenizer)\n        tokenizer.consume(\"WS\")\n\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer,\n            span_start=specifier_start,\n            after=(\n                \"version specifier\"\n                if specifier\n                else \"name and no valid version specifier\"\n            ),\n        )\n\n    return (url, specifier, marker)\n\n\ndef _parse_requirement_marker(\n    tokenizer: Tokenizer, *, span_start: int, after: str\n) -> MarkerList:\n    \"\"\"\n    requirement_marker = SEMICOLON marker WS?\n    \"\"\"\n\n    if not tokenizer.check(\"SEMICOLON\"):\n        tokenizer.raise_syntax_error(\n            f\"Expected end or semicolon (after {after})\",\n            span_start=span_start,\n        )\n    tokenizer.read()\n\n    marker = _parse_marker(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    return marker\n\n\ndef _parse_extras(tokenizer: Tokenizer) -> List[str]:\n    \"\"\"\n    extras = (LEFT_BRACKET wsp* extras_list? wsp* RIGHT_BRACKET)?\n    \"\"\"\n    if not tokenizer.check(\"LEFT_BRACKET\", peek=True):\n        return []\n\n    with tokenizer.enclosing_tokens(\n        \"LEFT_BRACKET\",\n        \"RIGHT_BRACKET\",\n        around=\"extras\",\n    ):\n        tokenizer.consume(\"WS\")\n        extras = _parse_extras_list(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return extras\n\n\ndef _parse_extras_list(tokenizer: Tokenizer) -> List[str]:\n    \"\"\"\n    extras_list = identifier (wsp* ',' wsp* identifier)*\n    \"\"\"\n    extras: List[str] = []\n\n    if not tokenizer.check(\"IDENTIFIER\"):\n        return extras\n\n    extras.append(tokenizer.read().text)\n\n    while True:\n        tokenizer.consume(\"WS\")\n        if tokenizer.check(\"IDENTIFIER\", peek=True):\n            tokenizer.raise_syntax_error(\"Expected comma between extra names\")\n        elif not tokenizer.check(\"COMMA\"):\n            break\n\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        extra_token = tokenizer.expect(\"IDENTIFIER\", expected=\"extra name after comma\")\n        extras.append(extra_token.text)\n\n    return extras\n\n\ndef _parse_specifier(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    specifier = LEFT_PARENTHESIS WS? version_many WS? RIGHT_PARENTHESIS\n              | WS? version_many WS?\n    \"\"\"\n    with tokenizer.enclosing_tokens(\n        \"LEFT_PARENTHESIS\",\n        \"RIGHT_PARENTHESIS\",\n        around=\"version specifier\",\n    ):\n        tokenizer.consume(\"WS\")\n        parsed_specifiers = _parse_version_many(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\ndef _parse_version_many(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    version_many = (SPECIFIER (WS? COMMA WS? SPECIFIER)*)?\n    \"\"\"\n    parsed_specifiers = \"\"\n    while tokenizer.check(\"SPECIFIER\"):\n        span_start = tokenizer.position\n        parsed_specifiers += tokenizer.read().text\n        if tokenizer.check(\"VERSION_PREFIX_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \".* suffix can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position + 1,\n            )\n        if tokenizer.check(\"VERSION_LOCAL_LABEL_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \"Local version label can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position,\n            )\n        tokenizer.consume(\"WS\")\n        if not tokenizer.check(\"COMMA\"):\n            break\n        parsed_specifiers += tokenizer.read().text\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for marker expression\n# --------------------------------------------------------------------------------------\ndef parse_marker(source: str) -> MarkerList:\n    return _parse_full_marker(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_full_marker(tokenizer: Tokenizer) -> MarkerList:\n    retval = _parse_marker(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of marker expression\")\n    return retval\n\n\ndef _parse_marker(tokenizer: Tokenizer) -> MarkerList:\n    \"\"\"\n    marker = marker_atom (BOOLOP marker_atom)+\n    \"\"\"\n    expression = [_parse_marker_atom(tokenizer)]\n    while tokenizer.check(\"BOOLOP\"):\n        token = tokenizer.read()\n        expr_right = _parse_marker_atom(tokenizer)\n        expression.extend((token.text, expr_right))\n    return expression\n\n\ndef _parse_marker_atom(tokenizer: Tokenizer) -> MarkerAtom:\n    \"\"\"\n    marker_atom = WS? LEFT_PARENTHESIS WS? marker WS? RIGHT_PARENTHESIS WS?\n                | WS? marker_item WS?\n    \"\"\"\n\n    tokenizer.consume(\"WS\")\n    if tokenizer.check(\"LEFT_PARENTHESIS\", peek=True):\n        with tokenizer.enclosing_tokens(\n            \"LEFT_PARENTHESIS\",\n            \"RIGHT_PARENTHESIS\",\n            around=\"marker expression\",\n        ):\n            tokenizer.consume(\"WS\")\n            marker: MarkerAtom = _parse_marker(tokenizer)\n            tokenizer.consume(\"WS\")\n    else:\n        marker = _parse_marker_item(tokenizer)\n    tokenizer.consume(\"WS\")\n    return marker\n\n\ndef _parse_marker_item(tokenizer: Tokenizer) -> MarkerItem:\n    \"\"\"\n    marker_item = WS? marker_var WS? marker_op WS? marker_var WS?\n    \"\"\"\n    tokenizer.consume(\"WS\")\n    marker_var_left = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_op = _parse_marker_op(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_var_right = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    return (marker_var_left, marker_op, marker_var_right)\n\n\ndef _parse_marker_var(tokenizer: Tokenizer) -> MarkerVar:\n    \"\"\"\n    marker_var = VARIABLE | QUOTED_STRING\n    \"\"\"\n    if tokenizer.check(\"VARIABLE\"):\n        return process_env_var(tokenizer.read().text.replace(\".\", \"_\"))\n    elif tokenizer.check(\"QUOTED_STRING\"):\n        return process_python_str(tokenizer.read().text)\n    else:\n        tokenizer.raise_syntax_error(\n            message=\"Expected a marker variable or quoted string\"\n        )\n\n\ndef process_env_var(env_var: str) -> Variable:\n    if env_var in (\"platform_python_implementation\", \"python_implementation\"):\n        return Variable(\"platform_python_implementation\")\n    else:\n        return Variable(env_var)\n\n\ndef process_python_str(python_str: str) -> Value:\n    value = ast.literal_eval(python_str)\n    return Value(str(value))\n\n\ndef _parse_marker_op(tokenizer: Tokenizer) -> Op:\n    \"\"\"\n    marker_op = IN | NOT IN | OP\n    \"\"\"\n    if tokenizer.check(\"IN\"):\n        tokenizer.read()\n        return Op(\"in\")\n    elif tokenizer.check(\"NOT\"):\n        tokenizer.read()\n        tokenizer.expect(\"WS\", expected=\"whitespace after 'not'\")\n        tokenizer.expect(\"IN\", expected=\"'in' after 'not'\")\n        return Op(\"not in\")\n    elif tokenizer.check(\"OP\"):\n        return Op(tokenizer.read().text)\n    else:\n        return tokenizer.raise_syntax_error(\n            \"Expected marker operator, one of \"\n            \"<=, <, !=, ==, >=, >, ~=, ===, in, not in\"\n        )\n", "pkg_resources/_vendor/packaging/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n__title__ = \"packaging\"\n__summary__ = \"Core utilities for Python packages\"\n__uri__ = \"https://github.com/pypa/packaging\"\n\n__version__ = \"24.0\"\n\n__author__ = \"Donald Stufft and individual contributors\"\n__email__ = \"donald@stufft.io\"\n\n__license__ = \"BSD-2-Clause or Apache-2.0\"\n__copyright__ = \"2014 %s\" % __author__\n", "pkg_resources/_vendor/packaging/specifiers.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier\n    from packaging.version import Version\n\"\"\"\n\nimport abc\nimport itertools\nimport re\nfrom typing import Callable, Iterable, Iterator, List, Optional, Tuple, TypeVar, Union\n\nfrom .utils import canonicalize_version\nfrom .version import Version\n\nUnparsedVersion = Union[Version, str]\nUnparsedVersionVar = TypeVar(\"UnparsedVersionVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[Version, str], bool]\n\n\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\n\n\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n\n    >>> Specifier(\"lolwat\")\n    Traceback (most recent call last):\n        ...\n    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'\n    \"\"\"\n\n\nclass BaseSpecifier(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __str__(self) -> str:\n        \"\"\"\n        Returns the str representation of this Specifier-like object. This\n        should be representative of the Specifier itself.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Returns a hash value for this Specifier-like object.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Returns a boolean representing whether or not the two Specifier-like\n        objects are equal.\n\n        :param other: The other object to check against.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def prereleases(self) -> Optional[bool]:\n        \"\"\"Whether or not pre-releases as a whole are allowed.\n\n        This can be set to either ``True`` or ``False`` to explicitly enable or disable\n        prereleases or it can be set to ``None`` (the default) to use default semantics.\n        \"\"\"\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        \"\"\"Setter for :attr:`prereleases`.\n\n        :param value: The value to set.\n        \"\"\"\n\n    @abc.abstractmethod\n    def contains(self, item: str, prereleases: Optional[bool] = None) -> bool:\n        \"\"\"\n        Determines if the given item is contained within this specifier.\n        \"\"\"\n\n    @abc.abstractmethod\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"\n        Takes an iterable of items and filters them so that only items which\n        are contained within this specifier are allowed in it.\n        \"\"\"\n\n\nclass Specifier(BaseSpecifier):\n    \"\"\"This class abstracts handling of version specifiers.\n\n    .. tip::\n\n        It is generally not required to instantiate this manually. You should instead\n        prefer to work with :class:`SpecifierSet` instead, which can parse\n        comma-separated version specifiers (which is what package metadata contains).\n    \"\"\"\n\n    _operator_regex_str = r\"\"\"\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        \"\"\"\n    _version_regex_str = r\"\"\"\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \\s*\n                [^\\s;)]*  # The arbitrary version can be just about anything,\n                          # we match everything except for whitespace, a\n                          # semi-colon for marker support, and a closing paren\n                          # since versions can be enclosed in them.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n\n                # You cannot use a wild card and a pre-release, post-release, a dev or\n                # local version together so group them with a | and make them optional.\n                (?:\n                    \\.\\*  # Wild card syntax of .*\n                    |\n                    (?:                                  # pre release\n                        [-_\\.]?\n                        (alpha|beta|preview|pre|a|b|c|rc)\n                        [-_\\.]?\n                        [0-9]*\n                    )?\n                    (?:                                  # post release\n                        (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                    )?\n                    (?:[-_\\.]?dev[-_\\.]?[0-9]*)?         # dev release\n                    (?:\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*)? # local\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n        )\n        \"\"\"\n\n    _regex = re.compile(\n        r\"^\\s*\" + _operator_regex_str + _version_regex_str + r\"\\s*$\",\n        re.VERBOSE | re.IGNORECASE,\n    )\n\n    _operators = {\n        \"~=\": \"compatible\",\n        \"==\": \"equal\",\n        \"!=\": \"not_equal\",\n        \"<=\": \"less_than_equal\",\n        \">=\": \"greater_than_equal\",\n        \"<\": \"less_than\",\n        \">\": \"greater_than\",\n        \"===\": \"arbitrary\",\n    }\n\n    def __init__(self, spec: str = \"\", prereleases: Optional[bool] = None) -> None:\n        \"\"\"Initialize a Specifier instance.\n\n        :param spec:\n            The string representation of a specifier which will be parsed and\n            normalized before use.\n        :param prereleases:\n            This tells the specifier if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n        :raises InvalidSpecifier:\n            If the given specifier is invalid (i.e. bad syntax).\n        \"\"\"\n        match = self._regex.search(spec)\n        if not match:\n            raise InvalidSpecifier(f\"Invalid specifier: '{spec}'\")\n\n        self._spec: Tuple[str, str] = (\n            match.group(\"operator\").strip(),\n            match.group(\"version\").strip(),\n        )\n\n        # Store whether or not this Specifier should accept prereleases\n        self._prereleases = prereleases\n\n    # https://github.com/python/mypy/pull/13475#pullrequestreview-1079784515\n    @property  # type: ignore[override]\n    def prereleases(self) -> bool:\n        # If there is an explicit prereleases set for this, then we'll just\n        # blindly use that.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # Look at all of our specifiers and determine if they are inclusive\n        # operators, and if they are if they are including an explicit\n        # prerelease.\n        operator, version = self._spec\n        if operator in [\"==\", \">=\", \"<=\", \"~=\", \"===\"]:\n            # The == specifier can include a trailing .*, if it does we\n            # want to remove before parsing.\n            if operator == \"==\" and version.endswith(\".*\"):\n                version = version[:-2]\n\n            # Parse the version, and if it is a pre-release than this\n            # specifier allows pre-releases.\n            if Version(version).is_prerelease:\n                return True\n\n        return False\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    @property\n    def operator(self) -> str:\n        \"\"\"The operator of this specifier.\n\n        >>> Specifier(\"==1.2.3\").operator\n        '=='\n        \"\"\"\n        return self._spec[0]\n\n    @property\n    def version(self) -> str:\n        \"\"\"The version of this specifier.\n\n        >>> Specifier(\"==1.2.3\").version\n        '1.2.3'\n        \"\"\"\n        return self._spec[1]\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Specifier that shows all internal state.\n\n        >>> Specifier('>=1.0.0')\n        <Specifier('>=1.0.0')>\n        >>> Specifier('>=1.0.0', prereleases=False)\n        <Specifier('>=1.0.0', prereleases=False)>\n        >>> Specifier('>=1.0.0', prereleases=True)\n        <Specifier('>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<{self.__class__.__name__}({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the Specifier that can be round-tripped.\n\n        >>> str(Specifier('>=1.0.0'))\n        '>=1.0.0'\n        >>> str(Specifier('>=1.0.0', prereleases=False))\n        '>=1.0.0'\n        \"\"\"\n        return \"{}{}\".format(*self._spec)\n\n    @property\n    def _canonical_spec(self) -> Tuple[str, str]:\n        canonical_version = canonicalize_version(\n            self._spec[1],\n            strip_trailing_zero=(self._spec[0] != \"~=\"),\n        )\n        return self._spec[0], canonical_version\n\n    def __hash__(self) -> int:\n        return hash(self._canonical_spec)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two Specifier-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> Specifier(\"==1.2.3\") == Specifier(\"== 1.2.3.0\")\n        True\n        >>> (Specifier(\"==1.2.3\", prereleases=False) ==\n        ...  Specifier(\"==1.2.3\", prereleases=True))\n        True\n        >>> Specifier(\"==1.2.3\") == \"==1.2.3\"\n        True\n        >>> Specifier(\"==1.2.3\") == Specifier(\"==1.2.4\")\n        False\n        >>> Specifier(\"==1.2.3\") == Specifier(\"~=1.2.3\")\n        False\n        \"\"\"\n        if isinstance(other, str):\n            try:\n                other = self.__class__(str(other))\n            except InvalidSpecifier:\n                return NotImplemented\n        elif not isinstance(other, self.__class__):\n            return NotImplemented\n\n        return self._canonical_spec == other._canonical_spec\n\n    def _get_operator(self, op: str) -> CallableOperator:\n        operator_callable: CallableOperator = getattr(\n            self, f\"_compare_{self._operators[op]}\"\n        )\n        return operator_callable\n\n    def _compare_compatible(self, prospective: Version, spec: str) -> bool:\n\n        # Compatible releases have an equivalent combination of >= and ==. That\n        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to\n        # implement this in terms of the other specifiers instead of\n        # implementing it ourselves. The only thing we need to do is construct\n        # the other specifiers.\n\n        # We want everything but the last item in the version, but we want to\n        # ignore suffix segments.\n        prefix = _version_join(\n            list(itertools.takewhile(_is_not_suffix, _version_split(spec)))[:-1]\n        )\n\n        # Add the prefix notation to the end of our string\n        prefix += \".*\"\n\n        return self._get_operator(\">=\")(prospective, spec) and self._get_operator(\"==\")(\n            prospective, prefix\n        )\n\n    def _compare_equal(self, prospective: Version, spec: str) -> bool:\n\n        # We need special logic to handle prefix matching\n        if spec.endswith(\".*\"):\n            # In the case of prefix matching we want to ignore local segment.\n            normalized_prospective = canonicalize_version(\n                prospective.public, strip_trailing_zero=False\n            )\n            # Get the normalized version string ignoring the trailing .*\n            normalized_spec = canonicalize_version(spec[:-2], strip_trailing_zero=False)\n            # Split the spec out by bangs and dots, and pretend that there is\n            # an implicit dot in between a release segment and a pre-release segment.\n            split_spec = _version_split(normalized_spec)\n\n            # Split the prospective version out by bangs and dots, and pretend\n            # that there is an implicit dot in between a release segment and\n            # a pre-release segment.\n            split_prospective = _version_split(normalized_prospective)\n\n            # 0-pad the prospective version before shortening it to get the correct\n            # shortened version.\n            padded_prospective, _ = _pad_version(split_prospective, split_spec)\n\n            # Shorten the prospective version to be the same length as the spec\n            # so that we can determine if the specifier is a prefix of the\n            # prospective version or not.\n            shortened_prospective = padded_prospective[: len(split_spec)]\n\n            return shortened_prospective == split_spec\n        else:\n            # Convert our spec string into a Version\n            spec_version = Version(spec)\n\n            # If the specifier does not have a local segment, then we want to\n            # act as if the prospective version also does not have a local\n            # segment.\n            if not spec_version.local:\n                prospective = Version(prospective.public)\n\n            return prospective == spec_version\n\n    def _compare_not_equal(self, prospective: Version, spec: str) -> bool:\n        return not self._compare_equal(prospective, spec)\n\n    def _compare_less_than_equal(self, prospective: Version, spec: str) -> bool:\n\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) <= Version(spec)\n\n    def _compare_greater_than_equal(self, prospective: Version, spec: str) -> bool:\n\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) >= Version(spec)\n\n    def _compare_less_than(self, prospective: Version, spec_str: str) -> bool:\n\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is less than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective < spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a pre-release version, that we do not accept pre-release\n        # versions for the version mentioned in the specifier (e.g. <3.1 should\n        # not match 3.1.dev0, but should match 3.0.dev0).\n        if not spec.is_prerelease and prospective.is_prerelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # less than the spec version *and* it's not a pre-release of the same\n        # version in the spec.\n        return True\n\n    def _compare_greater_than(self, prospective: Version, spec_str: str) -> bool:\n\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is greater than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective > spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a post-release version, that we do not accept\n        # post-release versions for the version mentioned in the specifier\n        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0).\n        if not spec.is_postrelease and prospective.is_postrelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # Ensure that we do not allow a local version of the version mentioned\n        # in the specifier, which is technically greater than, to match.\n        if prospective.local is not None:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # greater than the spec version *and* it's not a pre-release of the\n        # same version in the spec.\n        return True\n\n    def _compare_arbitrary(self, prospective: Version, spec: str) -> bool:\n        return str(prospective).lower() == str(spec).lower()\n\n    def __contains__(self, item: Union[str, Version]) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in Specifier(\">=1.2.3\")\n        True\n        >>> Version(\"1.2.3\") in Specifier(\">=1.2.3\")\n        True\n        >>> \"1.0.0\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(\n        self, item: UnparsedVersion, prereleases: Optional[bool] = None\n    ) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this Specifier. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> Specifier(\">=1.2.3\").contains(\"1.2.3\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(Version(\"1.2.3\"))\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.0.0\")\n        False\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\")\n        False\n        >>> Specifier(\">=1.2.3\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n\n        # Determine if prereleases are to be allowed or not.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # Normalize item to a Version, this allows us to have a shortcut for\n        # \"2.0\" in Specifier(\">=2\")\n        normalized_item = _coerce_version(item)\n\n        # Determine if we should be supporting prereleases in this specifier\n        # or not, if we do not support prereleases than we can short circuit\n        # logic if this version is a prereleases.\n        if normalized_item.is_prerelease and not prereleases:\n            return False\n\n        # Actually do the comparison to determine if this item is contained\n        # within this Specifier or not.\n        operator_callable: CallableOperator = self._get_operator(self.operator)\n        return operator_callable(normalized_item, self.version)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifier.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(Specifier().contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.2.3\", \"1.3\", Version(\"1.4\")]))\n        ['1.2.3', '1.3', <Version('1.4')>]\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        ['1.5a1']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(Specifier(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        \"\"\"\n\n        yielded = False\n        found_prereleases = []\n\n        kw = {\"prereleases\": prereleases if prereleases is not None else True}\n\n        # Attempt to iterate over all the values in the iterable and if any of\n        # them match, yield them.\n        for version in iterable:\n            parsed_version = _coerce_version(version)\n\n            if self.contains(parsed_version, **kw):\n                # If our version is a prerelease, and we were not set to allow\n                # prereleases, then we'll store it for later in case nothing\n                # else matches this specifier.\n                if parsed_version.is_prerelease and not (\n                    prereleases or self.prereleases\n                ):\n                    found_prereleases.append(version)\n                # Either this is not a prerelease, or we should have been\n                # accepting prereleases from the beginning.\n                else:\n                    yielded = True\n                    yield version\n\n        # Now that we've iterated over everything, determine if we've yielded\n        # any values, and if we have not and we have any prereleases stored up\n        # then we will go ahead and yield the prereleases.\n        if not yielded and found_prereleases:\n            for version in found_prereleases:\n                yield version\n\n\n_prefix_regex = re.compile(r\"^([0-9]+)((?:a|b|c|rc)[0-9]+)$\")\n\n\ndef _version_split(version: str) -> List[str]:\n    \"\"\"Split version into components.\n\n    The split components are intended for version comparison. The logic does\n    not attempt to retain the original version string, so joining the\n    components back with :func:`_version_join` may not produce the original\n    version string.\n    \"\"\"\n    result: List[str] = []\n\n    epoch, _, rest = version.rpartition(\"!\")\n    result.append(epoch or \"0\")\n\n    for item in rest.split(\".\"):\n        match = _prefix_regex.search(item)\n        if match:\n            result.extend(match.groups())\n        else:\n            result.append(item)\n    return result\n\n\ndef _version_join(components: List[str]) -> str:\n    \"\"\"Join split version components into a version string.\n\n    This function assumes the input came from :func:`_version_split`, where the\n    first component must be the epoch (either empty or numeric), and all other\n    components numeric.\n    \"\"\"\n    epoch, *rest = components\n    return f\"{epoch}!{'.'.join(rest)}\"\n\n\ndef _is_not_suffix(segment: str) -> bool:\n    return not any(\n        segment.startswith(prefix) for prefix in (\"dev\", \"a\", \"b\", \"rc\", \"post\")\n    )\n\n\ndef _pad_version(left: List[str], right: List[str]) -> Tuple[List[str], List[str]]:\n    left_split, right_split = [], []\n\n    # Get the release segment of our versions\n    left_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))\n    right_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))\n\n    # Get the rest of our versions\n    left_split.append(left[len(left_split[0]) :])\n    right_split.append(right[len(right_split[0]) :])\n\n    # Insert our padding\n    left_split.insert(1, [\"0\"] * max(0, len(right_split[0]) - len(left_split[0])))\n    right_split.insert(1, [\"0\"] * max(0, len(left_split[0]) - len(right_split[0])))\n\n    return (\n        list(itertools.chain.from_iterable(left_split)),\n        list(itertools.chain.from_iterable(right_split)),\n    )\n\n\nclass SpecifierSet(BaseSpecifier):\n    \"\"\"This class abstracts handling of a set of version specifiers.\n\n    It can be passed a single specifier (``>=3.0``), a comma-separated list of\n    specifiers (``>=3.0,!=3.1``), or no specifier at all.\n    \"\"\"\n\n    def __init__(\n        self, specifiers: str = \"\", prereleases: Optional[bool] = None\n    ) -> None:\n        \"\"\"Initialize a SpecifierSet instance.\n\n        :param specifiers:\n            The string representation of a specifier or a comma-separated list of\n            specifiers which will be parsed and normalized before use.\n        :param prereleases:\n            This tells the SpecifierSet if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n\n        :raises InvalidSpecifier:\n            If the given ``specifiers`` are not parseable than this exception will be\n            raised.\n        \"\"\"\n\n        # Split on `,` to break each individual specifier into it's own item, and\n        # strip each item to remove leading/trailing whitespace.\n        split_specifiers = [s.strip() for s in specifiers.split(\",\") if s.strip()]\n\n        # Make each individual specifier a Specifier and save in a frozen set for later.\n        self._specs = frozenset(map(Specifier, split_specifiers))\n\n        # Store our prereleases value so we can use it later to determine if\n        # we accept prereleases or not.\n        self._prereleases = prereleases\n\n    @property\n    def prereleases(self) -> Optional[bool]:\n        # If we have been given an explicit prerelease modifier, then we'll\n        # pass that through here.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # If we don't have any specifiers, and we don't have a forced value,\n        # then we'll just return None since we don't know if this should have\n        # pre-releases or not.\n        if not self._specs:\n            return None\n\n        # Otherwise we'll see if any of the given specifiers accept\n        # prereleases, if any of them do we'll return True, otherwise False.\n        return any(s.prereleases for s in self._specs)\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the specifier set that shows all internal state.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> SpecifierSet('>=1.0.0,!=2.0.0')\n        <SpecifierSet('!=2.0.0,>=1.0.0')>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=False)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=False)>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=True)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<SpecifierSet({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the specifier set that can be round-tripped.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\"))\n        '!=1.0.1,>=1.0.0'\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False))\n        '!=1.0.1,>=1.0.0'\n        \"\"\"\n        return \",\".join(sorted(str(s) for s in self._specs))\n\n    def __hash__(self) -> int:\n        return hash(self._specs)\n\n    def __and__(self, other: Union[\"SpecifierSet\", str]) -> \"SpecifierSet\":\n        \"\"\"Return a SpecifierSet which is a combination of the two sets.\n\n        :param other: The other object to combine with.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & '<=2.0.0,!=2.0.1'\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & SpecifierSet('<=2.0.0,!=2.0.1')\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        \"\"\"\n        if isinstance(other, str):\n            other = SpecifierSet(other)\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        specifier = SpecifierSet()\n        specifier._specs = frozenset(self._specs | other._specs)\n\n        if self._prereleases is None and other._prereleases is not None:\n            specifier._prereleases = other._prereleases\n        elif self._prereleases is not None and other._prereleases is None:\n            specifier._prereleases = self._prereleases\n        elif self._prereleases == other._prereleases:\n            specifier._prereleases = self._prereleases\n        else:\n            raise ValueError(\n                \"Cannot combine SpecifierSets with True and False prerelease \"\n                \"overrides.\"\n            )\n\n        return specifier\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two SpecifierSet-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> (SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False) ==\n        ...  SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == \">=1.0.0,!=1.0.1\"\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.2\")\n        False\n        \"\"\"\n        if isinstance(other, (str, Specifier)):\n            other = SpecifierSet(str(other))\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        return self._specs == other._specs\n\n    def __len__(self) -> int:\n        \"\"\"Returns the number of specifiers in this specifier set.\"\"\"\n        return len(self._specs)\n\n    def __iter__(self) -> Iterator[Specifier]:\n        \"\"\"\n        Returns an iterator over all the underlying :class:`Specifier` instances\n        in this specifier set.\n\n        >>> sorted(SpecifierSet(\">=1.0.0,!=1.0.1\"), key=str)\n        [<Specifier('!=1.0.1')>, <Specifier('>=1.0.0')>]\n        \"\"\"\n        return iter(self._specs)\n\n    def __contains__(self, item: UnparsedVersion) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> Version(\"1.2.3\") in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> \"1.0.1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(\n        self,\n        item: UnparsedVersion,\n        prereleases: Optional[bool] = None,\n        installed: Optional[bool] = None,\n    ) -> bool:\n        \"\"\"Return whether or not the item is contained in this SpecifierSet.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this SpecifierSet. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.2.3\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(Version(\"1.2.3\"))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.0.1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n        # Ensure that our item is a Version instance.\n        if not isinstance(item, Version):\n            item = Version(item)\n\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # We can determine if we're going to allow pre-releases by looking to\n        # see if any of the underlying items supports them. If none of them do\n        # and this item is a pre-release then we do not allow it and we can\n        # short circuit that here.\n        # Note: This means that 1.0.dev1 would not be contained in something\n        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0\n        if not prereleases and item.is_prerelease:\n            return False\n\n        if installed and item.is_prerelease:\n            item = Version(item.base_version)\n\n        # We simply dispatch to the underlying specs here to make sure that the\n        # given version is contained within all of them.\n        # Note: This use of all() here means that an empty set of specifiers\n        #       will always return True, this is an explicit design decision.\n        return all(s.contains(item, prereleases=prereleases) for s in self._specs)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifiers in this set.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(SpecifierSet(...).contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", Version(\"1.4\")]))\n        ['1.3', <Version('1.4')>]\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        []\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n\n        An \"empty\" SpecifierSet will filter items based on the presence of prerelease\n        versions in the set.\n\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\"\").filter([\"1.5a1\"]))\n        ['1.5a1']\n        >>> list(SpecifierSet(\"\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        \"\"\"\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # If we have any specifiers, then we want to wrap our iterable in the\n        # filter method for each one, this will act as a logical AND amongst\n        # each specifier.\n        if self._specs:\n            for spec in self._specs:\n                iterable = spec.filter(iterable, prereleases=bool(prereleases))\n            return iter(iterable)\n        # If we do not have any specifiers, then we need to have a rough filter\n        # which will filter out any pre-releases, unless there are no final\n        # releases.\n        else:\n            filtered: List[UnparsedVersionVar] = []\n            found_prereleases: List[UnparsedVersionVar] = []\n\n            for item in iterable:\n                parsed_version = _coerce_version(item)\n\n                # Store any item which is a pre-release for later unless we've\n                # already found a final version or we are accepting prereleases\n                if parsed_version.is_prerelease and not prereleases:\n                    if not filtered:\n                        found_prereleases.append(item)\n                else:\n                    filtered.append(item)\n\n            # If we've found no items except for pre-releases, then we'll go\n            # ahead and use the pre-releases\n            if not filtered and found_prereleases and prereleases is None:\n                return iter(found_prereleases)\n\n            return iter(filtered)\n", "pkg_resources/_vendor/packaging/markers.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport operator\nimport os\nimport platform\nimport sys\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\n\nfrom ._parser import (\n    MarkerAtom,\n    MarkerList,\n    Op,\n    Value,\n    Variable,\n    parse_marker as _parse_marker,\n)\nfrom ._tokenizer import ParserSyntaxError\nfrom .specifiers import InvalidSpecifier, Specifier\nfrom .utils import canonicalize_name\n\n__all__ = [\n    \"InvalidMarker\",\n    \"UndefinedComparison\",\n    \"UndefinedEnvironmentName\",\n    \"Marker\",\n    \"default_environment\",\n]\n\nOperator = Callable[[str, str], bool]\n\n\nclass InvalidMarker(ValueError):\n    \"\"\"\n    An invalid marker was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\n\n\nclass UndefinedEnvironmentName(ValueError):\n    \"\"\"\n    A name was attempted to be used that does not exist inside of the\n    environment.\n    \"\"\"\n\n\ndef _normalize_extra_values(results: Any) -> Any:\n    \"\"\"\n    Normalize extra values.\n    \"\"\"\n    if isinstance(results[0], tuple):\n        lhs, op, rhs = results[0]\n        if isinstance(lhs, Variable) and lhs.value == \"extra\":\n            normalized_extra = canonicalize_name(rhs.value)\n            rhs = Value(normalized_extra)\n        elif isinstance(rhs, Variable) and rhs.value == \"extra\":\n            normalized_extra = canonicalize_name(lhs.value)\n            lhs = Value(normalized_extra)\n        results[0] = lhs, op, rhs\n    return results\n\n\ndef _format_marker(\n    marker: Union[List[str], MarkerAtom, str], first: Optional[bool] = True\n) -> str:\n\n    assert isinstance(marker, (list, tuple, str))\n\n    # Sometimes we have a structure like [[...]] which is a single item list\n    # where the single item is itself it's own list. In that case we want skip\n    # the rest of this function so that we don't get extraneous () on the\n    # outside.\n    if (\n        isinstance(marker, list)\n        and len(marker) == 1\n        and isinstance(marker[0], (list, tuple))\n    ):\n        return _format_marker(marker[0])\n\n    if isinstance(marker, list):\n        inner = (_format_marker(m, first=False) for m in marker)\n        if first:\n            return \" \".join(inner)\n        else:\n            return \"(\" + \" \".join(inner) + \")\"\n    elif isinstance(marker, tuple):\n        return \" \".join([m.serialize() for m in marker])\n    else:\n        return marker\n\n\n_operators: Dict[str, Operator] = {\n    \"in\": lambda lhs, rhs: lhs in rhs,\n    \"not in\": lambda lhs, rhs: lhs not in rhs,\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \"==\": operator.eq,\n    \"!=\": operator.ne,\n    \">=\": operator.ge,\n    \">\": operator.gt,\n}\n\n\ndef _eval_op(lhs: str, op: Op, rhs: str) -> bool:\n    try:\n        spec = Specifier(\"\".join([op.serialize(), rhs]))\n    except InvalidSpecifier:\n        pass\n    else:\n        return spec.contains(lhs, prereleases=True)\n\n    oper: Optional[Operator] = _operators.get(op.serialize())\n    if oper is None:\n        raise UndefinedComparison(f\"Undefined {op!r} on {lhs!r} and {rhs!r}.\")\n\n    return oper(lhs, rhs)\n\n\ndef _normalize(*values: str, key: str) -> Tuple[str, ...]:\n    # PEP 685 \u2013 Comparison of extra names for optional distribution dependencies\n    # https://peps.python.org/pep-0685/\n    # > When comparing extra names, tools MUST normalize the names being\n    # > compared using the semantics outlined in PEP 503 for names\n    if key == \"extra\":\n        return tuple(canonicalize_name(v) for v in values)\n\n    # other environment markers don't have such standards\n    return values\n\n\ndef _evaluate_markers(markers: MarkerList, environment: Dict[str, str]) -> bool:\n    groups: List[List[bool]] = [[]]\n\n    for marker in markers:\n        assert isinstance(marker, (list, tuple, str))\n\n        if isinstance(marker, list):\n            groups[-1].append(_evaluate_markers(marker, environment))\n        elif isinstance(marker, tuple):\n            lhs, op, rhs = marker\n\n            if isinstance(lhs, Variable):\n                environment_key = lhs.value\n                lhs_value = environment[environment_key]\n                rhs_value = rhs.value\n            else:\n                lhs_value = lhs.value\n                environment_key = rhs.value\n                rhs_value = environment[environment_key]\n\n            lhs_value, rhs_value = _normalize(lhs_value, rhs_value, key=environment_key)\n            groups[-1].append(_eval_op(lhs_value, op, rhs_value))\n        else:\n            assert marker in [\"and\", \"or\"]\n            if marker == \"or\":\n                groups.append([])\n\n    return any(all(item) for item in groups)\n\n\ndef format_full_version(info: \"sys._version_info\") -> str:\n    version = \"{0.major}.{0.minor}.{0.micro}\".format(info)\n    kind = info.releaselevel\n    if kind != \"final\":\n        version += kind[0] + str(info.serial)\n    return version\n\n\ndef default_environment() -> Dict[str, str]:\n    iver = format_full_version(sys.implementation.version)\n    implementation_name = sys.implementation.name\n    return {\n        \"implementation_name\": implementation_name,\n        \"implementation_version\": iver,\n        \"os_name\": os.name,\n        \"platform_machine\": platform.machine(),\n        \"platform_release\": platform.release(),\n        \"platform_system\": platform.system(),\n        \"platform_version\": platform.version(),\n        \"python_full_version\": platform.python_version(),\n        \"platform_python_implementation\": platform.python_implementation(),\n        \"python_version\": \".\".join(platform.python_version_tuple()[:2]),\n        \"sys_platform\": sys.platform,\n    }\n\n\nclass Marker:\n    def __init__(self, marker: str) -> None:\n        # Note: We create a Marker object without calling this constructor in\n        #       packaging.requirements.Requirement. If any additional logic is\n        #       added here, make sure to mirror/adapt Requirement.\n        try:\n            self._markers = _normalize_extra_values(_parse_marker(marker))\n            # The attribute `_markers` can be described in terms of a recursive type:\n            # MarkerList = List[Union[Tuple[Node, ...], str, MarkerList]]\n            #\n            # For example, the following expression:\n            # python_version > \"3.6\" or (python_version == \"3.6\" and os_name == \"unix\")\n            #\n            # is parsed into:\n            # [\n            #     (<Variable('python_version')>, <Op('>')>, <Value('3.6')>),\n            #     'and',\n            #     [\n            #         (<Variable('python_version')>, <Op('==')>, <Value('3.6')>),\n            #         'or',\n            #         (<Variable('os_name')>, <Op('==')>, <Value('unix')>)\n            #     ]\n            # ]\n        except ParserSyntaxError as e:\n            raise InvalidMarker(str(e)) from e\n\n    def __str__(self) -> str:\n        return _format_marker(self._markers)\n\n    def __repr__(self) -> str:\n        return f\"<Marker('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash((self.__class__.__name__, str(self)))\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Marker):\n            return NotImplemented\n\n        return str(self) == str(other)\n\n    def evaluate(self, environment: Optional[Dict[str, str]] = None) -> bool:\n        \"\"\"Evaluate a marker.\n\n        Return the boolean from evaluating the given marker against the\n        environment. environment is an optional argument to override all or\n        part of the determined environment.\n\n        The environment is determined from the current Python process.\n        \"\"\"\n        current_environment = default_environment()\n        current_environment[\"extra\"] = \"\"\n        if environment is not None:\n            current_environment.update(environment)\n            # The API used to allow setting extra to None. We need to handle this\n            # case for backwards compatibility.\n            if current_environment[\"extra\"] is None:\n                current_environment[\"extra\"] = \"\"\n\n        return _evaluate_markers(self._markers, current_environment)\n", "pkg_resources/_vendor/backports/tarfile.py": "#!/usr/bin/env python3\n#-------------------------------------------------------------------\n# tarfile.py\n#-------------------------------------------------------------------\n# Copyright (C) 2002 Lars Gustaebel <lars@gustaebel.de>\n# All rights reserved.\n#\n# Permission  is  hereby granted,  free  of charge,  to  any person\n# obtaining a  copy of  this software  and associated documentation\n# files  (the  \"Software\"),  to   deal  in  the  Software   without\n# restriction,  including  without limitation  the  rights to  use,\n# copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies  of  the  Software,  and to  permit  persons  to  whom the\n# Software  is  furnished  to  do  so,  subject  to  the  following\n# conditions:\n#\n# The above copyright  notice and this  permission notice shall  be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS  IS\", WITHOUT WARRANTY OF ANY  KIND,\n# EXPRESS OR IMPLIED, INCLUDING  BUT NOT LIMITED TO  THE WARRANTIES\n# OF  MERCHANTABILITY,  FITNESS   FOR  A  PARTICULAR   PURPOSE  AND\n# NONINFRINGEMENT.  IN  NO  EVENT SHALL  THE  AUTHORS  OR COPYRIGHT\n# HOLDERS  BE LIABLE  FOR ANY  CLAIM, DAMAGES  OR OTHER  LIABILITY,\n# WHETHER  IN AN  ACTION OF  CONTRACT, TORT  OR OTHERWISE,  ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n# OTHER DEALINGS IN THE SOFTWARE.\n#\n\"\"\"Read from and write to tar format archives.\n\"\"\"\n\nversion     = \"0.9.0\"\n__author__  = \"Lars Gust\\u00e4bel (lars@gustaebel.de)\"\n__credits__ = \"Gustavo Niemeyer, Niels Gust\\u00e4bel, Richard Townsend.\"\n\n#---------\n# Imports\n#---------\nfrom builtins import open as bltn_open\nimport sys\nimport os\nimport io\nimport shutil\nimport stat\nimport time\nimport struct\nimport copy\nimport re\nimport warnings\n\ntry:\n    import pwd\nexcept ImportError:\n    pwd = None\ntry:\n    import grp\nexcept ImportError:\n    grp = None\n\n# os.symlink on Windows prior to 6.0 raises NotImplementedError\n# OSError (winerror=1314) will be raised if the caller does not hold the\n# SeCreateSymbolicLinkPrivilege privilege\nsymlink_exception = (AttributeError, NotImplementedError, OSError)\n\n# from tarfile import *\n__all__ = [\"TarFile\", \"TarInfo\", \"is_tarfile\", \"TarError\", \"ReadError\",\n           \"CompressionError\", \"StreamError\", \"ExtractError\", \"HeaderError\",\n           \"ENCODING\", \"USTAR_FORMAT\", \"GNU_FORMAT\", \"PAX_FORMAT\",\n           \"DEFAULT_FORMAT\", \"open\",\"fully_trusted_filter\", \"data_filter\",\n           \"tar_filter\", \"FilterError\", \"AbsoluteLinkError\",\n           \"OutsideDestinationError\", \"SpecialFileError\", \"AbsolutePathError\",\n           \"LinkOutsideDestinationError\"]\n\n\n#---------------------------------------------------------\n# tar constants\n#---------------------------------------------------------\nNUL = b\"\\0\"                     # the null character\nBLOCKSIZE = 512                 # length of processing blocks\nRECORDSIZE = BLOCKSIZE * 20     # length of records\nGNU_MAGIC = b\"ustar  \\0\"        # magic gnu tar string\nPOSIX_MAGIC = b\"ustar\\x0000\"    # magic posix tar string\n\nLENGTH_NAME = 100               # maximum length of a filename\nLENGTH_LINK = 100               # maximum length of a linkname\nLENGTH_PREFIX = 155             # maximum length of the prefix field\n\nREGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file\n\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\n\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\n\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT\n\n#---------------------------------------------------------\n# tarfile constants\n#---------------------------------------------------------\n# File types that tarfile supports:\nSUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,\n                   SYMTYPE, DIRTYPE, FIFOTYPE,\n                   CONTTYPE, CHRTYPE, BLKTYPE,\n                   GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\n                   GNUTYPE_SPARSE)\n\n# File types that will be treated as a regular file.\nREGULAR_TYPES = (REGTYPE, AREGTYPE,\n                 CONTTYPE, GNUTYPE_SPARSE)\n\n# File types that are part of the GNU tar format.\nGNU_TYPES = (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\n             GNUTYPE_SPARSE)\n\n# Fields from a pax header that override a TarInfo attribute.\nPAX_FIELDS = (\"path\", \"linkpath\", \"size\", \"mtime\",\n              \"uid\", \"gid\", \"uname\", \"gname\")\n\n# Fields from a pax header that are affected by hdrcharset.\nPAX_NAME_FIELDS = {\"path\", \"linkpath\", \"uname\", \"gname\"}\n\n# Fields in a pax header that are numbers, all other fields\n# are treated as strings.\nPAX_NUMBER_FIELDS = {\n    \"atime\": float,\n    \"ctime\": float,\n    \"mtime\": float,\n    \"uid\": int,\n    \"gid\": int,\n    \"size\": int\n}\n\n#---------------------------------------------------------\n# initialization\n#---------------------------------------------------------\nif os.name == \"nt\":\n    ENCODING = \"utf-8\"\nelse:\n    ENCODING = sys.getfilesystemencoding()\n\n#---------------------------------------------------------\n# Some useful functions\n#---------------------------------------------------------\n\ndef stn(s, length, encoding, errors):\n    \"\"\"Convert a string to a null-terminated bytes object.\n    \"\"\"\n    if s is None:\n        raise ValueError(\"metadata cannot contain None\")\n    s = s.encode(encoding, errors)\n    return s[:length] + (length - len(s)) * NUL\n\ndef nts(s, encoding, errors):\n    \"\"\"Convert a null-terminated bytes object to a string.\n    \"\"\"\n    p = s.find(b\"\\0\")\n    if p != -1:\n        s = s[:p]\n    return s.decode(encoding, errors)\n\ndef nti(s):\n    \"\"\"Convert a number field to a python number.\n    \"\"\"\n    # There are two possible encodings for a number field, see\n    # itn() below.\n    if s[0] in (0o200, 0o377):\n        n = 0\n        for i in range(len(s) - 1):\n            n <<= 8\n            n += s[i + 1]\n        if s[0] == 0o377:\n            n = -(256 ** (len(s) - 1) - n)\n    else:\n        try:\n            s = nts(s, \"ascii\", \"strict\")\n            n = int(s.strip() or \"0\", 8)\n        except ValueError:\n            raise InvalidHeaderError(\"invalid header\")\n    return n\n\ndef itn(n, digits=8, format=DEFAULT_FORMAT):\n    \"\"\"Convert a python number to a number field.\n    \"\"\"\n    # POSIX 1003.1-1988 requires numbers to be encoded as a string of\n    # octal digits followed by a null-byte, this allows values up to\n    # (8**(digits-1))-1. GNU tar allows storing numbers greater than\n    # that if necessary. A leading 0o200 or 0o377 byte indicate this\n    # particular encoding, the following digits-1 bytes are a big-endian\n    # base-256 representation. This allows values up to (256**(digits-1))-1.\n    # A 0o200 byte indicates a positive number, a 0o377 byte a negative\n    # number.\n    original_n = n\n    n = int(n)\n    if 0 <= n < 8 ** (digits - 1):\n        s = bytes(\"%0*o\" % (digits - 1, n), \"ascii\") + NUL\n    elif format == GNU_FORMAT and -256 ** (digits - 1) <= n < 256 ** (digits - 1):\n        if n >= 0:\n            s = bytearray([0o200])\n        else:\n            s = bytearray([0o377])\n            n = 256 ** digits + n\n\n        for i in range(digits - 1):\n            s.insert(1, n & 0o377)\n            n >>= 8\n    else:\n        raise ValueError(\"overflow in number field\")\n\n    return s\n\ndef calc_chksums(buf):\n    \"\"\"Calculate the checksum for a member's header by summing up all\n       characters except for the chksum field which is treated as if\n       it was filled with spaces. According to the GNU tar sources,\n       some tars (Sun and NeXT) calculate chksum with signed char,\n       which will be different if there are chars in the buffer with\n       the high bit set. So we calculate two checksums, unsigned and\n       signed.\n    \"\"\"\n    unsigned_chksum = 256 + sum(struct.unpack_from(\"148B8x356B\", buf))\n    signed_chksum = 256 + sum(struct.unpack_from(\"148b8x356b\", buf))\n    return unsigned_chksum, signed_chksum\n\ndef copyfileobj(src, dst, length=None, exception=OSError, bufsize=None):\n    \"\"\"Copy length bytes from fileobj src to fileobj dst.\n       If length is None, copy the entire content.\n    \"\"\"\n    bufsize = bufsize or 16 * 1024\n    if length == 0:\n        return\n    if length is None:\n        shutil.copyfileobj(src, dst, bufsize)\n        return\n\n    blocks, remainder = divmod(length, bufsize)\n    for b in range(blocks):\n        buf = src.read(bufsize)\n        if len(buf) < bufsize:\n            raise exception(\"unexpected end of data\")\n        dst.write(buf)\n\n    if remainder != 0:\n        buf = src.read(remainder)\n        if len(buf) < remainder:\n            raise exception(\"unexpected end of data\")\n        dst.write(buf)\n    return\n\ndef _safe_print(s):\n    encoding = getattr(sys.stdout, 'encoding', None)\n    if encoding is not None:\n        s = s.encode(encoding, 'backslashreplace').decode(encoding)\n    print(s, end=' ')\n\n\nclass TarError(Exception):\n    \"\"\"Base exception.\"\"\"\n    pass\nclass ExtractError(TarError):\n    \"\"\"General exception for extract errors.\"\"\"\n    pass\nclass ReadError(TarError):\n    \"\"\"Exception for unreadable tar archives.\"\"\"\n    pass\nclass CompressionError(TarError):\n    \"\"\"Exception for unavailable compression methods.\"\"\"\n    pass\nclass StreamError(TarError):\n    \"\"\"Exception for unsupported operations on stream-like TarFiles.\"\"\"\n    pass\nclass HeaderError(TarError):\n    \"\"\"Base exception for header errors.\"\"\"\n    pass\nclass EmptyHeaderError(HeaderError):\n    \"\"\"Exception for empty headers.\"\"\"\n    pass\nclass TruncatedHeaderError(HeaderError):\n    \"\"\"Exception for truncated headers.\"\"\"\n    pass\nclass EOFHeaderError(HeaderError):\n    \"\"\"Exception for end of file headers.\"\"\"\n    pass\nclass InvalidHeaderError(HeaderError):\n    \"\"\"Exception for invalid headers.\"\"\"\n    pass\nclass SubsequentHeaderError(HeaderError):\n    \"\"\"Exception for missing and invalid extended headers.\"\"\"\n    pass\n\n#---------------------------\n# internal stream interface\n#---------------------------\nclass _LowLevelFile:\n    \"\"\"Low-level file object. Supports reading and writing.\n       It is used instead of a regular file object for streaming\n       access.\n    \"\"\"\n\n    def __init__(self, name, mode):\n        mode = {\n            \"r\": os.O_RDONLY,\n            \"w\": os.O_WRONLY | os.O_CREAT | os.O_TRUNC,\n        }[mode]\n        if hasattr(os, \"O_BINARY\"):\n            mode |= os.O_BINARY\n        self.fd = os.open(name, mode, 0o666)\n\n    def close(self):\n        os.close(self.fd)\n\n    def read(self, size):\n        return os.read(self.fd, size)\n\n    def write(self, s):\n        os.write(self.fd, s)\n\nclass _Stream:\n    \"\"\"Class that serves as an adapter between TarFile and\n       a stream-like object.  The stream-like object only\n       needs to have a read() or write() method that works with bytes,\n       and the method is accessed blockwise.\n       Use of gzip or bzip2 compression is possible.\n       A stream-like object could be for example: sys.stdin.buffer,\n       sys.stdout.buffer, a socket, a tape device etc.\n\n       _Stream is intended to be used only internally.\n    \"\"\"\n\n    def __init__(self, name, mode, comptype, fileobj, bufsize,\n                 compresslevel):\n        \"\"\"Construct a _Stream object.\n        \"\"\"\n        self._extfileobj = True\n        if fileobj is None:\n            fileobj = _LowLevelFile(name, mode)\n            self._extfileobj = False\n\n        if comptype == '*':\n            # Enable transparent compression detection for the\n            # stream interface\n            fileobj = _StreamProxy(fileobj)\n            comptype = fileobj.getcomptype()\n\n        self.name     = name or \"\"\n        self.mode     = mode\n        self.comptype = comptype\n        self.fileobj  = fileobj\n        self.bufsize  = bufsize\n        self.buf      = b\"\"\n        self.pos      = 0\n        self.closed   = False\n\n        try:\n            if comptype == \"gz\":\n                try:\n                    import zlib\n                except ImportError:\n                    raise CompressionError(\"zlib module is not available\") from None\n                self.zlib = zlib\n                self.crc = zlib.crc32(b\"\")\n                if mode == \"r\":\n                    self.exception = zlib.error\n                    self._init_read_gz()\n                else:\n                    self._init_write_gz(compresslevel)\n\n            elif comptype == \"bz2\":\n                try:\n                    import bz2\n                except ImportError:\n                    raise CompressionError(\"bz2 module is not available\") from None\n                if mode == \"r\":\n                    self.dbuf = b\"\"\n                    self.cmp = bz2.BZ2Decompressor()\n                    self.exception = OSError\n                else:\n                    self.cmp = bz2.BZ2Compressor(compresslevel)\n\n            elif comptype == \"xz\":\n                try:\n                    import lzma\n                except ImportError:\n                    raise CompressionError(\"lzma module is not available\") from None\n                if mode == \"r\":\n                    self.dbuf = b\"\"\n                    self.cmp = lzma.LZMADecompressor()\n                    self.exception = lzma.LZMAError\n                else:\n                    self.cmp = lzma.LZMACompressor()\n\n            elif comptype != \"tar\":\n                raise CompressionError(\"unknown compression type %r\" % comptype)\n\n        except:\n            if not self._extfileobj:\n                self.fileobj.close()\n            self.closed = True\n            raise\n\n    def __del__(self):\n        if hasattr(self, \"closed\") and not self.closed:\n            self.close()\n\n    def _init_write_gz(self, compresslevel):\n        \"\"\"Initialize for writing with gzip compression.\n        \"\"\"\n        self.cmp = self.zlib.compressobj(compresslevel,\n                                         self.zlib.DEFLATED,\n                                         -self.zlib.MAX_WBITS,\n                                         self.zlib.DEF_MEM_LEVEL,\n                                         0)\n        timestamp = struct.pack(\"<L\", int(time.time()))\n        self.__write(b\"\\037\\213\\010\\010\" + timestamp + b\"\\002\\377\")\n        if self.name.endswith(\".gz\"):\n            self.name = self.name[:-3]\n        # Honor \"directory components removed\" from RFC1952\n        self.name = os.path.basename(self.name)\n        # RFC1952 says we must use ISO-8859-1 for the FNAME field.\n        self.__write(self.name.encode(\"iso-8859-1\", \"replace\") + NUL)\n\n    def write(self, s):\n        \"\"\"Write string s to the stream.\n        \"\"\"\n        if self.comptype == \"gz\":\n            self.crc = self.zlib.crc32(s, self.crc)\n        self.pos += len(s)\n        if self.comptype != \"tar\":\n            s = self.cmp.compress(s)\n        self.__write(s)\n\n    def __write(self, s):\n        \"\"\"Write string s to the stream if a whole new block\n           is ready to be written.\n        \"\"\"\n        self.buf += s\n        while len(self.buf) > self.bufsize:\n            self.fileobj.write(self.buf[:self.bufsize])\n            self.buf = self.buf[self.bufsize:]\n\n    def close(self):\n        \"\"\"Close the _Stream object. No operation should be\n           done on it afterwards.\n        \"\"\"\n        if self.closed:\n            return\n\n        self.closed = True\n        try:\n            if self.mode == \"w\" and self.comptype != \"tar\":\n                self.buf += self.cmp.flush()\n\n            if self.mode == \"w\" and self.buf:\n                self.fileobj.write(self.buf)\n                self.buf = b\"\"\n                if self.comptype == \"gz\":\n                    self.fileobj.write(struct.pack(\"<L\", self.crc))\n                    self.fileobj.write(struct.pack(\"<L\", self.pos & 0xffffFFFF))\n        finally:\n            if not self._extfileobj:\n                self.fileobj.close()\n\n    def _init_read_gz(self):\n        \"\"\"Initialize for reading a gzip compressed fileobj.\n        \"\"\"\n        self.cmp = self.zlib.decompressobj(-self.zlib.MAX_WBITS)\n        self.dbuf = b\"\"\n\n        # taken from gzip.GzipFile with some alterations\n        if self.__read(2) != b\"\\037\\213\":\n            raise ReadError(\"not a gzip file\")\n        if self.__read(1) != b\"\\010\":\n            raise CompressionError(\"unsupported compression method\")\n\n        flag = ord(self.__read(1))\n        self.__read(6)\n\n        if flag & 4:\n            xlen = ord(self.__read(1)) + 256 * ord(self.__read(1))\n            self.read(xlen)\n        if flag & 8:\n            while True:\n                s = self.__read(1)\n                if not s or s == NUL:\n                    break\n        if flag & 16:\n            while True:\n                s = self.__read(1)\n                if not s or s == NUL:\n                    break\n        if flag & 2:\n            self.__read(2)\n\n    def tell(self):\n        \"\"\"Return the stream's file pointer position.\n        \"\"\"\n        return self.pos\n\n    def seek(self, pos=0):\n        \"\"\"Set the stream's file pointer to pos. Negative seeking\n           is forbidden.\n        \"\"\"\n        if pos - self.pos >= 0:\n            blocks, remainder = divmod(pos - self.pos, self.bufsize)\n            for i in range(blocks):\n                self.read(self.bufsize)\n            self.read(remainder)\n        else:\n            raise StreamError(\"seeking backwards is not allowed\")\n        return self.pos\n\n    def read(self, size):\n        \"\"\"Return the next size number of bytes from the stream.\"\"\"\n        assert size is not None\n        buf = self._read(size)\n        self.pos += len(buf)\n        return buf\n\n    def _read(self, size):\n        \"\"\"Return size bytes from the stream.\n        \"\"\"\n        if self.comptype == \"tar\":\n            return self.__read(size)\n\n        c = len(self.dbuf)\n        t = [self.dbuf]\n        while c < size:\n            # Skip underlying buffer to avoid unaligned double buffering.\n            if self.buf:\n                buf = self.buf\n                self.buf = b\"\"\n            else:\n                buf = self.fileobj.read(self.bufsize)\n                if not buf:\n                    break\n            try:\n                buf = self.cmp.decompress(buf)\n            except self.exception as e:\n                raise ReadError(\"invalid compressed data\") from e\n            t.append(buf)\n            c += len(buf)\n        t = b\"\".join(t)\n        self.dbuf = t[size:]\n        return t[:size]\n\n    def __read(self, size):\n        \"\"\"Return size bytes from stream. If internal buffer is empty,\n           read another block from the stream.\n        \"\"\"\n        c = len(self.buf)\n        t = [self.buf]\n        while c < size:\n            buf = self.fileobj.read(self.bufsize)\n            if not buf:\n                break\n            t.append(buf)\n            c += len(buf)\n        t = b\"\".join(t)\n        self.buf = t[size:]\n        return t[:size]\n# class _Stream\n\nclass _StreamProxy(object):\n    \"\"\"Small proxy class that enables transparent compression\n       detection for the Stream interface (mode 'r|*').\n    \"\"\"\n\n    def __init__(self, fileobj):\n        self.fileobj = fileobj\n        self.buf = self.fileobj.read(BLOCKSIZE)\n\n    def read(self, size):\n        self.read = self.fileobj.read\n        return self.buf\n\n    def getcomptype(self):\n        if self.buf.startswith(b\"\\x1f\\x8b\\x08\"):\n            return \"gz\"\n        elif self.buf[0:3] == b\"BZh\" and self.buf[4:10] == b\"1AY&SY\":\n            return \"bz2\"\n        elif self.buf.startswith((b\"\\x5d\\x00\\x00\\x80\", b\"\\xfd7zXZ\")):\n            return \"xz\"\n        else:\n            return \"tar\"\n\n    def close(self):\n        self.fileobj.close()\n# class StreamProxy\n\n#------------------------\n# Extraction file object\n#------------------------\nclass _FileInFile(object):\n    \"\"\"A thin wrapper around an existing file object that\n       provides a part of its data as an individual file\n       object.\n    \"\"\"\n\n    def __init__(self, fileobj, offset, size, name, blockinfo=None):\n        self.fileobj = fileobj\n        self.offset = offset\n        self.size = size\n        self.position = 0\n        self.name = name\n        self.closed = False\n\n        if blockinfo is None:\n            blockinfo = [(0, size)]\n\n        # Construct a map with data and zero blocks.\n        self.map_index = 0\n        self.map = []\n        lastpos = 0\n        realpos = self.offset\n        for offset, size in blockinfo:\n            if offset > lastpos:\n                self.map.append((False, lastpos, offset, None))\n            self.map.append((True, offset, offset + size, realpos))\n            realpos += size\n            lastpos = offset + size\n        if lastpos < self.size:\n            self.map.append((False, lastpos, self.size, None))\n\n    def flush(self):\n        pass\n\n    def readable(self):\n        return True\n\n    def writable(self):\n        return False\n\n    def seekable(self):\n        return self.fileobj.seekable()\n\n    def tell(self):\n        \"\"\"Return the current file position.\n        \"\"\"\n        return self.position\n\n    def seek(self, position, whence=io.SEEK_SET):\n        \"\"\"Seek to a position in the file.\n        \"\"\"\n        if whence == io.SEEK_SET:\n            self.position = min(max(position, 0), self.size)\n        elif whence == io.SEEK_CUR:\n            if position < 0:\n                self.position = max(self.position + position, 0)\n            else:\n                self.position = min(self.position + position, self.size)\n        elif whence == io.SEEK_END:\n            self.position = max(min(self.size + position, self.size), 0)\n        else:\n            raise ValueError(\"Invalid argument\")\n        return self.position\n\n    def read(self, size=None):\n        \"\"\"Read data from the file.\n        \"\"\"\n        if size is None:\n            size = self.size - self.position\n        else:\n            size = min(size, self.size - self.position)\n\n        buf = b\"\"\n        while size > 0:\n            while True:\n                data, start, stop, offset = self.map[self.map_index]\n                if start <= self.position < stop:\n                    break\n                else:\n                    self.map_index += 1\n                    if self.map_index == len(self.map):\n                        self.map_index = 0\n            length = min(size, stop - self.position)\n            if data:\n                self.fileobj.seek(offset + (self.position - start))\n                b = self.fileobj.read(length)\n                if len(b) != length:\n                    raise ReadError(\"unexpected end of data\")\n                buf += b\n            else:\n                buf += NUL * length\n            size -= length\n            self.position += length\n        return buf\n\n    def readinto(self, b):\n        buf = self.read(len(b))\n        b[:len(buf)] = buf\n        return len(buf)\n\n    def close(self):\n        self.closed = True\n#class _FileInFile\n\nclass ExFileObject(io.BufferedReader):\n\n    def __init__(self, tarfile, tarinfo):\n        fileobj = _FileInFile(tarfile.fileobj, tarinfo.offset_data,\n                tarinfo.size, tarinfo.name, tarinfo.sparse)\n        super().__init__(fileobj)\n#class ExFileObject\n\n\n#-----------------------------\n# extraction filters (PEP 706)\n#-----------------------------\n\nclass FilterError(TarError):\n    pass\n\nclass AbsolutePathError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'member {tarinfo.name!r} has an absolute path')\n\nclass OutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):\n        self.tarinfo = tarinfo\n        self._path = path\n        super().__init__(f'{tarinfo.name!r} would be extracted to {path!r}, '\n                         + 'which is outside the destination')\n\nclass SpecialFileError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'{tarinfo.name!r} is a special file')\n\nclass AbsoluteLinkError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'{tarinfo.name!r} is a link to an absolute path')\n\nclass LinkOutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):\n        self.tarinfo = tarinfo\n        self._path = path\n        super().__init__(f'{tarinfo.name!r} would link to {path!r}, '\n                         + 'which is outside the destination')\n\ndef _get_filtered_attrs(member, dest_path, for_data=True):\n    new_attrs = {}\n    name = member.name\n    dest_path = os.path.realpath(dest_path)\n    # Strip leading / (tar's directory separator) from filenames.\n    # Include os.sep (target OS directory separator) as well.\n    if name.startswith(('/', os.sep)):\n        name = new_attrs['name'] = member.path.lstrip('/' + os.sep)\n    if os.path.isabs(name):\n        # Path is absolute even after stripping.\n        # For example, 'C:/foo' on Windows.\n        raise AbsolutePathError(member)\n    # Ensure we stay in the destination\n    target_path = os.path.realpath(os.path.join(dest_path, name))\n    if os.path.commonpath([target_path, dest_path]) != dest_path:\n        raise OutsideDestinationError(member, target_path)\n    # Limit permissions (no high bits, and go-w)\n    mode = member.mode\n    if mode is not None:\n        # Strip high bits & group/other write bits\n        mode = mode & 0o755\n        if for_data:\n            # For data, handle permissions & file types\n            if member.isreg() or member.islnk():\n                if not mode & 0o100:\n                    # Clear executable bits if not executable by user\n                    mode &= ~0o111\n                # Ensure owner can read & write\n                mode |= 0o600\n            elif member.isdir() or member.issym():\n                # Ignore mode for directories & symlinks\n                mode = None\n            else:\n                # Reject special files\n                raise SpecialFileError(member)\n        if mode != member.mode:\n            new_attrs['mode'] = mode\n    if for_data:\n        # Ignore ownership for 'data'\n        if member.uid is not None:\n            new_attrs['uid'] = None\n        if member.gid is not None:\n            new_attrs['gid'] = None\n        if member.uname is not None:\n            new_attrs['uname'] = None\n        if member.gname is not None:\n            new_attrs['gname'] = None\n        # Check link destination for 'data'\n        if member.islnk() or member.issym():\n            if os.path.isabs(member.linkname):\n                raise AbsoluteLinkError(member)\n            if member.issym():\n                target_path = os.path.join(dest_path,\n                                           os.path.dirname(name),\n                                           member.linkname)\n            else:\n                target_path = os.path.join(dest_path,\n                                           member.linkname)\n            target_path = os.path.realpath(target_path)\n            if os.path.commonpath([target_path, dest_path]) != dest_path:\n                raise LinkOutsideDestinationError(member, target_path)\n    return new_attrs\n\ndef fully_trusted_filter(member, dest_path):\n    return member\n\ndef tar_filter(member, dest_path):\n    new_attrs = _get_filtered_attrs(member, dest_path, False)\n    if new_attrs:\n        return member.replace(**new_attrs, deep=False)\n    return member\n\ndef data_filter(member, dest_path):\n    new_attrs = _get_filtered_attrs(member, dest_path, True)\n    if new_attrs:\n        return member.replace(**new_attrs, deep=False)\n    return member\n\n_NAMED_FILTERS = {\n    \"fully_trusted\": fully_trusted_filter,\n    \"tar\": tar_filter,\n    \"data\": data_filter,\n}\n\n#------------------\n# Exported Classes\n#------------------\n\n# Sentinel for replace() defaults, meaning \"don't change the attribute\"\n_KEEP = object()\n\nclass TarInfo(object):\n    \"\"\"Informational class which holds the details about an\n       archive member given by a tar header block.\n       TarInfo objects are returned by TarFile.getmember(),\n       TarFile.getmembers() and TarFile.gettarinfo() and are\n       usually created internally.\n    \"\"\"\n\n    __slots__ = dict(\n        name = 'Name of the archive member.',\n        mode = 'Permission bits.',\n        uid = 'User ID of the user who originally stored this member.',\n        gid = 'Group ID of the user who originally stored this member.',\n        size = 'Size in bytes.',\n        mtime = 'Time of last modification.',\n        chksum = 'Header checksum.',\n        type = ('File type. type is usually one of these constants: '\n                'REGTYPE, AREGTYPE, LNKTYPE, SYMTYPE, DIRTYPE, FIFOTYPE, '\n                'CONTTYPE, CHRTYPE, BLKTYPE, GNUTYPE_SPARSE.'),\n        linkname = ('Name of the target file name, which is only present '\n                    'in TarInfo objects of type LNKTYPE and SYMTYPE.'),\n        uname = 'User name.',\n        gname = 'Group name.',\n        devmajor = 'Device major number.',\n        devminor = 'Device minor number.',\n        offset = 'The tar header starts here.',\n        offset_data = \"The file's data starts here.\",\n        pax_headers = ('A dictionary containing key-value pairs of an '\n                       'associated pax extended header.'),\n        sparse = 'Sparse member information.',\n        tarfile = None,\n        _sparse_structs = None,\n        _link_target = None,\n        )\n\n    def __init__(self, name=\"\"):\n        \"\"\"Construct a TarInfo object. name is the optional name\n           of the member.\n        \"\"\"\n        self.name = name        # member name\n        self.mode = 0o644       # file permissions\n        self.uid = 0            # user id\n        self.gid = 0            # group id\n        self.size = 0           # file size\n        self.mtime = 0          # modification time\n        self.chksum = 0         # header checksum\n        self.type = REGTYPE     # member type\n        self.linkname = \"\"      # link name\n        self.uname = \"\"         # user name\n        self.gname = \"\"         # group name\n        self.devmajor = 0       # device major number\n        self.devminor = 0       # device minor number\n\n        self.offset = 0         # the tar header starts here\n        self.offset_data = 0    # the file's data starts here\n\n        self.sparse = None      # sparse member information\n        self.pax_headers = {}   # pax header information\n\n    @property\n    def path(self):\n        'In pax headers, \"name\" is called \"path\".'\n        return self.name\n\n    @path.setter\n    def path(self, name):\n        self.name = name\n\n    @property\n    def linkpath(self):\n        'In pax headers, \"linkname\" is called \"linkpath\".'\n        return self.linkname\n\n    @linkpath.setter\n    def linkpath(self, linkname):\n        self.linkname = linkname\n\n    def __repr__(self):\n        return \"<%s %r at %#x>\" % (self.__class__.__name__,self.name,id(self))\n\n    def replace(self, *,\n                name=_KEEP, mtime=_KEEP, mode=_KEEP, linkname=_KEEP,\n                uid=_KEEP, gid=_KEEP, uname=_KEEP, gname=_KEEP,\n                deep=True, _KEEP=_KEEP):\n        \"\"\"Return a deep copy of self with the given attributes replaced.\n        \"\"\"\n        if deep:\n            result = copy.deepcopy(self)\n        else:\n            result = copy.copy(self)\n        if name is not _KEEP:\n            result.name = name\n        if mtime is not _KEEP:\n            result.mtime = mtime\n        if mode is not _KEEP:\n            result.mode = mode\n        if linkname is not _KEEP:\n            result.linkname = linkname\n        if uid is not _KEEP:\n            result.uid = uid\n        if gid is not _KEEP:\n            result.gid = gid\n        if uname is not _KEEP:\n            result.uname = uname\n        if gname is not _KEEP:\n            result.gname = gname\n        return result\n\n    def get_info(self):\n        \"\"\"Return the TarInfo's attributes as a dictionary.\n        \"\"\"\n        if self.mode is None:\n            mode = None\n        else:\n            mode = self.mode & 0o7777\n        info = {\n            \"name\":     self.name,\n            \"mode\":     mode,\n            \"uid\":      self.uid,\n            \"gid\":      self.gid,\n            \"size\":     self.size,\n            \"mtime\":    self.mtime,\n            \"chksum\":   self.chksum,\n            \"type\":     self.type,\n            \"linkname\": self.linkname,\n            \"uname\":    self.uname,\n            \"gname\":    self.gname,\n            \"devmajor\": self.devmajor,\n            \"devminor\": self.devminor\n        }\n\n        if info[\"type\"] == DIRTYPE and not info[\"name\"].endswith(\"/\"):\n            info[\"name\"] += \"/\"\n\n        return info\n\n    def tobuf(self, format=DEFAULT_FORMAT, encoding=ENCODING, errors=\"surrogateescape\"):\n        \"\"\"Return a tar header as a string of 512 byte blocks.\n        \"\"\"\n        info = self.get_info()\n        for name, value in info.items():\n            if value is None:\n                raise ValueError(\"%s may not be None\" % name)\n\n        if format == USTAR_FORMAT:\n            return self.create_ustar_header(info, encoding, errors)\n        elif format == GNU_FORMAT:\n            return self.create_gnu_header(info, encoding, errors)\n        elif format == PAX_FORMAT:\n            return self.create_pax_header(info, encoding)\n        else:\n            raise ValueError(\"invalid format\")\n\n    def create_ustar_header(self, info, encoding, errors):\n        \"\"\"Return the object as a ustar header block.\n        \"\"\"\n        info[\"magic\"] = POSIX_MAGIC\n\n        if len(info[\"linkname\"].encode(encoding, errors)) > LENGTH_LINK:\n            raise ValueError(\"linkname is too long\")\n\n        if len(info[\"name\"].encode(encoding, errors)) > LENGTH_NAME:\n            info[\"prefix\"], info[\"name\"] = self._posix_split_name(info[\"name\"], encoding, errors)\n\n        return self._create_header(info, USTAR_FORMAT, encoding, errors)\n\n    def create_gnu_header(self, info, encoding, errors):\n        \"\"\"Return the object as a GNU header block sequence.\n        \"\"\"\n        info[\"magic\"] = GNU_MAGIC\n\n        buf = b\"\"\n        if len(info[\"linkname\"].encode(encoding, errors)) > LENGTH_LINK:\n            buf += self._create_gnu_long_header(info[\"linkname\"], GNUTYPE_LONGLINK, encoding, errors)\n\n        if len(info[\"name\"].encode(encoding, errors)) > LENGTH_NAME:\n            buf += self._create_gnu_long_header(info[\"name\"], GNUTYPE_LONGNAME, encoding, errors)\n\n        return buf + self._create_header(info, GNU_FORMAT, encoding, errors)\n\n    def create_pax_header(self, info, encoding):\n        \"\"\"Return the object as a ustar header block. If it cannot be\n           represented this way, prepend a pax extended header sequence\n           with supplement information.\n        \"\"\"\n        info[\"magic\"] = POSIX_MAGIC\n        pax_headers = self.pax_headers.copy()\n\n        # Test string fields for values that exceed the field length or cannot\n        # be represented in ASCII encoding.\n        for name, hname, length in (\n                (\"name\", \"path\", LENGTH_NAME), (\"linkname\", \"linkpath\", LENGTH_LINK),\n                (\"uname\", \"uname\", 32), (\"gname\", \"gname\", 32)):\n\n            if hname in pax_headers:\n                # The pax header has priority.\n                continue\n\n            # Try to encode the string as ASCII.\n            try:\n                info[name].encode(\"ascii\", \"strict\")\n            except UnicodeEncodeError:\n                pax_headers[hname] = info[name]\n                continue\n\n            if len(info[name]) > length:\n                pax_headers[hname] = info[name]\n\n        # Test number fields for values that exceed the field limit or values\n        # that like to be stored as float.\n        for name, digits in ((\"uid\", 8), (\"gid\", 8), (\"size\", 12), (\"mtime\", 12)):\n            needs_pax = False\n\n            val = info[name]\n            val_is_float = isinstance(val, float)\n            val_int = round(val) if val_is_float else val\n            if not 0 <= val_int < 8 ** (digits - 1):\n                # Avoid overflow.\n                info[name] = 0\n                needs_pax = True\n            elif val_is_float:\n                # Put rounded value in ustar header, and full\n                # precision value in pax header.\n                info[name] = val_int\n                needs_pax = True\n\n            # The existing pax header has priority.\n            if needs_pax and name not in pax_headers:\n                pax_headers[name] = str(val)\n\n        # Create a pax extended header if necessary.\n        if pax_headers:\n            buf = self._create_pax_generic_header(pax_headers, XHDTYPE, encoding)\n        else:\n            buf = b\"\"\n\n        return buf + self._create_header(info, USTAR_FORMAT, \"ascii\", \"replace\")\n\n    @classmethod\n    def create_pax_global_header(cls, pax_headers):\n        \"\"\"Return the object as a pax global header block sequence.\n        \"\"\"\n        return cls._create_pax_generic_header(pax_headers, XGLTYPE, \"utf-8\")\n\n    def _posix_split_name(self, name, encoding, errors):\n        \"\"\"Split a name longer than 100 chars into a prefix\n           and a name part.\n        \"\"\"\n        components = name.split(\"/\")\n        for i in range(1, len(components)):\n            prefix = \"/\".join(components[:i])\n            name = \"/\".join(components[i:])\n            if len(prefix.encode(encoding, errors)) <= LENGTH_PREFIX and \\\n                    len(name.encode(encoding, errors)) <= LENGTH_NAME:\n                break\n        else:\n            raise ValueError(\"name is too long\")\n\n        return prefix, name\n\n    @staticmethod\n    def _create_header(info, format, encoding, errors):\n        \"\"\"Return a header block. info is a dictionary with file\n           information, format must be one of the *_FORMAT constants.\n        \"\"\"\n        has_device_fields = info.get(\"type\") in (CHRTYPE, BLKTYPE)\n        if has_device_fields:\n            devmajor = itn(info.get(\"devmajor\", 0), 8, format)\n            devminor = itn(info.get(\"devminor\", 0), 8, format)\n        else:\n            devmajor = stn(\"\", 8, encoding, errors)\n            devminor = stn(\"\", 8, encoding, errors)\n\n        # None values in metadata should cause ValueError.\n        # itn()/stn() do this for all fields except type.\n        filetype = info.get(\"type\", REGTYPE)\n        if filetype is None:\n            raise ValueError(\"TarInfo.type must not be None\")\n\n        parts = [\n            stn(info.get(\"name\", \"\"), 100, encoding, errors),\n            itn(info.get(\"mode\", 0) & 0o7777, 8, format),\n            itn(info.get(\"uid\", 0), 8, format),\n            itn(info.get(\"gid\", 0), 8, format),\n            itn(info.get(\"size\", 0), 12, format),\n            itn(info.get(\"mtime\", 0), 12, format),\n            b\"        \", # checksum field\n            filetype,\n            stn(info.get(\"linkname\", \"\"), 100, encoding, errors),\n            info.get(\"magic\", POSIX_MAGIC),\n            stn(info.get(\"uname\", \"\"), 32, encoding, errors),\n            stn(info.get(\"gname\", \"\"), 32, encoding, errors),\n            devmajor,\n            devminor,\n            stn(info.get(\"prefix\", \"\"), 155, encoding, errors)\n        ]\n\n        buf = struct.pack(\"%ds\" % BLOCKSIZE, b\"\".join(parts))\n        chksum = calc_chksums(buf[-BLOCKSIZE:])[0]\n        buf = buf[:-364] + bytes(\"%06o\\0\" % chksum, \"ascii\") + buf[-357:]\n        return buf\n\n    @staticmethod\n    def _create_payload(payload):\n        \"\"\"Return the string payload filled with zero bytes\n           up to the next 512 byte border.\n        \"\"\"\n        blocks, remainder = divmod(len(payload), BLOCKSIZE)\n        if remainder > 0:\n            payload += (BLOCKSIZE - remainder) * NUL\n        return payload\n\n    @classmethod\n    def _create_gnu_long_header(cls, name, type, encoding, errors):\n        \"\"\"Return a GNUTYPE_LONGNAME or GNUTYPE_LONGLINK sequence\n           for name.\n        \"\"\"\n        name = name.encode(encoding, errors) + NUL\n\n        info = {}\n        info[\"name\"] = \"././@LongLink\"\n        info[\"type\"] = type\n        info[\"size\"] = len(name)\n        info[\"magic\"] = GNU_MAGIC\n\n        # create extended header + name blocks.\n        return cls._create_header(info, USTAR_FORMAT, encoding, errors) + \\\n                cls._create_payload(name)\n\n    @classmethod\n    def _create_pax_generic_header(cls, pax_headers, type, encoding):\n        \"\"\"Return a POSIX.1-2008 extended or global header sequence\n           that contains a list of keyword, value pairs. The values\n           must be strings.\n        \"\"\"\n        # Check if one of the fields contains surrogate characters and thereby\n        # forces hdrcharset=BINARY, see _proc_pax() for more information.\n        binary = False\n        for keyword, value in pax_headers.items():\n            try:\n                value.encode(\"utf-8\", \"strict\")\n            except UnicodeEncodeError:\n                binary = True\n                break\n\n        records = b\"\"\n        if binary:\n            # Put the hdrcharset field at the beginning of the header.\n            records += b\"21 hdrcharset=BINARY\\n\"\n\n        for keyword, value in pax_headers.items():\n            keyword = keyword.encode(\"utf-8\")\n            if binary:\n                # Try to restore the original byte representation of `value'.\n                # Needless to say, that the encoding must match the string.\n                value = value.encode(encoding, \"surrogateescape\")\n            else:\n                value = value.encode(\"utf-8\")\n\n            l = len(keyword) + len(value) + 3   # ' ' + '=' + '\\n'\n            n = p = 0\n            while True:\n                n = l + len(str(p))\n                if n == p:\n                    break\n                p = n\n            records += bytes(str(p), \"ascii\") + b\" \" + keyword + b\"=\" + value + b\"\\n\"\n\n        # We use a hardcoded \"././@PaxHeader\" name like star does\n        # instead of the one that POSIX recommends.\n        info = {}\n        info[\"name\"] = \"././@PaxHeader\"\n        info[\"type\"] = type\n        info[\"size\"] = len(records)\n        info[\"magic\"] = POSIX_MAGIC\n\n        # Create pax header + record blocks.\n        return cls._create_header(info, USTAR_FORMAT, \"ascii\", \"replace\") + \\\n                cls._create_payload(records)\n\n    @classmethod\n    def frombuf(cls, buf, encoding, errors):\n        \"\"\"Construct a TarInfo object from a 512 byte bytes object.\n        \"\"\"\n        if len(buf) == 0:\n            raise EmptyHeaderError(\"empty header\")\n        if len(buf) != BLOCKSIZE:\n            raise TruncatedHeaderError(\"truncated header\")\n        if buf.count(NUL) == BLOCKSIZE:\n            raise EOFHeaderError(\"end of file header\")\n\n        chksum = nti(buf[148:156])\n        if chksum not in calc_chksums(buf):\n            raise InvalidHeaderError(\"bad checksum\")\n\n        obj = cls()\n        obj.name = nts(buf[0:100], encoding, errors)\n        obj.mode = nti(buf[100:108])\n        obj.uid = nti(buf[108:116])\n        obj.gid = nti(buf[116:124])\n        obj.size = nti(buf[124:136])\n        obj.mtime = nti(buf[136:148])\n        obj.chksum = chksum\n        obj.type = buf[156:157]\n        obj.linkname = nts(buf[157:257], encoding, errors)\n        obj.uname = nts(buf[265:297], encoding, errors)\n        obj.gname = nts(buf[297:329], encoding, errors)\n        obj.devmajor = nti(buf[329:337])\n        obj.devminor = nti(buf[337:345])\n        prefix = nts(buf[345:500], encoding, errors)\n\n        # Old V7 tar format represents a directory as a regular\n        # file with a trailing slash.\n        if obj.type == AREGTYPE and obj.name.endswith(\"/\"):\n            obj.type = DIRTYPE\n\n        # The old GNU sparse format occupies some of the unused\n        # space in the buffer for up to 4 sparse structures.\n        # Save them for later processing in _proc_sparse().\n        if obj.type == GNUTYPE_SPARSE:\n            pos = 386\n            structs = []\n            for i in range(4):\n                try:\n                    offset = nti(buf[pos:pos + 12])\n                    numbytes = nti(buf[pos + 12:pos + 24])\n                except ValueError:\n                    break\n                structs.append((offset, numbytes))\n                pos += 24\n            isextended = bool(buf[482])\n            origsize = nti(buf[483:495])\n            obj._sparse_structs = (structs, isextended, origsize)\n\n        # Remove redundant slashes from directories.\n        if obj.isdir():\n            obj.name = obj.name.rstrip(\"/\")\n\n        # Reconstruct a ustar longname.\n        if prefix and obj.type not in GNU_TYPES:\n            obj.name = prefix + \"/\" + obj.name\n        return obj\n\n    @classmethod\n    def fromtarfile(cls, tarfile):\n        \"\"\"Return the next TarInfo object from TarFile object\n           tarfile.\n        \"\"\"\n        buf = tarfile.fileobj.read(BLOCKSIZE)\n        obj = cls.frombuf(buf, tarfile.encoding, tarfile.errors)\n        obj.offset = tarfile.fileobj.tell() - BLOCKSIZE\n        return obj._proc_member(tarfile)\n\n    #--------------------------------------------------------------------------\n    # The following are methods that are called depending on the type of a\n    # member. The entry point is _proc_member() which can be overridden in a\n    # subclass to add custom _proc_*() methods. A _proc_*() method MUST\n    # implement the following\n    # operations:\n    # 1. Set self.offset_data to the position where the data blocks begin,\n    #    if there is data that follows.\n    # 2. Set tarfile.offset to the position where the next member's header will\n    #    begin.\n    # 3. Return self or another valid TarInfo object.\n    def _proc_member(self, tarfile):\n        \"\"\"Choose the right processing method depending on\n           the type and call it.\n        \"\"\"\n        if self.type in (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK):\n            return self._proc_gnulong(tarfile)\n        elif self.type == GNUTYPE_SPARSE:\n            return self._proc_sparse(tarfile)\n        elif self.type in (XHDTYPE, XGLTYPE, SOLARIS_XHDTYPE):\n            return self._proc_pax(tarfile)\n        else:\n            return self._proc_builtin(tarfile)\n\n    def _proc_builtin(self, tarfile):\n        \"\"\"Process a builtin type or an unknown type which\n           will be treated as a regular file.\n        \"\"\"\n        self.offset_data = tarfile.fileobj.tell()\n        offset = self.offset_data\n        if self.isreg() or self.type not in SUPPORTED_TYPES:\n            # Skip the following data blocks.\n            offset += self._block(self.size)\n        tarfile.offset = offset\n\n        # Patch the TarInfo object with saved global\n        # header information.\n        self._apply_pax_info(tarfile.pax_headers, tarfile.encoding, tarfile.errors)\n\n        # Remove redundant slashes from directories. This is to be consistent\n        # with frombuf().\n        if self.isdir():\n            self.name = self.name.rstrip(\"/\")\n\n        return self\n\n    def _proc_gnulong(self, tarfile):\n        \"\"\"Process the blocks that hold a GNU longname\n           or longlink member.\n        \"\"\"\n        buf = tarfile.fileobj.read(self._block(self.size))\n\n        # Fetch the next header and process it.\n        try:\n            next = self.fromtarfile(tarfile)\n        except HeaderError as e:\n            raise SubsequentHeaderError(str(e)) from None\n\n        # Patch the TarInfo object from the next header with\n        # the longname information.\n        next.offset = self.offset\n        if self.type == GNUTYPE_LONGNAME:\n            next.name = nts(buf, tarfile.encoding, tarfile.errors)\n        elif self.type == GNUTYPE_LONGLINK:\n            next.linkname = nts(buf, tarfile.encoding, tarfile.errors)\n\n        # Remove redundant slashes from directories. This is to be consistent\n        # with frombuf().\n        if next.isdir():\n            next.name = next.name.removesuffix(\"/\")\n\n        return next\n\n    def _proc_sparse(self, tarfile):\n        \"\"\"Process a GNU sparse header plus extra headers.\n        \"\"\"\n        # We already collected some sparse structures in frombuf().\n        structs, isextended, origsize = self._sparse_structs\n        del self._sparse_structs\n\n        # Collect sparse structures from extended header blocks.\n        while isextended:\n            buf = tarfile.fileobj.read(BLOCKSIZE)\n            pos = 0\n            for i in range(21):\n                try:\n                    offset = nti(buf[pos:pos + 12])\n                    numbytes = nti(buf[pos + 12:pos + 24])\n                except ValueError:\n                    break\n                if offset and numbytes:\n                    structs.append((offset, numbytes))\n                pos += 24\n            isextended = bool(buf[504])\n        self.sparse = structs\n\n        self.offset_data = tarfile.fileobj.tell()\n        tarfile.offset = self.offset_data + self._block(self.size)\n        self.size = origsize\n        return self\n\n    def _proc_pax(self, tarfile):\n        \"\"\"Process an extended or global header as described in\n           POSIX.1-2008.\n        \"\"\"\n        # Read the header information.\n        buf = tarfile.fileobj.read(self._block(self.size))\n\n        # A pax header stores supplemental information for either\n        # the following file (extended) or all following files\n        # (global).\n        if self.type == XGLTYPE:\n            pax_headers = tarfile.pax_headers\n        else:\n            pax_headers = tarfile.pax_headers.copy()\n\n        # Check if the pax header contains a hdrcharset field. This tells us\n        # the encoding of the path, linkpath, uname and gname fields. Normally,\n        # these fields are UTF-8 encoded but since POSIX.1-2008 tar\n        # implementations are allowed to store them as raw binary strings if\n        # the translation to UTF-8 fails.\n        match = re.search(br\"\\d+ hdrcharset=([^\\n]+)\\n\", buf)\n        if match is not None:\n            pax_headers[\"hdrcharset\"] = match.group(1).decode(\"utf-8\")\n\n        # For the time being, we don't care about anything other than \"BINARY\".\n        # The only other value that is currently allowed by the standard is\n        # \"ISO-IR 10646 2000 UTF-8\" in other words UTF-8.\n        hdrcharset = pax_headers.get(\"hdrcharset\")\n        if hdrcharset == \"BINARY\":\n            encoding = tarfile.encoding\n        else:\n            encoding = \"utf-8\"\n\n        # Parse pax header information. A record looks like that:\n        # \"%d %s=%s\\n\" % (length, keyword, value). length is the size\n        # of the complete record including the length field itself and\n        # the newline. keyword and value are both UTF-8 encoded strings.\n        regex = re.compile(br\"(\\d+) ([^=]+)=\")\n        pos = 0\n        while match := regex.match(buf, pos):\n            length, keyword = match.groups()\n            length = int(length)\n            if length == 0:\n                raise InvalidHeaderError(\"invalid header\")\n            value = buf[match.end(2) + 1:match.start(1) + length - 1]\n\n            # Normally, we could just use \"utf-8\" as the encoding and \"strict\"\n            # as the error handler, but we better not take the risk. For\n            # example, GNU tar <= 1.23 is known to store filenames it cannot\n            # translate to UTF-8 as raw strings (unfortunately without a\n            # hdrcharset=BINARY header).\n            # We first try the strict standard encoding, and if that fails we\n            # fall back on the user's encoding and error handler.\n            keyword = self._decode_pax_field(keyword, \"utf-8\", \"utf-8\",\n                    tarfile.errors)\n            if keyword in PAX_NAME_FIELDS:\n                value = self._decode_pax_field(value, encoding, tarfile.encoding,\n                        tarfile.errors)\n            else:\n                value = self._decode_pax_field(value, \"utf-8\", \"utf-8\",\n                        tarfile.errors)\n\n            pax_headers[keyword] = value\n            pos += length\n\n        # Fetch the next header.\n        try:\n            next = self.fromtarfile(tarfile)\n        except HeaderError as e:\n            raise SubsequentHeaderError(str(e)) from None\n\n        # Process GNU sparse information.\n        if \"GNU.sparse.map\" in pax_headers:\n            # GNU extended sparse format version 0.1.\n            self._proc_gnusparse_01(next, pax_headers)\n\n        elif \"GNU.sparse.size\" in pax_headers:\n            # GNU extended sparse format version 0.0.\n            self._proc_gnusparse_00(next, pax_headers, buf)\n\n        elif pax_headers.get(\"GNU.sparse.major\") == \"1\" and pax_headers.get(\"GNU.sparse.minor\") == \"0\":\n            # GNU extended sparse format version 1.0.\n            self._proc_gnusparse_10(next, pax_headers, tarfile)\n\n        if self.type in (XHDTYPE, SOLARIS_XHDTYPE):\n            # Patch the TarInfo object with the extended header info.\n            next._apply_pax_info(pax_headers, tarfile.encoding, tarfile.errors)\n            next.offset = self.offset\n\n            if \"size\" in pax_headers:\n                # If the extended header replaces the size field,\n                # we need to recalculate the offset where the next\n                # header starts.\n                offset = next.offset_data\n                if next.isreg() or next.type not in SUPPORTED_TYPES:\n                    offset += next._block(next.size)\n                tarfile.offset = offset\n\n        return next\n\n    def _proc_gnusparse_00(self, next, pax_headers, buf):\n        \"\"\"Process a GNU tar extended sparse header, version 0.0.\n        \"\"\"\n        offsets = []\n        for match in re.finditer(br\"\\d+ GNU.sparse.offset=(\\d+)\\n\", buf):\n            offsets.append(int(match.group(1)))\n        numbytes = []\n        for match in re.finditer(br\"\\d+ GNU.sparse.numbytes=(\\d+)\\n\", buf):\n            numbytes.append(int(match.group(1)))\n        next.sparse = list(zip(offsets, numbytes))\n\n    def _proc_gnusparse_01(self, next, pax_headers):\n        \"\"\"Process a GNU tar extended sparse header, version 0.1.\n        \"\"\"\n        sparse = [int(x) for x in pax_headers[\"GNU.sparse.map\"].split(\",\")]\n        next.sparse = list(zip(sparse[::2], sparse[1::2]))\n\n    def _proc_gnusparse_10(self, next, pax_headers, tarfile):\n        \"\"\"Process a GNU tar extended sparse header, version 1.0.\n        \"\"\"\n        fields = None\n        sparse = []\n        buf = tarfile.fileobj.read(BLOCKSIZE)\n        fields, buf = buf.split(b\"\\n\", 1)\n        fields = int(fields)\n        while len(sparse) < fields * 2:\n            if b\"\\n\" not in buf:\n                buf += tarfile.fileobj.read(BLOCKSIZE)\n            number, buf = buf.split(b\"\\n\", 1)\n            sparse.append(int(number))\n        next.offset_data = tarfile.fileobj.tell()\n        next.sparse = list(zip(sparse[::2], sparse[1::2]))\n\n    def _apply_pax_info(self, pax_headers, encoding, errors):\n        \"\"\"Replace fields with supplemental information from a previous\n           pax extended or global header.\n        \"\"\"\n        for keyword, value in pax_headers.items():\n            if keyword == \"GNU.sparse.name\":\n                setattr(self, \"path\", value)\n            elif keyword == \"GNU.sparse.size\":\n                setattr(self, \"size\", int(value))\n            elif keyword == \"GNU.sparse.realsize\":\n                setattr(self, \"size\", int(value))\n            elif keyword in PAX_FIELDS:\n                if keyword in PAX_NUMBER_FIELDS:\n                    try:\n                        value = PAX_NUMBER_FIELDS[keyword](value)\n                    except ValueError:\n                        value = 0\n                if keyword == \"path\":\n                    value = value.rstrip(\"/\")\n                setattr(self, keyword, value)\n\n        self.pax_headers = pax_headers.copy()\n\n    def _decode_pax_field(self, value, encoding, fallback_encoding, fallback_errors):\n        \"\"\"Decode a single field from a pax record.\n        \"\"\"\n        try:\n            return value.decode(encoding, \"strict\")\n        except UnicodeDecodeError:\n            return value.decode(fallback_encoding, fallback_errors)\n\n    def _block(self, count):\n        \"\"\"Round up a byte count by BLOCKSIZE and return it,\n           e.g. _block(834) => 1024.\n        \"\"\"\n        blocks, remainder = divmod(count, BLOCKSIZE)\n        if remainder:\n            blocks += 1\n        return blocks * BLOCKSIZE\n\n    def isreg(self):\n        'Return True if the Tarinfo object is a regular file.'\n        return self.type in REGULAR_TYPES\n\n    def isfile(self):\n        'Return True if the Tarinfo object is a regular file.'\n        return self.isreg()\n\n    def isdir(self):\n        'Return True if it is a directory.'\n        return self.type == DIRTYPE\n\n    def issym(self):\n        'Return True if it is a symbolic link.'\n        return self.type == SYMTYPE\n\n    def islnk(self):\n        'Return True if it is a hard link.'\n        return self.type == LNKTYPE\n\n    def ischr(self):\n        'Return True if it is a character device.'\n        return self.type == CHRTYPE\n\n    def isblk(self):\n        'Return True if it is a block device.'\n        return self.type == BLKTYPE\n\n    def isfifo(self):\n        'Return True if it is a FIFO.'\n        return self.type == FIFOTYPE\n\n    def issparse(self):\n        return self.sparse is not None\n\n    def isdev(self):\n        'Return True if it is one of character device, block device or FIFO.'\n        return self.type in (CHRTYPE, BLKTYPE, FIFOTYPE)\n# class TarInfo\n\nclass TarFile(object):\n    \"\"\"The TarFile Class provides an interface to tar archives.\n    \"\"\"\n\n    debug = 0                   # May be set from 0 (no msgs) to 3 (all msgs)\n\n    dereference = False         # If true, add content of linked file to the\n                                # tar file, else the link.\n\n    ignore_zeros = False        # If true, skips empty or invalid blocks and\n                                # continues processing.\n\n    errorlevel = 1              # If 0, fatal errors only appear in debug\n                                # messages (if debug >= 0). If > 0, errors\n                                # are passed to the caller as exceptions.\n\n    format = DEFAULT_FORMAT     # The format to use when creating an archive.\n\n    encoding = ENCODING         # Encoding for 8-bit character strings.\n\n    errors = None               # Error handler for unicode conversion.\n\n    tarinfo = TarInfo           # The default TarInfo class to use.\n\n    fileobject = ExFileObject   # The file-object for extractfile().\n\n    extraction_filter = None    # The default filter for extraction.\n\n    def __init__(self, name=None, mode=\"r\", fileobj=None, format=None,\n            tarinfo=None, dereference=None, ignore_zeros=None, encoding=None,\n            errors=\"surrogateescape\", pax_headers=None, debug=None,\n            errorlevel=None, copybufsize=None):\n        \"\"\"Open an (uncompressed) tar archive `name'. `mode' is either 'r' to\n           read from an existing archive, 'a' to append data to an existing\n           file or 'w' to create a new file overwriting an existing one. `mode'\n           defaults to 'r'.\n           If `fileobj' is given, it is used for reading or writing data. If it\n           can be determined, `mode' is overridden by `fileobj's mode.\n           `fileobj' is not closed, when TarFile is closed.\n        \"\"\"\n        modes = {\"r\": \"rb\", \"a\": \"r+b\", \"w\": \"wb\", \"x\": \"xb\"}\n        if mode not in modes:\n            raise ValueError(\"mode must be 'r', 'a', 'w' or 'x'\")\n        self.mode = mode\n        self._mode = modes[mode]\n\n        if not fileobj:\n            if self.mode == \"a\" and not os.path.exists(name):\n                # Create nonexistent files in append mode.\n                self.mode = \"w\"\n                self._mode = \"wb\"\n            fileobj = bltn_open(name, self._mode)\n            self._extfileobj = False\n        else:\n            if (name is None and hasattr(fileobj, \"name\") and\n                isinstance(fileobj.name, (str, bytes))):\n                name = fileobj.name\n            if hasattr(fileobj, \"mode\"):\n                self._mode = fileobj.mode\n            self._extfileobj = True\n        self.name = os.path.abspath(name) if name else None\n        self.fileobj = fileobj\n\n        # Init attributes.\n        if format is not None:\n            self.format = format\n        if tarinfo is not None:\n            self.tarinfo = tarinfo\n        if dereference is not None:\n            self.dereference = dereference\n        if ignore_zeros is not None:\n            self.ignore_zeros = ignore_zeros\n        if encoding is not None:\n            self.encoding = encoding\n        self.errors = errors\n\n        if pax_headers is not None and self.format == PAX_FORMAT:\n            self.pax_headers = pax_headers\n        else:\n            self.pax_headers = {}\n\n        if debug is not None:\n            self.debug = debug\n        if errorlevel is not None:\n            self.errorlevel = errorlevel\n\n        # Init datastructures.\n        self.copybufsize = copybufsize\n        self.closed = False\n        self.members = []       # list of members as TarInfo objects\n        self._loaded = False    # flag if all members have been read\n        self.offset = self.fileobj.tell()\n                                # current position in the archive file\n        self.inodes = {}        # dictionary caching the inodes of\n                                # archive members already added\n\n        try:\n            if self.mode == \"r\":\n                self.firstmember = None\n                self.firstmember = self.next()\n\n            if self.mode == \"a\":\n                # Move to the end of the archive,\n                # before the first empty block.\n                while True:\n                    self.fileobj.seek(self.offset)\n                    try:\n                        tarinfo = self.tarinfo.fromtarfile(self)\n                        self.members.append(tarinfo)\n                    except EOFHeaderError:\n                        self.fileobj.seek(self.offset)\n                        break\n                    except HeaderError as e:\n                        raise ReadError(str(e)) from None\n\n            if self.mode in (\"a\", \"w\", \"x\"):\n                self._loaded = True\n\n                if self.pax_headers:\n                    buf = self.tarinfo.create_pax_global_header(self.pax_headers.copy())\n                    self.fileobj.write(buf)\n                    self.offset += len(buf)\n        except:\n            if not self._extfileobj:\n                self.fileobj.close()\n            self.closed = True\n            raise\n\n    #--------------------------------------------------------------------------\n    # Below are the classmethods which act as alternate constructors to the\n    # TarFile class. The open() method is the only one that is needed for\n    # public use; it is the \"super\"-constructor and is able to select an\n    # adequate \"sub\"-constructor for a particular compression using the mapping\n    # from OPEN_METH.\n    #\n    # This concept allows one to subclass TarFile without losing the comfort of\n    # the super-constructor. A sub-constructor is registered and made available\n    # by adding it to the mapping in OPEN_METH.\n\n    @classmethod\n    def open(cls, name=None, mode=\"r\", fileobj=None, bufsize=RECORDSIZE, **kwargs):\n        r\"\"\"Open a tar archive for reading, writing or appending. Return\n           an appropriate TarFile class.\n\n           mode:\n           'r' or 'r:\\*' open for reading with transparent compression\n           'r:'         open for reading exclusively uncompressed\n           'r:gz'       open for reading with gzip compression\n           'r:bz2'      open for reading with bzip2 compression\n           'r:xz'       open for reading with lzma compression\n           'a' or 'a:'  open for appending, creating the file if necessary\n           'w' or 'w:'  open for writing without compression\n           'w:gz'       open for writing with gzip compression\n           'w:bz2'      open for writing with bzip2 compression\n           'w:xz'       open for writing with lzma compression\n\n           'x' or 'x:'  create a tarfile exclusively without compression, raise\n                        an exception if the file is already created\n           'x:gz'       create a gzip compressed tarfile, raise an exception\n                        if the file is already created\n           'x:bz2'      create a bzip2 compressed tarfile, raise an exception\n                        if the file is already created\n           'x:xz'       create an lzma compressed tarfile, raise an exception\n                        if the file is already created\n\n           'r|\\*'        open a stream of tar blocks with transparent compression\n           'r|'         open an uncompressed stream of tar blocks for reading\n           'r|gz'       open a gzip compressed stream of tar blocks\n           'r|bz2'      open a bzip2 compressed stream of tar blocks\n           'r|xz'       open an lzma compressed stream of tar blocks\n           'w|'         open an uncompressed stream for writing\n           'w|gz'       open a gzip compressed stream for writing\n           'w|bz2'      open a bzip2 compressed stream for writing\n           'w|xz'       open an lzma compressed stream for writing\n        \"\"\"\n\n        if not name and not fileobj:\n            raise ValueError(\"nothing to open\")\n\n        if mode in (\"r\", \"r:*\"):\n            # Find out which *open() is appropriate for opening the file.\n            def not_compressed(comptype):\n                return cls.OPEN_METH[comptype] == 'taropen'\n            error_msgs = []\n            for comptype in sorted(cls.OPEN_METH, key=not_compressed):\n                func = getattr(cls, cls.OPEN_METH[comptype])\n                if fileobj is not None:\n                    saved_pos = fileobj.tell()\n                try:\n                    return func(name, \"r\", fileobj, **kwargs)\n                except (ReadError, CompressionError) as e:\n                    error_msgs.append(f'- method {comptype}: {e!r}')\n                    if fileobj is not None:\n                        fileobj.seek(saved_pos)\n                    continue\n            error_msgs_summary = '\\n'.join(error_msgs)\n            raise ReadError(f\"file could not be opened successfully:\\n{error_msgs_summary}\")\n\n        elif \":\" in mode:\n            filemode, comptype = mode.split(\":\", 1)\n            filemode = filemode or \"r\"\n            comptype = comptype or \"tar\"\n\n            # Select the *open() function according to\n            # given compression.\n            if comptype in cls.OPEN_METH:\n                func = getattr(cls, cls.OPEN_METH[comptype])\n            else:\n                raise CompressionError(\"unknown compression type %r\" % comptype)\n            return func(name, filemode, fileobj, **kwargs)\n\n        elif \"|\" in mode:\n            filemode, comptype = mode.split(\"|\", 1)\n            filemode = filemode or \"r\"\n            comptype = comptype or \"tar\"\n\n            if filemode not in (\"r\", \"w\"):\n                raise ValueError(\"mode must be 'r' or 'w'\")\n\n            compresslevel = kwargs.pop(\"compresslevel\", 9)\n            stream = _Stream(name, filemode, comptype, fileobj, bufsize,\n                             compresslevel)\n            try:\n                t = cls(name, filemode, stream, **kwargs)\n            except:\n                stream.close()\n                raise\n            t._extfileobj = False\n            return t\n\n        elif mode in (\"a\", \"w\", \"x\"):\n            return cls.taropen(name, mode, fileobj, **kwargs)\n\n        raise ValueError(\"undiscernible mode\")\n\n    @classmethod\n    def taropen(cls, name, mode=\"r\", fileobj=None, **kwargs):\n        \"\"\"Open uncompressed tar archive name for reading or writing.\n        \"\"\"\n        if mode not in (\"r\", \"a\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'a', 'w' or 'x'\")\n        return cls(name, mode, fileobj, **kwargs)\n\n    @classmethod\n    def gzopen(cls, name, mode=\"r\", fileobj=None, compresslevel=9, **kwargs):\n        \"\"\"Open gzip compressed tar archive name for reading or writing.\n           Appending is not allowed.\n        \"\"\"\n        if mode not in (\"r\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'w' or 'x'\")\n\n        try:\n            from gzip import GzipFile\n        except ImportError:\n            raise CompressionError(\"gzip module is not available\") from None\n\n        try:\n            fileobj = GzipFile(name, mode + \"b\", compresslevel, fileobj)\n        except OSError as e:\n            if fileobj is not None and mode == 'r':\n                raise ReadError(\"not a gzip file\") from e\n            raise\n\n        try:\n            t = cls.taropen(name, mode, fileobj, **kwargs)\n        except OSError as e:\n            fileobj.close()\n            if mode == 'r':\n                raise ReadError(\"not a gzip file\") from e\n            raise\n        except:\n            fileobj.close()\n            raise\n        t._extfileobj = False\n        return t\n\n    @classmethod\n    def bz2open(cls, name, mode=\"r\", fileobj=None, compresslevel=9, **kwargs):\n        \"\"\"Open bzip2 compressed tar archive name for reading or writing.\n           Appending is not allowed.\n        \"\"\"\n        if mode not in (\"r\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'w' or 'x'\")\n\n        try:\n            from bz2 import BZ2File\n        except ImportError:\n            raise CompressionError(\"bz2 module is not available\") from None\n\n        fileobj = BZ2File(fileobj or name, mode, compresslevel=compresslevel)\n\n        try:\n            t = cls.taropen(name, mode, fileobj, **kwargs)\n        except (OSError, EOFError) as e:\n            fileobj.close()\n            if mode == 'r':\n                raise ReadError(\"not a bzip2 file\") from e\n            raise\n        except:\n            fileobj.close()\n            raise\n        t._extfileobj = False\n        return t\n\n    @classmethod\n    def xzopen(cls, name, mode=\"r\", fileobj=None, preset=None, **kwargs):\n        \"\"\"Open lzma compressed tar archive name for reading or writing.\n           Appending is not allowed.\n        \"\"\"\n        if mode not in (\"r\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'w' or 'x'\")\n\n        try:\n            from lzma import LZMAFile, LZMAError\n        except ImportError:\n            raise CompressionError(\"lzma module is not available\") from None\n\n        fileobj = LZMAFile(fileobj or name, mode, preset=preset)\n\n        try:\n            t = cls.taropen(name, mode, fileobj, **kwargs)\n        except (LZMAError, EOFError) as e:\n            fileobj.close()\n            if mode == 'r':\n                raise ReadError(\"not an lzma file\") from e\n            raise\n        except:\n            fileobj.close()\n            raise\n        t._extfileobj = False\n        return t\n\n    # All *open() methods are registered here.\n    OPEN_METH = {\n        \"tar\": \"taropen\",   # uncompressed tar\n        \"gz\":  \"gzopen\",    # gzip compressed tar\n        \"bz2\": \"bz2open\",   # bzip2 compressed tar\n        \"xz\":  \"xzopen\"     # lzma compressed tar\n    }\n\n    #--------------------------------------------------------------------------\n    # The public methods which TarFile provides:\n\n    def close(self):\n        \"\"\"Close the TarFile. In write-mode, two finishing zero blocks are\n           appended to the archive.\n        \"\"\"\n        if self.closed:\n            return\n\n        self.closed = True\n        try:\n            if self.mode in (\"a\", \"w\", \"x\"):\n                self.fileobj.write(NUL * (BLOCKSIZE * 2))\n                self.offset += (BLOCKSIZE * 2)\n                # fill up the end with zero-blocks\n                # (like option -b20 for tar does)\n                blocks, remainder = divmod(self.offset, RECORDSIZE)\n                if remainder > 0:\n                    self.fileobj.write(NUL * (RECORDSIZE - remainder))\n        finally:\n            if not self._extfileobj:\n                self.fileobj.close()\n\n    def getmember(self, name):\n        \"\"\"Return a TarInfo object for member ``name``. If ``name`` can not be\n           found in the archive, KeyError is raised. If a member occurs more\n           than once in the archive, its last occurrence is assumed to be the\n           most up-to-date version.\n        \"\"\"\n        tarinfo = self._getmember(name.rstrip('/'))\n        if tarinfo is None:\n            raise KeyError(\"filename %r not found\" % name)\n        return tarinfo\n\n    def getmembers(self):\n        \"\"\"Return the members of the archive as a list of TarInfo objects. The\n           list has the same order as the members in the archive.\n        \"\"\"\n        self._check()\n        if not self._loaded:    # if we want to obtain a list of\n            self._load()        # all members, we first have to\n                                # scan the whole archive.\n        return self.members\n\n    def getnames(self):\n        \"\"\"Return the members of the archive as a list of their names. It has\n           the same order as the list returned by getmembers().\n        \"\"\"\n        return [tarinfo.name for tarinfo in self.getmembers()]\n\n    def gettarinfo(self, name=None, arcname=None, fileobj=None):\n        \"\"\"Create a TarInfo object from the result of os.stat or equivalent\n           on an existing file. The file is either named by ``name``, or\n           specified as a file object ``fileobj`` with a file descriptor. If\n           given, ``arcname`` specifies an alternative name for the file in the\n           archive, otherwise, the name is taken from the 'name' attribute of\n           'fileobj', or the 'name' argument. The name should be a text\n           string.\n        \"\"\"\n        self._check(\"awx\")\n\n        # When fileobj is given, replace name by\n        # fileobj's real name.\n        if fileobj is not None:\n            name = fileobj.name\n\n        # Building the name of the member in the archive.\n        # Backward slashes are converted to forward slashes,\n        # Absolute paths are turned to relative paths.\n        if arcname is None:\n            arcname = name\n        drv, arcname = os.path.splitdrive(arcname)\n        arcname = arcname.replace(os.sep, \"/\")\n        arcname = arcname.lstrip(\"/\")\n\n        # Now, fill the TarInfo object with\n        # information specific for the file.\n        tarinfo = self.tarinfo()\n        tarinfo.tarfile = self  # Not needed\n\n        # Use os.stat or os.lstat, depending on if symlinks shall be resolved.\n        if fileobj is None:\n            if not self.dereference:\n                statres = os.lstat(name)\n            else:\n                statres = os.stat(name)\n        else:\n            statres = os.fstat(fileobj.fileno())\n        linkname = \"\"\n\n        stmd = statres.st_mode\n        if stat.S_ISREG(stmd):\n            inode = (statres.st_ino, statres.st_dev)\n            if not self.dereference and statres.st_nlink > 1 and \\\n                    inode in self.inodes and arcname != self.inodes[inode]:\n                # Is it a hardlink to an already\n                # archived file?\n                type = LNKTYPE\n                linkname = self.inodes[inode]\n            else:\n                # The inode is added only if its valid.\n                # For win32 it is always 0.\n                type = REGTYPE\n                if inode[0]:\n                    self.inodes[inode] = arcname\n        elif stat.S_ISDIR(stmd):\n            type = DIRTYPE\n        elif stat.S_ISFIFO(stmd):\n            type = FIFOTYPE\n        elif stat.S_ISLNK(stmd):\n            type = SYMTYPE\n            linkname = os.readlink(name)\n        elif stat.S_ISCHR(stmd):\n            type = CHRTYPE\n        elif stat.S_ISBLK(stmd):\n            type = BLKTYPE\n        else:\n            return None\n\n        # Fill the TarInfo object with all\n        # information we can get.\n        tarinfo.name = arcname\n        tarinfo.mode = stmd\n        tarinfo.uid = statres.st_uid\n        tarinfo.gid = statres.st_gid\n        if type == REGTYPE:\n            tarinfo.size = statres.st_size\n        else:\n            tarinfo.size = 0\n        tarinfo.mtime = statres.st_mtime\n        tarinfo.type = type\n        tarinfo.linkname = linkname\n        if pwd:\n            try:\n                tarinfo.uname = pwd.getpwuid(tarinfo.uid)[0]\n            except KeyError:\n                pass\n        if grp:\n            try:\n                tarinfo.gname = grp.getgrgid(tarinfo.gid)[0]\n            except KeyError:\n                pass\n\n        if type in (CHRTYPE, BLKTYPE):\n            if hasattr(os, \"major\") and hasattr(os, \"minor\"):\n                tarinfo.devmajor = os.major(statres.st_rdev)\n                tarinfo.devminor = os.minor(statres.st_rdev)\n        return tarinfo\n\n    def list(self, verbose=True, *, members=None):\n        \"\"\"Print a table of contents to sys.stdout. If ``verbose`` is False, only\n           the names of the members are printed. If it is True, an `ls -l'-like\n           output is produced. ``members`` is optional and must be a subset of the\n           list returned by getmembers().\n        \"\"\"\n        self._check()\n\n        if members is None:\n            members = self\n        for tarinfo in members:\n            if verbose:\n                if tarinfo.mode is None:\n                    _safe_print(\"??????????\")\n                else:\n                    _safe_print(stat.filemode(tarinfo.mode))\n                _safe_print(\"%s/%s\" % (tarinfo.uname or tarinfo.uid,\n                                       tarinfo.gname or tarinfo.gid))\n                if tarinfo.ischr() or tarinfo.isblk():\n                    _safe_print(\"%10s\" %\n                            (\"%d,%d\" % (tarinfo.devmajor, tarinfo.devminor)))\n                else:\n                    _safe_print(\"%10d\" % tarinfo.size)\n                if tarinfo.mtime is None:\n                    _safe_print(\"????-??-?? ??:??:??\")\n                else:\n                    _safe_print(\"%d-%02d-%02d %02d:%02d:%02d\" \\\n                                % time.localtime(tarinfo.mtime)[:6])\n\n            _safe_print(tarinfo.name + (\"/\" if tarinfo.isdir() else \"\"))\n\n            if verbose:\n                if tarinfo.issym():\n                    _safe_print(\"-> \" + tarinfo.linkname)\n                if tarinfo.islnk():\n                    _safe_print(\"link to \" + tarinfo.linkname)\n            print()\n\n    def add(self, name, arcname=None, recursive=True, *, filter=None):\n        \"\"\"Add the file ``name`` to the archive. ``name`` may be any type of file\n           (directory, fifo, symbolic link, etc.). If given, ``arcname``\n           specifies an alternative name for the file in the archive.\n           Directories are added recursively by default. This can be avoided by\n           setting ``recursive`` to False. ``filter`` is a function\n           that expects a TarInfo object argument and returns the changed\n           TarInfo object, if it returns None the TarInfo object will be\n           excluded from the archive.\n        \"\"\"\n        self._check(\"awx\")\n\n        if arcname is None:\n            arcname = name\n\n        # Skip if somebody tries to archive the archive...\n        if self.name is not None and os.path.abspath(name) == self.name:\n            self._dbg(2, \"tarfile: Skipped %r\" % name)\n            return\n\n        self._dbg(1, name)\n\n        # Create a TarInfo object from the file.\n        tarinfo = self.gettarinfo(name, arcname)\n\n        if tarinfo is None:\n            self._dbg(1, \"tarfile: Unsupported type %r\" % name)\n            return\n\n        # Change or exclude the TarInfo object.\n        if filter is not None:\n            tarinfo = filter(tarinfo)\n            if tarinfo is None:\n                self._dbg(2, \"tarfile: Excluded %r\" % name)\n                return\n\n        # Append the tar header and data to the archive.\n        if tarinfo.isreg():\n            with bltn_open(name, \"rb\") as f:\n                self.addfile(tarinfo, f)\n\n        elif tarinfo.isdir():\n            self.addfile(tarinfo)\n            if recursive:\n                for f in sorted(os.listdir(name)):\n                    self.add(os.path.join(name, f), os.path.join(arcname, f),\n                            recursive, filter=filter)\n\n        else:\n            self.addfile(tarinfo)\n\n    def addfile(self, tarinfo, fileobj=None):\n        \"\"\"Add the TarInfo object ``tarinfo`` to the archive. If ``fileobj`` is\n           given, it should be a binary file, and tarinfo.size bytes are read\n           from it and added to the archive. You can create TarInfo objects\n           directly, or by using gettarinfo().\n        \"\"\"\n        self._check(\"awx\")\n\n        tarinfo = copy.copy(tarinfo)\n\n        buf = tarinfo.tobuf(self.format, self.encoding, self.errors)\n        self.fileobj.write(buf)\n        self.offset += len(buf)\n        bufsize=self.copybufsize\n        # If there's data to follow, append it.\n        if fileobj is not None:\n            copyfileobj(fileobj, self.fileobj, tarinfo.size, bufsize=bufsize)\n            blocks, remainder = divmod(tarinfo.size, BLOCKSIZE)\n            if remainder > 0:\n                self.fileobj.write(NUL * (BLOCKSIZE - remainder))\n                blocks += 1\n            self.offset += blocks * BLOCKSIZE\n\n        self.members.append(tarinfo)\n\n    def _get_filter_function(self, filter):\n        if filter is None:\n            filter = self.extraction_filter\n            if filter is None:\n                warnings.warn(\n                    'Python 3.14 will, by default, filter extracted tar '\n                    + 'archives and reject files or modify their metadata. '\n                    + 'Use the filter argument to control this behavior.',\n                    DeprecationWarning)\n                return fully_trusted_filter\n            if isinstance(filter, str):\n                raise TypeError(\n                    'String names are not supported for '\n                    + 'TarFile.extraction_filter. Use a function such as '\n                    + 'tarfile.data_filter directly.')\n            return filter\n        if callable(filter):\n            return filter\n        try:\n            return _NAMED_FILTERS[filter]\n        except KeyError:\n            raise ValueError(f\"filter {filter!r} not found\") from None\n\n    def extractall(self, path=\".\", members=None, *, numeric_owner=False,\n                   filter=None):\n        \"\"\"Extract all members from the archive to the current working\n           directory and set owner, modification time and permissions on\n           directories afterwards. `path' specifies a different directory\n           to extract to. `members' is optional and must be a subset of the\n           list returned by getmembers(). If `numeric_owner` is True, only\n           the numbers for user/group names are used and not the names.\n\n           The `filter` function will be called on each member just\n           before extraction.\n           It can return a changed TarInfo or None to skip the member.\n           String names of common filters are accepted.\n        \"\"\"\n        directories = []\n\n        filter_function = self._get_filter_function(filter)\n        if members is None:\n            members = self\n\n        for member in members:\n            tarinfo = self._get_extract_tarinfo(member, filter_function, path)\n            if tarinfo is None:\n                continue\n            if tarinfo.isdir():\n                # For directories, delay setting attributes until later,\n                # since permissions can interfere with extraction and\n                # extracting contents can reset mtime.\n                directories.append(tarinfo)\n            self._extract_one(tarinfo, path, set_attrs=not tarinfo.isdir(),\n                              numeric_owner=numeric_owner)\n\n        # Reverse sort directories.\n        directories.sort(key=lambda a: a.name, reverse=True)\n\n        # Set correct owner, mtime and filemode on directories.\n        for tarinfo in directories:\n            dirpath = os.path.join(path, tarinfo.name)\n            try:\n                self.chown(tarinfo, dirpath, numeric_owner=numeric_owner)\n                self.utime(tarinfo, dirpath)\n                self.chmod(tarinfo, dirpath)\n            except ExtractError as e:\n                self._handle_nonfatal_error(e)\n\n    def extract(self, member, path=\"\", set_attrs=True, *, numeric_owner=False,\n                filter=None):\n        \"\"\"Extract a member from the archive to the current working directory,\n           using its full name. Its file information is extracted as accurately\n           as possible. `member' may be a filename or a TarInfo object. You can\n           specify a different directory using `path'. File attributes (owner,\n           mtime, mode) are set unless `set_attrs' is False. If `numeric_owner`\n           is True, only the numbers for user/group names are used and not\n           the names.\n\n           The `filter` function will be called before extraction.\n           It can return a changed TarInfo or None to skip the member.\n           String names of common filters are accepted.\n        \"\"\"\n        filter_function = self._get_filter_function(filter)\n        tarinfo = self._get_extract_tarinfo(member, filter_function, path)\n        if tarinfo is not None:\n            self._extract_one(tarinfo, path, set_attrs, numeric_owner)\n\n    def _get_extract_tarinfo(self, member, filter_function, path):\n        \"\"\"Get filtered TarInfo (or None) from member, which might be a str\"\"\"\n        if isinstance(member, str):\n            tarinfo = self.getmember(member)\n        else:\n            tarinfo = member\n\n        unfiltered = tarinfo\n        try:\n            tarinfo = filter_function(tarinfo, path)\n        except (OSError, FilterError) as e:\n            self._handle_fatal_error(e)\n        except ExtractError as e:\n            self._handle_nonfatal_error(e)\n        if tarinfo is None:\n            self._dbg(2, \"tarfile: Excluded %r\" % unfiltered.name)\n            return None\n        # Prepare the link target for makelink().\n        if tarinfo.islnk():\n            tarinfo = copy.copy(tarinfo)\n            tarinfo._link_target = os.path.join(path, tarinfo.linkname)\n        return tarinfo\n\n    def _extract_one(self, tarinfo, path, set_attrs, numeric_owner):\n        \"\"\"Extract from filtered tarinfo to disk\"\"\"\n        self._check(\"r\")\n\n        try:\n            self._extract_member(tarinfo, os.path.join(path, tarinfo.name),\n                                 set_attrs=set_attrs,\n                                 numeric_owner=numeric_owner)\n        except OSError as e:\n            self._handle_fatal_error(e)\n        except ExtractError as e:\n            self._handle_nonfatal_error(e)\n\n    def _handle_nonfatal_error(self, e):\n        \"\"\"Handle non-fatal error (ExtractError) according to errorlevel\"\"\"\n        if self.errorlevel > 1:\n            raise\n        else:\n            self._dbg(1, \"tarfile: %s\" % e)\n\n    def _handle_fatal_error(self, e):\n        \"\"\"Handle \"fatal\" error according to self.errorlevel\"\"\"\n        if self.errorlevel > 0:\n            raise\n        elif isinstance(e, OSError):\n            if e.filename is None:\n                self._dbg(1, \"tarfile: %s\" % e.strerror)\n            else:\n                self._dbg(1, \"tarfile: %s %r\" % (e.strerror, e.filename))\n        else:\n            self._dbg(1, \"tarfile: %s %s\" % (type(e).__name__, e))\n\n    def extractfile(self, member):\n        \"\"\"Extract a member from the archive as a file object. ``member`` may be\n           a filename or a TarInfo object. If ``member`` is a regular file or\n           a link, an io.BufferedReader object is returned. For all other\n           existing members, None is returned. If ``member`` does not appear\n           in the archive, KeyError is raised.\n        \"\"\"\n        self._check(\"r\")\n\n        if isinstance(member, str):\n            tarinfo = self.getmember(member)\n        else:\n            tarinfo = member\n\n        if tarinfo.isreg() or tarinfo.type not in SUPPORTED_TYPES:\n            # Members with unknown types are treated as regular files.\n            return self.fileobject(self, tarinfo)\n\n        elif tarinfo.islnk() or tarinfo.issym():\n            if isinstance(self.fileobj, _Stream):\n                # A small but ugly workaround for the case that someone tries\n                # to extract a (sym)link as a file-object from a non-seekable\n                # stream of tar blocks.\n                raise StreamError(\"cannot extract (sym)link as file object\")\n            else:\n                # A (sym)link's file object is its target's file object.\n                return self.extractfile(self._find_link_target(tarinfo))\n        else:\n            # If there's no data associated with the member (directory, chrdev,\n            # blkdev, etc.), return None instead of a file object.\n            return None\n\n    def _extract_member(self, tarinfo, targetpath, set_attrs=True,\n                        numeric_owner=False):\n        \"\"\"Extract the TarInfo object tarinfo to a physical\n           file called targetpath.\n        \"\"\"\n        # Fetch the TarInfo object for the given name\n        # and build the destination pathname, replacing\n        # forward slashes to platform specific separators.\n        targetpath = targetpath.rstrip(\"/\")\n        targetpath = targetpath.replace(\"/\", os.sep)\n\n        # Create all upper directories.\n        upperdirs = os.path.dirname(targetpath)\n        if upperdirs and not os.path.exists(upperdirs):\n            # Create directories that are not part of the archive with\n            # default permissions.\n            os.makedirs(upperdirs)\n\n        if tarinfo.islnk() or tarinfo.issym():\n            self._dbg(1, \"%s -> %s\" % (tarinfo.name, tarinfo.linkname))\n        else:\n            self._dbg(1, tarinfo.name)\n\n        if tarinfo.isreg():\n            self.makefile(tarinfo, targetpath)\n        elif tarinfo.isdir():\n            self.makedir(tarinfo, targetpath)\n        elif tarinfo.isfifo():\n            self.makefifo(tarinfo, targetpath)\n        elif tarinfo.ischr() or tarinfo.isblk():\n            self.makedev(tarinfo, targetpath)\n        elif tarinfo.islnk() or tarinfo.issym():\n            self.makelink(tarinfo, targetpath)\n        elif tarinfo.type not in SUPPORTED_TYPES:\n            self.makeunknown(tarinfo, targetpath)\n        else:\n            self.makefile(tarinfo, targetpath)\n\n        if set_attrs:\n            self.chown(tarinfo, targetpath, numeric_owner)\n            if not tarinfo.issym():\n                self.chmod(tarinfo, targetpath)\n                self.utime(tarinfo, targetpath)\n\n    #--------------------------------------------------------------------------\n    # Below are the different file methods. They are called via\n    # _extract_member() when extract() is called. They can be replaced in a\n    # subclass to implement other functionality.\n\n    def makedir(self, tarinfo, targetpath):\n        \"\"\"Make a directory called targetpath.\n        \"\"\"\n        try:\n            if tarinfo.mode is None:\n                # Use the system's default mode\n                os.mkdir(targetpath)\n            else:\n                # Use a safe mode for the directory, the real mode is set\n                # later in _extract_member().\n                os.mkdir(targetpath, 0o700)\n        except FileExistsError:\n            if not os.path.isdir(targetpath):\n                raise\n\n    def makefile(self, tarinfo, targetpath):\n        \"\"\"Make a file called targetpath.\n        \"\"\"\n        source = self.fileobj\n        source.seek(tarinfo.offset_data)\n        bufsize = self.copybufsize\n        with bltn_open(targetpath, \"wb\") as target:\n            if tarinfo.sparse is not None:\n                for offset, size in tarinfo.sparse:\n                    target.seek(offset)\n                    copyfileobj(source, target, size, ReadError, bufsize)\n                target.seek(tarinfo.size)\n                target.truncate()\n            else:\n                copyfileobj(source, target, tarinfo.size, ReadError, bufsize)\n\n    def makeunknown(self, tarinfo, targetpath):\n        \"\"\"Make a file from a TarInfo object with an unknown type\n           at targetpath.\n        \"\"\"\n        self.makefile(tarinfo, targetpath)\n        self._dbg(1, \"tarfile: Unknown file type %r, \" \\\n                     \"extracted as regular file.\" % tarinfo.type)\n\n    def makefifo(self, tarinfo, targetpath):\n        \"\"\"Make a fifo called targetpath.\n        \"\"\"\n        if hasattr(os, \"mkfifo\"):\n            os.mkfifo(targetpath)\n        else:\n            raise ExtractError(\"fifo not supported by system\")\n\n    def makedev(self, tarinfo, targetpath):\n        \"\"\"Make a character or block device called targetpath.\n        \"\"\"\n        if not hasattr(os, \"mknod\") or not hasattr(os, \"makedev\"):\n            raise ExtractError(\"special devices not supported by system\")\n\n        mode = tarinfo.mode\n        if mode is None:\n            # Use mknod's default\n            mode = 0o600\n        if tarinfo.isblk():\n            mode |= stat.S_IFBLK\n        else:\n            mode |= stat.S_IFCHR\n\n        os.mknod(targetpath, mode,\n                 os.makedev(tarinfo.devmajor, tarinfo.devminor))\n\n    def makelink(self, tarinfo, targetpath):\n        \"\"\"Make a (symbolic) link called targetpath. If it cannot be created\n          (platform limitation), we try to make a copy of the referenced file\n          instead of a link.\n        \"\"\"\n        try:\n            # For systems that support symbolic and hard links.\n            if tarinfo.issym():\n                if os.path.lexists(targetpath):\n                    # Avoid FileExistsError on following os.symlink.\n                    os.unlink(targetpath)\n                os.symlink(tarinfo.linkname, targetpath)\n            else:\n                if os.path.exists(tarinfo._link_target):\n                    os.link(tarinfo._link_target, targetpath)\n                else:\n                    self._extract_member(self._find_link_target(tarinfo),\n                                         targetpath)\n        except symlink_exception:\n            try:\n                self._extract_member(self._find_link_target(tarinfo),\n                                     targetpath)\n            except KeyError:\n                raise ExtractError(\"unable to resolve link inside archive\") from None\n\n    def chown(self, tarinfo, targetpath, numeric_owner):\n        \"\"\"Set owner of targetpath according to tarinfo. If numeric_owner\n           is True, use .gid/.uid instead of .gname/.uname. If numeric_owner\n           is False, fall back to .gid/.uid when the search based on name\n           fails.\n        \"\"\"\n        if hasattr(os, \"geteuid\") and os.geteuid() == 0:\n            # We have to be root to do so.\n            g = tarinfo.gid\n            u = tarinfo.uid\n            if not numeric_owner:\n                try:\n                    if grp and tarinfo.gname:\n                        g = grp.getgrnam(tarinfo.gname)[2]\n                except KeyError:\n                    pass\n                try:\n                    if pwd and tarinfo.uname:\n                        u = pwd.getpwnam(tarinfo.uname)[2]\n                except KeyError:\n                    pass\n            if g is None:\n                g = -1\n            if u is None:\n                u = -1\n            try:\n                if tarinfo.issym() and hasattr(os, \"lchown\"):\n                    os.lchown(targetpath, u, g)\n                else:\n                    os.chown(targetpath, u, g)\n            except OSError as e:\n                raise ExtractError(\"could not change owner\") from e\n\n    def chmod(self, tarinfo, targetpath):\n        \"\"\"Set file permissions of targetpath according to tarinfo.\n        \"\"\"\n        if tarinfo.mode is None:\n            return\n        try:\n            os.chmod(targetpath, tarinfo.mode)\n        except OSError as e:\n            raise ExtractError(\"could not change mode\") from e\n\n    def utime(self, tarinfo, targetpath):\n        \"\"\"Set modification time of targetpath according to tarinfo.\n        \"\"\"\n        mtime = tarinfo.mtime\n        if mtime is None:\n            return\n        if not hasattr(os, 'utime'):\n            return\n        try:\n            os.utime(targetpath, (mtime, mtime))\n        except OSError as e:\n            raise ExtractError(\"could not change modification time\") from e\n\n    #--------------------------------------------------------------------------\n    def next(self):\n        \"\"\"Return the next member of the archive as a TarInfo object, when\n           TarFile is opened for reading. Return None if there is no more\n           available.\n        \"\"\"\n        self._check(\"ra\")\n        if self.firstmember is not None:\n            m = self.firstmember\n            self.firstmember = None\n            return m\n\n        # Advance the file pointer.\n        if self.offset != self.fileobj.tell():\n            if self.offset == 0:\n                return None\n            self.fileobj.seek(self.offset - 1)\n            if not self.fileobj.read(1):\n                raise ReadError(\"unexpected end of data\")\n\n        # Read the next block.\n        tarinfo = None\n        while True:\n            try:\n                tarinfo = self.tarinfo.fromtarfile(self)\n            except EOFHeaderError as e:\n                if self.ignore_zeros:\n                    self._dbg(2, \"0x%X: %s\" % (self.offset, e))\n                    self.offset += BLOCKSIZE\n                    continue\n            except InvalidHeaderError as e:\n                if self.ignore_zeros:\n                    self._dbg(2, \"0x%X: %s\" % (self.offset, e))\n                    self.offset += BLOCKSIZE\n                    continue\n                elif self.offset == 0:\n                    raise ReadError(str(e)) from None\n            except EmptyHeaderError:\n                if self.offset == 0:\n                    raise ReadError(\"empty file\") from None\n            except TruncatedHeaderError as e:\n                if self.offset == 0:\n                    raise ReadError(str(e)) from None\n            except SubsequentHeaderError as e:\n                raise ReadError(str(e)) from None\n            except Exception as e:\n                try:\n                    import zlib\n                    if isinstance(e, zlib.error):\n                        raise ReadError(f'zlib error: {e}') from None\n                    else:\n                        raise e\n                except ImportError:\n                    raise e\n            break\n\n        if tarinfo is not None:\n            self.members.append(tarinfo)\n        else:\n            self._loaded = True\n\n        return tarinfo\n\n    #--------------------------------------------------------------------------\n    # Little helper methods:\n\n    def _getmember(self, name, tarinfo=None, normalize=False):\n        \"\"\"Find an archive member by name from bottom to top.\n           If tarinfo is given, it is used as the starting point.\n        \"\"\"\n        # Ensure that all members have been loaded.\n        members = self.getmembers()\n\n        # Limit the member search list up to tarinfo.\n        skipping = False\n        if tarinfo is not None:\n            try:\n                index = members.index(tarinfo)\n            except ValueError:\n                # The given starting point might be a (modified) copy.\n                # We'll later skip members until we find an equivalent.\n                skipping = True\n            else:\n                # Happy fast path\n                members = members[:index]\n\n        if normalize:\n            name = os.path.normpath(name)\n\n        for member in reversed(members):\n            if skipping:\n                if tarinfo.offset == member.offset:\n                    skipping = False\n                continue\n            if normalize:\n                member_name = os.path.normpath(member.name)\n            else:\n                member_name = member.name\n\n            if name == member_name:\n                return member\n\n        if skipping:\n            # Starting point was not found\n            raise ValueError(tarinfo)\n\n    def _load(self):\n        \"\"\"Read through the entire archive file and look for readable\n           members.\n        \"\"\"\n        while self.next() is not None:\n            pass\n        self._loaded = True\n\n    def _check(self, mode=None):\n        \"\"\"Check if TarFile is still open, and if the operation's mode\n           corresponds to TarFile's mode.\n        \"\"\"\n        if self.closed:\n            raise OSError(\"%s is closed\" % self.__class__.__name__)\n        if mode is not None and self.mode not in mode:\n            raise OSError(\"bad operation for mode %r\" % self.mode)\n\n    def _find_link_target(self, tarinfo):\n        \"\"\"Find the target member of a symlink or hardlink member in the\n           archive.\n        \"\"\"\n        if tarinfo.issym():\n            # Always search the entire archive.\n            linkname = \"/\".join(filter(None, (os.path.dirname(tarinfo.name), tarinfo.linkname)))\n            limit = None\n        else:\n            # Search the archive before the link, because a hard link is\n            # just a reference to an already archived file.\n            linkname = tarinfo.linkname\n            limit = tarinfo\n\n        member = self._getmember(linkname, tarinfo=limit, normalize=True)\n        if member is None:\n            raise KeyError(\"linkname %r not found\" % linkname)\n        return member\n\n    def __iter__(self):\n        \"\"\"Provide an iterator object.\n        \"\"\"\n        if self._loaded:\n            yield from self.members\n            return\n\n        # Yield items using TarFile's next() method.\n        # When all members have been read, set TarFile as _loaded.\n        index = 0\n        # Fix for SF #1100429: Under rare circumstances it can\n        # happen that getmembers() is called during iteration,\n        # which will have already exhausted the next() method.\n        if self.firstmember is not None:\n            tarinfo = self.next()\n            index += 1\n            yield tarinfo\n\n        while True:\n            if index < len(self.members):\n                tarinfo = self.members[index]\n            elif not self._loaded:\n                tarinfo = self.next()\n                if not tarinfo:\n                    self._loaded = True\n                    return\n            else:\n                return\n            index += 1\n            yield tarinfo\n\n    def _dbg(self, level, msg):\n        \"\"\"Write debugging output to sys.stderr.\n        \"\"\"\n        if level <= self.debug:\n            print(msg, file=sys.stderr)\n\n    def __enter__(self):\n        self._check()\n        return self\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            self.close()\n        else:\n            # An exception occurred. We must not call close() because\n            # it would try to write end-of-archive blocks and padding.\n            if not self._extfileobj:\n                self.fileobj.close()\n            self.closed = True\n\n#--------------------\n# exported functions\n#--------------------\n\ndef is_tarfile(name):\n    \"\"\"Return True if name points to a tar archive that we\n       are able to handle, else return False.\n\n       'name' should be a string, file, or file-like object.\n    \"\"\"\n    try:\n        if hasattr(name, \"read\"):\n            pos = name.tell()\n            t = open(fileobj=name)\n            name.seek(pos)\n        else:\n            t = open(name)\n        t.close()\n        return True\n    except TarError:\n        return False\n\nopen = TarFile.open\n\n\ndef main():\n    import argparse\n\n    description = 'A simple command-line interface for tarfile module.'\n    parser = argparse.ArgumentParser(description=description)\n    parser.add_argument('-v', '--verbose', action='store_true', default=False,\n                        help='Verbose output')\n    parser.add_argument('--filter', metavar='<filtername>',\n                        choices=_NAMED_FILTERS,\n                        help='Filter for extraction')\n\n    group = parser.add_mutually_exclusive_group(required=True)\n    group.add_argument('-l', '--list', metavar='<tarfile>',\n                       help='Show listing of a tarfile')\n    group.add_argument('-e', '--extract', nargs='+',\n                       metavar=('<tarfile>', '<output_dir>'),\n                       help='Extract tarfile into target dir')\n    group.add_argument('-c', '--create', nargs='+',\n                       metavar=('<name>', '<file>'),\n                       help='Create tarfile from sources')\n    group.add_argument('-t', '--test', metavar='<tarfile>',\n                       help='Test if a tarfile is valid')\n\n    args = parser.parse_args()\n\n    if args.filter and args.extract is None:\n        parser.exit(1, '--filter is only valid for extraction\\n')\n\n    if args.test is not None:\n        src = args.test\n        if is_tarfile(src):\n            with open(src, 'r') as tar:\n                tar.getmembers()\n                print(tar.getmembers(), file=sys.stderr)\n            if args.verbose:\n                print('{!r} is a tar archive.'.format(src))\n        else:\n            parser.exit(1, '{!r} is not a tar archive.\\n'.format(src))\n\n    elif args.list is not None:\n        src = args.list\n        if is_tarfile(src):\n            with TarFile.open(src, 'r:*') as tf:\n                tf.list(verbose=args.verbose)\n        else:\n            parser.exit(1, '{!r} is not a tar archive.\\n'.format(src))\n\n    elif args.extract is not None:\n        if len(args.extract) == 1:\n            src = args.extract[0]\n            curdir = os.curdir\n        elif len(args.extract) == 2:\n            src, curdir = args.extract\n        else:\n            parser.exit(1, parser.format_help())\n\n        if is_tarfile(src):\n            with TarFile.open(src, 'r:*') as tf:\n                tf.extractall(path=curdir, filter=args.filter)\n            if args.verbose:\n                if curdir == '.':\n                    msg = '{!r} file is extracted.'.format(src)\n                else:\n                    msg = ('{!r} file is extracted '\n                           'into {!r} directory.').format(src, curdir)\n                print(msg)\n        else:\n            parser.exit(1, '{!r} is not a tar archive.\\n'.format(src))\n\n    elif args.create is not None:\n        tar_name = args.create.pop(0)\n        _, ext = os.path.splitext(tar_name)\n        compressions = {\n            # gz\n            '.gz': 'gz',\n            '.tgz': 'gz',\n            # xz\n            '.xz': 'xz',\n            '.txz': 'xz',\n            # bz2\n            '.bz2': 'bz2',\n            '.tbz': 'bz2',\n            '.tbz2': 'bz2',\n            '.tb2': 'bz2',\n        }\n        tar_mode = 'w:' + compressions[ext] if ext in compressions else 'w'\n        tar_files = args.create\n\n        with TarFile.open(tar_name, tar_mode) as tf:\n            for file_name in tar_files:\n                tf.add(file_name)\n\n        if args.verbose:\n            print('{!r} file created.'.format(tar_name))\n\nif __name__ == '__main__':\n    main()\n", "pkg_resources/_vendor/backports/__init__.py": "", "pkg_resources/_vendor/more_itertools/more.py": "import warnings\n\nfrom collections import Counter, defaultdict, deque, abc\nfrom collections.abc import Sequence\nfrom functools import cached_property, partial, reduce, wraps\nfrom heapq import heapify, heapreplace, heappop\nfrom itertools import (\n    chain,\n    compress,\n    count,\n    cycle,\n    dropwhile,\n    groupby,\n    islice,\n    repeat,\n    starmap,\n    takewhile,\n    tee,\n    zip_longest,\n    product,\n)\nfrom math import exp, factorial, floor, log, perm, comb\nfrom queue import Empty, Queue\nfrom random import random, randrange, uniform\nfrom operator import itemgetter, mul, sub, gt, lt, ge, le\nfrom sys import hexversion, maxsize\nfrom time import monotonic\n\nfrom .recipes import (\n    _marker,\n    _zip_equal,\n    UnequalIterablesError,\n    consume,\n    flatten,\n    pairwise,\n    powerset,\n    take,\n    unique_everseen,\n    all_equal,\n    batched,\n)\n\n__all__ = [\n    'AbortThread',\n    'SequenceView',\n    'UnequalIterablesError',\n    'adjacent',\n    'all_unique',\n    'always_iterable',\n    'always_reversible',\n    'bucket',\n    'callback_iter',\n    'chunked',\n    'chunked_even',\n    'circular_shifts',\n    'collapse',\n    'combination_index',\n    'combination_with_replacement_index',\n    'consecutive_groups',\n    'constrained_batches',\n    'consumer',\n    'count_cycle',\n    'countable',\n    'difference',\n    'distinct_combinations',\n    'distinct_permutations',\n    'distribute',\n    'divide',\n    'duplicates_everseen',\n    'duplicates_justseen',\n    'classify_unique',\n    'exactly_n',\n    'filter_except',\n    'filter_map',\n    'first',\n    'gray_product',\n    'groupby_transform',\n    'ichunked',\n    'iequals',\n    'ilen',\n    'interleave',\n    'interleave_evenly',\n    'interleave_longest',\n    'intersperse',\n    'is_sorted',\n    'islice_extended',\n    'iterate',\n    'iter_suppress',\n    'last',\n    'locate',\n    'longest_common_prefix',\n    'lstrip',\n    'make_decorator',\n    'map_except',\n    'map_if',\n    'map_reduce',\n    'mark_ends',\n    'minmax',\n    'nth_or_last',\n    'nth_permutation',\n    'nth_product',\n    'nth_combination_with_replacement',\n    'numeric_range',\n    'one',\n    'only',\n    'outer_product',\n    'padded',\n    'partial_product',\n    'partitions',\n    'peekable',\n    'permutation_index',\n    'product_index',\n    'raise_',\n    'repeat_each',\n    'repeat_last',\n    'replace',\n    'rlocate',\n    'rstrip',\n    'run_length',\n    'sample',\n    'seekable',\n    'set_partitions',\n    'side_effect',\n    'sliced',\n    'sort_together',\n    'split_after',\n    'split_at',\n    'split_before',\n    'split_into',\n    'split_when',\n    'spy',\n    'stagger',\n    'strip',\n    'strictly_n',\n    'substrings',\n    'substrings_indexes',\n    'takewhile_inclusive',\n    'time_limited',\n    'unique_in_window',\n    'unique_to_each',\n    'unzip',\n    'value_chain',\n    'windowed',\n    'windowed_complete',\n    'with_iter',\n    'zip_broadcast',\n    'zip_equal',\n    'zip_offset',\n]\n\n\ndef chunked(iterable, n, strict=False):\n    \"\"\"Break *iterable* into lists of length *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6], 3))\n        [[1, 2, 3], [4, 5, 6]]\n\n    By the default, the last yielded list will have fewer than *n* elements\n    if the length of *iterable* is not divisible by *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))\n        [[1, 2, 3], [4, 5, 6], [7, 8]]\n\n    To use a fill-in value instead, see the :func:`grouper` recipe.\n\n    If the length of *iterable* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    list is yielded.\n\n    \"\"\"\n    iterator = iter(partial(take, n, iter(iterable)), [])\n    if strict:\n        if n is None:\n            raise ValueError('n must not be None when using strict mode.')\n\n        def ret():\n            for chunk in iterator:\n                if len(chunk) != n:\n                    raise ValueError('iterable is not divisible by n.')\n                yield chunk\n\n        return iter(ret())\n    else:\n        return iterator\n\n\ndef first(iterable, default=_marker):\n    \"\"\"Return the first item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> first([0, 1, 2, 3])\n        0\n        >>> first([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n\n    :func:`first` is useful when you have a generator of expensive-to-retrieve\n    values and want any arbitrary one. It is marginally shorter than\n    ``next(iter(iterable), default)``.\n\n    \"\"\"\n    for item in iterable:\n        return item\n    if default is _marker:\n        raise ValueError(\n            'first() was called on an empty iterable, and no '\n            'default value was provided.'\n        )\n    return default\n\n\ndef last(iterable, default=_marker):\n    \"\"\"Return the last item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> last([0, 1, 2, 3])\n        3\n        >>> last([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    \"\"\"\n    try:\n        if isinstance(iterable, Sequence):\n            return iterable[-1]\n        # Work around https://bugs.python.org/issue38525\n        elif hasattr(iterable, '__reversed__') and (hexversion != 0x030800F0):\n            return next(reversed(iterable))\n        else:\n            return deque(iterable, maxlen=1)[-1]\n    except (IndexError, TypeError, StopIteration):\n        if default is _marker:\n            raise ValueError(\n                'last() was called on an empty iterable, and no default was '\n                'provided.'\n            )\n        return default\n\n\ndef nth_or_last(iterable, n, default=_marker):\n    \"\"\"Return the nth or the last item of *iterable*,\n    or *default* if *iterable* is empty.\n\n        >>> nth_or_last([0, 1, 2, 3], 2)\n        2\n        >>> nth_or_last([0, 1], 2)\n        1\n        >>> nth_or_last([], 0, 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    \"\"\"\n    return last(islice(iterable, n + 1), default=default)\n\n\nclass peekable:\n    \"\"\"Wrap an iterator to allow lookahead and prepending elements.\n\n    Call :meth:`peek` on the result to get the value that will be returned\n    by :func:`next`. This won't advance the iterator:\n\n        >>> p = peekable(['a', 'b'])\n        >>> p.peek()\n        'a'\n        >>> next(p)\n        'a'\n\n    Pass :meth:`peek` a default value to return that instead of raising\n    ``StopIteration`` when the iterator is exhausted.\n\n        >>> p = peekable([])\n        >>> p.peek('hi')\n        'hi'\n\n    peekables also offer a :meth:`prepend` method, which \"inserts\" items\n    at the head of the iterable:\n\n        >>> p = peekable([1, 2, 3])\n        >>> p.prepend(10, 11, 12)\n        >>> next(p)\n        10\n        >>> p.peek()\n        11\n        >>> list(p)\n        [11, 12, 1, 2, 3]\n\n    peekables can be indexed. Index 0 is the item that will be returned by\n    :func:`next`, index 1 is the item after that, and so on:\n    The values up to the given index will be cached.\n\n        >>> p = peekable(['a', 'b', 'c', 'd'])\n        >>> p[0]\n        'a'\n        >>> p[1]\n        'b'\n        >>> next(p)\n        'a'\n\n    Negative indexes are supported, but be aware that they will cache the\n    remaining items in the source iterator, which may require significant\n    storage.\n\n    To check whether a peekable is exhausted, check its truth value:\n\n        >>> p = peekable(['a', 'b'])\n        >>> if p:  # peekable has items\n        ...     list(p)\n        ['a', 'b']\n        >>> if not p:  # peekable is exhausted\n        ...     list(p)\n        []\n\n    \"\"\"\n\n    def __init__(self, iterable):\n        self._it = iter(iterable)\n        self._cache = deque()\n\n    def __iter__(self):\n        return self\n\n    def __bool__(self):\n        try:\n            self.peek()\n        except StopIteration:\n            return False\n        return True\n\n    def peek(self, default=_marker):\n        \"\"\"Return the item that will be next returned from ``next()``.\n\n        Return ``default`` if there are no items left. If ``default`` is not\n        provided, raise ``StopIteration``.\n\n        \"\"\"\n        if not self._cache:\n            try:\n                self._cache.append(next(self._it))\n            except StopIteration:\n                if default is _marker:\n                    raise\n                return default\n        return self._cache[0]\n\n    def prepend(self, *items):\n        \"\"\"Stack up items to be the next ones returned from ``next()`` or\n        ``self.peek()``. The items will be returned in\n        first in, first out order::\n\n            >>> p = peekable([1, 2, 3])\n            >>> p.prepend(10, 11, 12)\n            >>> next(p)\n            10\n            >>> list(p)\n            [11, 12, 1, 2, 3]\n\n        It is possible, by prepending items, to \"resurrect\" a peekable that\n        previously raised ``StopIteration``.\n\n            >>> p = peekable([])\n            >>> next(p)\n            Traceback (most recent call last):\n              ...\n            StopIteration\n            >>> p.prepend(1)\n            >>> next(p)\n            1\n            >>> next(p)\n            Traceback (most recent call last):\n              ...\n            StopIteration\n\n        \"\"\"\n        self._cache.extendleft(reversed(items))\n\n    def __next__(self):\n        if self._cache:\n            return self._cache.popleft()\n\n        return next(self._it)\n\n    def _get_slice(self, index):\n        # Normalize the slice's arguments\n        step = 1 if (index.step is None) else index.step\n        if step > 0:\n            start = 0 if (index.start is None) else index.start\n            stop = maxsize if (index.stop is None) else index.stop\n        elif step < 0:\n            start = -1 if (index.start is None) else index.start\n            stop = (-maxsize - 1) if (index.stop is None) else index.stop\n        else:\n            raise ValueError('slice step cannot be zero')\n\n        # If either the start or stop index is negative, we'll need to cache\n        # the rest of the iterable in order to slice from the right side.\n        if (start < 0) or (stop < 0):\n            self._cache.extend(self._it)\n        # Otherwise we'll need to find the rightmost index and cache to that\n        # point.\n        else:\n            n = min(max(start, stop) + 1, maxsize)\n            cache_len = len(self._cache)\n            if n >= cache_len:\n                self._cache.extend(islice(self._it, n - cache_len))\n\n        return list(self._cache)[index]\n\n    def __getitem__(self, index):\n        if isinstance(index, slice):\n            return self._get_slice(index)\n\n        cache_len = len(self._cache)\n        if index < 0:\n            self._cache.extend(self._it)\n        elif index >= cache_len:\n            self._cache.extend(islice(self._it, index + 1 - cache_len))\n\n        return self._cache[index]\n\n\ndef consumer(func):\n    \"\"\"Decorator that automatically advances a PEP-342-style \"reverse iterator\"\n    to its first yield point so you don't have to call ``next()`` on it\n    manually.\n\n        >>> @consumer\n        ... def tally():\n        ...     i = 0\n        ...     while True:\n        ...         print('Thing number %s is %s.' % (i, (yield)))\n        ...         i += 1\n        ...\n        >>> t = tally()\n        >>> t.send('red')\n        Thing number 0 is red.\n        >>> t.send('fish')\n        Thing number 1 is fish.\n\n    Without the decorator, you would have to call ``next(t)`` before\n    ``t.send()`` could be used.\n\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        gen = func(*args, **kwargs)\n        next(gen)\n        return gen\n\n    return wrapper\n\n\ndef ilen(iterable):\n    \"\"\"Return the number of items in *iterable*.\n\n        >>> ilen(x for x in range(1000000) if x % 3 == 0)\n        333334\n\n    This consumes the iterable, so handle with care.\n\n    \"\"\"\n    # This approach was selected because benchmarks showed it's likely the\n    # fastest of the known implementations at the time of writing.\n    # See GitHub tracker: #236, #230.\n    counter = count()\n    deque(zip(iterable, counter), maxlen=0)\n    return next(counter)\n\n\ndef iterate(func, start):\n    \"\"\"Return ``start``, ``func(start)``, ``func(func(start))``, ...\n\n    >>> from itertools import islice\n    >>> list(islice(iterate(lambda x: 2*x, 1), 10))\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n\n    \"\"\"\n    while True:\n        yield start\n        try:\n            start = func(start)\n        except StopIteration:\n            break\n\n\ndef with_iter(context_manager):\n    \"\"\"Wrap an iterable in a ``with`` statement, so it closes once exhausted.\n\n    For example, this will close the file when the iterator is exhausted::\n\n        upper_lines = (line.upper() for line in with_iter(open('foo')))\n\n    Any context manager which returns an iterable is a candidate for\n    ``with_iter``.\n\n    \"\"\"\n    with context_manager as iterable:\n        yield from iterable\n\n\ndef one(iterable, too_short=None, too_long=None):\n    \"\"\"Return the first item from *iterable*, which is expected to contain only\n    that item. Raise an exception if *iterable* is empty or has more than one\n    item.\n\n    :func:`one` is useful for ensuring that an iterable contains only one item.\n    For example, it can be used to retrieve the result of a database query\n    that is expected to return a single row.\n\n    If *iterable* is empty, ``ValueError`` will be raised. You may specify a\n    different exception with the *too_short* keyword:\n\n        >>> it = []\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too many items in iterable (expected 1)'\n        >>> too_short = IndexError('too few items')\n        >>> one(it, too_short=too_short)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        IndexError: too few items\n\n    Similarly, if *iterable* contains more than one item, ``ValueError`` will\n    be raised. You may specify a different exception with the *too_long*\n    keyword:\n\n        >>> it = ['too', 'many']\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: Expected exactly one item in iterable, but got 'too',\n        'many', and perhaps more.\n        >>> too_long = RuntimeError\n        >>> one(it, too_long=too_long)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        RuntimeError\n\n    Note that :func:`one` attempts to advance *iterable* twice to ensure there\n    is only one item. See :func:`spy` or :func:`peekable` to check iterable\n    contents less destructively.\n\n    \"\"\"\n    it = iter(iterable)\n\n    try:\n        first_value = next(it)\n    except StopIteration as e:\n        raise (\n            too_short or ValueError('too few items in iterable (expected 1)')\n        ) from e\n\n    try:\n        second_value = next(it)\n    except StopIteration:\n        pass\n    else:\n        msg = (\n            'Expected exactly one item in iterable, but got {!r}, {!r}, '\n            'and perhaps more.'.format(first_value, second_value)\n        )\n        raise too_long or ValueError(msg)\n\n    return first_value\n\n\ndef raise_(exception, *args):\n    raise exception(*args)\n\n\ndef strictly_n(iterable, n, too_short=None, too_long=None):\n    \"\"\"Validate that *iterable* has exactly *n* items and return them if\n    it does. If it has fewer than *n* items, call function *too_short*\n    with those items. If it has more than *n* items, call function\n    *too_long* with the first ``n + 1`` items.\n\n        >>> iterable = ['a', 'b', 'c', 'd']\n        >>> n = 4\n        >>> list(strictly_n(iterable, n))\n        ['a', 'b', 'c', 'd']\n\n    Note that the returned iterable must be consumed in order for the check to\n    be made.\n\n    By default, *too_short* and *too_long* are functions that raise\n    ``ValueError``.\n\n        >>> list(strictly_n('ab', 3))  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too few items in iterable (got 2)\n\n        >>> list(strictly_n('abc', 2))  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too many items in iterable (got at least 3)\n\n    You can instead supply functions that do something else.\n    *too_short* will be called with the number of items in *iterable*.\n    *too_long* will be called with `n + 1`.\n\n        >>> def too_short(item_count):\n        ...     raise RuntimeError\n        >>> it = strictly_n('abcd', 6, too_short=too_short)\n        >>> list(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        RuntimeError\n\n        >>> def too_long(item_count):\n        ...     print('The boss is going to hear about this')\n        >>> it = strictly_n('abcdef', 4, too_long=too_long)\n        >>> list(it)\n        The boss is going to hear about this\n        ['a', 'b', 'c', 'd']\n\n    \"\"\"\n    if too_short is None:\n        too_short = lambda item_count: raise_(\n            ValueError,\n            'Too few items in iterable (got {})'.format(item_count),\n        )\n\n    if too_long is None:\n        too_long = lambda item_count: raise_(\n            ValueError,\n            'Too many items in iterable (got at least {})'.format(item_count),\n        )\n\n    it = iter(iterable)\n    for i in range(n):\n        try:\n            item = next(it)\n        except StopIteration:\n            too_short(i)\n            return\n        else:\n            yield item\n\n    try:\n        next(it)\n    except StopIteration:\n        pass\n    else:\n        too_long(n + 1)\n\n\ndef distinct_permutations(iterable, r=None):\n    \"\"\"Yield successive distinct permutations of the elements in *iterable*.\n\n        >>> sorted(distinct_permutations([1, 0, 1]))\n        [(0, 1, 1), (1, 0, 1), (1, 1, 0)]\n\n    Equivalent to ``set(permutations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    Duplicate permutations arise when there are duplicated elements in the\n    input iterable. The number of items returned is\n    `n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of\n    items input, and each `x_i` is the count of a distinct item in the input\n    sequence.\n\n    If *r* is given, only the *r*-length permutations are yielded.\n\n        >>> sorted(distinct_permutations([1, 0, 1], r=2))\n        [(0, 1), (1, 0), (1, 1)]\n        >>> sorted(distinct_permutations(range(3), r=2))\n        [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]\n\n    \"\"\"\n\n    # Algorithm: https://w.wiki/Qai\n    def _full(A):\n        while True:\n            # Yield the permutation we have\n            yield tuple(A)\n\n            # Find the largest index i such that A[i] < A[i + 1]\n            for i in range(size - 2, -1, -1):\n                if A[i] < A[i + 1]:\n                    break\n            #  If no such index exists, this permutation is the last one\n            else:\n                return\n\n            # Find the largest index j greater than j such that A[i] < A[j]\n            for j in range(size - 1, i, -1):\n                if A[i] < A[j]:\n                    break\n\n            # Swap the value of A[i] with that of A[j], then reverse the\n            # sequence from A[i + 1] to form the new permutation\n            A[i], A[j] = A[j], A[i]\n            A[i + 1 :] = A[: i - size : -1]  # A[i + 1:][::-1]\n\n    # Algorithm: modified from the above\n    def _partial(A, r):\n        # Split A into the first r items and the last r items\n        head, tail = A[:r], A[r:]\n        right_head_indexes = range(r - 1, -1, -1)\n        left_tail_indexes = range(len(tail))\n\n        while True:\n            # Yield the permutation we have\n            yield tuple(head)\n\n            # Starting from the right, find the first index of the head with\n            # value smaller than the maximum value of the tail - call it i.\n            pivot = tail[-1]\n            for i in right_head_indexes:\n                if head[i] < pivot:\n                    break\n                pivot = head[i]\n            else:\n                return\n\n            # Starting from the left, find the first value of the tail\n            # with a value greater than head[i] and swap.\n            for j in left_tail_indexes:\n                if tail[j] > head[i]:\n                    head[i], tail[j] = tail[j], head[i]\n                    break\n            # If we didn't find one, start from the right and find the first\n            # index of the head with a value greater than head[i] and swap.\n            else:\n                for j in right_head_indexes:\n                    if head[j] > head[i]:\n                        head[i], head[j] = head[j], head[i]\n                        break\n\n            # Reverse head[i + 1:] and swap it with tail[:r - (i + 1)]\n            tail += head[: i - r : -1]  # head[i + 1:][::-1]\n            i += 1\n            head[i:], tail[:] = tail[: r - i], tail[r - i :]\n\n    items = sorted(iterable)\n\n    size = len(items)\n    if r is None:\n        r = size\n\n    if 0 < r <= size:\n        return _full(items) if (r == size) else _partial(items, r)\n\n    return iter(() if r else ((),))\n\n\ndef intersperse(e, iterable, n=1):\n    \"\"\"Intersperse filler element *e* among the items in *iterable*, leaving\n    *n* items between each filler element.\n\n        >>> list(intersperse('!', [1, 2, 3, 4, 5]))\n        [1, '!', 2, '!', 3, '!', 4, '!', 5]\n\n        >>> list(intersperse(None, [1, 2, 3, 4, 5], n=2))\n        [1, 2, None, 3, 4, None, 5]\n\n    \"\"\"\n    if n == 0:\n        raise ValueError('n must be > 0')\n    elif n == 1:\n        # interleave(repeat(e), iterable) -> e, x_0, e, x_1, e, x_2...\n        # islice(..., 1, None) -> x_0, e, x_1, e, x_2...\n        return islice(interleave(repeat(e), iterable), 1, None)\n    else:\n        # interleave(filler, chunks) -> [e], [x_0, x_1], [e], [x_2, x_3]...\n        # islice(..., 1, None) -> [x_0, x_1], [e], [x_2, x_3]...\n        # flatten(...) -> x_0, x_1, e, x_2, x_3...\n        filler = repeat([e])\n        chunks = chunked(iterable, n)\n        return flatten(islice(interleave(filler, chunks), 1, None))\n\n\ndef unique_to_each(*iterables):\n    \"\"\"Return the elements from each of the input iterables that aren't in the\n    other input iterables.\n\n    For example, suppose you have a set of packages, each with a set of\n    dependencies::\n\n        {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}\n\n    If you remove one package, which dependencies can also be removed?\n\n    If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not\n    associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for\n    ``pkg_2``, and ``D`` is only needed for ``pkg_3``::\n\n        >>> unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})\n        [['A'], ['C'], ['D']]\n\n    If there are duplicates in one input iterable that aren't in the others\n    they will be duplicated in the output. Input order is preserved::\n\n        >>> unique_to_each(\"mississippi\", \"missouri\")\n        [['p', 'p'], ['o', 'u', 'r']]\n\n    It is assumed that the elements of each iterable are hashable.\n\n    \"\"\"\n    pool = [list(it) for it in iterables]\n    counts = Counter(chain.from_iterable(map(set, pool)))\n    uniques = {element for element in counts if counts[element] == 1}\n    return [list(filter(uniques.__contains__, it)) for it in pool]\n\n\ndef windowed(seq, n, fillvalue=None, step=1):\n    \"\"\"Return a sliding window of width *n* over the given iterable.\n\n        >>> all_windows = windowed([1, 2, 3, 4, 5], 3)\n        >>> list(all_windows)\n        [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n\n    When the window is larger than the iterable, *fillvalue* is used in place\n    of missing values:\n\n        >>> list(windowed([1, 2, 3], 4))\n        [(1, 2, 3, None)]\n\n    Each window will advance in increments of *step*:\n\n        >>> list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue='!', step=2))\n        [(1, 2, 3), (3, 4, 5), (5, 6, '!')]\n\n    To slide into the iterable's items, use :func:`chain` to add filler items\n    to the left:\n\n        >>> iterable = [1, 2, 3, 4]\n        >>> n = 3\n        >>> padding = [None] * (n - 1)\n        >>> list(windowed(chain(padding, iterable), 3))\n        [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        yield tuple()\n        return\n    if step < 1:\n        raise ValueError('step must be >= 1')\n\n    window = deque(maxlen=n)\n    i = n\n    for _ in map(window.append, seq):\n        i -= 1\n        if not i:\n            i = step\n            yield tuple(window)\n\n    size = len(window)\n    if size == 0:\n        return\n    elif size < n:\n        yield tuple(chain(window, repeat(fillvalue, n - size)))\n    elif 0 < i < min(step, n):\n        window += (fillvalue,) * i\n        yield tuple(window)\n\n\ndef substrings(iterable):\n    \"\"\"Yield all of the substrings of *iterable*.\n\n        >>> [''.join(s) for s in substrings('more')]\n        ['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more']\n\n    Note that non-string iterables can also be subdivided.\n\n        >>> list(substrings([0, 1, 2]))\n        [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]\n\n    \"\"\"\n    # The length-1 substrings\n    seq = []\n    for item in iter(iterable):\n        seq.append(item)\n        yield (item,)\n    seq = tuple(seq)\n    item_count = len(seq)\n\n    # And the rest\n    for n in range(2, item_count + 1):\n        for i in range(item_count - n + 1):\n            yield seq[i : i + n]\n\n\ndef substrings_indexes(seq, reverse=False):\n    \"\"\"Yield all substrings and their positions in *seq*\n\n    The items yielded will be a tuple of the form ``(substr, i, j)``, where\n    ``substr == seq[i:j]``.\n\n    This function only works for iterables that support slicing, such as\n    ``str`` objects.\n\n    >>> for item in substrings_indexes('more'):\n    ...    print(item)\n    ('m', 0, 1)\n    ('o', 1, 2)\n    ('r', 2, 3)\n    ('e', 3, 4)\n    ('mo', 0, 2)\n    ('or', 1, 3)\n    ('re', 2, 4)\n    ('mor', 0, 3)\n    ('ore', 1, 4)\n    ('more', 0, 4)\n\n    Set *reverse* to ``True`` to yield the same items in the opposite order.\n\n\n    \"\"\"\n    r = range(1, len(seq) + 1)\n    if reverse:\n        r = reversed(r)\n    return (\n        (seq[i : i + L], i, i + L) for L in r for i in range(len(seq) - L + 1)\n    )\n\n\nclass bucket:\n    \"\"\"Wrap *iterable* and return an object that buckets the iterable into\n    child iterables based on a *key* function.\n\n        >>> iterable = ['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'b3']\n        >>> s = bucket(iterable, key=lambda x: x[0])  # Bucket by 1st character\n        >>> sorted(list(s))  # Get the keys\n        ['a', 'b', 'c']\n        >>> a_iterable = s['a']\n        >>> next(a_iterable)\n        'a1'\n        >>> next(a_iterable)\n        'a2'\n        >>> list(s['b'])\n        ['b1', 'b2', 'b3']\n\n    The original iterable will be advanced and its items will be cached until\n    they are used by the child iterables. This may require significant storage.\n\n    By default, attempting to select a bucket to which no items belong  will\n    exhaust the iterable and cache all values.\n    If you specify a *validator* function, selected buckets will instead be\n    checked against it.\n\n        >>> from itertools import count\n        >>> it = count(1, 2)  # Infinite sequence of odd numbers\n        >>> key = lambda x: x % 10  # Bucket by last digit\n        >>> validator = lambda x: x in {1, 3, 5, 7, 9}  # Odd digits only\n        >>> s = bucket(it, key=key, validator=validator)\n        >>> 2 in s\n        False\n        >>> list(s[2])\n        []\n\n    \"\"\"\n\n    def __init__(self, iterable, key, validator=None):\n        self._it = iter(iterable)\n        self._key = key\n        self._cache = defaultdict(deque)\n        self._validator = validator or (lambda x: True)\n\n    def __contains__(self, value):\n        if not self._validator(value):\n            return False\n\n        try:\n            item = next(self[value])\n        except StopIteration:\n            return False\n        else:\n            self._cache[value].appendleft(item)\n\n        return True\n\n    def _get_values(self, value):\n        \"\"\"\n        Helper to yield items from the parent iterator that match *value*.\n        Items that don't match are stored in the local cache as they\n        are encountered.\n        \"\"\"\n        while True:\n            # If we've cached some items that match the target value, emit\n            # the first one and evict it from the cache.\n            if self._cache[value]:\n                yield self._cache[value].popleft()\n            # Otherwise we need to advance the parent iterator to search for\n            # a matching item, caching the rest.\n            else:\n                while True:\n                    try:\n                        item = next(self._it)\n                    except StopIteration:\n                        return\n                    item_value = self._key(item)\n                    if item_value == value:\n                        yield item\n                        break\n                    elif self._validator(item_value):\n                        self._cache[item_value].append(item)\n\n    def __iter__(self):\n        for item in self._it:\n            item_value = self._key(item)\n            if self._validator(item_value):\n                self._cache[item_value].append(item)\n\n        yield from self._cache.keys()\n\n    def __getitem__(self, value):\n        if not self._validator(value):\n            return iter(())\n\n        return self._get_values(value)\n\n\ndef spy(iterable, n=1):\n    \"\"\"Return a 2-tuple with a list containing the first *n* elements of\n    *iterable*, and an iterator with the same items as *iterable*.\n    This allows you to \"look ahead\" at the items in the iterable without\n    advancing it.\n\n    There is one item in the list by default:\n\n        >>> iterable = 'abcdefg'\n        >>> head, iterable = spy(iterable)\n        >>> head\n        ['a']\n        >>> list(iterable)\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\n    You may use unpacking to retrieve items instead of lists:\n\n        >>> (head,), iterable = spy('abcdefg')\n        >>> head\n        'a'\n        >>> (first, second), iterable = spy('abcdefg', 2)\n        >>> first\n        'a'\n        >>> second\n        'b'\n\n    The number of items requested can be larger than the number of items in\n    the iterable:\n\n        >>> iterable = [1, 2, 3, 4, 5]\n        >>> head, iterable = spy(iterable, 10)\n        >>> head\n        [1, 2, 3, 4, 5]\n        >>> list(iterable)\n        [1, 2, 3, 4, 5]\n\n    \"\"\"\n    it = iter(iterable)\n    head = take(n, it)\n\n    return head.copy(), chain(head, it)\n\n\ndef interleave(*iterables):\n    \"\"\"Return a new iterable yielding from each iterable in turn,\n    until the shortest is exhausted.\n\n        >>> list(interleave([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7]\n\n    For a version that doesn't terminate after the shortest iterable is\n    exhausted, see :func:`interleave_longest`.\n\n    \"\"\"\n    return chain.from_iterable(zip(*iterables))\n\n\ndef interleave_longest(*iterables):\n    \"\"\"Return a new iterable yielding from each iterable in turn,\n    skipping any that are exhausted.\n\n        >>> list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7, 3, 8]\n\n    This function produces the same output as :func:`roundrobin`, but may\n    perform better for some inputs (in particular when the number of iterables\n    is large).\n\n    \"\"\"\n    i = chain.from_iterable(zip_longest(*iterables, fillvalue=_marker))\n    return (x for x in i if x is not _marker)\n\n\ndef interleave_evenly(iterables, lengths=None):\n    \"\"\"\n    Interleave multiple iterables so that their elements are evenly distributed\n    throughout the output sequence.\n\n    >>> iterables = [1, 2, 3, 4, 5], ['a', 'b']\n    >>> list(interleave_evenly(iterables))\n    [1, 2, 'a', 3, 4, 'b', 5]\n\n    >>> iterables = [[1, 2, 3], [4, 5], [6, 7, 8]]\n    >>> list(interleave_evenly(iterables))\n    [1, 6, 4, 2, 7, 3, 8, 5]\n\n    This function requires iterables of known length. Iterables without\n    ``__len__()`` can be used by manually specifying lengths with *lengths*:\n\n    >>> from itertools import combinations, repeat\n    >>> iterables = [combinations(range(4), 2), ['a', 'b', 'c']]\n    >>> lengths = [4 * (4 - 1) // 2, 3]\n    >>> list(interleave_evenly(iterables, lengths=lengths))\n    [(0, 1), (0, 2), 'a', (0, 3), (1, 2), 'b', (1, 3), (2, 3), 'c']\n\n    Based on Bresenham's algorithm.\n    \"\"\"\n    if lengths is None:\n        try:\n            lengths = [len(it) for it in iterables]\n        except TypeError:\n            raise ValueError(\n                'Iterable lengths could not be determined automatically. '\n                'Specify them with the lengths keyword.'\n            )\n    elif len(iterables) != len(lengths):\n        raise ValueError('Mismatching number of iterables and lengths.')\n\n    dims = len(lengths)\n\n    # sort iterables by length, descending\n    lengths_permute = sorted(\n        range(dims), key=lambda i: lengths[i], reverse=True\n    )\n    lengths_desc = [lengths[i] for i in lengths_permute]\n    iters_desc = [iter(iterables[i]) for i in lengths_permute]\n\n    # the longest iterable is the primary one (Bresenham: the longest\n    # distance along an axis)\n    delta_primary, deltas_secondary = lengths_desc[0], lengths_desc[1:]\n    iter_primary, iters_secondary = iters_desc[0], iters_desc[1:]\n    errors = [delta_primary // dims] * len(deltas_secondary)\n\n    to_yield = sum(lengths)\n    while to_yield:\n        yield next(iter_primary)\n        to_yield -= 1\n        # update errors for each secondary iterable\n        errors = [e - delta for e, delta in zip(errors, deltas_secondary)]\n\n        # those iterables for which the error is negative are yielded\n        # (\"diagonal step\" in Bresenham)\n        for i, e in enumerate(errors):\n            if e < 0:\n                yield next(iters_secondary[i])\n                to_yield -= 1\n                errors[i] += delta_primary\n\n\ndef collapse(iterable, base_type=None, levels=None):\n    \"\"\"Flatten an iterable with multiple levels of nesting (e.g., a list of\n    lists of tuples) into non-iterable types.\n\n        >>> iterable = [(1, 2), ([3, 4], [[5], [6]])]\n        >>> list(collapse(iterable))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and\n    will not be collapsed.\n\n    To avoid collapsing other types, specify *base_type*:\n\n        >>> iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]\n        >>> list(collapse(iterable, base_type=tuple))\n        ['ab', ('cd', 'ef'), 'gh', 'ij']\n\n    Specify *levels* to stop flattening after a certain level:\n\n    >>> iterable = [('a', ['b']), ('c', ['d'])]\n    >>> list(collapse(iterable))  # Fully flattened\n    ['a', 'b', 'c', 'd']\n    >>> list(collapse(iterable, levels=1))  # Only one level flattened\n    ['a', ['b'], 'c', ['d']]\n\n    \"\"\"\n\n    def walk(node, level):\n        if (\n            ((levels is not None) and (level > levels))\n            or isinstance(node, (str, bytes))\n            or ((base_type is not None) and isinstance(node, base_type))\n        ):\n            yield node\n            return\n\n        try:\n            tree = iter(node)\n        except TypeError:\n            yield node\n            return\n        else:\n            for child in tree:\n                yield from walk(child, level + 1)\n\n    yield from walk(iterable, 0)\n\n\ndef side_effect(func, iterable, chunk_size=None, before=None, after=None):\n    \"\"\"Invoke *func* on each item in *iterable* (or on each *chunk_size* group\n    of items) before yielding the item.\n\n    `func` must be a function that takes a single argument. Its return value\n    will be discarded.\n\n    *before* and *after* are optional functions that take no arguments. They\n    will be executed before iteration starts and after it ends, respectively.\n\n    `side_effect` can be used for logging, updating progress bars, or anything\n    that is not functionally \"pure.\"\n\n    Emitting a status message:\n\n        >>> from more_itertools import consume\n        >>> func = lambda item: print('Received {}'.format(item))\n        >>> consume(side_effect(func, range(2)))\n        Received 0\n        Received 1\n\n    Operating on chunks of items:\n\n        >>> pair_sums = []\n        >>> func = lambda chunk: pair_sums.append(sum(chunk))\n        >>> list(side_effect(func, [0, 1, 2, 3, 4, 5], 2))\n        [0, 1, 2, 3, 4, 5]\n        >>> list(pair_sums)\n        [1, 5, 9]\n\n    Writing to a file-like object:\n\n        >>> from io import StringIO\n        >>> from more_itertools import consume\n        >>> f = StringIO()\n        >>> func = lambda x: print(x, file=f)\n        >>> before = lambda: print(u'HEADER', file=f)\n        >>> after = f.close\n        >>> it = [u'a', u'b', u'c']\n        >>> consume(side_effect(func, it, before=before, after=after))\n        >>> f.closed\n        True\n\n    \"\"\"\n    try:\n        if before is not None:\n            before()\n\n        if chunk_size is None:\n            for item in iterable:\n                func(item)\n                yield item\n        else:\n            for chunk in chunked(iterable, chunk_size):\n                func(chunk)\n                yield from chunk\n    finally:\n        if after is not None:\n            after()\n\n\ndef sliced(seq, n, strict=False):\n    \"\"\"Yield slices of length *n* from the sequence *seq*.\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6), 3))\n    [(1, 2, 3), (4, 5, 6)]\n\n    By the default, the last yielded slice will have fewer than *n* elements\n    if the length of *seq* is not divisible by *n*:\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))\n    [(1, 2, 3), (4, 5, 6), (7, 8)]\n\n    If the length of *seq* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    slice is yielded.\n\n    This function will only work for iterables that support slicing.\n    For non-sliceable iterables, see :func:`chunked`.\n\n    \"\"\"\n    iterator = takewhile(len, (seq[i : i + n] for i in count(0, n)))\n    if strict:\n\n        def ret():\n            for _slice in iterator:\n                if len(_slice) != n:\n                    raise ValueError(\"seq is not divisible by n.\")\n                yield _slice\n\n        return iter(ret())\n    else:\n        return iterator\n\n\ndef split_at(iterable, pred, maxsplit=-1, keep_separator=False):\n    \"\"\"Yield lists of items from *iterable*, where each list is delimited by\n    an item where callable *pred* returns ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b'))\n        [['a'], ['c', 'd', 'c'], ['a']]\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1))\n        [[0], [2], [4], [6], [8], []]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1, maxsplit=2))\n        [[0], [2], [4, 5, 6, 7, 8, 9]]\n\n    By default, the delimiting items are not included in the output.\n    To include them, set *keep_separator* to ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b', keep_separator=True))\n        [['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item):\n            yield buf\n            if keep_separator:\n                yield [item]\n            if maxsplit == 1:\n                yield list(it)\n                return\n            buf = []\n            maxsplit -= 1\n        else:\n            buf.append(item)\n    yield buf\n\n\ndef split_before(iterable, pred, maxsplit=-1):\n    \"\"\"Yield lists of items from *iterable*, where each list ends just before\n    an item for which callable *pred* returns ``True``:\n\n        >>> list(split_before('OneTwo', lambda s: s.isupper()))\n        [['O', 'n', 'e'], ['T', 'w', 'o']]\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                yield [item] + list(it)\n                return\n            buf = []\n            maxsplit -= 1\n        buf.append(item)\n    if buf:\n        yield buf\n\n\ndef split_after(iterable, pred, maxsplit=-1):\n    \"\"\"Yield lists of items from *iterable*, where each list ends with an\n    item where callable *pred* returns ``True``:\n\n        >>> list(split_after('one1two2', lambda s: s.isdigit()))\n        [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0))\n        [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        buf.append(item)\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                buf = list(it)\n                if buf:\n                    yield buf\n                return\n            buf = []\n            maxsplit -= 1\n    if buf:\n        yield buf\n\n\ndef split_when(iterable, pred, maxsplit=-1):\n    \"\"\"Split *iterable* into pieces based on the output of *pred*.\n    *pred* should be a function that takes successive pairs of items and\n    returns ``True`` if the iterable should be split in between them.\n\n    For example, to find runs of increasing numbers, split the iterable when\n    element ``i`` is larger than element ``i + 1``:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x > y))\n        [[1, 2, 3, 3], [2, 5], [2, 4], [2]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],\n        ...                 lambda x, y: x > y, maxsplit=2))\n        [[1, 2, 3, 3], [2, 5], [2, 4, 2]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    it = iter(iterable)\n    try:\n        cur_item = next(it)\n    except StopIteration:\n        return\n\n    buf = [cur_item]\n    for next_item in it:\n        if pred(cur_item, next_item):\n            yield buf\n            if maxsplit == 1:\n                yield [next_item] + list(it)\n                return\n            buf = []\n            maxsplit -= 1\n\n        buf.append(next_item)\n        cur_item = next_item\n\n    yield buf\n\n\ndef split_into(iterable, sizes):\n    \"\"\"Yield a list of sequential items from *iterable* of length 'n' for each\n    integer 'n' in *sizes*.\n\n        >>> list(split_into([1,2,3,4,5,6], [1,2,3]))\n        [[1], [2, 3], [4, 5, 6]]\n\n    If the sum of *sizes* is smaller than the length of *iterable*, then the\n    remaining items of *iterable* will not be returned.\n\n        >>> list(split_into([1,2,3,4,5,6], [2,3]))\n        [[1, 2], [3, 4, 5]]\n\n    If the sum of *sizes* is larger than the length of *iterable*, fewer items\n    will be returned in the iteration that overruns *iterable* and further\n    lists will be empty:\n\n        >>> list(split_into([1,2,3,4], [1,2,3,4]))\n        [[1], [2, 3], [4], []]\n\n    When a ``None`` object is encountered in *sizes*, the returned list will\n    contain items up to the end of *iterable* the same way that itertools.slice\n    does:\n\n        >>> list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))\n        [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]\n\n    :func:`split_into` can be useful for grouping a series of items where the\n    sizes of the groups are not uniform. An example would be where in a row\n    from a table, multiple columns represent elements of the same feature\n    (e.g. a point represented by x,y,z) but, the format is not the same for\n    all columns.\n    \"\"\"\n    # convert the iterable argument into an iterator so its contents can\n    # be consumed by islice in case it is a generator\n    it = iter(iterable)\n\n    for size in sizes:\n        if size is None:\n            yield list(it)\n            return\n        else:\n            yield list(islice(it, size))\n\n\ndef padded(iterable, fillvalue=None, n=None, next_multiple=False):\n    \"\"\"Yield the elements from *iterable*, followed by *fillvalue*, such that\n    at least *n* items are emitted.\n\n        >>> list(padded([1, 2, 3], '?', 5))\n        [1, 2, 3, '?', '?']\n\n    If *next_multiple* is ``True``, *fillvalue* will be emitted until the\n    number of items emitted is a multiple of *n*::\n\n        >>> list(padded([1, 2, 3, 4], n=3, next_multiple=True))\n        [1, 2, 3, 4, None, None]\n\n    If *n* is ``None``, *fillvalue* will be emitted indefinitely.\n\n    \"\"\"\n    it = iter(iterable)\n    if n is None:\n        yield from chain(it, repeat(fillvalue))\n    elif n < 1:\n        raise ValueError('n must be at least 1')\n    else:\n        item_count = 0\n        for item in it:\n            yield item\n            item_count += 1\n\n        remaining = (n - item_count) % n if next_multiple else n - item_count\n        for _ in range(remaining):\n            yield fillvalue\n\n\ndef repeat_each(iterable, n=2):\n    \"\"\"Repeat each element in *iterable* *n* times.\n\n    >>> list(repeat_each('ABC', 3))\n    ['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C']\n    \"\"\"\n    return chain.from_iterable(map(repeat, iterable, repeat(n)))\n\n\ndef repeat_last(iterable, default=None):\n    \"\"\"After the *iterable* is exhausted, keep yielding its last element.\n\n        >>> list(islice(repeat_last(range(3)), 5))\n        [0, 1, 2, 2, 2]\n\n    If the iterable is empty, yield *default* forever::\n\n        >>> list(islice(repeat_last(range(0), 42), 5))\n        [42, 42, 42, 42, 42]\n\n    \"\"\"\n    item = _marker\n    for item in iterable:\n        yield item\n    final = default if item is _marker else item\n    yield from repeat(final)\n\n\ndef distribute(n, iterable):\n    \"\"\"Distribute the items from *iterable* among *n* smaller iterables.\n\n        >>> group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 3, 5]\n        >>> list(group_2)\n        [2, 4, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = distribute(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 4, 7], [2, 5], [3, 6]]\n\n    If the length of *iterable* is smaller than *n*, then the last returned\n    iterables will be empty:\n\n        >>> children = distribute(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function uses :func:`itertools.tee` and may require significant\n    storage. If you need the order items in the smaller iterables to match the\n    original iterable, see :func:`divide`.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    children = tee(iterable, n)\n    return [islice(it, index, None, n) for index, it in enumerate(children)]\n\n\ndef stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):\n    \"\"\"Yield tuples whose elements are offset from *iterable*.\n    The amount by which the `i`-th item in each tuple is offset is given by\n    the `i`-th item in *offsets*.\n\n        >>> list(stagger([0, 1, 2, 3]))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3)]\n        >>> list(stagger(range(8), offsets=(0, 2, 4)))\n        [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]\n\n    By default, the sequence will end when the final element of a tuple is the\n    last item in the iterable. To continue until the first element of a tuple\n    is the last item in the iterable, set *longest* to ``True``::\n\n        >>> list(stagger([0, 1, 2, 3], longest=True))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    \"\"\"\n    children = tee(iterable, len(offsets))\n\n    return zip_offset(\n        *children, offsets=offsets, longest=longest, fillvalue=fillvalue\n    )\n\n\ndef zip_equal(*iterables):\n    \"\"\"``zip`` the input *iterables* together, but raise\n    ``UnequalIterablesError`` if they aren't all the same length.\n\n        >>> it_1 = range(3)\n        >>> it_2 = iter('abc')\n        >>> list(zip_equal(it_1, it_2))\n        [(0, 'a'), (1, 'b'), (2, 'c')]\n\n        >>> it_1 = range(3)\n        >>> it_2 = iter('abcd')\n        >>> list(zip_equal(it_1, it_2)) # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        more_itertools.more.UnequalIterablesError: Iterables have different\n        lengths\n\n    \"\"\"\n    if hexversion >= 0x30A00A6:\n        warnings.warn(\n            (\n                'zip_equal will be removed in a future version of '\n                'more-itertools. Use the builtin zip function with '\n                'strict=True instead.'\n            ),\n            DeprecationWarning,\n        )\n\n    return _zip_equal(*iterables)\n\n\ndef zip_offset(*iterables, offsets, longest=False, fillvalue=None):\n    \"\"\"``zip`` the input *iterables* together, but offset the `i`-th iterable\n    by the `i`-th item in *offsets*.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1)))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]\n\n    This can be used as a lightweight alternative to SciPy or pandas to analyze\n    data sets in which some series have a lead or lag relationship.\n\n    By default, the sequence will end when the shortest iterable is exhausted.\n    To continue until the longest iterable is exhausted, set *longest* to\n    ``True``.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    \"\"\"\n    if len(iterables) != len(offsets):\n        raise ValueError(\"Number of iterables and offsets didn't match\")\n\n    staggered = []\n    for it, n in zip(iterables, offsets):\n        if n < 0:\n            staggered.append(chain(repeat(fillvalue, -n), it))\n        elif n > 0:\n            staggered.append(islice(it, n, None))\n        else:\n            staggered.append(it)\n\n    if longest:\n        return zip_longest(*staggered, fillvalue=fillvalue)\n\n    return zip(*staggered)\n\n\ndef sort_together(iterables, key_list=(0,), key=None, reverse=False):\n    \"\"\"Return the input iterables sorted together, with *key_list* as the\n    priority for sorting. All iterables are trimmed to the length of the\n    shortest one.\n\n    This can be used like the sorting function in a spreadsheet. If each\n    iterable represents a column of data, the key list determines which\n    columns are used for sorting.\n\n    By default, all iterables are sorted using the ``0``-th iterable::\n\n        >>> iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]\n        >>> sort_together(iterables)\n        [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]\n\n    Set a different key list to sort according to another iterable.\n    Specifying multiple keys dictates how ties are broken::\n\n        >>> iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]\n        >>> sort_together(iterables, key_list=(1, 2))\n        [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]\n\n    To sort by a function of the elements of the iterable, pass a *key*\n    function. Its arguments are the elements of the iterables corresponding to\n    the key list::\n\n        >>> names = ('a', 'b', 'c')\n        >>> lengths = (1, 2, 3)\n        >>> widths = (5, 2, 1)\n        >>> def area(length, width):\n        ...     return length * width\n        >>> sort_together([names, lengths, widths], key_list=(1, 2), key=area)\n        [('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)]\n\n    Set *reverse* to ``True`` to sort in descending order.\n\n        >>> sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True)\n        [(3, 2, 1), ('a', 'b', 'c')]\n\n    \"\"\"\n    if key is None:\n        # if there is no key function, the key argument to sorted is an\n        # itemgetter\n        key_argument = itemgetter(*key_list)\n    else:\n        # if there is a key function, call it with the items at the offsets\n        # specified by the key function as arguments\n        key_list = list(key_list)\n        if len(key_list) == 1:\n            # if key_list contains a single item, pass the item at that offset\n            # as the only argument to the key function\n            key_offset = key_list[0]\n            key_argument = lambda zipped_items: key(zipped_items[key_offset])\n        else:\n            # if key_list contains multiple items, use itemgetter to return a\n            # tuple of items, which we pass as *args to the key function\n            get_key_items = itemgetter(*key_list)\n            key_argument = lambda zipped_items: key(\n                *get_key_items(zipped_items)\n            )\n\n    return list(\n        zip(*sorted(zip(*iterables), key=key_argument, reverse=reverse))\n    )\n\n\ndef unzip(iterable):\n    \"\"\"The inverse of :func:`zip`, this function disaggregates the elements\n    of the zipped *iterable*.\n\n    The ``i``-th iterable contains the ``i``-th element from each element\n    of the zipped iterable. The first element is used to determine the\n    length of the remaining elements.\n\n        >>> iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> letters, numbers = unzip(iterable)\n        >>> list(letters)\n        ['a', 'b', 'c', 'd']\n        >>> list(numbers)\n        [1, 2, 3, 4]\n\n    This is similar to using ``zip(*iterable)``, but it avoids reading\n    *iterable* into memory. Note, however, that this function uses\n    :func:`itertools.tee` and thus may require significant storage.\n\n    \"\"\"\n    head, iterable = spy(iter(iterable))\n    if not head:\n        # empty iterable, e.g. zip([], [], [])\n        return ()\n    # spy returns a one-length iterable as head\n    head = head[0]\n    iterables = tee(iterable, len(head))\n\n    def itemgetter(i):\n        def getter(obj):\n            try:\n                return obj[i]\n            except IndexError:\n                # basically if we have an iterable like\n                # iter([(1, 2, 3), (4, 5), (6,)])\n                # the second unzipped iterable would fail at the third tuple\n                # since it would try to access tup[1]\n                # same with the third unzipped iterable and the second tuple\n                # to support these \"improperly zipped\" iterables,\n                # we create a custom itemgetter\n                # which just stops the unzipped iterables\n                # at first length mismatch\n                raise StopIteration\n\n        return getter\n\n    return tuple(map(itemgetter(i), it) for i, it in enumerate(iterables))\n\n\ndef divide(n, iterable):\n    \"\"\"Divide the elements from *iterable* into *n* parts, maintaining\n    order.\n\n        >>> group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 2, 3]\n        >>> list(group_2)\n        [4, 5, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = divide(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 2, 3], [4, 5], [6, 7]]\n\n    If the length of the iterable is smaller than n, then the last returned\n    iterables will be empty:\n\n        >>> children = divide(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function will exhaust the iterable before returning and may require\n    significant storage. If order is not important, see :func:`distribute`,\n    which does not first pull the iterable into memory.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    try:\n        iterable[:0]\n    except TypeError:\n        seq = tuple(iterable)\n    else:\n        seq = iterable\n\n    q, r = divmod(len(seq), n)\n\n    ret = []\n    stop = 0\n    for i in range(1, n + 1):\n        start = stop\n        stop += q + 1 if i <= r else q\n        ret.append(iter(seq[start:stop]))\n\n    return ret\n\n\ndef always_iterable(obj, base_type=(str, bytes)):\n    \"\"\"If *obj* is iterable, return an iterator over its items::\n\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n\n    If *obj* is ``None``, return an empty iterable:\n\n        >>> obj = None\n        >>> list(always_iterable(None))\n        []\n\n    By default, binary and text strings are not considered iterable::\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj))\n        ['foo']\n\n    If *base_type* is set, objects for which ``isinstance(obj, base_type)``\n    returns ``True`` won't be considered iterable.\n\n        >>> obj = {'a': 1}\n        >>> list(always_iterable(obj))  # Iterate over the dict's keys\n        ['a']\n        >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n        [{'a': 1}]\n\n    Set *base_type* to ``None`` to avoid any special handling and treat objects\n    Python considers iterable as iterable:\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj, base_type=None))\n        ['f', 'o', 'o']\n    \"\"\"\n    if obj is None:\n        return iter(())\n\n    if (base_type is not None) and isinstance(obj, base_type):\n        return iter((obj,))\n\n    try:\n        return iter(obj)\n    except TypeError:\n        return iter((obj,))\n\n\ndef adjacent(predicate, iterable, distance=1):\n    \"\"\"Return an iterable over `(bool, item)` tuples where the `item` is\n    drawn from *iterable* and the `bool` indicates whether\n    that item satisfies the *predicate* or is adjacent to an item that does.\n\n    For example, to find whether items are adjacent to a ``3``::\n\n        >>> list(adjacent(lambda x: x == 3, range(6)))\n        [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]\n\n    Set *distance* to change what counts as adjacent. For example, to find\n    whether items are two places away from a ``3``:\n\n        >>> list(adjacent(lambda x: x == 3, range(6), distance=2))\n        [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]\n\n    This is useful for contextualizing the results of a search function.\n    For example, a code comparison tool might want to identify lines that\n    have changed, but also surrounding lines to give the viewer of the diff\n    context.\n\n    The predicate function will only be called once for each item in the\n    iterable.\n\n    See also :func:`groupby_transform`, which can be used with this function\n    to group ranges of items with the same `bool` value.\n\n    \"\"\"\n    # Allow distance=0 mainly for testing that it reproduces results with map()\n    if distance < 0:\n        raise ValueError('distance must be at least 0')\n\n    i1, i2 = tee(iterable)\n    padding = [False] * distance\n    selected = chain(padding, map(predicate, i1), padding)\n    adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))\n    return zip(adjacent_to_selected, i2)\n\n\ndef groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):\n    \"\"\"An extension of :func:`itertools.groupby` that can apply transformations\n    to the grouped data.\n\n    * *keyfunc* is a function computing a key value for each item in *iterable*\n    * *valuefunc* is a function that transforms the individual items from\n      *iterable* after grouping\n    * *reducefunc* is a function that transforms each group of items\n\n    >>> iterable = 'aAAbBBcCC'\n    >>> keyfunc = lambda k: k.upper()\n    >>> valuefunc = lambda v: v.lower()\n    >>> reducefunc = lambda g: ''.join(g)\n    >>> list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))\n    [('A', 'aaa'), ('B', 'bbb'), ('C', 'ccc')]\n\n    Each optional argument defaults to an identity function if not specified.\n\n    :func:`groupby_transform` is useful when grouping elements of an iterable\n    using a separate iterable as the key. To do this, :func:`zip` the iterables\n    and pass a *keyfunc* that extracts the first element and a *valuefunc*\n    that extracts the second element::\n\n        >>> from operator import itemgetter\n        >>> keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]\n        >>> values = 'abcdefghi'\n        >>> iterable = zip(keys, values)\n        >>> grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))\n        >>> [(k, ''.join(g)) for k, g in grouper]\n        [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')]\n\n    Note that the order of items in the iterable is significant.\n    Only adjacent items are grouped together, so if you don't want any\n    duplicate groups, you should sort the iterable by the key function.\n\n    \"\"\"\n    ret = groupby(iterable, keyfunc)\n    if valuefunc:\n        ret = ((k, map(valuefunc, g)) for k, g in ret)\n    if reducefunc:\n        ret = ((k, reducefunc(g)) for k, g in ret)\n\n    return ret\n\n\nclass numeric_range(abc.Sequence, abc.Hashable):\n    \"\"\"An extension of the built-in ``range()`` function whose arguments can\n    be any orderable numeric type.\n\n    With only *stop* specified, *start* defaults to ``0`` and *step*\n    defaults to ``1``. The output items will match the type of *stop*:\n\n        >>> list(numeric_range(3.5))\n        [0.0, 1.0, 2.0, 3.0]\n\n    With only *start* and *stop* specified, *step* defaults to ``1``. The\n    output items will match the type of *start*:\n\n        >>> from decimal import Decimal\n        >>> start = Decimal('2.1')\n        >>> stop = Decimal('5.1')\n        >>> list(numeric_range(start, stop))\n        [Decimal('2.1'), Decimal('3.1'), Decimal('4.1')]\n\n    With *start*, *stop*, and *step*  specified the output items will match\n    the type of ``start + step``:\n\n        >>> from fractions import Fraction\n        >>> start = Fraction(1, 2)  # Start at 1/2\n        >>> stop = Fraction(5, 2)  # End at 5/2\n        >>> step = Fraction(1, 2)  # Count by 1/2\n        >>> list(numeric_range(start, stop, step))\n        [Fraction(1, 2), Fraction(1, 1), Fraction(3, 2), Fraction(2, 1)]\n\n    If *step* is zero, ``ValueError`` is raised. Negative steps are supported:\n\n        >>> list(numeric_range(3, -1, -1.0))\n        [3.0, 2.0, 1.0, 0.0]\n\n    Be aware of the limitations of floating point numbers; the representation\n    of the yielded numbers may be surprising.\n\n    ``datetime.datetime`` objects can be used for *start* and *stop*, if *step*\n    is a ``datetime.timedelta`` object:\n\n        >>> import datetime\n        >>> start = datetime.datetime(2019, 1, 1)\n        >>> stop = datetime.datetime(2019, 1, 3)\n        >>> step = datetime.timedelta(days=1)\n        >>> items = iter(numeric_range(start, stop, step))\n        >>> next(items)\n        datetime.datetime(2019, 1, 1, 0, 0)\n        >>> next(items)\n        datetime.datetime(2019, 1, 2, 0, 0)\n\n    \"\"\"\n\n    _EMPTY_HASH = hash(range(0, 0))\n\n    def __init__(self, *args):\n        argc = len(args)\n        if argc == 1:\n            (self._stop,) = args\n            self._start = type(self._stop)(0)\n            self._step = type(self._stop - self._start)(1)\n        elif argc == 2:\n            self._start, self._stop = args\n            self._step = type(self._stop - self._start)(1)\n        elif argc == 3:\n            self._start, self._stop, self._step = args\n        elif argc == 0:\n            raise TypeError(\n                'numeric_range expected at least '\n                '1 argument, got {}'.format(argc)\n            )\n        else:\n            raise TypeError(\n                'numeric_range expected at most '\n                '3 arguments, got {}'.format(argc)\n            )\n\n        self._zero = type(self._step)(0)\n        if self._step == self._zero:\n            raise ValueError('numeric_range() arg 3 must not be zero')\n        self._growing = self._step > self._zero\n\n    def __bool__(self):\n        if self._growing:\n            return self._start < self._stop\n        else:\n            return self._start > self._stop\n\n    def __contains__(self, elem):\n        if self._growing:\n            if self._start <= elem < self._stop:\n                return (elem - self._start) % self._step == self._zero\n        else:\n            if self._start >= elem > self._stop:\n                return (self._start - elem) % (-self._step) == self._zero\n\n        return False\n\n    def __eq__(self, other):\n        if isinstance(other, numeric_range):\n            empty_self = not bool(self)\n            empty_other = not bool(other)\n            if empty_self or empty_other:\n                return empty_self and empty_other  # True if both empty\n            else:\n                return (\n                    self._start == other._start\n                    and self._step == other._step\n                    and self._get_by_index(-1) == other._get_by_index(-1)\n                )\n        else:\n            return False\n\n    def __getitem__(self, key):\n        if isinstance(key, int):\n            return self._get_by_index(key)\n        elif isinstance(key, slice):\n            step = self._step if key.step is None else key.step * self._step\n\n            if key.start is None or key.start <= -self._len:\n                start = self._start\n            elif key.start >= self._len:\n                start = self._stop\n            else:  # -self._len < key.start < self._len\n                start = self._get_by_index(key.start)\n\n            if key.stop is None or key.stop >= self._len:\n                stop = self._stop\n            elif key.stop <= -self._len:\n                stop = self._start\n            else:  # -self._len < key.stop < self._len\n                stop = self._get_by_index(key.stop)\n\n            return numeric_range(start, stop, step)\n        else:\n            raise TypeError(\n                'numeric range indices must be '\n                'integers or slices, not {}'.format(type(key).__name__)\n            )\n\n    def __hash__(self):\n        if self:\n            return hash((self._start, self._get_by_index(-1), self._step))\n        else:\n            return self._EMPTY_HASH\n\n    def __iter__(self):\n        values = (self._start + (n * self._step) for n in count())\n        if self._growing:\n            return takewhile(partial(gt, self._stop), values)\n        else:\n            return takewhile(partial(lt, self._stop), values)\n\n    def __len__(self):\n        return self._len\n\n    @cached_property\n    def _len(self):\n        if self._growing:\n            start = self._start\n            stop = self._stop\n            step = self._step\n        else:\n            start = self._stop\n            stop = self._start\n            step = -self._step\n        distance = stop - start\n        if distance <= self._zero:\n            return 0\n        else:  # distance > 0 and step > 0: regular euclidean division\n            q, r = divmod(distance, step)\n            return int(q) + int(r != self._zero)\n\n    def __reduce__(self):\n        return numeric_range, (self._start, self._stop, self._step)\n\n    def __repr__(self):\n        if self._step == 1:\n            return \"numeric_range({}, {})\".format(\n                repr(self._start), repr(self._stop)\n            )\n        else:\n            return \"numeric_range({}, {}, {})\".format(\n                repr(self._start), repr(self._stop), repr(self._step)\n            )\n\n    def __reversed__(self):\n        return iter(\n            numeric_range(\n                self._get_by_index(-1), self._start - self._step, -self._step\n            )\n        )\n\n    def count(self, value):\n        return int(value in self)\n\n    def index(self, value):\n        if self._growing:\n            if self._start <= value < self._stop:\n                q, r = divmod(value - self._start, self._step)\n                if r == self._zero:\n                    return int(q)\n        else:\n            if self._start >= value > self._stop:\n                q, r = divmod(self._start - value, -self._step)\n                if r == self._zero:\n                    return int(q)\n\n        raise ValueError(\"{} is not in numeric range\".format(value))\n\n    def _get_by_index(self, i):\n        if i < 0:\n            i += self._len\n        if i < 0 or i >= self._len:\n            raise IndexError(\"numeric range object index out of range\")\n        return self._start + i * self._step\n\n\ndef count_cycle(iterable, n=None):\n    \"\"\"Cycle through the items from *iterable* up to *n* times, yielding\n    the number of completed cycles along with each item. If *n* is omitted the\n    process repeats indefinitely.\n\n    >>> list(count_cycle('AB', 3))\n    [(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]\n\n    \"\"\"\n    iterable = tuple(iterable)\n    if not iterable:\n        return iter(())\n    counter = count() if n is None else range(n)\n    return ((i, item) for i in counter for item in iterable)\n\n\ndef mark_ends(iterable):\n    \"\"\"Yield 3-tuples of the form ``(is_first, is_last, item)``.\n\n    >>> list(mark_ends('ABC'))\n    [(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]\n\n    Use this when looping over an iterable to take special action on its first\n    and/or last items:\n\n    >>> iterable = ['Header', 100, 200, 'Footer']\n    >>> total = 0\n    >>> for is_first, is_last, item in mark_ends(iterable):\n    ...     if is_first:\n    ...         continue  # Skip the header\n    ...     if is_last:\n    ...         continue  # Skip the footer\n    ...     total += item\n    >>> print(total)\n    300\n    \"\"\"\n    it = iter(iterable)\n\n    try:\n        b = next(it)\n    except StopIteration:\n        return\n\n    try:\n        for i in count():\n            a = b\n            b = next(it)\n            yield i == 0, False, a\n\n    except StopIteration:\n        yield i == 0, True, a\n\n\ndef locate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(locate([0, 1, 1, 0, 1, 0, 0]))\n        [1, 2, 4]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item.\n\n        >>> list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b'))\n        [1, 3]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(locate(iterable, pred=pred, window_size=3))\n        [1, 5, 9]\n\n    Use with :func:`seekable` to find indexes and then retrieve the associated\n    items:\n\n        >>> from itertools import count\n        >>> from more_itertools import seekable\n        >>> source = (3 * n + 1 if (n % 2) else n // 2 for n in count())\n        >>> it = seekable(source)\n        >>> pred = lambda x: x > 100\n        >>> indexes = locate(it, pred=pred)\n        >>> i = next(indexes)\n        >>> it.seek(i)\n        >>> next(it)\n        106\n\n    \"\"\"\n    if window_size is None:\n        return compress(count(), map(pred, iterable))\n\n    if window_size < 1:\n        raise ValueError('window size must be at least 1')\n\n    it = windowed(iterable, window_size, fillvalue=_marker)\n    return compress(count(), starmap(pred, it))\n\n\ndef longest_common_prefix(iterables):\n    \"\"\"Yield elements of the longest common prefix amongst given *iterables*.\n\n    >>> ''.join(longest_common_prefix(['abcd', 'abc', 'abf']))\n    'ab'\n\n    \"\"\"\n    return (c[0] for c in takewhile(all_equal, zip(*iterables)))\n\n\ndef lstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the beginning\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the start of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(lstrip(iterable, pred))\n        [1, 2, None, 3, False, None]\n\n    This function is analogous to to :func:`str.lstrip`, and is essentially\n    an wrapper for :func:`itertools.dropwhile`.\n\n    \"\"\"\n    return dropwhile(pred, iterable)\n\n\ndef rstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the end\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the end of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(rstrip(iterable, pred))\n        [None, False, None, 1, 2, None, 3]\n\n    This function is analogous to :func:`str.rstrip`.\n\n    \"\"\"\n    cache = []\n    cache_append = cache.append\n    cache_clear = cache.clear\n    for x in iterable:\n        if pred(x):\n            cache_append(x)\n        else:\n            yield from cache\n            cache_clear()\n            yield x\n\n\ndef strip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the\n    beginning and end for which *pred* returns ``True``.\n\n    For example, to remove a set of items from both ends of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(strip(iterable, pred))\n        [1, 2, None, 3]\n\n    This function is analogous to :func:`str.strip`.\n\n    \"\"\"\n    return rstrip(lstrip(iterable, pred), pred)\n\n\nclass islice_extended:\n    \"\"\"An extension of :func:`itertools.islice` that supports negative values\n    for *stop*, *start*, and *step*.\n\n        >>> iterable = iter('abcdefgh')\n        >>> list(islice_extended(iterable, -4, -1))\n        ['e', 'f', 'g']\n\n    Slices with negative values require some caching of *iterable*, but this\n    function takes care to minimize the amount of memory required.\n\n    For example, you can use a negative step with an infinite iterator:\n\n        >>> from itertools import count\n        >>> list(islice_extended(count(), 110, 99, -2))\n        [110, 108, 106, 104, 102, 100]\n\n    You can also use slice notation directly:\n\n        >>> iterable = map(str, count())\n        >>> it = islice_extended(iterable)[10:20:2]\n        >>> list(it)\n        ['10', '12', '14', '16', '18']\n\n    \"\"\"\n\n    def __init__(self, iterable, *args):\n        it = iter(iterable)\n        if args:\n            self._iterable = _islice_helper(it, slice(*args))\n        else:\n            self._iterable = it\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return next(self._iterable)\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return islice_extended(_islice_helper(self._iterable, key))\n\n        raise TypeError('islice_extended.__getitem__ argument must be a slice')\n\n\ndef _islice_helper(it, s):\n    start = s.start\n    stop = s.stop\n    if s.step == 0:\n        raise ValueError('step argument must be a non-zero integer or None.')\n    step = s.step or 1\n\n    if step > 0:\n        start = 0 if (start is None) else start\n\n        if start < 0:\n            # Consume all but the last -start items\n            cache = deque(enumerate(it, 1), maxlen=-start)\n            len_iter = cache[-1][0] if cache else 0\n\n            # Adjust start to be positive\n            i = max(len_iter + start, 0)\n\n            # Adjust stop to be positive\n            if stop is None:\n                j = len_iter\n            elif stop >= 0:\n                j = min(stop, len_iter)\n            else:\n                j = max(len_iter + stop, 0)\n\n            # Slice the cache\n            n = j - i\n            if n <= 0:\n                return\n\n            for index, item in islice(cache, 0, n, step):\n                yield item\n        elif (stop is not None) and (stop < 0):\n            # Advance to the start position\n            next(islice(it, start, start), None)\n\n            # When stop is negative, we have to carry -stop items while\n            # iterating\n            cache = deque(islice(it, -stop), maxlen=-stop)\n\n            for index, item in enumerate(it):\n                cached_item = cache.popleft()\n                if index % step == 0:\n                    yield cached_item\n                cache.append(item)\n        else:\n            # When both start and stop are positive we have the normal case\n            yield from islice(it, start, stop, step)\n    else:\n        start = -1 if (start is None) else start\n\n        if (stop is not None) and (stop < 0):\n            # Consume all but the last items\n            n = -stop - 1\n            cache = deque(enumerate(it, 1), maxlen=n)\n            len_iter = cache[-1][0] if cache else 0\n\n            # If start and stop are both negative they are comparable and\n            # we can just slice. Otherwise we can adjust start to be negative\n            # and then slice.\n            if start < 0:\n                i, j = start, stop\n            else:\n                i, j = min(start - len_iter, -1), None\n\n            for index, item in list(cache)[i:j:step]:\n                yield item\n        else:\n            # Advance to the stop position\n            if stop is not None:\n                m = stop + 1\n                next(islice(it, m, m), None)\n\n            # stop is positive, so if start is negative they are not comparable\n            # and we need the rest of the items.\n            if start < 0:\n                i = start\n                n = None\n            # stop is None and start is positive, so we just need items up to\n            # the start index.\n            elif stop is None:\n                i = None\n                n = start + 1\n            # Both stop and start are positive, so they are comparable.\n            else:\n                i = None\n                n = start - stop\n                if n <= 0:\n                    return\n\n            cache = list(islice(it, n))\n\n            yield from cache[i::step]\n\n\ndef always_reversible(iterable):\n    \"\"\"An extension of :func:`reversed` that supports all iterables, not\n    just those which implement the ``Reversible`` or ``Sequence`` protocols.\n\n        >>> print(*always_reversible(x for x in range(3)))\n        2 1 0\n\n    If the iterable is already reversible, this function returns the\n    result of :func:`reversed()`. If the iterable is not reversible,\n    this function will cache the remaining items in the iterable and\n    yield them in reverse order, which may require significant storage.\n    \"\"\"\n    try:\n        return reversed(iterable)\n    except TypeError:\n        return reversed(list(iterable))\n\n\ndef consecutive_groups(iterable, ordering=lambda x: x):\n    \"\"\"Yield groups of consecutive items using :func:`itertools.groupby`.\n    The *ordering* function determines whether two items are adjacent by\n    returning their position.\n\n    By default, the ordering function is the identity function. This is\n    suitable for finding runs of numbers:\n\n        >>> iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]\n        >>> for group in consecutive_groups(iterable):\n        ...     print(list(group))\n        [1]\n        [10, 11, 12]\n        [20]\n        [30, 31, 32, 33]\n        [40]\n\n    For finding runs of adjacent letters, try using the :meth:`index` method\n    of a string of letters:\n\n        >>> from string import ascii_lowercase\n        >>> iterable = 'abcdfgilmnop'\n        >>> ordering = ascii_lowercase.index\n        >>> for group in consecutive_groups(iterable, ordering):\n        ...     print(list(group))\n        ['a', 'b', 'c', 'd']\n        ['f', 'g']\n        ['i']\n        ['l', 'm', 'n', 'o', 'p']\n\n    Each group of consecutive items is an iterator that shares it source with\n    *iterable*. When an an output group is advanced, the previous group is\n    no longer available unless its elements are copied (e.g., into a ``list``).\n\n        >>> iterable = [1, 2, 11, 12, 21, 22]\n        >>> saved_groups = []\n        >>> for group in consecutive_groups(iterable):\n        ...     saved_groups.append(list(group))  # Copy group elements\n        >>> saved_groups\n        [[1, 2], [11, 12], [21, 22]]\n\n    \"\"\"\n    for k, g in groupby(\n        enumerate(iterable), key=lambda x: x[0] - ordering(x[1])\n    ):\n        yield map(itemgetter(1), g)\n\n\ndef difference(iterable, func=sub, *, initial=None):\n    \"\"\"This function is the inverse of :func:`itertools.accumulate`. By default\n    it will compute the first difference of *iterable* using\n    :func:`operator.sub`:\n\n        >>> from itertools import accumulate\n        >>> iterable = accumulate([0, 1, 2, 3, 4])  # produces 0, 1, 3, 6, 10\n        >>> list(difference(iterable))\n        [0, 1, 2, 3, 4]\n\n    *func* defaults to :func:`operator.sub`, but other functions can be\n    specified. They will be applied as follows::\n\n        A, B, C, D, ... --> A, func(B, A), func(C, B), func(D, C), ...\n\n    For example, to do progressive division:\n\n        >>> iterable = [1, 2, 6, 24, 120]\n        >>> func = lambda x, y: x // y\n        >>> list(difference(iterable, func))\n        [1, 2, 3, 4, 5]\n\n    If the *initial* keyword is set, the first element will be skipped when\n    computing successive differences.\n\n        >>> it = [10, 11, 13, 16]  # from accumulate([1, 2, 3], initial=10)\n        >>> list(difference(it, initial=10))\n        [1, 2, 3]\n\n    \"\"\"\n    a, b = tee(iterable)\n    try:\n        first = [next(b)]\n    except StopIteration:\n        return iter([])\n\n    if initial is not None:\n        first = []\n\n    return chain(first, map(func, b, a))\n\n\nclass SequenceView(Sequence):\n    \"\"\"Return a read-only view of the sequence object *target*.\n\n    :class:`SequenceView` objects are analogous to Python's built-in\n    \"dictionary view\" types. They provide a dynamic view of a sequence's items,\n    meaning that when the sequence updates, so does the view.\n\n        >>> seq = ['0', '1', '2']\n        >>> view = SequenceView(seq)\n        >>> view\n        SequenceView(['0', '1', '2'])\n        >>> seq.append('3')\n        >>> view\n        SequenceView(['0', '1', '2', '3'])\n\n    Sequence views support indexing, slicing, and length queries. They act\n    like the underlying sequence, except they don't allow assignment:\n\n        >>> view[1]\n        '1'\n        >>> view[1:-1]\n        ['1', '2']\n        >>> len(view)\n        4\n\n    Sequence views are useful as an alternative to copying, as they don't\n    require (much) extra storage.\n\n    \"\"\"\n\n    def __init__(self, target):\n        if not isinstance(target, Sequence):\n            raise TypeError\n        self._target = target\n\n    def __getitem__(self, index):\n        return self._target[index]\n\n    def __len__(self):\n        return len(self._target)\n\n    def __repr__(self):\n        return '{}({})'.format(self.__class__.__name__, repr(self._target))\n\n\nclass seekable:\n    \"\"\"Wrap an iterator to allow for seeking backward and forward. This\n    progressively caches the items in the source iterable so they can be\n    re-visited.\n\n    Call :meth:`seek` with an index to seek to that position in the source\n    iterable.\n\n    To \"reset\" an iterator, seek to ``0``:\n\n        >>> from itertools import count\n        >>> it = seekable((str(n) for n in count()))\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> it.seek(0)\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> next(it)\n        '3'\n\n    You can also seek forward:\n\n        >>> it = seekable((str(n) for n in range(20)))\n        >>> it.seek(10)\n        >>> next(it)\n        '10'\n        >>> it.relative_seek(-2)  # Seeking relative to the current position\n        >>> next(it)\n        '9'\n        >>> it.seek(20)  # Seeking past the end of the source isn't a problem\n        >>> list(it)\n        []\n        >>> it.seek(0)  # Resetting works even after hitting the end\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n\n    Call :meth:`peek` to look ahead one item without advancing the iterator:\n\n        >>> it = seekable('1234')\n        >>> it.peek()\n        '1'\n        >>> list(it)\n        ['1', '2', '3', '4']\n        >>> it.peek(default='empty')\n        'empty'\n\n    Before the iterator is at its end, calling :func:`bool` on it will return\n    ``True``. After it will return ``False``:\n\n        >>> it = seekable('5678')\n        >>> bool(it)\n        True\n        >>> list(it)\n        ['5', '6', '7', '8']\n        >>> bool(it)\n        False\n\n    You may view the contents of the cache with the :meth:`elements` method.\n    That returns a :class:`SequenceView`, a view that updates automatically:\n\n        >>> it = seekable((str(n) for n in range(10)))\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> elements = it.elements()\n        >>> elements\n        SequenceView(['0', '1', '2'])\n        >>> next(it)\n        '3'\n        >>> elements\n        SequenceView(['0', '1', '2', '3'])\n\n    By default, the cache grows as the source iterable progresses, so beware of\n    wrapping very large or infinite iterables. Supply *maxlen* to limit the\n    size of the cache (this of course limits how far back you can seek).\n\n        >>> from itertools import count\n        >>> it = seekable((str(n) for n in count()), maxlen=2)\n        >>> next(it), next(it), next(it), next(it)\n        ('0', '1', '2', '3')\n        >>> list(it.elements())\n        ['2', '3']\n        >>> it.seek(0)\n        >>> next(it), next(it), next(it), next(it)\n        ('2', '3', '4', '5')\n        >>> next(it)\n        '6'\n\n    \"\"\"\n\n    def __init__(self, iterable, maxlen=None):\n        self._source = iter(iterable)\n        if maxlen is None:\n            self._cache = []\n        else:\n            self._cache = deque([], maxlen)\n        self._index = None\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self._index is not None:\n            try:\n                item = self._cache[self._index]\n            except IndexError:\n                self._index = None\n            else:\n                self._index += 1\n                return item\n\n        item = next(self._source)\n        self._cache.append(item)\n        return item\n\n    def __bool__(self):\n        try:\n            self.peek()\n        except StopIteration:\n            return False\n        return True\n\n    def peek(self, default=_marker):\n        try:\n            peeked = next(self)\n        except StopIteration:\n            if default is _marker:\n                raise\n            return default\n        if self._index is None:\n            self._index = len(self._cache)\n        self._index -= 1\n        return peeked\n\n    def elements(self):\n        return SequenceView(self._cache)\n\n    def seek(self, index):\n        self._index = index\n        remainder = index - len(self._cache)\n        if remainder > 0:\n            consume(self, remainder)\n\n    def relative_seek(self, count):\n        index = len(self._cache)\n        self.seek(max(index + count, 0))\n\n\nclass run_length:\n    \"\"\"\n    :func:`run_length.encode` compresses an iterable with run-length encoding.\n    It yields groups of repeated items with the count of how many times they\n    were repeated:\n\n        >>> uncompressed = 'abbcccdddd'\n        >>> list(run_length.encode(uncompressed))\n        [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n\n    :func:`run_length.decode` decompresses an iterable that was previously\n    compressed with run-length encoding. It yields the items of the\n    decompressed iterable:\n\n        >>> compressed = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> list(run_length.decode(compressed))\n        ['a', 'b', 'b', 'c', 'c', 'c', 'd', 'd', 'd', 'd']\n\n    \"\"\"\n\n    @staticmethod\n    def encode(iterable):\n        return ((k, ilen(g)) for k, g in groupby(iterable))\n\n    @staticmethod\n    def decode(iterable):\n        return chain.from_iterable(repeat(k, n) for k, n in iterable)\n\n\ndef exactly_n(iterable, n, predicate=bool):\n    \"\"\"Return ``True`` if exactly ``n`` items in the iterable are ``True``\n    according to the *predicate* function.\n\n        >>> exactly_n([True, True, False], 2)\n        True\n        >>> exactly_n([True, True, False], 1)\n        False\n        >>> exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x < 3)\n        True\n\n    The iterable will be advanced until ``n + 1`` truthy items are encountered,\n    so avoid calling it on infinite iterables.\n\n    \"\"\"\n    return len(take(n + 1, filter(predicate, iterable))) == n\n\n\ndef circular_shifts(iterable):\n    \"\"\"Return a list of circular shifts of *iterable*.\n\n    >>> circular_shifts(range(4))\n    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n    \"\"\"\n    lst = list(iterable)\n    return take(len(lst), windowed(cycle(lst), len(lst)))\n\n\ndef make_decorator(wrapping_func, result_index=0):\n    \"\"\"Return a decorator version of *wrapping_func*, which is a function that\n    modifies an iterable. *result_index* is the position in that function's\n    signature where the iterable goes.\n\n    This lets you use itertools on the \"production end,\" i.e. at function\n    definition. This can augment what the function returns without changing the\n    function's code.\n\n    For example, to produce a decorator version of :func:`chunked`:\n\n        >>> from more_itertools import chunked\n        >>> chunker = make_decorator(chunked, result_index=0)\n        >>> @chunker(3)\n        ... def iter_range(n):\n        ...     return iter(range(n))\n        ...\n        >>> list(iter_range(9))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n    To only allow truthy items to be returned:\n\n        >>> truth_serum = make_decorator(filter, result_index=1)\n        >>> @truth_serum(bool)\n        ... def boolean_test():\n        ...     return [0, 1, '', ' ', False, True]\n        ...\n        >>> list(boolean_test())\n        [1, ' ', True]\n\n    The :func:`peekable` and :func:`seekable` wrappers make for practical\n    decorators:\n\n        >>> from more_itertools import peekable\n        >>> peekable_function = make_decorator(peekable)\n        >>> @peekable_function()\n        ... def str_range(*args):\n        ...     return (str(x) for x in range(*args))\n        ...\n        >>> it = str_range(1, 20, 2)\n        >>> next(it), next(it), next(it)\n        ('1', '3', '5')\n        >>> it.peek()\n        '7'\n        >>> next(it)\n        '7'\n\n    \"\"\"\n\n    # See https://sites.google.com/site/bbayles/index/decorator_factory for\n    # notes on how this works.\n    def decorator(*wrapping_args, **wrapping_kwargs):\n        def outer_wrapper(f):\n            def inner_wrapper(*args, **kwargs):\n                result = f(*args, **kwargs)\n                wrapping_args_ = list(wrapping_args)\n                wrapping_args_.insert(result_index, result)\n                return wrapping_func(*wrapping_args_, **wrapping_kwargs)\n\n            return inner_wrapper\n\n        return outer_wrapper\n\n    return decorator\n\n\ndef map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):\n    \"\"\"Return a dictionary that maps the items in *iterable* to categories\n    defined by *keyfunc*, transforms them with *valuefunc*, and\n    then summarizes them by category with *reducefunc*.\n\n    *valuefunc* defaults to the identity function if it is unspecified.\n    If *reducefunc* is unspecified, no summarization takes place:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> result = map_reduce('abbccc', keyfunc)\n        >>> sorted(result.items())\n        [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    Specifying *valuefunc* transforms the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc)\n        >>> sorted(result.items())\n        [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    Specifying *reducefunc* summarizes the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> reducefunc = sum\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)\n        >>> sorted(result.items())\n        [('A', 1), ('B', 2), ('C', 3)]\n\n    You may want to filter the input iterable before applying the map/reduce\n    procedure:\n\n        >>> all_items = range(30)\n        >>> items = [x for x in all_items if 10 <= x <= 20]  # Filter\n        >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n        >>> categories = map_reduce(items, keyfunc=keyfunc)\n        >>> sorted(categories.items())\n        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n        >>> summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)\n        >>> sorted(summaries.items())\n        [(0, 90), (1, 75)]\n\n    Note that all items in the iterable are gathered into a list before the\n    summarization step, which may require significant storage.\n\n    The returned object is a :obj:`collections.defaultdict` with the\n    ``default_factory`` set to ``None``, such that it behaves like a normal\n    dictionary.\n\n    \"\"\"\n    valuefunc = (lambda x: x) if (valuefunc is None) else valuefunc\n\n    ret = defaultdict(list)\n    for item in iterable:\n        key = keyfunc(item)\n        value = valuefunc(item)\n        ret[key].append(value)\n\n    if reducefunc is not None:\n        for key, value_list in ret.items():\n            ret[key] = reducefunc(value_list)\n\n    ret.default_factory = None\n    return ret\n\n\ndef rlocate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``, starting from the right and moving left.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(rlocate([0, 1, 1, 0, 1, 0, 0]))  # Truthy at 1, 2, and 4\n        [4, 2, 1]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item:\n\n        >>> iterable = iter('abcb')\n        >>> pred = lambda x: x == 'b'\n        >>> list(rlocate(iterable, pred))\n        [3, 1]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(rlocate(iterable, pred=pred, window_size=3))\n        [9, 5, 1]\n\n    Beware, this function won't return anything for infinite iterables.\n    If *iterable* is reversible, ``rlocate`` will reverse it and search from\n    the right. Otherwise, it will search from the left and return the results\n    in reverse order.\n\n    See :func:`locate` to for other example applications.\n\n    \"\"\"\n    if window_size is None:\n        try:\n            len_iter = len(iterable)\n            return (len_iter - i - 1 for i in locate(reversed(iterable), pred))\n        except TypeError:\n            pass\n\n    return reversed(list(locate(iterable, pred, window_size)))\n\n\ndef replace(iterable, pred, substitutes, count=None, window_size=1):\n    \"\"\"Yield the items from *iterable*, replacing the items for which *pred*\n    returns ``True`` with the items from the iterable *substitutes*.\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = (2, 3)\n        >>> list(replace(iterable, pred, substitutes))\n        [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]\n\n    If *count* is given, the number of replacements will be limited:\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = [None]\n        >>> list(replace(iterable, pred, substitutes, count=2))\n        [1, 1, None, 1, 1, None, 1, 1, 0]\n\n    Use *window_size* to control the number of items passed as arguments to\n    *pred*. This allows for locating and replacing subsequences.\n\n        >>> iterable = [0, 1, 2, 5, 0, 1, 2, 5]\n        >>> window_size = 3\n        >>> pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred\n        >>> substitutes = [3, 4] # Splice in these items\n        >>> list(replace(iterable, pred, substitutes, window_size=window_size))\n        [3, 4, 5, 3, 4, 5]\n\n    \"\"\"\n    if window_size < 1:\n        raise ValueError('window_size must be at least 1')\n\n    # Save the substitutes iterable, since it's used more than once\n    substitutes = tuple(substitutes)\n\n    # Add padding such that the number of windows matches the length of the\n    # iterable\n    it = chain(iterable, [_marker] * (window_size - 1))\n    windows = windowed(it, window_size)\n\n    n = 0\n    for w in windows:\n        # If the current window matches our predicate (and we haven't hit\n        # our maximum number of replacements), splice in the substitutes\n        # and then consume the following windows that overlap with this one.\n        # For example, if the iterable is (0, 1, 2, 3, 4...)\n        # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...\n        # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)\n        if pred(*w):\n            if (count is None) or (n < count):\n                n += 1\n                yield from substitutes\n                consume(windows, window_size - 1)\n                continue\n\n        # If there was no match (or we've reached the replacement limit),\n        # yield the first item from the window.\n        if w and (w[0] is not _marker):\n            yield w[0]\n\n\ndef partitions(iterable):\n    \"\"\"Yield all possible order-preserving partitions of *iterable*.\n\n    >>> iterable = 'abc'\n    >>> for part in partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['a', 'b', 'c']\n\n    This is unrelated to :func:`partition`.\n\n    \"\"\"\n    sequence = list(iterable)\n    n = len(sequence)\n    for i in powerset(range(1, n)):\n        yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]\n\n\ndef set_partitions(iterable, k=None):\n    \"\"\"\n    Yield the set partitions of *iterable* into *k* parts. Set partitions are\n    not order-preserving.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable, 2):\n    ...     print([''.join(p) for p in part])\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n\n\n    If *k* is not given, every set partition is generated.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n    ['a', 'b', 'c']\n\n    \"\"\"\n    L = list(iterable)\n    n = len(L)\n    if k is not None:\n        if k < 1:\n            raise ValueError(\n                \"Can't partition in a negative or zero number of groups\"\n            )\n        elif k > n:\n            return\n\n    def set_partitions_helper(L, k):\n        n = len(L)\n        if k == 1:\n            yield [L]\n        elif n == k:\n            yield [[s] for s in L]\n        else:\n            e, *M = L\n            for p in set_partitions_helper(M, k - 1):\n                yield [[e], *p]\n            for p in set_partitions_helper(M, k):\n                for i in range(len(p)):\n                    yield p[:i] + [[e] + p[i]] + p[i + 1 :]\n\n    if k is None:\n        for k in range(1, n + 1):\n            yield from set_partitions_helper(L, k)\n    else:\n        yield from set_partitions_helper(L, k)\n\n\nclass time_limited:\n    \"\"\"\n    Yield items from *iterable* until *limit_seconds* have passed.\n    If the time limit expires before all items have been yielded, the\n    ``timed_out`` parameter will be set to ``True``.\n\n    >>> from time import sleep\n    >>> def generator():\n    ...     yield 1\n    ...     yield 2\n    ...     sleep(0.2)\n    ...     yield 3\n    >>> iterable = time_limited(0.1, generator())\n    >>> list(iterable)\n    [1, 2]\n    >>> iterable.timed_out\n    True\n\n    Note that the time is checked before each item is yielded, and iteration\n    stops if  the time elapsed is greater than *limit_seconds*. If your time\n    limit is 1 second, but it takes 2 seconds to generate the first item from\n    the iterable, the function will run for 2 seconds and not yield anything.\n    As a special case, when *limit_seconds* is zero, the iterator never\n    returns anything.\n\n    \"\"\"\n\n    def __init__(self, limit_seconds, iterable):\n        if limit_seconds < 0:\n            raise ValueError('limit_seconds must be positive')\n        self.limit_seconds = limit_seconds\n        self._iterable = iter(iterable)\n        self._start_time = monotonic()\n        self.timed_out = False\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.limit_seconds == 0:\n            self.timed_out = True\n            raise StopIteration\n        item = next(self._iterable)\n        if monotonic() - self._start_time > self.limit_seconds:\n            self.timed_out = True\n            raise StopIteration\n\n        return item\n\n\ndef only(iterable, default=None, too_long=None):\n    \"\"\"If *iterable* has only one item, return it.\n    If it has zero items, return *default*.\n    If it has more than one item, raise the exception given by *too_long*,\n    which is ``ValueError`` by default.\n\n    >>> only([], default='missing')\n    'missing'\n    >>> only([1])\n    1\n    >>> only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: Expected exactly one item in iterable, but got 1, 2,\n     and perhaps more.'\n    >>> only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    TypeError\n\n    Note that :func:`only` attempts to advance *iterable* twice to ensure there\n    is only one item.  See :func:`spy` or :func:`peekable` to check\n    iterable contents less destructively.\n    \"\"\"\n    it = iter(iterable)\n    first_value = next(it, default)\n\n    try:\n        second_value = next(it)\n    except StopIteration:\n        pass\n    else:\n        msg = (\n            'Expected exactly one item in iterable, but got {!r}, {!r}, '\n            'and perhaps more.'.format(first_value, second_value)\n        )\n        raise too_long or ValueError(msg)\n\n    return first_value\n\n\nclass _IChunk:\n    def __init__(self, iterable, n):\n        self._it = islice(iterable, n)\n        self._cache = deque()\n\n    def fill_cache(self):\n        self._cache.extend(self._it)\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        try:\n            return next(self._it)\n        except StopIteration:\n            if self._cache:\n                return self._cache.popleft()\n            else:\n                raise\n\n\ndef ichunked(iterable, n):\n    \"\"\"Break *iterable* into sub-iterables with *n* elements each.\n    :func:`ichunked` is like :func:`chunked`, but it yields iterables\n    instead of lists.\n\n    If the sub-iterables are read in order, the elements of *iterable*\n    won't be stored in memory.\n    If they are read out of order, :func:`itertools.tee` is used to cache\n    elements as necessary.\n\n    >>> from itertools import count\n    >>> all_chunks = ichunked(count(), 4)\n    >>> c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)\n    >>> list(c_2)  # c_1's elements have been cached; c_3's haven't been\n    [4, 5, 6, 7]\n    >>> list(c_1)\n    [0, 1, 2, 3]\n    >>> list(c_3)\n    [8, 9, 10, 11]\n\n    \"\"\"\n    source = peekable(iter(iterable))\n    ichunk_marker = object()\n    while True:\n        # Check to see whether we're at the end of the source iterable\n        item = source.peek(ichunk_marker)\n        if item is ichunk_marker:\n            return\n\n        chunk = _IChunk(source, n)\n        yield chunk\n\n        # Advance the source iterable and fill previous chunk's cache\n        chunk.fill_cache()\n\n\ndef iequals(*iterables):\n    \"\"\"Return ``True`` if all given *iterables* are equal to each other,\n    which means that they contain the same elements in the same order.\n\n    The function is useful for comparing iterables of different data types\n    or iterables that do not support equality checks.\n\n    >>> iequals(\"abc\", ['a', 'b', 'c'], ('a', 'b', 'c'), iter(\"abc\"))\n    True\n\n    >>> iequals(\"abc\", \"acb\")\n    False\n\n    Not to be confused with :func:`all_equal`, which checks whether all\n    elements of iterable are equal to each other.\n\n    \"\"\"\n    return all(map(all_equal, zip_longest(*iterables, fillvalue=object())))\n\n\ndef distinct_combinations(iterable, r):\n    \"\"\"Yield the distinct combinations of *r* items taken from *iterable*.\n\n        >>> list(distinct_combinations([0, 0, 1], 2))\n        [(0, 0), (0, 1)]\n\n    Equivalent to ``set(combinations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    \"\"\"\n    if r < 0:\n        raise ValueError('r must be non-negative')\n    elif r == 0:\n        yield ()\n        return\n    pool = tuple(iterable)\n    generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]\n    current_combo = [None] * r\n    level = 0\n    while generators:\n        try:\n            cur_idx, p = next(generators[-1])\n        except StopIteration:\n            generators.pop()\n            level -= 1\n            continue\n        current_combo[level] = p\n        if level + 1 == r:\n            yield tuple(current_combo)\n        else:\n            generators.append(\n                unique_everseen(\n                    enumerate(pool[cur_idx + 1 :], cur_idx + 1),\n                    key=itemgetter(1),\n                )\n            )\n            level += 1\n\n\ndef filter_except(validator, iterable, *exceptions):\n    \"\"\"Yield the items from *iterable* for which the *validator* function does\n    not raise one of the specified *exceptions*.\n\n    *validator* is called for each item in *iterable*.\n    It should be a function that accepts one argument and raises an exception\n    if that item is not valid.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(filter_except(int, iterable, ValueError, TypeError))\n    ['1', '2', '4']\n\n    If an exception other than one given by *exceptions* is raised by\n    *validator*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            validator(item)\n        except exceptions:\n            pass\n        else:\n            yield item\n\n\ndef map_except(function, iterable, *exceptions):\n    \"\"\"Transform each item from *iterable* with *function* and yield the\n    result, unless *function* raises one of the specified *exceptions*.\n\n    *function* is called to transform each item in *iterable*.\n    It should accept one argument.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(map_except(int, iterable, ValueError, TypeError))\n    [1, 2, 4]\n\n    If an exception other than one given by *exceptions* is raised by\n    *function*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            yield function(item)\n        except exceptions:\n            pass\n\n\ndef map_if(iterable, pred, func, func_else=lambda x: x):\n    \"\"\"Evaluate each item from *iterable* using *pred*. If the result is\n    equivalent to ``True``, transform the item with *func* and yield it.\n    Otherwise, transform the item with *func_else* and yield it.\n\n    *pred*, *func*, and *func_else* should each be functions that accept\n    one argument. By default, *func_else* is the identity function.\n\n    >>> from math import sqrt\n    >>> iterable = list(range(-5, 5))\n    >>> iterable\n    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n    >>> list(map_if(iterable, lambda x: x > 3, lambda x: 'toobig'))\n    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']\n    >>> list(map_if(iterable, lambda x: x >= 0,\n    ... lambda x: f'{sqrt(x):.2f}', lambda x: None))\n    [None, None, None, None, None, '0.00', '1.00', '1.41', '1.73', '2.00']\n    \"\"\"\n    for item in iterable:\n        yield func(item) if pred(item) else func_else(item)\n\n\ndef _sample_unweighted(iterable, k):\n    # Implementation of \"Algorithm L\" from the 1994 paper by Kim-Hung Li:\n    # \"Reservoir-Sampling Algorithms of Time Complexity O(n(1+log(N/n)))\".\n\n    # Fill up the reservoir (collection of samples) with the first `k` samples\n    reservoir = take(k, iterable)\n\n    # Generate random number that's the largest in a sample of k U(0,1) numbers\n    # Largest order statistic: https://en.wikipedia.org/wiki/Order_statistic\n    W = exp(log(random()) / k)\n\n    # The number of elements to skip before changing the reservoir is a random\n    # number with a geometric distribution. Sample it using random() and logs.\n    next_index = k + floor(log(random()) / log(1 - W))\n\n    for index, element in enumerate(iterable, k):\n        if index == next_index:\n            reservoir[randrange(k)] = element\n            # The new W is the largest in a sample of k U(0, `old_W`) numbers\n            W *= exp(log(random()) / k)\n            next_index += floor(log(random()) / log(1 - W)) + 1\n\n    return reservoir\n\n\ndef _sample_weighted(iterable, k, weights):\n    # Implementation of \"A-ExpJ\" from the 2006 paper by Efraimidis et al. :\n    # \"Weighted random sampling with a reservoir\".\n\n    # Log-transform for numerical stability for weights that are small/large\n    weight_keys = (log(random()) / weight for weight in weights)\n\n    # Fill up the reservoir (collection of samples) with the first `k`\n    # weight-keys and elements, then heapify the list.\n    reservoir = take(k, zip(weight_keys, iterable))\n    heapify(reservoir)\n\n    # The number of jumps before changing the reservoir is a random variable\n    # with an exponential distribution. Sample it using random() and logs.\n    smallest_weight_key, _ = reservoir[0]\n    weights_to_skip = log(random()) / smallest_weight_key\n\n    for weight, element in zip(weights, iterable):\n        if weight >= weights_to_skip:\n            # The notation here is consistent with the paper, but we store\n            # the weight-keys in log-space for better numerical stability.\n            smallest_weight_key, _ = reservoir[0]\n            t_w = exp(weight * smallest_weight_key)\n            r_2 = uniform(t_w, 1)  # generate U(t_w, 1)\n            weight_key = log(r_2) / weight\n            heapreplace(reservoir, (weight_key, element))\n            smallest_weight_key, _ = reservoir[0]\n            weights_to_skip = log(random()) / smallest_weight_key\n        else:\n            weights_to_skip -= weight\n\n    # Equivalent to [element for weight_key, element in sorted(reservoir)]\n    return [heappop(reservoir)[1] for _ in range(k)]\n\n\ndef sample(iterable, k, weights=None):\n    \"\"\"Return a *k*-length list of elements chosen (without replacement)\n    from the *iterable*. Like :func:`random.sample`, but works on iterables\n    of unknown length.\n\n    >>> iterable = range(100)\n    >>> sample(iterable, 5)  # doctest: +SKIP\n    [81, 60, 96, 16, 4]\n\n    An iterable with *weights* may also be given:\n\n    >>> iterable = range(100)\n    >>> weights = (i * i + 1 for i in range(100))\n    >>> sampled = sample(iterable, 5, weights=weights)  # doctest: +SKIP\n    [79, 67, 74, 66, 78]\n\n    The algorithm can also be used to generate weighted random permutations.\n    The relative weight of each item determines the probability that it\n    appears late in the permutation.\n\n    >>> data = \"abcdefgh\"\n    >>> weights = range(1, len(data) + 1)\n    >>> sample(data, k=len(data), weights=weights)  # doctest: +SKIP\n    ['c', 'a', 'b', 'e', 'g', 'd', 'h', 'f']\n    \"\"\"\n    if k == 0:\n        return []\n\n    iterable = iter(iterable)\n    if weights is None:\n        return _sample_unweighted(iterable, k)\n    else:\n        weights = iter(weights)\n        return _sample_weighted(iterable, k, weights)\n\n\ndef is_sorted(iterable, key=None, reverse=False, strict=False):\n    \"\"\"Returns ``True`` if the items of iterable are in sorted order, and\n    ``False`` otherwise. *key* and *reverse* have the same meaning that they do\n    in the built-in :func:`sorted` function.\n\n    >>> is_sorted(['1', '2', '3', '4', '5'], key=int)\n    True\n    >>> is_sorted([5, 4, 3, 1, 2], reverse=True)\n    False\n\n    If *strict*, tests for strict sorting, that is, returns ``False`` if equal\n    elements are found:\n\n    >>> is_sorted([1, 2, 2])\n    True\n    >>> is_sorted([1, 2, 2], strict=True)\n    False\n\n    The function returns ``False`` after encountering the first out-of-order\n    item. If there are no out-of-order items, the iterable is exhausted.\n    \"\"\"\n\n    compare = (le if reverse else ge) if strict else (lt if reverse else gt)\n    it = iterable if key is None else map(key, iterable)\n    return not any(starmap(compare, pairwise(it)))\n\n\nclass AbortThread(BaseException):\n    pass\n\n\nclass callback_iter:\n    \"\"\"Convert a function that uses callbacks to an iterator.\n\n    Let *func* be a function that takes a `callback` keyword argument.\n    For example:\n\n    >>> def func(callback=None):\n    ...     for i, c in [(1, 'a'), (2, 'b'), (3, 'c')]:\n    ...         if callback:\n    ...             callback(i, c)\n    ...     return 4\n\n\n    Use ``with callback_iter(func)`` to get an iterator over the parameters\n    that are delivered to the callback.\n\n    >>> with callback_iter(func) as it:\n    ...     for args, kwargs in it:\n    ...         print(args)\n    (1, 'a')\n    (2, 'b')\n    (3, 'c')\n\n    The function will be called in a background thread. The ``done`` property\n    indicates whether it has completed execution.\n\n    >>> it.done\n    True\n\n    If it completes successfully, its return value will be available\n    in the ``result`` property.\n\n    >>> it.result\n    4\n\n    Notes:\n\n    * If the function uses some keyword argument besides ``callback``, supply\n      *callback_kwd*.\n    * If it finished executing, but raised an exception, accessing the\n      ``result`` property will raise the same exception.\n    * If it hasn't finished executing, accessing the ``result``\n      property from within the ``with`` block will raise ``RuntimeError``.\n    * If it hasn't finished executing, accessing the ``result`` property from\n      outside the ``with`` block will raise a\n      ``more_itertools.AbortThread`` exception.\n    * Provide *wait_seconds* to adjust how frequently the it is polled for\n      output.\n\n    \"\"\"\n\n    def __init__(self, func, callback_kwd='callback', wait_seconds=0.1):\n        self._func = func\n        self._callback_kwd = callback_kwd\n        self._aborted = False\n        self._future = None\n        self._wait_seconds = wait_seconds\n        # Lazily import concurrent.future\n        self._executor = __import__(\n        ).futures.__import__(\"concurrent.futures\").futures.ThreadPoolExecutor(max_workers=1)\n        self._iterator = self._reader()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self._aborted = True\n        self._executor.shutdown()\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return next(self._iterator)\n\n    @property\n    def done(self):\n        if self._future is None:\n            return False\n        return self._future.done()\n\n    @property\n    def result(self):\n        if not self.done:\n            raise RuntimeError('Function has not yet completed')\n\n        return self._future.result()\n\n    def _reader(self):\n        q = Queue()\n\n        def callback(*args, **kwargs):\n            if self._aborted:\n                raise AbortThread('canceled by user')\n\n            q.put((args, kwargs))\n\n        self._future = self._executor.submit(\n            self._func, **{self._callback_kwd: callback}\n        )\n\n        while True:\n            try:\n                item = q.get(timeout=self._wait_seconds)\n            except Empty:\n                pass\n            else:\n                q.task_done()\n                yield item\n\n            if self._future.done():\n                break\n\n        remaining = []\n        while True:\n            try:\n                item = q.get_nowait()\n            except Empty:\n                break\n            else:\n                q.task_done()\n                remaining.append(item)\n        q.join()\n        yield from remaining\n\n\ndef windowed_complete(iterable, n):\n    \"\"\"\n    Yield ``(beginning, middle, end)`` tuples, where:\n\n    * Each ``middle`` has *n* items from *iterable*\n    * Each ``beginning`` has the items before the ones in ``middle``\n    * Each ``end`` has the items after the ones in ``middle``\n\n    >>> iterable = range(7)\n    >>> n = 3\n    >>> for beginning, middle, end in windowed_complete(iterable, n):\n    ...     print(beginning, middle, end)\n    () (0, 1, 2) (3, 4, 5, 6)\n    (0,) (1, 2, 3) (4, 5, 6)\n    (0, 1) (2, 3, 4) (5, 6)\n    (0, 1, 2) (3, 4, 5) (6,)\n    (0, 1, 2, 3) (4, 5, 6) ()\n\n    Note that *n* must be at least 0 and most equal to the length of\n    *iterable*.\n\n    This function will exhaust the iterable and may require significant\n    storage.\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be >= 0')\n\n    seq = tuple(iterable)\n    size = len(seq)\n\n    if n > size:\n        raise ValueError('n must be <= len(seq)')\n\n    for i in range(size - n + 1):\n        beginning = seq[:i]\n        middle = seq[i : i + n]\n        end = seq[i + n :]\n        yield beginning, middle, end\n\n\ndef all_unique(iterable, key=None):\n    \"\"\"\n    Returns ``True`` if all the elements of *iterable* are unique (no two\n    elements are equal).\n\n        >>> all_unique('ABCB')\n        False\n\n    If a *key* function is specified, it will be used to make comparisons.\n\n        >>> all_unique('ABCb')\n        True\n        >>> all_unique('ABCb', str.lower)\n        False\n\n    The function returns as soon as the first non-unique element is\n    encountered. Iterables with a mix of hashable and unhashable items can\n    be used, but the function will be slower for unhashable items.\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    for element in map(key, iterable) if key else iterable:\n        try:\n            if element in seenset:\n                return False\n            seenset_add(element)\n        except TypeError:\n            if element in seenlist:\n                return False\n            seenlist_add(element)\n    return True\n\n\ndef nth_product(index, *args):\n    \"\"\"Equivalent to ``list(product(*args))[index]``.\n\n    The products of *args* can be ordered lexicographically.\n    :func:`nth_product` computes the product at sort position *index* without\n    computing the previous products.\n\n        >>> nth_product(8, range(2), range(2), range(2), range(2))\n        (1, 0, 0, 0)\n\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pools = list(map(tuple, reversed(args)))\n    ns = list(map(len, pools))\n\n    c = reduce(mul, ns)\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = []\n    for pool, n in zip(pools, ns):\n        result.append(pool[index % n])\n        index //= n\n\n    return tuple(reversed(result))\n\n\ndef nth_permutation(iterable, r, index):\n    \"\"\"Equivalent to ``list(permutations(iterable, r))[index]```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`nth_permutation`\n    computes the subsequence at sort position *index* directly, without\n    computing the previous subsequences.\n\n        >>> nth_permutation('ghijk', 2, 5)\n        ('h', 'i')\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = list(iterable)\n    n = len(pool)\n\n    if r is None or r == n:\n        r, c = n, factorial(n)\n    elif not 0 <= r < n:\n        raise ValueError\n    else:\n        c = perm(n, r)\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    if c == 0:\n        return tuple()\n\n    result = [0] * r\n    q = index * factorial(n) // c if r < n else index\n    for d in range(1, n + 1):\n        q, i = divmod(q, d)\n        if 0 <= n - d < r:\n            result[n - d] = i\n        if q == 0:\n            break\n\n    return tuple(map(pool.pop, result))\n\n\ndef nth_combination_with_replacement(iterable, r, index):\n    \"\"\"Equivalent to\n    ``list(combinations_with_replacement(iterable, r))[index]``.\n\n\n    The subsequences with repetition of *iterable* that are of length *r* can\n    be ordered lexicographically. :func:`nth_combination_with_replacement`\n    computes the subsequence at sort position *index* directly, without\n    computing the previous subsequences with replacement.\n\n        >>> nth_combination_with_replacement(range(5), 3, 5)\n        (0, 1, 1)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = comb(n + r - 1, r)\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    i = 0\n    while r:\n        r -= 1\n        while n >= 0:\n            num_combs = comb(n + r - 1, r)\n            if index < num_combs:\n                break\n            n -= 1\n            i += 1\n            index -= num_combs\n        result.append(pool[i])\n\n    return tuple(result)\n\n\ndef value_chain(*args):\n    \"\"\"Yield all arguments passed to the function in the same order in which\n    they were passed. If an argument itself is iterable then iterate over its\n    values.\n\n        >>> list(value_chain(1, 2, 3, [4, 5, 6]))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and are emitted\n    as-is:\n\n        >>> list(value_chain('12', '34', ['56', '78']))\n        ['12', '34', '56', '78']\n\n\n    Multiple levels of nesting are not flattened.\n\n    \"\"\"\n    for value in args:\n        if isinstance(value, (str, bytes)):\n            yield value\n            continue\n        try:\n            yield from value\n        except TypeError:\n            yield value\n\n\ndef product_index(element, *args):\n    \"\"\"Equivalent to ``list(product(*args)).index(element)``\n\n    The products of *args* can be ordered lexicographically.\n    :func:`product_index` computes the first index of *element* without\n    computing the previous products.\n\n        >>> product_index([8, 2], range(10), range(5))\n        42\n\n    ``ValueError`` will be raised if the given *element* isn't in the product\n    of *args*.\n    \"\"\"\n    index = 0\n\n    for x, pool in zip_longest(element, args, fillvalue=_marker):\n        if x is _marker or pool is _marker:\n            raise ValueError('element is not a product of args')\n\n        pool = tuple(pool)\n        index = index * len(pool) + pool.index(x)\n\n    return index\n\n\ndef combination_index(element, iterable):\n    \"\"\"Equivalent to ``list(combinations(iterable, r)).index(element)``\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`combination_index` computes the index of the\n    first *element*, without computing the previous combinations.\n\n        >>> combination_index('adf', 'abcdefg')\n        10\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations of *iterable*.\n    \"\"\"\n    element = enumerate(element)\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = enumerate(iterable)\n    for n, x in pool:\n        if x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n    else:\n        raise ValueError('element is not a combination of iterable')\n\n    n, _ = last(pool, default=(n, None))\n\n    # Python versions below 3.8 don't have math.comb\n    index = 1\n    for i, j in enumerate(reversed(indexes), start=1):\n        j = n - j\n        if i <= j:\n            index += comb(j, i)\n\n    return comb(n + 1, k + 1) - index\n\n\ndef combination_with_replacement_index(element, iterable):\n    \"\"\"Equivalent to\n    ``list(combinations_with_replacement(iterable, r)).index(element)``\n\n    The subsequences with repetition of *iterable* that are of length *r* can\n    be ordered lexicographically. :func:`combination_with_replacement_index`\n    computes the index of the first *element*, without computing the previous\n    combinations with replacement.\n\n        >>> combination_with_replacement_index('adf', 'abcdefg')\n        20\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations with replacement of *iterable*.\n    \"\"\"\n    element = tuple(element)\n    l = len(element)\n    element = enumerate(element)\n\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = tuple(iterable)\n    for n, x in enumerate(pool):\n        while x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n        if y is None:\n            break\n    else:\n        raise ValueError(\n            'element is not a combination with replacement of iterable'\n        )\n\n    n = len(pool)\n    occupations = [0] * n\n    for p in indexes:\n        occupations[p] += 1\n\n    index = 0\n    cumulative_sum = 0\n    for k in range(1, n):\n        cumulative_sum += occupations[k - 1]\n        j = l + n - 1 - k - cumulative_sum\n        i = n - k\n        if i <= j:\n            index += comb(j, i)\n\n    return index\n\n\ndef permutation_index(element, iterable):\n    \"\"\"Equivalent to ``list(permutations(iterable, r)).index(element)```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`permutation_index`\n    computes the index of the first *element* directly, without computing\n    the previous permutations.\n\n        >>> permutation_index([1, 3, 2], range(5))\n        19\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    permutations of *iterable*.\n    \"\"\"\n    index = 0\n    pool = list(iterable)\n    for i, x in zip(range(len(pool), -1, -1), element):\n        r = pool.index(x)\n        index = index * i + r\n        del pool[r]\n\n    return index\n\n\nclass countable:\n    \"\"\"Wrap *iterable* and keep a count of how many items have been consumed.\n\n    The ``items_seen`` attribute starts at ``0`` and increments as the iterable\n    is consumed:\n\n        >>> iterable = map(str, range(10))\n        >>> it = countable(iterable)\n        >>> it.items_seen\n        0\n        >>> next(it), next(it)\n        ('0', '1')\n        >>> list(it)\n        ['2', '3', '4', '5', '6', '7', '8', '9']\n        >>> it.items_seen\n        10\n    \"\"\"\n\n    def __init__(self, iterable):\n        self._it = iter(iterable)\n        self.items_seen = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        item = next(self._it)\n        self.items_seen += 1\n\n        return item\n\n\ndef chunked_even(iterable, n):\n    \"\"\"Break *iterable* into lists of approximately length *n*.\n    Items are distributed such the lengths of the lists differ by at most\n    1 item.\n\n    >>> iterable = [1, 2, 3, 4, 5, 6, 7]\n    >>> n = 3\n    >>> list(chunked_even(iterable, n))  # List lengths: 3, 2, 2\n    [[1, 2, 3], [4, 5], [6, 7]]\n    >>> list(chunked(iterable, n))  # List lengths: 3, 3, 1\n    [[1, 2, 3], [4, 5, 6], [7]]\n\n    \"\"\"\n\n    len_method = getattr(iterable, '__len__', None)\n\n    if len_method is None:\n        return _chunked_even_online(iterable, n)\n    else:\n        return _chunked_even_finite(iterable, len_method(), n)\n\n\ndef _chunked_even_online(iterable, n):\n    buffer = []\n    maxbuf = n + (n - 2) * (n - 1)\n    for x in iterable:\n        buffer.append(x)\n        if len(buffer) == maxbuf:\n            yield buffer[:n]\n            buffer = buffer[n:]\n    yield from _chunked_even_finite(buffer, len(buffer), n)\n\n\ndef _chunked_even_finite(iterable, N, n):\n    if N < 1:\n        return\n\n    # Lists are either size `full_size <= n` or `partial_size = full_size - 1`\n    q, r = divmod(N, n)\n    num_lists = q + (1 if r > 0 else 0)\n    q, r = divmod(N, num_lists)\n    full_size = q + (1 if r > 0 else 0)\n    partial_size = full_size - 1\n    num_full = N - partial_size * num_lists\n    num_partial = num_lists - num_full\n\n    # Yield num_full lists of full_size\n    partial_start_idx = num_full * full_size\n    if full_size > 0:\n        for i in range(0, partial_start_idx, full_size):\n            yield list(islice(iterable, i, i + full_size))\n\n    # Yield num_partial lists of partial_size\n    if partial_size > 0:\n        for i in range(\n            partial_start_idx,\n            partial_start_idx + (num_partial * partial_size),\n            partial_size,\n        ):\n            yield list(islice(iterable, i, i + partial_size))\n\n\ndef zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):\n    \"\"\"A version of :func:`zip` that \"broadcasts\" any scalar\n    (i.e., non-iterable) items into output tuples.\n\n    >>> iterable_1 = [1, 2, 3]\n    >>> iterable_2 = ['a', 'b', 'c']\n    >>> scalar = '_'\n    >>> list(zip_broadcast(iterable_1, iterable_2, scalar))\n    [(1, 'a', '_'), (2, 'b', '_'), (3, 'c', '_')]\n\n    The *scalar_types* keyword argument determines what types are considered\n    scalar. It is set to ``(str, bytes)`` by default. Set it to ``None`` to\n    treat strings and byte strings as iterable:\n\n    >>> list(zip_broadcast('abc', 0, 'xyz', scalar_types=None))\n    [('a', 0, 'x'), ('b', 0, 'y'), ('c', 0, 'z')]\n\n    If the *strict* keyword argument is ``True``, then\n    ``UnequalIterablesError`` will be raised if any of the iterables have\n    different lengths.\n    \"\"\"\n\n    def is_scalar(obj):\n        if scalar_types and isinstance(obj, scalar_types):\n            return True\n        try:\n            iter(obj)\n        except TypeError:\n            return True\n        else:\n            return False\n\n    size = len(objects)\n    if not size:\n        return\n\n    new_item = [None] * size\n    iterables, iterable_positions = [], []\n    for i, obj in enumerate(objects):\n        if is_scalar(obj):\n            new_item[i] = obj\n        else:\n            iterables.append(iter(obj))\n            iterable_positions.append(i)\n\n    if not iterables:\n        yield tuple(objects)\n        return\n\n    zipper = _zip_equal if strict else zip\n    for item in zipper(*iterables):\n        for i, new_item[i] in zip(iterable_positions, item):\n            pass\n        yield tuple(new_item)\n\n\ndef unique_in_window(iterable, n, key=None):\n    \"\"\"Yield the items from *iterable* that haven't been seen recently.\n    *n* is the size of the lookback window.\n\n        >>> iterable = [0, 1, 0, 2, 3, 0]\n        >>> n = 3\n        >>> list(unique_in_window(iterable, n))\n        [0, 1, 2, 3, 0]\n\n    The *key* function, if provided, will be used to determine uniqueness:\n\n        >>> list(unique_in_window('abAcda', 3, key=lambda x: x.lower()))\n        ['a', 'b', 'c', 'd', 'a']\n\n    The items in *iterable* must be hashable.\n\n    \"\"\"\n    if n <= 0:\n        raise ValueError('n must be greater than 0')\n\n    window = deque(maxlen=n)\n    counts = defaultdict(int)\n    use_key = key is not None\n\n    for item in iterable:\n        if len(window) == n:\n            to_discard = window[0]\n            if counts[to_discard] == 1:\n                del counts[to_discard]\n            else:\n                counts[to_discard] -= 1\n\n        k = key(item) if use_key else item\n        if k not in counts:\n            yield item\n        counts[k] += 1\n        window.append(k)\n\n\ndef duplicates_everseen(iterable, key=None):\n    \"\"\"Yield duplicate elements after their first appearance.\n\n    >>> list(duplicates_everseen('mississippi'))\n    ['s', 'i', 's', 's', 'i', 'p', 'i']\n    >>> list(duplicates_everseen('AaaBbbCccAaa', str.lower))\n    ['a', 'a', 'b', 'b', 'c', 'c', 'A', 'a', 'a']\n\n    This function is analogous to :func:`unique_everseen` and is subject to\n    the same performance considerations.\n\n    \"\"\"\n    seen_set = set()\n    seen_list = []\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seen_set:\n                seen_set.add(k)\n            else:\n                yield element\n        except TypeError:\n            if k not in seen_list:\n                seen_list.append(k)\n            else:\n                yield element\n\n\ndef duplicates_justseen(iterable, key=None):\n    \"\"\"Yields serially-duplicate elements after their first appearance.\n\n    >>> list(duplicates_justseen('mississippi'))\n    ['s', 's', 'p']\n    >>> list(duplicates_justseen('AaaBbbCccAaa', str.lower))\n    ['a', 'a', 'b', 'b', 'c', 'c', 'a', 'a']\n\n    This function is analogous to :func:`unique_justseen`.\n\n    \"\"\"\n    return flatten(g for _, g in groupby(iterable, key) for _ in g)\n\n\ndef classify_unique(iterable, key=None):\n    \"\"\"Classify each element in terms of its uniqueness.\n\n    For each element in the input iterable, return a 3-tuple consisting of:\n\n    1. The element itself\n    2. ``False`` if the element is equal to the one preceding it in the input,\n       ``True`` otherwise (i.e. the equivalent of :func:`unique_justseen`)\n    3. ``False`` if this element has been seen anywhere in the input before,\n       ``True`` otherwise (i.e. the equivalent of :func:`unique_everseen`)\n\n    >>> list(classify_unique('otto'))    # doctest: +NORMALIZE_WHITESPACE\n    [('o', True,  True),\n     ('t', True,  True),\n     ('t', False, False),\n     ('o', True,  False)]\n\n    This function is analogous to :func:`unique_everseen` and is subject to\n    the same performance considerations.\n\n    \"\"\"\n    seen_set = set()\n    seen_list = []\n    use_key = key is not None\n    previous = None\n\n    for i, element in enumerate(iterable):\n        k = key(element) if use_key else element\n        is_unique_justseen = not i or previous != k\n        previous = k\n        is_unique_everseen = False\n        try:\n            if k not in seen_set:\n                seen_set.add(k)\n                is_unique_everseen = True\n        except TypeError:\n            if k not in seen_list:\n                seen_list.append(k)\n                is_unique_everseen = True\n        yield element, is_unique_justseen, is_unique_everseen\n\n\ndef minmax(iterable_or_value, *others, key=None, default=_marker):\n    \"\"\"Returns both the smallest and largest items in an iterable\n    or the largest of two or more arguments.\n\n        >>> minmax([3, 1, 5])\n        (1, 5)\n\n        >>> minmax(4, 2, 6)\n        (2, 6)\n\n    If a *key* function is provided, it will be used to transform the input\n    items for comparison.\n\n        >>> minmax([5, 30], key=str)  # '30' sorts before '5'\n        (30, 5)\n\n    If a *default* value is provided, it will be returned if there are no\n    input items.\n\n        >>> minmax([], default=(0, 0))\n        (0, 0)\n\n    Otherwise ``ValueError`` is raised.\n\n    This function is based on the\n    `recipe <http://code.activestate.com/recipes/577916/>`__ by\n    Raymond Hettinger and takes care to minimize the number of comparisons\n    performed.\n    \"\"\"\n    iterable = (iterable_or_value, *others) if others else iterable_or_value\n\n    it = iter(iterable)\n\n    try:\n        lo = hi = next(it)\n    except StopIteration as e:\n        if default is _marker:\n            raise ValueError(\n                '`minmax()` argument is an empty iterable. '\n                'Provide a `default` value to suppress this error.'\n            ) from e\n        return default\n\n    # Different branches depending on the presence of key. This saves a lot\n    # of unimportant copies which would slow the \"key=None\" branch\n    # significantly down.\n    if key is None:\n        for x, y in zip_longest(it, it, fillvalue=lo):\n            if y < x:\n                x, y = y, x\n            if x < lo:\n                lo = x\n            if hi < y:\n                hi = y\n\n    else:\n        lo_key = hi_key = key(lo)\n\n        for x, y in zip_longest(it, it, fillvalue=lo):\n            x_key, y_key = key(x), key(y)\n\n            if y_key < x_key:\n                x, y, x_key, y_key = y, x, y_key, x_key\n            if x_key < lo_key:\n                lo, lo_key = x, x_key\n            if hi_key < y_key:\n                hi, hi_key = y, y_key\n\n    return lo, hi\n\n\ndef constrained_batches(\n    iterable, max_size, max_count=None, get_len=len, strict=True\n):\n    \"\"\"Yield batches of items from *iterable* with a combined size limited by\n    *max_size*.\n\n    >>> iterable = [b'12345', b'123', b'12345678', b'1', b'1', b'12', b'1']\n    >>> list(constrained_batches(iterable, 10))\n    [(b'12345', b'123'), (b'12345678', b'1', b'1'), (b'12', b'1')]\n\n    If a *max_count* is supplied, the number of items per batch is also\n    limited:\n\n    >>> iterable = [b'12345', b'123', b'12345678', b'1', b'1', b'12', b'1']\n    >>> list(constrained_batches(iterable, 10, max_count = 2))\n    [(b'12345', b'123'), (b'12345678', b'1'), (b'1', b'12'), (b'1',)]\n\n    If a *get_len* function is supplied, use that instead of :func:`len` to\n    determine item size.\n\n    If *strict* is ``True``, raise ``ValueError`` if any single item is bigger\n    than *max_size*. Otherwise, allow single items to exceed *max_size*.\n    \"\"\"\n    if max_size <= 0:\n        raise ValueError('maximum size must be greater than zero')\n\n    batch = []\n    batch_size = 0\n    batch_count = 0\n    for item in iterable:\n        item_len = get_len(item)\n        if strict and item_len > max_size:\n            raise ValueError('item size exceeds maximum size')\n\n        reached_count = batch_count == max_count\n        reached_size = item_len + batch_size > max_size\n        if batch_count and (reached_size or reached_count):\n            yield tuple(batch)\n            batch.clear()\n            batch_size = 0\n            batch_count = 0\n\n        batch.append(item)\n        batch_size += item_len\n        batch_count += 1\n\n    if batch:\n        yield tuple(batch)\n\n\ndef gray_product(*iterables):\n    \"\"\"Like :func:`itertools.product`, but return tuples in an order such\n    that only one element in the generated tuple changes from one iteration\n    to the next.\n\n        >>> list(gray_product('AB','CD'))\n        [('A', 'C'), ('B', 'C'), ('B', 'D'), ('A', 'D')]\n\n    This function consumes all of the input iterables before producing output.\n    If any of the input iterables have fewer than two items, ``ValueError``\n    is raised.\n\n    For information on the algorithm, see\n    `this section <https://www-cs-faculty.stanford.edu/~knuth/fasc2a.ps.gz>`__\n    of Donald Knuth's *The Art of Computer Programming*.\n    \"\"\"\n    all_iterables = tuple(tuple(x) for x in iterables)\n    iterable_count = len(all_iterables)\n    for iterable in all_iterables:\n        if len(iterable) < 2:\n            raise ValueError(\"each iterable must have two or more items\")\n\n    # This is based on \"Algorithm H\" from section 7.2.1.1, page 20.\n    # a holds the indexes of the source iterables for the n-tuple to be yielded\n    # f is the array of \"focus pointers\"\n    # o is the array of \"directions\"\n    a = [0] * iterable_count\n    f = list(range(iterable_count + 1))\n    o = [1] * iterable_count\n    while True:\n        yield tuple(all_iterables[i][a[i]] for i in range(iterable_count))\n        j = f[0]\n        f[0] = 0\n        if j == iterable_count:\n            break\n        a[j] = a[j] + o[j]\n        if a[j] == 0 or a[j] == len(all_iterables[j]) - 1:\n            o[j] = -o[j]\n            f[j] = f[j + 1]\n            f[j + 1] = j + 1\n\n\ndef partial_product(*iterables):\n    \"\"\"Yields tuples containing one item from each iterator, with subsequent\n    tuples changing a single item at a time by advancing each iterator until it\n    is exhausted. This sequence guarantees every value in each iterable is\n    output at least once without generating all possible combinations.\n\n    This may be useful, for example, when testing an expensive function.\n\n        >>> list(partial_product('AB', 'C', 'DEF'))\n        [('A', 'C', 'D'), ('B', 'C', 'D'), ('B', 'C', 'E'), ('B', 'C', 'F')]\n    \"\"\"\n\n    iterators = list(map(iter, iterables))\n\n    try:\n        prod = [next(it) for it in iterators]\n    except StopIteration:\n        return\n    yield tuple(prod)\n\n    for i, it in enumerate(iterators):\n        for prod[i] in it:\n            yield tuple(prod)\n\n\ndef takewhile_inclusive(predicate, iterable):\n    \"\"\"A variant of :func:`takewhile` that yields one additional element.\n\n        >>> list(takewhile_inclusive(lambda x: x < 5, [1, 4, 6, 4, 1]))\n        [1, 4, 6]\n\n    :func:`takewhile` would return ``[1, 4]``.\n    \"\"\"\n    for x in iterable:\n        yield x\n        if not predicate(x):\n            break\n\n\ndef outer_product(func, xs, ys, *args, **kwargs):\n    \"\"\"A generalized outer product that applies a binary function to all\n    pairs of items. Returns a 2D matrix with ``len(xs)`` rows and ``len(ys)``\n    columns.\n    Also accepts ``*args`` and ``**kwargs`` that are passed to ``func``.\n\n    Multiplication table:\n\n    >>> list(outer_product(mul, range(1, 4), range(1, 6)))\n    [(1, 2, 3, 4, 5), (2, 4, 6, 8, 10), (3, 6, 9, 12, 15)]\n\n    Cross tabulation:\n\n    >>> xs = ['A', 'B', 'A', 'A', 'B', 'B', 'A', 'A', 'B', 'B']\n    >>> ys = ['X', 'X', 'X', 'Y', 'Z', 'Z', 'Y', 'Y', 'Z', 'Z']\n    >>> rows = list(zip(xs, ys))\n    >>> count_rows = lambda x, y: rows.count((x, y))\n    >>> list(outer_product(count_rows, sorted(set(xs)), sorted(set(ys))))\n    [(2, 3, 0), (1, 0, 4)]\n\n    Usage with ``*args`` and ``**kwargs``:\n\n    >>> animals = ['cat', 'wolf', 'mouse']\n    >>> list(outer_product(min, animals, animals, key=len))\n    [('cat', 'cat', 'cat'), ('cat', 'wolf', 'wolf'), ('cat', 'wolf', 'mouse')]\n    \"\"\"\n    ys = tuple(ys)\n    return batched(\n        starmap(lambda x, y: func(x, y, *args, **kwargs), product(xs, ys)),\n        n=len(ys),\n    )\n\n\ndef iter_suppress(iterable, *exceptions):\n    \"\"\"Yield each of the items from *iterable*. If the iteration raises one of\n    the specified *exceptions*, that exception will be suppressed and iteration\n    will stop.\n\n    >>> from itertools import chain\n    >>> def breaks_at_five(x):\n    ...     while True:\n    ...         if x >= 5:\n    ...             raise RuntimeError\n    ...         yield x\n    ...         x += 1\n    >>> it_1 = iter_suppress(breaks_at_five(1), RuntimeError)\n    >>> it_2 = iter_suppress(breaks_at_five(2), RuntimeError)\n    >>> list(chain(it_1, it_2))\n    [1, 2, 3, 4, 2, 3, 4]\n    \"\"\"\n    try:\n        yield from iterable\n    except exceptions:\n        return\n\n\ndef filter_map(func, iterable):\n    \"\"\"Apply *func* to every element of *iterable*, yielding only those which\n    are not ``None``.\n\n    >>> elems = ['1', 'a', '2', 'b', '3']\n    >>> list(filter_map(lambda s: int(s) if s.isnumeric() else None, elems))\n    [1, 2, 3]\n    \"\"\"\n    for x in iterable:\n        y = func(x)\n        if y is not None:\n            yield y\n", "pkg_resources/_vendor/more_itertools/recipes.py": "\"\"\"Imported from the recipes section of the itertools documentation.\n\nAll functions taken from the recipes section of the itertools library docs\n[1]_.\nSome backward-compatible usability improvements have been made.\n\n.. [1] http://docs.python.org/library/itertools.html#recipes\n\n\"\"\"\nimport math\nimport operator\n\nfrom collections import deque\nfrom collections.abc import Sized\nfrom functools import partial, reduce\nfrom itertools import (\n    chain,\n    combinations,\n    compress,\n    count,\n    cycle,\n    groupby,\n    islice,\n    product,\n    repeat,\n    starmap,\n    tee,\n    zip_longest,\n)\nfrom random import randrange, sample, choice\nfrom sys import hexversion\n\n__all__ = [\n    'all_equal',\n    'batched',\n    'before_and_after',\n    'consume',\n    'convolve',\n    'dotproduct',\n    'first_true',\n    'factor',\n    'flatten',\n    'grouper',\n    'iter_except',\n    'iter_index',\n    'matmul',\n    'ncycles',\n    'nth',\n    'nth_combination',\n    'padnone',\n    'pad_none',\n    'pairwise',\n    'partition',\n    'polynomial_eval',\n    'polynomial_from_roots',\n    'polynomial_derivative',\n    'powerset',\n    'prepend',\n    'quantify',\n    'reshape',\n    'random_combination_with_replacement',\n    'random_combination',\n    'random_permutation',\n    'random_product',\n    'repeatfunc',\n    'roundrobin',\n    'sieve',\n    'sliding_window',\n    'subslices',\n    'sum_of_squares',\n    'tabulate',\n    'tail',\n    'take',\n    'totient',\n    'transpose',\n    'triplewise',\n    'unique_everseen',\n    'unique_justseen',\n]\n\n_marker = object()\n\n\n# zip with strict is available for Python 3.10+\ntry:\n    zip(strict=True)\nexcept TypeError:\n    _zip_strict = zip\nelse:\n    _zip_strict = partial(zip, strict=True)\n\n# math.sumprod is available for Python 3.12+\n_sumprod = getattr(math, 'sumprod', lambda x, y: dotproduct(x, y))\n\n\ndef take(n, iterable):\n    \"\"\"Return first *n* items of the iterable as a list.\n\n        >>> take(3, range(10))\n        [0, 1, 2]\n\n    If there are fewer than *n* items in the iterable, all of them are\n    returned.\n\n        >>> take(10, range(3))\n        [0, 1, 2]\n\n    \"\"\"\n    return list(islice(iterable, n))\n\n\ndef tabulate(function, start=0):\n    \"\"\"Return an iterator over the results of ``func(start)``,\n    ``func(start + 1)``, ``func(start + 2)``...\n\n    *func* should be a function that accepts one integer argument.\n\n    If *start* is not specified it defaults to 0. It will be incremented each\n    time the iterator is advanced.\n\n        >>> square = lambda x: x ** 2\n        >>> iterator = tabulate(square, -3)\n        >>> take(4, iterator)\n        [9, 4, 1, 0]\n\n    \"\"\"\n    return map(function, count(start))\n\n\ndef tail(n, iterable):\n    \"\"\"Return an iterator over the last *n* items of *iterable*.\n\n    >>> t = tail(3, 'ABCDEFG')\n    >>> list(t)\n    ['E', 'F', 'G']\n\n    \"\"\"\n    # If the given iterable has a length, then we can use islice to get its\n    # final elements. Note that if the iterable is not actually Iterable,\n    # either islice or deque will throw a TypeError. This is why we don't\n    # check if it is Iterable.\n    if isinstance(iterable, Sized):\n        yield from islice(iterable, max(0, len(iterable) - n), None)\n    else:\n        yield from iter(deque(iterable, maxlen=n))\n\n\ndef consume(iterator, n=None):\n    \"\"\"Advance *iterable* by *n* steps. If *n* is ``None``, consume it\n    entirely.\n\n    Efficiently exhausts an iterator without returning values. Defaults to\n    consuming the whole iterator, but an optional second argument may be\n    provided to limit consumption.\n\n        >>> i = (x for x in range(10))\n        >>> next(i)\n        0\n        >>> consume(i, 3)\n        >>> next(i)\n        4\n        >>> consume(i)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    If the iterator has fewer items remaining than the provided limit, the\n    whole iterator will be consumed.\n\n        >>> i = (x for x in range(3))\n        >>> consume(i, 5)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    \"\"\"\n    # Use functions that consume iterators at C speed.\n    if n is None:\n        # feed the entire iterator into a zero-length deque\n        deque(iterator, maxlen=0)\n    else:\n        # advance to the empty slice starting at position n\n        next(islice(iterator, n, n), None)\n\n\ndef nth(iterable, n, default=None):\n    \"\"\"Returns the nth item or a default value.\n\n    >>> l = range(10)\n    >>> nth(l, 3)\n    3\n    >>> nth(l, 20, \"zebra\")\n    'zebra'\n\n    \"\"\"\n    return next(islice(iterable, n, None), default)\n\n\ndef all_equal(iterable):\n    \"\"\"\n    Returns ``True`` if all the elements are equal to each other.\n\n        >>> all_equal('aaaa')\n        True\n        >>> all_equal('aaab')\n        False\n\n    \"\"\"\n    g = groupby(iterable)\n    return next(g, True) and not next(g, False)\n\n\ndef quantify(iterable, pred=bool):\n    \"\"\"Return the how many times the predicate is true.\n\n    >>> quantify([True, False, True])\n    2\n\n    \"\"\"\n    return sum(map(pred, iterable))\n\n\ndef pad_none(iterable):\n    \"\"\"Returns the sequence of elements and then returns ``None`` indefinitely.\n\n        >>> take(5, pad_none(range(3)))\n        [0, 1, 2, None, None]\n\n    Useful for emulating the behavior of the built-in :func:`map` function.\n\n    See also :func:`padded`.\n\n    \"\"\"\n    return chain(iterable, repeat(None))\n\n\npadnone = pad_none\n\n\ndef ncycles(iterable, n):\n    \"\"\"Returns the sequence elements *n* times\n\n    >>> list(ncycles([\"a\", \"b\"], 3))\n    ['a', 'b', 'a', 'b', 'a', 'b']\n\n    \"\"\"\n    return chain.from_iterable(repeat(tuple(iterable), n))\n\n\ndef dotproduct(vec1, vec2):\n    \"\"\"Returns the dot product of the two iterables.\n\n    >>> dotproduct([10, 10], [20, 20])\n    400\n\n    \"\"\"\n    return sum(map(operator.mul, vec1, vec2))\n\n\ndef flatten(listOfLists):\n    \"\"\"Return an iterator flattening one level of nesting in a list of lists.\n\n        >>> list(flatten([[0, 1], [2, 3]]))\n        [0, 1, 2, 3]\n\n    See also :func:`collapse`, which can flatten multiple levels of nesting.\n\n    \"\"\"\n    return chain.from_iterable(listOfLists)\n\n\ndef repeatfunc(func, times=None, *args):\n    \"\"\"Call *func* with *args* repeatedly, returning an iterable over the\n    results.\n\n    If *times* is specified, the iterable will terminate after that many\n    repetitions:\n\n        >>> from operator import add\n        >>> times = 4\n        >>> args = 3, 5\n        >>> list(repeatfunc(add, times, *args))\n        [8, 8, 8, 8]\n\n    If *times* is ``None`` the iterable will not terminate:\n\n        >>> from random import randrange\n        >>> times = None\n        >>> args = 1, 11\n        >>> take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP\n        [2, 4, 8, 1, 8, 4]\n\n    \"\"\"\n    if times is None:\n        return starmap(func, repeat(args))\n    return starmap(func, repeat(args, times))\n\n\ndef _pairwise(iterable):\n    \"\"\"Returns an iterator of paired items, overlapping, from the original\n\n    >>> take(4, pairwise(count()))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n\n    On Python 3.10 and above, this is an alias for :func:`itertools.pairwise`.\n\n    \"\"\"\n    a, b = tee(iterable)\n    next(b, None)\n    return zip(a, b)\n\n\ntry:\n    from itertools import pairwise as itertools_pairwise\nexcept ImportError:\n    pairwise = _pairwise\nelse:\n\n    def pairwise(iterable):\n        return itertools_pairwise(iterable)\n\n    pairwise.__doc__ = _pairwise.__doc__\n\n\nclass UnequalIterablesError(ValueError):\n    def __init__(self, details=None):\n        msg = 'Iterables have different lengths'\n        if details is not None:\n            msg += (': index 0 has length {}; index {} has length {}').format(\n                *details\n            )\n\n        super().__init__(msg)\n\n\ndef _zip_equal_generator(iterables):\n    for combo in zip_longest(*iterables, fillvalue=_marker):\n        for val in combo:\n            if val is _marker:\n                raise UnequalIterablesError()\n        yield combo\n\n\ndef _zip_equal(*iterables):\n    # Check whether the iterables are all the same size.\n    try:\n        first_size = len(iterables[0])\n        for i, it in enumerate(iterables[1:], 1):\n            size = len(it)\n            if size != first_size:\n                raise UnequalIterablesError(details=(first_size, i, size))\n        # All sizes are equal, we can use the built-in zip.\n        return zip(*iterables)\n    # If any one of the iterables didn't have a length, start reading\n    # them until one runs out.\n    except TypeError:\n        return _zip_equal_generator(iterables)\n\n\ndef grouper(iterable, n, incomplete='fill', fillvalue=None):\n    \"\"\"Group elements from *iterable* into fixed-length groups of length *n*.\n\n    >>> list(grouper('ABCDEF', 3))\n    [('A', 'B', 'C'), ('D', 'E', 'F')]\n\n    The keyword arguments *incomplete* and *fillvalue* control what happens for\n    iterables whose length is not a multiple of *n*.\n\n    When *incomplete* is `'fill'`, the last group will contain instances of\n    *fillvalue*.\n\n    >>> list(grouper('ABCDEFG', 3, incomplete='fill', fillvalue='x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')]\n\n    When *incomplete* is `'ignore'`, the last group will not be emitted.\n\n    >>> list(grouper('ABCDEFG', 3, incomplete='ignore', fillvalue='x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F')]\n\n    When *incomplete* is `'strict'`, a subclass of `ValueError` will be raised.\n\n    >>> it = grouper('ABCDEFG', 3, incomplete='strict')\n    >>> list(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    UnequalIterablesError\n\n    \"\"\"\n    args = [iter(iterable)] * n\n    if incomplete == 'fill':\n        return zip_longest(*args, fillvalue=fillvalue)\n    if incomplete == 'strict':\n        return _zip_equal(*args)\n    if incomplete == 'ignore':\n        return zip(*args)\n    else:\n        raise ValueError('Expected fill, strict, or ignore')\n\n\ndef roundrobin(*iterables):\n    \"\"\"Yields an item from each iterable, alternating between them.\n\n        >>> list(roundrobin('ABC', 'D', 'EF'))\n        ['A', 'D', 'E', 'B', 'F', 'C']\n\n    This function produces the same output as :func:`interleave_longest`, but\n    may perform better for some inputs (in particular when the number of\n    iterables is small).\n\n    \"\"\"\n    # Recipe credited to George Sakkis\n    pending = len(iterables)\n    nexts = cycle(iter(it).__next__ for it in iterables)\n    while pending:\n        try:\n            for next in nexts:\n                yield next()\n        except StopIteration:\n            pending -= 1\n            nexts = cycle(islice(nexts, pending))\n\n\ndef partition(pred, iterable):\n    \"\"\"\n    Returns a 2-tuple of iterables derived from the input iterable.\n    The first yields the items that have ``pred(item) == False``.\n    The second yields the items that have ``pred(item) == True``.\n\n        >>> is_odd = lambda x: x % 2 != 0\n        >>> iterable = range(10)\n        >>> even_items, odd_items = partition(is_odd, iterable)\n        >>> list(even_items), list(odd_items)\n        ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9])\n\n    If *pred* is None, :func:`bool` is used.\n\n        >>> iterable = [0, 1, False, True, '', ' ']\n        >>> false_items, true_items = partition(None, iterable)\n        >>> list(false_items), list(true_items)\n        ([0, False, ''], [1, True, ' '])\n\n    \"\"\"\n    if pred is None:\n        pred = bool\n\n    t1, t2, p = tee(iterable, 3)\n    p1, p2 = tee(map(pred, p))\n    return (compress(t1, map(operator.not_, p1)), compress(t2, p2))\n\n\ndef powerset(iterable):\n    \"\"\"Yields all possible subsets of the iterable.\n\n        >>> list(powerset([1, 2, 3]))\n        [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]\n\n    :func:`powerset` will operate on iterables that aren't :class:`set`\n    instances, so repeated elements in the input will produce repeated elements\n    in the output. Use :func:`unique_everseen` on the input to avoid generating\n    duplicates:\n\n        >>> seq = [1, 1, 0]\n        >>> list(powerset(seq))\n        [(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)]\n        >>> from more_itertools import unique_everseen\n        >>> list(powerset(unique_everseen(seq)))\n        [(), (1,), (0,), (1, 0)]\n\n    \"\"\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n\n\ndef unique_everseen(iterable, key=None):\n    \"\"\"\n    Yield unique elements, preserving order.\n\n        >>> list(unique_everseen('AAAABBBCCDAABBB'))\n        ['A', 'B', 'C', 'D']\n        >>> list(unique_everseen('ABBCcAD', str.lower))\n        ['A', 'B', 'C', 'D']\n\n    Sequences with a mix of hashable and unhashable items can be used.\n    The function will be slower (i.e., `O(n^2)`) for unhashable items.\n\n    Remember that ``list`` objects are unhashable - you can use the *key*\n    parameter to transform the list to a tuple (which is hashable) to\n    avoid a slowdown.\n\n        >>> iterable = ([1, 2], [2, 3], [1, 2])\n        >>> list(unique_everseen(iterable))  # Slow\n        [[1, 2], [2, 3]]\n        >>> list(unique_everseen(iterable, key=tuple))  # Faster\n        [[1, 2], [2, 3]]\n\n    Similarly, you may want to convert unhashable ``set`` objects with\n    ``key=frozenset``. For ``dict`` objects,\n    ``key=lambda x: frozenset(x.items())`` can be used.\n\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seenset:\n                seenset_add(k)\n                yield element\n        except TypeError:\n            if k not in seenlist:\n                seenlist_add(k)\n                yield element\n\n\ndef unique_justseen(iterable, key=None):\n    \"\"\"Yields elements in order, ignoring serial duplicates\n\n    >>> list(unique_justseen('AAAABBBCCDAABBB'))\n    ['A', 'B', 'C', 'D', 'A', 'B']\n    >>> list(unique_justseen('ABBCcAD', str.lower))\n    ['A', 'B', 'C', 'A', 'D']\n\n    \"\"\"\n    if key is None:\n        return map(operator.itemgetter(0), groupby(iterable))\n\n    return map(next, map(operator.itemgetter(1), groupby(iterable, key)))\n\n\ndef iter_except(func, exception, first=None):\n    \"\"\"Yields results from a function repeatedly until an exception is raised.\n\n    Converts a call-until-exception interface to an iterator interface.\n    Like ``iter(func, sentinel)``, but uses an exception instead of a sentinel\n    to end the loop.\n\n        >>> l = [0, 1, 2]\n        >>> list(iter_except(l.pop, IndexError))\n        [2, 1, 0]\n\n    Multiple exceptions can be specified as a stopping condition:\n\n        >>> l = [1, 2, 3, '...', 4, 5, 6]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        [7, 6, 5]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        [4, 3, 2]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        []\n\n    \"\"\"\n    try:\n        if first is not None:\n            yield first()\n        while 1:\n            yield func()\n    except exception:\n        pass\n\n\ndef first_true(iterable, default=None, pred=None):\n    \"\"\"\n    Returns the first true value in the iterable.\n\n    If no true value is found, returns *default*\n\n    If *pred* is not None, returns the first item for which\n    ``pred(item) == True`` .\n\n        >>> first_true(range(10))\n        1\n        >>> first_true(range(10), pred=lambda x: x > 5)\n        6\n        >>> first_true(range(10), default='missing', pred=lambda x: x > 9)\n        'missing'\n\n    \"\"\"\n    return next(filter(pred, iterable), default)\n\n\ndef random_product(*args, repeat=1):\n    \"\"\"Draw an item at random from each of the input iterables.\n\n        >>> random_product('abc', range(4), 'XYZ')  # doctest:+SKIP\n        ('c', 3, 'Z')\n\n    If *repeat* is provided as a keyword argument, that many items will be\n    drawn from each iterable.\n\n        >>> random_product('abcd', range(4), repeat=2)  # doctest:+SKIP\n        ('a', 2, 'd', 3)\n\n    This equivalent to taking a random selection from\n    ``itertools.product(*args, **kwarg)``.\n\n    \"\"\"\n    pools = [tuple(pool) for pool in args] * repeat\n    return tuple(choice(pool) for pool in pools)\n\n\ndef random_permutation(iterable, r=None):\n    \"\"\"Return a random *r* length permutation of the elements in *iterable*.\n\n    If *r* is not specified or is ``None``, then *r* defaults to the length of\n    *iterable*.\n\n        >>> random_permutation(range(5))  # doctest:+SKIP\n        (3, 4, 0, 1, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.permutations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    r = len(pool) if r is None else r\n    return tuple(sample(pool, r))\n\n\ndef random_combination(iterable, r):\n    \"\"\"Return a random *r* length subsequence of the elements in *iterable*.\n\n        >>> random_combination(range(5), 3)  # doctest:+SKIP\n        (2, 3, 4)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(sample(range(n), r))\n    return tuple(pool[i] for i in indices)\n\n\ndef random_combination_with_replacement(iterable, r):\n    \"\"\"Return a random *r* length subsequence of elements in *iterable*,\n    allowing individual elements to be repeated.\n\n        >>> random_combination_with_replacement(range(3), 5) # doctest:+SKIP\n        (0, 0, 1, 2, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations_with_replacement(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(randrange(n) for i in range(r))\n    return tuple(pool[i] for i in indices)\n\n\ndef nth_combination(iterable, r, index):\n    \"\"\"Equivalent to ``list(combinations(iterable, r))[index]``.\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`nth_combination` computes the subsequence at\n    sort position *index* directly, without computing the previous\n    subsequences.\n\n        >>> nth_combination(range(5), 3, 5)\n        (0, 3, 4)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = 1\n    k = min(r, n - r)\n    for i in range(1, k + 1):\n        c = c * (n - k + i) // i\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    while r:\n        c, n, r = c * r // n, n - 1, r - 1\n        while index >= c:\n            index -= c\n            c, n = c * (n - r) // n, n - 1\n        result.append(pool[-1 - n])\n\n    return tuple(result)\n\n\ndef prepend(value, iterator):\n    \"\"\"Yield *value*, followed by the elements in *iterator*.\n\n        >>> value = '0'\n        >>> iterator = ['1', '2', '3']\n        >>> list(prepend(value, iterator))\n        ['0', '1', '2', '3']\n\n    To prepend multiple values, see :func:`itertools.chain`\n    or :func:`value_chain`.\n\n    \"\"\"\n    return chain([value], iterator)\n\n\ndef convolve(signal, kernel):\n    \"\"\"Convolve the iterable *signal* with the iterable *kernel*.\n\n        >>> signal = (1, 2, 3, 4, 5)\n        >>> kernel = [3, 2, 1]\n        >>> list(convolve(signal, kernel))\n        [3, 8, 14, 20, 26, 14, 5]\n\n    Note: the input arguments are not interchangeable, as the *kernel*\n    is immediately consumed and stored.\n\n    \"\"\"\n    # This implementation intentionally doesn't match the one in the itertools\n    # documentation.\n    kernel = tuple(kernel)[::-1]\n    n = len(kernel)\n    window = deque([0], maxlen=n) * n\n    for x in chain(signal, repeat(0, n - 1)):\n        window.append(x)\n        yield _sumprod(kernel, window)\n\n\ndef before_and_after(predicate, it):\n    \"\"\"A variant of :func:`takewhile` that allows complete access to the\n    remainder of the iterator.\n\n         >>> it = iter('ABCdEfGhI')\n         >>> all_upper, remainder = before_and_after(str.isupper, it)\n         >>> ''.join(all_upper)\n         'ABC'\n         >>> ''.join(remainder) # takewhile() would lose the 'd'\n         'dEfGhI'\n\n    Note that the first iterator must be fully consumed before the second\n    iterator can generate valid results.\n    \"\"\"\n    it = iter(it)\n    transition = []\n\n    def true_iterator():\n        for elem in it:\n            if predicate(elem):\n                yield elem\n            else:\n                transition.append(elem)\n                return\n\n    # Note: this is different from itertools recipes to allow nesting\n    # before_and_after remainders into before_and_after again. See tests\n    # for an example.\n    remainder_iterator = chain(transition, it)\n\n    return true_iterator(), remainder_iterator\n\n\ndef triplewise(iterable):\n    \"\"\"Return overlapping triplets from *iterable*.\n\n    >>> list(triplewise('ABCDE'))\n    [('A', 'B', 'C'), ('B', 'C', 'D'), ('C', 'D', 'E')]\n\n    \"\"\"\n    for (a, _), (b, c) in pairwise(pairwise(iterable)):\n        yield a, b, c\n\n\ndef sliding_window(iterable, n):\n    \"\"\"Return a sliding window of width *n* over *iterable*.\n\n        >>> list(sliding_window(range(6), 4))\n        [(0, 1, 2, 3), (1, 2, 3, 4), (2, 3, 4, 5)]\n\n    If *iterable* has fewer than *n* items, then nothing is yielded:\n\n        >>> list(sliding_window(range(3), 4))\n        []\n\n    For a variant with more features, see :func:`windowed`.\n    \"\"\"\n    it = iter(iterable)\n    window = deque(islice(it, n - 1), maxlen=n)\n    for x in it:\n        window.append(x)\n        yield tuple(window)\n\n\ndef subslices(iterable):\n    \"\"\"Return all contiguous non-empty subslices of *iterable*.\n\n        >>> list(subslices('ABC'))\n        [['A'], ['A', 'B'], ['A', 'B', 'C'], ['B'], ['B', 'C'], ['C']]\n\n    This is similar to :func:`substrings`, but emits items in a different\n    order.\n    \"\"\"\n    seq = list(iterable)\n    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n    return map(operator.getitem, repeat(seq), slices)\n\n\ndef polynomial_from_roots(roots):\n    \"\"\"Compute a polynomial's coefficients from its roots.\n\n    >>> roots = [5, -4, 3]  # (x - 5) * (x + 4) * (x - 3)\n    >>> polynomial_from_roots(roots)  # x^3 - 4 * x^2 - 17 * x + 60\n    [1, -4, -17, 60]\n    \"\"\"\n    factors = zip(repeat(1), map(operator.neg, roots))\n    return list(reduce(convolve, factors, [1]))\n\n\ndef iter_index(iterable, value, start=0, stop=None):\n    \"\"\"Yield the index of each place in *iterable* that *value* occurs,\n    beginning with index *start* and ending before index *stop*.\n\n    See :func:`locate` for a more general means of finding the indexes\n    associated with particular values.\n\n    >>> list(iter_index('AABCADEAF', 'A'))\n    [0, 1, 4, 7]\n    >>> list(iter_index('AABCADEAF', 'A', 1))  # start index is inclusive\n    [1, 4, 7]\n    >>> list(iter_index('AABCADEAF', 'A', 1, 7))  # stop index is not inclusive\n    [1, 4]\n    \"\"\"\n    seq_index = getattr(iterable, 'index', None)\n    if seq_index is None:\n        # Slow path for general iterables\n        it = islice(iterable, start, stop)\n        for i, element in enumerate(it, start):\n            if element is value or element == value:\n                yield i\n    else:\n        # Fast path for sequences\n        stop = len(iterable) if stop is None else stop\n        i = start - 1\n        try:\n            while True:\n                yield (i := seq_index(value, i + 1, stop))\n        except ValueError:\n            pass\n\n\ndef sieve(n):\n    \"\"\"Yield the primes less than n.\n\n    >>> list(sieve(30))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    \"\"\"\n    if n > 2:\n        yield 2\n    start = 3\n    data = bytearray((0, 1)) * (n // 2)\n    limit = math.isqrt(n) + 1\n    for p in iter_index(data, 1, start, limit):\n        yield from iter_index(data, 1, start, p * p)\n        data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))\n        start = p * p\n    yield from iter_index(data, 1, start)\n\n\ndef _batched(iterable, n, *, strict=False):\n    \"\"\"Batch data into tuples of length *n*. If the number of items in\n    *iterable* is not divisible by *n*:\n    * The last batch will be shorter if *strict* is ``False``.\n    * :exc:`ValueError` will be raised if *strict* is ``True``.\n\n    >>> list(batched('ABCDEFG', 3))\n    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G',)]\n\n    On Python 3.13 and above, this is an alias for :func:`itertools.batched`.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least one')\n    it = iter(iterable)\n    while batch := tuple(islice(it, n)):\n        if strict and len(batch) != n:\n            raise ValueError('batched(): incomplete batch')\n        yield batch\n\n\nif hexversion >= 0x30D00A2:\n    from itertools import batched as itertools_batched\n\n    def batched(iterable, n, *, strict=False):\n        return itertools_batched(iterable, n, strict=strict)\n\nelse:\n    batched = _batched\n\n    batched.__doc__ = _batched.__doc__\n\n\ndef transpose(it):\n    \"\"\"Swap the rows and columns of the input matrix.\n\n    >>> list(transpose([(1, 2, 3), (11, 22, 33)]))\n    [(1, 11), (2, 22), (3, 33)]\n\n    The caller should ensure that the dimensions of the input are compatible.\n    If the input is empty, no output will be produced.\n    \"\"\"\n    return _zip_strict(*it)\n\n\ndef reshape(matrix, cols):\n    \"\"\"Reshape the 2-D input *matrix* to have a column count given by *cols*.\n\n    >>> matrix = [(0, 1), (2, 3), (4, 5)]\n    >>> cols = 3\n    >>> list(reshape(matrix, cols))\n    [(0, 1, 2), (3, 4, 5)]\n    \"\"\"\n    return batched(chain.from_iterable(matrix), cols)\n\n\ndef matmul(m1, m2):\n    \"\"\"Multiply two matrices.\n\n    >>> list(matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]))\n    [(49, 80), (41, 60)]\n\n    The caller should ensure that the dimensions of the input matrices are\n    compatible with each other.\n    \"\"\"\n    n = len(m2[0])\n    return batched(starmap(_sumprod, product(m1, transpose(m2))), n)\n\n\ndef factor(n):\n    \"\"\"Yield the prime factors of n.\n\n    >>> list(factor(360))\n    [2, 2, 2, 3, 3, 5]\n    \"\"\"\n    for prime in sieve(math.isqrt(n) + 1):\n        while not n % prime:\n            yield prime\n            n //= prime\n            if n == 1:\n                return\n    if n > 1:\n        yield n\n\n\ndef polynomial_eval(coefficients, x):\n    \"\"\"Evaluate a polynomial at a specific value.\n\n    Example: evaluating x^3 - 4 * x^2 - 17 * x + 60 at x = 2.5:\n\n    >>> coefficients = [1, -4, -17, 60]\n    >>> x = 2.5\n    >>> polynomial_eval(coefficients, x)\n    8.125\n    \"\"\"\n    n = len(coefficients)\n    if n == 0:\n        return x * 0  # coerce zero to the type of x\n    powers = map(pow, repeat(x), reversed(range(n)))\n    return _sumprod(coefficients, powers)\n\n\ndef sum_of_squares(it):\n    \"\"\"Return the sum of the squares of the input values.\n\n    >>> sum_of_squares([10, 20, 30])\n    1400\n    \"\"\"\n    return _sumprod(*tee(it))\n\n\ndef polynomial_derivative(coefficients):\n    \"\"\"Compute the first derivative of a polynomial.\n\n    Example: evaluating the derivative of x^3 - 4 * x^2 - 17 * x + 60\n\n    >>> coefficients = [1, -4, -17, 60]\n    >>> derivative_coefficients = polynomial_derivative(coefficients)\n    >>> derivative_coefficients\n    [3, -8, -17]\n    \"\"\"\n    n = len(coefficients)\n    powers = reversed(range(1, n))\n    return list(map(operator.mul, coefficients, powers))\n\n\ndef totient(n):\n    \"\"\"Return the count of natural numbers up to *n* that are coprime with *n*.\n\n    >>> totient(9)\n    6\n    >>> totient(12)\n    4\n    \"\"\"\n    for p in unique_justseen(factor(n)):\n        n = n // p * (p - 1)\n\n    return n\n", "pkg_resources/_vendor/more_itertools/__init__.py": "\"\"\"More routines for operating on iterables, beyond itertools\"\"\"\n\nfrom .more import *  # noqa\nfrom .recipes import *  # noqa\n\n__version__ = '10.2.0'\n", "pkg_resources/extern/__init__.py": "from __future__ import annotations\nfrom importlib.machinery import ModuleSpec\nimport importlib.util\nimport sys\nfrom types import ModuleType\nfrom typing import Iterable, Sequence\n\n\nclass VendorImporter:\n    \"\"\"\n    A PEP 302 meta path importer for finding optionally-vendored\n    or otherwise naturally-installed packages from root_name.\n    \"\"\"\n\n    def __init__(\n        self,\n        root_name: str,\n        vendored_names: Iterable[str] = (),\n        vendor_pkg: str | None = None,\n    ):\n        self.root_name = root_name\n        self.vendored_names = set(vendored_names)\n        self.vendor_pkg = vendor_pkg or root_name.replace('extern', '_vendor')\n\n    @property\n    def search_path(self):\n        \"\"\"\n        Search first the vendor package then as a natural package.\n        \"\"\"\n        yield self.vendor_pkg + '.'\n        yield ''\n\n    def _module_matches_namespace(self, fullname):\n        \"\"\"Figure out if the target module is vendored.\"\"\"\n        root, base, target = fullname.partition(self.root_name + '.')\n        return not root and any(map(target.startswith, self.vendored_names))\n\n    def load_module(self, fullname: str):\n        \"\"\"\n        Iterate over the search path to locate and load fullname.\n        \"\"\"\n        root, base, target = fullname.partition(self.root_name + '.')\n        for prefix in self.search_path:\n            try:\n                extant = prefix + target\n                __import__(extant)\n                mod = sys.modules[extant]\n                sys.modules[fullname] = mod\n                return mod\n            except ImportError:\n                pass\n        else:\n            raise ImportError(\n                \"The '{target}' package is required; \"\n                \"normally this is bundled with this package so if you get \"\n                \"this warning, consult the packager of your \"\n                \"distribution.\".format(**locals())\n            )\n\n    def create_module(self, spec: ModuleSpec):\n        return self.load_module(spec.name)\n\n    def exec_module(self, module: ModuleType):\n        pass\n\n    def find_spec(\n        self,\n        fullname: str,\n        path: Sequence[str] | None = None,\n        target: ModuleType | None = None,\n    ):\n        \"\"\"Return a module spec for vendored names.\"\"\"\n        return (\n            # This should fix itself next mypy release https://github.com/python/typeshed/pull/11890\n            importlib.util.spec_from_loader(fullname, self)  # type: ignore[arg-type]\n            if self._module_matches_namespace(fullname)\n            else None\n        )\n\n    def install(self):\n        \"\"\"\n        Install this importer into sys.meta_path if not already present.\n        \"\"\"\n        if self not in sys.meta_path:\n            sys.meta_path.append(self)\n\n\n# [[[cog\n# import cog\n# from tools.vendored import yield_top_level\n# names = \"\\n\".join(f\"    {x!r},\" for x in yield_top_level('pkg_resources'))\n# cog.outl(f\"names = (\\n{names}\\n)\")\n# ]]]\nnames = (\n    'backports',\n    'importlib_resources',\n    'jaraco',\n    'more_itertools',\n    'packaging',\n    'platformdirs',\n    'zipp',\n)\n# [[[end]]]\nVendorImporter(__name__, names).install()\n", "_distutils_hack/override.py": "__import__('_distutils_hack').do_override()\n", "_distutils_hack/__init__.py": "# don't import any costly modules\nimport sys\nimport os\n\n\ndef warn_distutils_present():\n    if 'distutils' not in sys.modules:\n        return\n    import warnings\n\n    warnings.warn(\n        \"Distutils was imported before Setuptools, but importing Setuptools \"\n        \"also replaces the `distutils` module in `sys.modules`. This may lead \"\n        \"to undesirable behaviors or errors. To avoid these issues, avoid \"\n        \"using distutils directly, ensure that setuptools is installed in the \"\n        \"traditional way (e.g. not an editable install), and/or make sure \"\n        \"that setuptools is always imported before distutils.\"\n    )\n\n\ndef clear_distutils():\n    if 'distutils' not in sys.modules:\n        return\n    import warnings\n\n    warnings.warn(\"Setuptools is replacing distutils.\")\n    mods = [\n        name\n        for name in sys.modules\n        if name == \"distutils\" or name.startswith(\"distutils.\")\n    ]\n    for name in mods:\n        del sys.modules[name]\n\n\ndef enabled():\n    \"\"\"\n    Allow selection of distutils by environment variable.\n    \"\"\"\n    which = os.environ.get('SETUPTOOLS_USE_DISTUTILS', 'local')\n    return which == 'local'\n\n\ndef ensure_local_distutils():\n    import importlib\n\n    clear_distutils()\n\n    # With the DistutilsMetaFinder in place,\n    # perform an import to cause distutils to be\n    # loaded from setuptools._distutils. Ref #2906.\n    with shim():\n        importlib.import_module('distutils')\n\n    # check that submodules load as expected\n    core = importlib.import_module('distutils.core')\n    assert '_distutils' in core.__file__, core.__file__\n    assert 'setuptools._distutils.log' not in sys.modules\n\n\ndef do_override():\n    \"\"\"\n    Ensure that the local copy of distutils is preferred over stdlib.\n\n    See https://github.com/pypa/setuptools/issues/417#issuecomment-392298401\n    for more motivation.\n    \"\"\"\n    if enabled():\n        warn_distutils_present()\n        ensure_local_distutils()\n\n\nclass _TrivialRe:\n    def __init__(self, *patterns):\n        self._patterns = patterns\n\n    def match(self, string):\n        return all(pat in string for pat in self._patterns)\n\n\nclass DistutilsMetaFinder:\n    def find_spec(self, fullname, path, target=None):\n        # optimization: only consider top level modules and those\n        # found in the CPython test suite.\n        if path is not None and not fullname.startswith('test.'):\n            return None\n\n        method_name = 'spec_for_{fullname}'.format(**locals())\n        method = getattr(self, method_name, lambda: None)\n        return method()\n\n    def spec_for_distutils(self):\n        if self.is_cpython():\n            return None\n\n        import importlib\n        import importlib.abc\n        import importlib.util\n\n        try:\n            mod = importlib.import_module('setuptools._distutils')\n        except Exception:\n            # There are a couple of cases where setuptools._distutils\n            # may not be present:\n            # - An older Setuptools without a local distutils is\n            #   taking precedence. Ref #2957.\n            # - Path manipulation during sitecustomize removes\n            #   setuptools from the path but only after the hook\n            #   has been loaded. Ref #2980.\n            # In either case, fall back to stdlib behavior.\n            return None\n\n        class DistutilsLoader(importlib.abc.Loader):\n            def create_module(self, spec):\n                mod.__name__ = 'distutils'\n                return mod\n\n            def exec_module(self, module):\n                pass\n\n        return importlib.util.spec_from_loader(\n            'distutils', DistutilsLoader(), origin=mod.__file__\n        )\n\n    @staticmethod\n    def is_cpython():\n        \"\"\"\n        Suppress supplying distutils for CPython (build and tests).\n        Ref #2965 and #3007.\n        \"\"\"\n        return os.path.isfile('pybuilddir.txt')\n\n    def spec_for_pip(self):\n        \"\"\"\n        Ensure stdlib distutils when running under pip.\n        See pypa/pip#8761 for rationale.\n        \"\"\"\n        if sys.version_info >= (3, 12) or self.pip_imported_during_build():\n            return\n        clear_distutils()\n        self.spec_for_distutils = lambda: None\n\n    @classmethod\n    def pip_imported_during_build(cls):\n        \"\"\"\n        Detect if pip is being imported in a build script. Ref #2355.\n        \"\"\"\n        import traceback\n\n        return any(\n            cls.frame_file_is_setup(frame) for frame, line in traceback.walk_stack(None)\n        )\n\n    @staticmethod\n    def frame_file_is_setup(frame):\n        \"\"\"\n        Return True if the indicated frame suggests a setup.py file.\n        \"\"\"\n        # some frames may not have __file__ (#2940)\n        return frame.f_globals.get('__file__', '').endswith('setup.py')\n\n    def spec_for_sensitive_tests(self):\n        \"\"\"\n        Ensure stdlib distutils when running select tests under CPython.\n\n        python/cpython#91169\n        \"\"\"\n        clear_distutils()\n        self.spec_for_distutils = lambda: None\n\n    sensitive_tests = (\n        [\n            'test.test_distutils',\n            'test.test_peg_generator',\n            'test.test_importlib',\n        ]\n        if sys.version_info < (3, 10)\n        else [\n            'test.test_distutils',\n        ]\n    )\n\n\nfor name in DistutilsMetaFinder.sensitive_tests:\n    setattr(\n        DistutilsMetaFinder,\n        f'spec_for_{name}',\n        DistutilsMetaFinder.spec_for_sensitive_tests,\n    )\n\n\nDISTUTILS_FINDER = DistutilsMetaFinder()\n\n\ndef add_shim():\n    DISTUTILS_FINDER in sys.meta_path or insert_shim()\n\n\nclass shim:\n    def __enter__(self):\n        insert_shim()\n\n    def __exit__(self, exc, value, tb):\n        _remove_shim()\n\n\ndef insert_shim():\n    sys.meta_path.insert(0, DISTUTILS_FINDER)\n\n\ndef _remove_shim():\n    try:\n        sys.meta_path.remove(DISTUTILS_FINDER)\n    except ValueError:\n        pass\n\n\nif sys.version_info < (3, 12):\n    # DistutilsMetaFinder can only be disabled in Python < 3.12 (PEP 632)\n    remove_shim = _remove_shim\n"}